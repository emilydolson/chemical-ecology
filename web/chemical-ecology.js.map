{"version":3,"sources":["third-party/Empirical/include/emp/prefab/../web/CanvasShape.hpp","third-party/Empirical/include/emp/web/d3/d3_init.hpp","third-party/Empirical/include/emp/web/d3/scales.hpp","third-party/Empirical/include/emp/prefab/../web/../Evolve/../data/../base/vector.hpp","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/iterator","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/string","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/sstream","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/istream","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/ios","third-party/Empirical/include/emp/prefab/../datastructs/../base/_emscripten_assert_trigger.hpp","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/memory","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/utility","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/unordered_set","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/__hash_table","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/math.h","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/algorithm","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/new","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/stdexcept","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/vector","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/__split_buffer","third-party/Empirical/include/emp/web/d3/../js_utils.hpp","third-party/Empirical/include/emp/prefab/../web/../Evolve/../base/array.hpp","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/typeinfo","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/map","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/__tree","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/string_view","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/ostream","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/__locale","third-party/Empirical/include/emp/prefab/../web/Canvas.hpp","third-party/Empirical/include/emp/prefab/../web/../web/Widget.hpp","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/type_traits","third-party/Empirical/include/emp/prefab/../web/../Evolve/../data/../io/NullStream.hpp","third-party/Empirical/include/emp/prefab/../web/Document.hpp","third-party/Empirical/include/emp/prefab/../web/Div.hpp","third-party/Empirical/include/emp/web/d3/../init.hpp","third-party/Empirical/include/emp/prefab/../web/../Evolve/../control/Signal.hpp","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/streambuf","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/fstream","third-party/Empirical/include/emp/web/d3/../../base/errors.hpp","third-party/Empirical/include/emp/config/config.hpp","third-party/Empirical/include/emp/web/UrlParams.hpp","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/filesystem","include/chemical-ecology/config_setup.hpp","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/unordered_map","third-party/Empirical/include/emp/config/ArgManager.hpp","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/functional","third-party/Empirical/include/emp/prefab/../web/../datastructs/DynamicString.hpp","third-party/Empirical/include/emp/prefab/../web/Text.hpp","third-party/Empirical/include/emp/prefab/../web/Style.hpp","third-party/Empirical/include/emp/prefab/../web/JSWrap.hpp","third-party/Empirical/include/emp/web/d3/../JSWrap.hpp","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/iosfwd","third-party/Empirical/include/emp/prefab/../web/Widget.hpp","third-party/Empirical/include/emp/prefab/../web/../Evolve/../tools/string_utils.hpp","third-party/Empirical/include/emp/prefab/../web/../geometry/../debug/mem_track.hpp","third-party/Empirical/include/emp/prefab/../web/WidgetExtras.hpp","third-party/Empirical/include/emp/prefab/../web/events.hpp","include/chemical-ecology/ExampleConfig.hpp","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/numeric","source/web.cpp","include/chemical-ecology/a-eco.hpp","third-party/Empirical/include/emp/prefab/ConfigPanel.hpp","third-party/Empirical/include/emp/prefab/../web/../Evolve/../data/../functional/FunctionSet.hpp","third-party/Empirical/include/emp/prefab/../web/../control/Action.hpp","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/__functional_base","third-party/Empirical/include/emp/prefab/ValueBox.hpp","third-party/Empirical/include/emp/prefab/../web/Input.hpp","third-party/Empirical/include/emp/prefab/ToggleSwitch.hpp","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/bit","third-party/Empirical/include/emp/prefab/../web/../Evolve/../math/Random.hpp","third-party/Empirical/include/emp/prefab/../web/../debug/alert.hpp","third-party/Empirical/include/emp/prefab/../web/js_utils.hpp","third-party/Empirical/include/emp/prefab/Card.hpp","third-party/Empirical/include/emp/prefab/FontAwesomeIcon.hpp","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/__string","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/optional","third-party/Empirical/include/emp/prefab/../config/../base/optional.hpp","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/tuple","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/set","third-party/Empirical/include/emp/prefab/CommentBox.hpp","third-party/Empirical/include/emp/prefab/Collapse.hpp","third-party/Empirical/include/emp/prefab/../web/_FacetedWidget.hpp","third-party/Empirical/include/emp/prefab/../datastructs/../base/MapProxy.hpp","third-party/Empirical/include/emp/prefab/../config/../base/unordered_map.hpp","third-party/Empirical/include/emp/prefab/../web/Font.hpp","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/initializer_list","third-party/Empirical/include/emp/prefab/../web/../Evolve/../data/../datastructs/map_utils.hpp","third-party/Empirical/include/emp/prefab/../web/Element.hpp","third-party/Empirical/include/emp/prefab/../web/Listeners.hpp","third-party/Empirical/include/emp/prefab/../web/Attributes.hpp","third-party/Empirical/include/emp/prefab/../web/CanvasAction.hpp","third-party/Empirical/include/emp/prefab/../web/../geometry/../debug/alert.hpp","third-party/Empirical/include/emp/prefab/../web/../geometry/../math/../base/map.hpp","third-party/Empirical/include/emp/prefab/../web/../Evolve/../data/../base/Ptr.hpp","third-party/Empirical/include/emp/prefab/../web/../Evolve/../data/../math/math.hpp","third-party/Empirical/include/emp/prefab/../web/../geometry/Point2D.hpp","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/iomanip","/home/emily/repos/chemical-ecology/third-party/emsdk/fastcomp/emscripten/system/include/libcxx/locale","third-party/Empirical/include/emp/prefab/../web/color_map.hpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6FA;;;;;;;AClCA;AAAA;AAEA;AAGA;;;;;;;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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ASrhDA;AAAA;AAAA;;;AA+MA;AAAA;;;;AACA;AAAA;ATijDA;;ASngDA;AAAA;;AAAA;AA3PA;AHmKA;;;;;;;;;;;;;;;;;AEwuBA;;;;;AhBt0BA;;;;;;;;;;;;;;AgB84BA;AAAA;AAAA;ARklBA;;;;;AAGA;AACA;;;;;AQplBA;;;;;;AE31BA;;AAAA;AAAA;AACA;;;;;;;;;;ACzFA;AAAA;AAAA;AAAA;AAAA;;;AhByrBA;;;AAAA;;;AgBzrBA;;AAAA;;;;;;;AD1CA;AEkGA;;;AZ87DA;;;;;AL7zCA;;;AKsyCA;;Aa7vBA;;AH3wCA;;AAGA;;;;AAIA;;;;AfwzCA;;;AAkFA;;;;;;;;;;;;;;;;;;;;;;AA/qBA;AKsyCA;;;;;;;;;;;AH75DA;;;ACsfA;AACA;AAAA;;AFjeA;;;;;ADmyCA;AADA;;;;;;;AI38CA;;AAAA;;;;;;AAAA;AACA;AAAA;AH+5BA;;ADyhBA;;AIt7CA;AAWA;AAIA;;;;;;AYqFA;;;;;AAAA;;;AAAA;AACA;;;;;;;;AGg6BA;AAm/CA;AnBppCA;;;;AoB7qCA;AAAA;;;;;;;;;;;;;;;;;ApB6qCA;;AAkCA;;AmByrCA;;;;;;;;;;;;AlB9tDA;;;;AE1NA;;AACA;;;AHg0BA;;;;AACA;AAAA;;AI58CA;;AAAA;AAAA;;AAAA;ACgjEA;;;;;;;;;ADliEA;AAIA;AAAA;;;;;;;;;;;;;;;;AA1BA;;;AAAA;AAAA;AAAA;AAAA;AiBs8BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;ACjWA;;AtB6KA;AIhxBA;;AACA;;;;;;;;;;;AiBm8BA;;AlBnPA;AmB7gBA;AA+ZA;AAAA;AAAA;;ADkWA;AAAA;AAAA;;ArBrLA;AI/wBA;;;;;;AS6YA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AE/NA;;;;;;;;;ACxFA;;AhByrBA;;AgBzrBA;;;;AAAA;;;;;;;;;;ADPA;;;;AhBi4CA;;AgBh3CA;;;Af02CA;Aex2CA;;;;AAFA;;;;;;;;;;;;;ACIA;;;;;;AAEA;;;;;;;;AX+8DA;ALtyCA;;AgBluBA;;;AACA;;;;;;;;;;;AAgBA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAjCA;;;;;;;;;;AAEA;AjBi1CA;;AA0LA;;AiBzgDA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoEA;AAAA;;;;;;;;AA/EA;;AAAA;;;;;ArB2CA;;AAAA;;;;;;;A4BgBA;;;AAEA;;;AACA;AAAA;;;;;;;ACgMA;AAAA;;AACA;;;;;;;ADnRA;AAAA;;;;AV2YA;ARgrDA;;APp7DA;AAAA;AAAA;;;;;AyBpIA;;;;;AAAA;AAAA;;;;;;;AvB0wBA;;;;AAAA;;AuBpwBA;;;AACA;AAAA;;;AACA;;;;;;;;;;;;;;;;AAmCA;AAAA;;;;;;;;;;;;;;;;AvB+tBA;;;;;;;AF9nBA;;AesRA;;AArCA;;;;;;;;;;AW9GA;;AAAA;AAAA;;AA+BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;;AAAA;AAAA;AAAA;A/CqlEA;;;;;ALtyCA;AoD/yBA;ApD+yBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AoD/yBA;AAAA;ApD+yBA;;AoD/yBA;AAAA;AAAA;AAAA;ApD+yBA;AAAA;AAAA;AAAA;AAAA;AoD/yBA;;;A/CqlEA;AAAA;AAAA;AAAA;ALtyCA;;;;;;;AoD/yBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;ApD+yBA;AAAA;AAAA;AKsyCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;A+CrlEA;A/CqlEA;ALtyCA;AAAA;AoD/yBA;;;;;;A/CqlEA;ALtyCA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;AoD/yBA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;A/CqlEA;AAAA;AAAA;AAAA;AAAA;AAAA;ALtyCA;;AoD/yBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;ApD+yBA;AAAA;;AoD/yBA;;AAAA;;;A/CqlEA;ALtyCA;;AKsyCA;;;ALtyCA;;AoD/yBA;AAAA;;ApD+yBA;;;;;AoD/yBA;;AAAA;;;A/CqlEA;;;A+CrlEA;;AAAA;AAAA;;;;;;;;;;;A5CswDA;;;AAp6CA;;;;A8B2RA;;;AJpPA;;;AAAA;;;;;;;AAAA;;AACA;;;;;;;;;;;;AvBjDA;;;;AuBkDA;AAAA;;A1BxDA;;A0BwDA;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;;AAAA;;AAAA;;;;;;;;;AqB3XA;;AAPA;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AlDykEA;AAAA;AAAA;;;;;;ALpmBA;;;AKomBA;AAAA;AAAA;;;;;;ALpmBA;;;AkC18BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;;;;;A/BsMA;AmB7gBA;AA+ZA;AnB8GA;ADmqBA;AgCv2BA;AlCmwGA;AAn6EA;;;;;;;;;;AkC51BA;AlC+vGA;AAn6EA;;;AkCx1BA;AACA;A7BgiDA;AAAA;AAAA;ALtyCA;AkC1PA;AAAA;AAAA;AACA;;;;;;;;;;AlCyvGA;AAn6EA;;;AkCn1BA;AAGA;AAAA;AAAA;AACA;;;;AlCkvGA;AAn6EA;;;AkC70BA;AlC60BA;;AkC10BA;;;;;;AAMA;AACA;AACA;;;;AlCquGA;AAn6EA;;;;;;;AAm6EA;AAn6EA;;;AkCnzBA;;;;;AAOA;AAAA;AACA;;;;AlC8sGA;AAn6EA;;;AkCzyBA;AAEA;AAAA;AACA;;;;;AAGA;AAAA;;;AjCgSA;AChtBA;AAAA;AADA;ACsfA;AACA;AACA;AFyNA;AAAA;AAAA;AA3rBA;AAgCA;AIu2DA;AAAA;AAAA;;;;;;ALpmBA;;;ACrwCA;AACA;AiCiYA;A/BkIA;AmB7gBA;AA+ZA;AnB8GA;AkBmPA;AACA;ApB/BA;AiCtVA;AAAA;AACA;;;AACA;;;;AA5CA;AAAA;AAAA;AAKA;AAuCA;;;AArCA;AlCg0BA;;AkC7zBA;;AlC6zBA;AAAA;AAkCA;AA3fA;AAydA;AAAA;;;AA8FA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AkCx5BA;AAAA;AAAA;;;AAKA;AA0BA;;;AAtBA;AAAA;AAAA;AAMA;AAgBA;;;AjC6UA;A8BvxBA;AAAA;;;;;;;A9B8xBA;AiChVA;AAAA;A7Bg+CA;AAAA;AAAA;;;;;;ALpmBA;;;ACriBA;AiCtVA;;AAEA;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A7B09CA;AAAA;AAAA;ALtyCA;AwDjrBA;AAAA;AAIA;AACA;AAAA;AAAA;AnDk9DA;AAAA;AAAA;ALtyCA;AwD3qBA;AAAA;AnDi9DA;AAAA;AAAA;ALtyCA;AwDxqBA;AAAA;AAAA;AAAA;AnD88DA;AAAA;AAAA;ALtyCA;AwDvqBA;AAAA;AvDiwBA;AAAA;AAAA;AAFA;AC9sBA;AAAA;AADA;ACsfA;AACA;AACA;AFyNA;AAAA;AAAA;AA3rBA;AAgCA;AAhCA;AIu4DA;AAAA;AAAA;;;;;;ALpmBA;;;ACrwCA;AACA;AuDnGA;AnD28DA;AAAA;AAAA;ALtyCA;ACsJA;AuD1zBA;AAAA;AAAA;AACA;AAAA;AAEA;AAEA;AAAA;AAAA;;;;;;;;;;;AAAA;AACA;AACA;AAGA;AnDg8DA;AAAA;AAAA;ALtyCA;AwDxpBA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AnDw7DA;AAAA;AAAA;ALtyCA;AwDjpBA;AAAA;AACA;;;;;;AAGA;AAEA;AACA;AACA;AACA;AACA;AAGA;AAGA;AAAA;AADA;AAAA;;;AAiBA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;AxDknHA;AAn6EA;;;AwD1sCA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AxD8mHA;AAn6EA;;;AwDtsCA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAMA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AA9DA;;AAAA;AAAA;AAAA;AAiEA;AAAA;AAAA;AnDo4DA;AAAA;AAAA;ALtyCA;AwD7lBA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AnDw5DA;AQhwDA;AAAA;AAAA;AAAA;AFvHA;;AEqNA;;;;;;AAmhBA;;;;;;AR+oCA;AcjkCA;AA8vBA;;;;;;;;;;;;;ARl9CA;ANo3CA;AMt9CA;;;;;;;;;AAwFA;;;;;AsB9LA;;;;;;;;;;;;;;;;;;;;;;;;;;;;A5Bo8DA;;;ALrmBA;AAAA;;;;;;;AKqmBA;;;ALrmBA;AAAA;;;;;;;AkCz8BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAGA;;;;;;A/BlBA;;;;;AAwNA;;;;;;ADmqBA;AgCv2BA;AlCmwGA;AAn6EA;AAAA;AA8DA;;;;;;;;;;;;;;;;;AAAA;AA5BA;AA3fA;AA63FA;AAAA;AACA;;;;;;AAlgGA;AkC1PA;AAAA;AAAA;AAAA;;;;;;;;;AlC0vGA;AAn6EA;AAAA;AA8DA;;;;;;;AkCj5BA;AAGA;AAAA;AAAA;AACA;;;;;;AlC64BA;AAs2EA;;;;;;AAp6EA;AAzdA;;;;;;AkC/WA;;;;;;;AAKA;AACA;AAAA;;;;;AlCg4BA;;;AAu2EA;;;;;;;;;;AAv2EA;AA5BA;;;;AAm4EA;;AkCxtGA;;;;;AAOA;;;;;AlC+sGA;;AAn6EA;;;;;;AAq6EA;;;AkC9sGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AjCsSA;AAAA;AAAA;AAFA;AC9sBA;AAAA;AADA;ACsfA;AACA;AACA;AFyNA;AAAA;AAAA;AA3rBA;AAgCA;AAhCA;AIu4DA;AAAA;AAAA;;;;;;ALpmBA;;;ACrwCA;AACA;A+C1LA;;;;;;;;;;A3CkiEA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;AgD/sBA;A/Cq2BA;;;;;;;;;;;A+Cj5BA;A/Ci5BA;;A+Cl2BA;AAA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AAA;;;;;;;;;;;A5B7FA;;;AOkrDA;AZ3iDA;AY2iDA;AZ3iDA;AiClCA;;;;;;AczRA;A1CoLA;ALsJA;AACA;A+C3UA;AAAA;AAAA;AAAA;AAAA;AlCIA;;;;AArGA;;;;;;;;;;;AAkEA;;;;;;;;;;;AkCgCA;AdqRA;ArBglDA;AZ3iDA;AY2iDA;AZ3iDA;AYs6CA;AAAA;AAAA;AAAA;AAAA;AZ18CA;AAAA;Aau1BA;AoB30BA;AACA;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ArBqfA;ADlxBA;AZu6DA;AAAA;AAAA;ALtyCA;AA2EA;AkEl1BA;AjDsIA;AZu6DA;AAAA;AAAA;ALtyCA;AA2EA;AkEj1BA;AjDqIA;AZu6DA;AAAA;AAAA;ALtyCA;AA2EA;AkEh1BA;AjDoIA;AZu6DA;AAAA;AAAA;ALtyCA;AA2EA;AkE/0BA;AjDmIA;AZu6DA;AAAA;AAAA;ALtyCA;AA2EA;AkE90BA;AjDkIA;AZu6DA;AAAA;AAAA;ALtyCA;AA2EA;AkE70BA;AjDiIA;AZu6DA;AAAA;AAAA;ALtyCA;AA2EA;AkE50BA;AjDgIA;AZu6DA;AAAA;AAAA;ALtyCA;AA2EA;AkE30BA;AjD+HA;AZu6DA;AAAA;AAAA;ALtyCA;AA2EA;AkE10BA;AjD8HA;AZu6DA;AAAA;AAAA;ALtyCA;AA2EA;AkEz0BA;AjD6HA;AZu6DA;AAAA;AAAA;ALtyCA;AA2EA;AkEx0BA;AjD4HA;AZu6DA;AAAA;AAAA;ALtyCA;AA2EA;AkEv0BA;AjD2HA;AZu6DA;AAAA;AAAA;ALtyCA;AA2EA;AkEt0BA;A7DiiEA;AAAA;AAAA;ALtyCA;AA2EA;AkEr0BA;AAGA;;;;;;;;;;;A5Bk1CA;AAKA;A9B+YA;;;;;;;;;;;;;AGr8CA;A2B4FA;A9BoWA;AA6xCA;;;;;;AAv8DA;AAAA;;;;;;;;;;A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AAA;;;;;;;AAGA;AAAA;AAAA;;;;AAGA;AAAA;ApDosBA;AmB7gBA;AA+ZA;AnB8GA;AkBmPA;AACA;AkCx7BA;;;ApDosBA;AmB7gBA;AA+ZA;AnB8GA;AkBmPA;AACA;AkCr7BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AzD2BA;AAAA;;;AEgzBA;;;AF/yBA;;AE+yBA;;;;;AAAA;;;;ADgtBA;AAAA;ADr/CA;;;;AEqyBA;;;;;;;;;;;;AAAA;;;;;AAAA;AA+FA;AF/3BA;AAAA;AEkzCA;AAAA;AAimCA;AFn5EA;AE+3BA;AF73BA;AAAA;AEgzCA;AAAA;AAimCA;AFj5EA;;;;AAMA;AAAA;;;;;;;;;;;AAxBA;AAAA;;;AEgzBA;;;AF/yBA;;AE+yBA;;;;;AAAA;;;;ADgtBA;AAAA;ADr/CA;;;;AEqyBA;;;;;;;;;;;;AAAA;;;;;AAAA;AA+FA;AF/3BA;AAAA;AEkzCA;AAAA;AAimCA;AFn5EA;AE+3BA;AF73BA;AAAA;AEgzCA;AAAA;AAimCA;AFj5EA;;;;AAMA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE21EA;AAAA;AAAA;AAAA;;;;;AanzDA;AAAA;AAAA;AAAA;AAAA;AA82CA;AAAA;;AACA;;AACA;;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lDA;AAEA;;;;;;;;;;ATk8CA;AAkJA;AAjJA;;AoBuxFA;;AADA;AACA;;ApBrzEA;;;AoBqzEA;;AZv/GA;;;;;;;;AC3lBA;;;AA3PA;;;;;;;;;ADyVA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AbkYA;AAAA;AAAA;AkC1KA;AAAA;AFgrBA;;;AACA;AAAA;;A7B5yBA;;;;;;;ADlVA;AAAA;;;ACwfA;AAAA;AFyNA;;;;;;;;;;;;;AiCxQA;;;AbkWA;AAAA;;;;ACjWA;AAAA;ADkWA;;AalWA;AAAA;;;;;A1B4pCA;;;AGr8CA;;A4B2IA;;;;;;;;;;;;;AzC/SA;;AAAA;;;;;;;;;;;;AOg6DA;ALtyCA;;;AFpsBA;;;;;AAAA;;;AACA;;;;;;;;;AEmsBA;AAAA;;;;AFlrBA;;;AAAA;;;;;;;AC0uCA;;;;;;;;;;;AM8uBA;;ALtyCA;;;AFlrBA;;;;;;;AAzDA;;;;;;AAqIA;;;;AEsmBA;;;AAAA;;AFtmBA;;AAEA;;;;;;;;;;;;;;;;AAUA;;AOg4DA;;AQ38CA;;AfrbA;;;Ae4yCA;;;;;;;;;;;;;;;;;;;ARolBA;;;;;;;;AmC5JA;AAAA;AAAA;AAoDA;AAAA;AhC6fA;AACA;AAAA;AACA;AAEA;;;;;;;;AA3KA;AAAA;AACA;;;AAEA;;;AACA;;AACA;AAAA;;AAhuEA;;AAAA;AHogEA;;AIjzCA;;AsD3wBA;AvDuEA;AAAA;AAAA;AAAA;;;;AE8kBA;;AF4oDA;;;;AAEA;;;AgC78BA;AAAA;;;;;;;;;;;;;;AnCu+CA;AAEA;AG5kEA;AH++BA;AAAA;AM3hDA;;AHwmEA;;AHnlBA;;;;;;;;;AJv0CA;AAAA;A8BpNA;AAAA;AACA;;;;A9BwNA;;;;;ADggCA;;;;;;AAUA;;;;AAtCA;;;;;;AA6CA;AAjBA;;;;;AC1/BA;;A8B7MA;;AACA;;A9B6MA;;;;;;;;;;;;;AAKA;;;;A8B1NA;;;;;;;;AelHA;;;AAAA;;AAAA;;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;Af+FA;AADA;A9BoSA;A8BpRA;AAAA;AACA;AAAA;;A9BsRA;;;;;A8BxRA;AAAA;A9B+RA;AAAA;AACA;AAAA;ADq3BA;;;;;;AAjdA;AAidA;;;;;;;;ACl3BA;A8BvRA;AACA;AALA;AAAA;A9B6RA;AAAA;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;;AAGA;;;;;;A8BvTA;AACA;AACA;;A9BwTA;;A8BnVA;AAAA;;;;AACA;AAAA;;;;;;A9BqVA;AAAA;;;;;;AD47BA;AIl8CA;AAAA;AAAA;;AAWA;AAIA;AAAA;;;;;;;;;;;AA1BA;;AAAA;;;ADmtBA;AmB9GA;;;AnB8GA;;;;AChtBA;;;;;;;;AAHA;AAAA;AAAA;;;;AkBsMA;;;;;;AnB6gBA;;;;;;;;;;;;;AgB9CA;Ad25CA;Ac7mBA;;;;;AA9yBA;;Ad25CA;;;;;;;;;AwBxjEA;;;AAEA;;;;;;;;;;;;;;;;;;;AV8wDA;AR59CA;;ALpCA;;;;AK0BA;;;;;;;AQ8tBA;AA8vBA;;;;;;;;;AASA;AAAA;;;;;;AnB1WA;AAAA;AAAA;AA5BA;AA4DA;AAAA;AAmgCA;AFj5EA;;;;;AArBA;;;AAAA;;;AEwuBA;;;;;;;;;AmBytDA;;;;AAGA;AAAA;;;;;;;Ad7ZA;AcjkCA;AAm/CA;;;;AwCh/EA;;;;;;;;;;;;;;;;;;;;AxCyHA;;;;;;AArGA;;;;;;;;;;;;;;AAkwEA;AAAA;;;Ad1NA;Ac4NA;;;;;;;AAgLA;;;;;;;;;;;;;;;;;;;;;;AlB/mDA;;AAFA;AC9sBA;AAAA;;AADA;;;ACufA;AAAA;;;;;;;;;;;ALrmBA;AAAA;;;AEgzBA;;;AF/yBA;;AE+yBA;;;;;AAAA;;;;ADgtBA;AAAA;ADr/CA;;;;AEqyBA;;;;;;;;;;;;AAAA;;;;;AAAA;AA+FA;AF/3BA;AAAA;AEkzCA;AAAA;AAimCA;AFn5EA;AE+3BA;AF73BA;AAAA;AEgzCA;AAAA;AAimCA;AFj5EA;;;;AAMA;AAAA;;;;;;;AMnEA;AAAA;AAAA;AACA;;;;;;;;AAHA;;AAAA;AiBs8BA;;;;ACjWA;AAAA;;;AlBlmBA;;;;;;AoC2sEA;;;;;;;;;AApMA;;;;;;;;ACn+DA;;;;ADk0CA;AAAA;;AAfA;;;;;;;;;;;;;;;;;;;;;;;;;;;ApC11CA;AAAA;;AAAA;;AiBs8BA;AlBnPA;;;;AkBoPA;AjBr8BA;;;;;;;;;AF0JA;AADA;;;;ACufA;;;;AF0NA;;;AI4sCA;;;;;;ALpmBA;;ACrwCA;AACA;AAAA;A+C4qBA;AAAA;AAEA;AAAA;;;;ALp1BA;;;;;AAAA;AAAA;;;;;;;;;;;AnCwCA;;;;;AACA;;;;;;;;;AAy1EA;;;;;;;;;;;AH3VA;;;;AMrxDA;;;;;;;AAAA;A4B6JA;;;;AAAA;AAAA;AACA;;;AAAA;;;AAXA;AAAA;AAAA;;;;;;;;AgCzaA;AAAA;;;;;;;;;;;;;;;;;;;AJsBA;;;;;;AvC0NA;;;;;;;;;;;A+C9NA;;;;;;AACA;;;;;;;;;;;;;;;;;;;A/C8NA;;;A5B2fA;;AAAA;;;;A4B3fA;;;;;;;;;;AJoQA;AACA;;;;;AAAA;;;AmD/VA;;;;;ARGA;AAAA;;;;;;;;;;;;;;A3C0hBA;;AAAA;;;;;;AnB81CA;ALtyCA;;;;;;;AAAA;AoEnxBA;AAAA;;;;;;;;;;A5C4hBA;;;;;;;;;;;;;ALpfA;;;;AAkEA;;;;;;;;;;;;;;;;;AnBswCA;;A2C7wCA;;AxB3DA;;;;;;;;;;AAkEA;;;;;;;;;;;;;;;;;;;;;AnBswCA;;AA8FA;;;;;;AmBvpBA;;;;AnBunBA;;AAs2EA;AACA;;;AAr6EA;;;;;;;AA8FA;;AmBj0CA;;;;AArGA;;;;;;;;;;;;;;;;;;;;;;;;;;AnB05CA;;;;;;;;;;;;AWroCA;;;;;;;;;AXsdA;AIzwBA;AAAA;AAAA;AACA;AAAA;;;AJq2CA;AAkFA;;AIt7CA;;AAeA;;;;;;;;;AA1BA;AAAA;AAAA;;;;AkBqmBA;AAAA;;;;AjBm9CA;;;;;;;A6CvkEA;AAAA;;;;;;;;AuBsdA;AAAA;;;AWxcA;;;;;;;;;;;;;;;;;;;;;;;;;;AhC5BA;AAAA;;AAAA;;AAAA;AAAA;;;;AAAA;A/CqlEA;;;ALtyCA;AoD/yBA;AAAA;;;;ApD+yBA;AAAA;;;;AoD/yBA;;;;AAAA;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;A/CqlEA;ALtyCA;AKsyCA;ALtyCA;AAAA;AoD/yBA;A/CqlEA;ALtyCA;AoD/yBA;AAAA;A/CqlEA;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GA;AAn6EA;AAAA;;;;;;;;AmBzdA;AAAA;AD9QA;AP5UA;AXmjCA;AAAA;AAAA;AAkFA;AAYA;;AoB3wCA;;;;;;;;ADg1DA;;;;AAEA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AqBlkBA;;;;A8BtxCA;AAAA;;AACA;;;;;;;;;;;;;;;;;AjEo3DA;AAAA;;;;;;AoC3gEA;;;;;AjB4gBA;AAAA;AAAA;AAAA;;;;;AkB5gBA;;;;;;AlBmhBA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;AXkDA;AAAA;;;;;AR28CA;AAAA;AAAA;ALtyCA;AKsyCA;AAAA;AAAA;ALtyCA;AarKA;AfrbA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;;;;;;;;;;;AiDoLA;;A1C2sDA;AAAA;AAAA;ALtyCA;AKsyCA;AAAA;AAAA;ALtyCA;A+CpaA;AAAA;AAAA;AAAA;;A1C0sDA;AAAA;AAAA;ALtyCA;A+ChaA;AAAA;AACA;;;;;;;;;;AjD3LA;AACA;AAAA;Ae2yCA;;Af3yCA;;;;;AeobA;AAAA;AAAA;AAAA;AAAA;AAAA;AfrbA;;AAAA;;;;;;;;;;;;;;;;AMxLA;AAAA;ADmtBA;AmB7gBA;AA+ZA;AnB8GA;AkBmPA;AACA;AhBinCA;AAAA;AAAA;ALtyCA;AIhxBA;AAAA;AACA;;;;;;;;;;;;;;;;AS0mBA;AAAA;;;;;AR28CA;AAAA;AAAA;ALtyCA;AKsyCA;AAAA;AAAA;ALtyCA;AarKA;AfrbA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;;;;;;;;AAbA;AAAA;AAAA;AACA;;AACA;AACA;;AsD5MA;;;;;;;;;;;;;;;;;;;;;AnD4OA;AACA;AAAA;AAAA;AuBmIA;AAAA;AACA;AAAA;;;AxB2hCA;AAAA;AAAA;AAAA;AAAA;AAkFA;AAAA;;;;;;;;;AyB4xFA;A6ChiIA;AAAA;AAAA;AAAA;AACA;;;;;;;AAqEA;;;;A/BsDA;;AxC0jCA;;;;;;AwC1jCA;AAAA;;;;;;;;;;;;;;;A1BoTA;AAAA;;;;;AR28CA;AAAA;AAAA;ALtyCA;AKsyCA;AAAA;AAAA;ALtyCA;AarKA;AfrbA;AAAA;AAAA;AAA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;;;;;;;;A3BrbA;AACA;;;;;;;;;AGuqHA;;;;;;AQp+CA;;;;;;;;;;;;;;;;;AwBh/DA;AAKA;;AAQA;;;AAEA;;AACA;;;;;;;;;;;;;;AnCpOA;;;;;;;AiDnCA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAFA;AAAA;AAAA;AAAA;AAAA;;;;;;AtCkvEA;;;;;;AgCz3BA;A7B5wCA;;;;;;AqC+VA;;;;;;;ARgzBA;AAAA;AAAA;AAAA;;;;ADx2CA;AAAA;AAAA;;;;;;;AAwjBA;;;;;;A4CpiBA;;;;;;ACdA;AACA;;;;AjEswDA;;;;;;;;;;;;;;;;;AYzjDA;ACgnBA;AACA;;;;;;;;;ApBluBA;;AAyFA;;APqjDA;;;;AciPA;;;;;AmBpoCA;;;;;;;;AdpUA;AACA;AAAA;;;;;;;;;;;;;;ALjGA;;;;;;;;;;;;ARhPA;AN63DA;AmC7OA;;;;AhC6jBA;;;;;AAGA;;;;;;;;;AR5iCA;AA8DA;AAAA;;;;;;A+ChgCA;;;;;;AAAA;;;;;;AAPA;;;;;;AAAA;;;;;;AJpZA;AACA;;;;;;AyCOA;;;;;;;A5E+ZA;;;;;;AHgmEA;AG3dA;;AA1gEA;;;;;;;AgCqzCA;AAAA;AAAA;AAAA;;;;;;A4C9zCA;;;;;;;AjFumBA;;;;;;;;;;;;;;AqCutBA;AAAA;AAAA;AAAA;;;;;AGr0CA;;;;;;;;AzB+3BA;AkEp6BA;;;;;;;A5EoFA;;;;;;;;;;;;;;;AUg1BA;AiEt6BA;;;;;;;;;;;;;;AtEg9BA;;;;;;;;;;;;;ASxWA;;;;;;AxBxiBA;AAAA;AEkzCA;AAkFA;;;;;;;;;AAn8BA;AC8EA;;;;;;;;;;;;;A2BzgBA;AACA;;;;;;;;;AJqIA;AADA;AADA;AACA;AADA;AACA;;;;;;A7BjIA;AAAA;AAAA;AAAA;AAIA;;;;;;;;AuBw1BA;A2E36BA;;;;;;;;;;;;;;;;;;;AvE6mBA;AAAA;AAAA;AAAA;AAAA;AnB8GA;AkBmPA;AAAA;;;;AFw0BA;;;;;;;;;;;;;AXkRA;;;;;;A0BnxDA;;;;;;;AhBspBA;AuD5dA;;;;;;;;;;;;;;;AtDu0CA;;;;;;;;;;;AxBpvDA;AACA;AACA;;;;;;;A2C0rCA;;;;;;AE6xBA;;;;;;;;;;;A9Bj+BA;;;;;;;;;;;;;;;;AN1gCA;;;;;;A2BmMA;AACA;AAAA;ACgiBA;;;;;;;;;AnBpWA;;;;;;;;;;AiChSA;;;;;;;AxB2wBA;;;;;;;;;;;;;ArBPA;;;;;;;;;;;;;;;;;;;;;;;;;;;A+CEA;;;;;;;;AxBvSA;AAAA;;;;;AAKA;;;;;;;AwB5IA;AjD04BA;;;;;;;;;;;;;;AMwuBA;;;;;AAAA;;;;;;;;;;;;;;;Aap7CA;APlUA;AAAA;AAAA;AAAA;AO+mCA;;;;;;;;;;;;;AqB16CA;AAAA;AAAA;;;;;;AlC6yFA;AGrbA;AACA;;;;;;;;AJ13EA;;AAAA;;AiBs8BA;;;;;;AhB0nCA;AAAA;AMpwDA;A6D89BA;;;;;;;;;;;;;;;;;;;;;;;;;;;AtCl4BA;;;;;;AA7IA;;;;;;;;;;;;ApClEA;;;;;;AGxBA;;;;;;;;;;;AGjLA;;;;;;;;;;;;;;;;;;;;;;;AmC8iBA;;;;;;;;;;;;;;;AvCsuGA;;;;;;;;;;;;;;;;AU5mGA;;;;;;;AsDxpBA;;AAAA;;AACA;;AAAA;;;;;;AjBkfA;;AAAA;;AACA;;AACA;;;;;;;;;;A/C88BA;;;;;;A6Ez5CA;;;;;;;;;;;;;;;;;ArEqyEA;;;;;;;AHvSA;ALtyCA;AMnXA;AAAA;AiCxFA;;;;;;;;;;;;;;;AhBvQA;;AxBm5CA;;;;AwBn5CA;;;;;;AvBktBA;AarKA;Af5aA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AOu3DA;;;;ALtyCA;;;;;;;;;;;;;;;;;;;;;;;;;;AKsyCA;AAAA;AAAA;ALtyCA;;;;;;ACjkBA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADikBA;;AI/wBA;;;;A8ClBA;AAAA;;;;;;;;AoBwNA;AACA;;;;;;;;;;;;;;;;;;;;;;;A5D8dA;;;;;;;;;AV4yBA;;;;;;AAPA;;AAyyEA;;;;;;;;;AazoGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AR28CA;AAAA;AAAA;ALtyCA;AgD1wBA;;;;;;;;;;;;;;;;;A3CsiFA;AGreA;;;;;;A8Dt0DA;;;A/B0EA;AAAA;;;;;;;AlC2uDA;AAAA;AAAA;ALtyCA;;;;;;;;;;;;;Ac1mBA;;;;;;;;AK6fA;Ad25CA;Ac3lBA;;;;;;;;;;;;;;ARzqCA;;;;;;;AX8/GA;AmB5tCA;;;;;AoB9qEA;AAAA;;;;;;;AvCi+BA;AAlCA;AAAA;;;;;;;AKysBA;A8C7jEA;;;;;;AkBwNA;;;;;;;;;;;;ArE+jBA;AFlrBA;AAAA;;;;;;AA9BA;AE2xBA;;;AF1xBA;;;;;;;;A0Ci7DA;;;;;;;;;;;;;AN78DA;;;;;;;;;;;;;;AXyBA;;;;ApBmlBA;;AFyNA;;;ADumBA;;;;AAAA;;;;;;;;AKqmBA;ALtyCA;;;;;;;AoBhlBA;;;;;;;;ADusBA;;;;;AN5RA;;;;;;;;;;;;;;;;;AmBoEA;AAGA;;;;;;;ARzJA;AACA;;;;;;;;;;;;;;;AhBm0DA;AAAA;;AAEA;;;;;;;;;ARp5BA;;;;;;;Aa5nCA;;;;;;;;;;;;;;;;;;;;;;;;;;AZ2hBA;;;;;;;AD1FA;AAAA;;;;;;;;;AQ/rBA;;;;;;;;;;;AKmTA;;;;;;;;;;;;;;;AmBwcA;;;;;;AhCy6FA;;;;;;AQrqHA;AAAA;;;;;;;;AG0OA;;;;;;;AX27GA;;;;;;;;;;;;;;;;;;;;;AuEjtHA;;;;;;AhCrCA;;;;;;A/BiFA;;;AACA;;;;;;;;;AA/BA;AA8BA;;;;;;;;;;;;;;;;AiB2oIA;;;;;;;;;;;;;;;;;;;;;;AzBv0GA;;;;;;;;;;AAydA;;;;;AAsnDA;;;;;AQl5FA;;;;;AR22CA;;;;;;;;;;;AmBzxBA;Ad25CA;Ac3lBA;;;;;;AbjsCA;AAAA;;;;;;AOsIA;AAAA;;AAlCA;AF9KA;;;;;;;A4BzNA;AAAA;;;;;;;AvC46CA;;;;AEjxCA;;AADA;;;;;;;;;;;;;;;AI6HA;;;;;;;;;ANy9GA;;AAhzEA;;;;;;;AkC/yCA;AACA;;;;;A1BjEA;;;;;;;;;;;AR+zCA;AoB/sCA;;;;;;AzBzGA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AqCm3BA;AAAA;AAAA;;;;;;ArBhpBA;AXmjCA;;;;;;ADh2BA;;;;;;;ASpcA;AAq+DA;AACA;;;;;;;AH8BA;AoBqzEA;AZ1/GA;AAGA;;;;;;;A8B3vBA;;;;;;ALskCA;;;;;AxCvhCA;;;;;AO84DA;;;;;;;;;;ALhuBA;AA8DA;;AAvhBA;;;;;;;;;AawpBA;ARgNA;;;;;;AApJA;AAAA;AAAA;;;;;;;AQ7/BA;AAAA;AAAA;AfrbA;;;;;;;;;;;;;;;AGorBA;AAAA;AAAA;AAAA;;;;;;AkB5gBA;;AAKA;;;;;;;ArBlUA;AAAA;AAAA;;;;;;AU00EA;;;;;;;;;;;;;;;;AWt0EA;AAAA;;;;;;;;ArBJA;AAAA;AAAA;;;;;;;AkC+rBA;;;;;;AduHA;;;;;;ACpLA;Ad25CA;Ac9mBA;;;;;;;;;;;;;;;;;;;AkDjwBA;;;;;;A7CvdA;;AACA;;AACA;;;;;;;;;;;;;A1B7LA;AEgzCA;;;;;;;AatjCA;AAwBA;;;;;;;;;;;AO/IA;ApBu5GA;;;;;;;;;A+CzrGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A9CjNA;A+CzLA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A7B0GA;;;;;;;;;;;;;;;;;;;;;;;AsB7HA;;;;;;AdsBA;AAAA;AAAA;;;;;;;AtB+hEA;ALrmBA;;;;;;;;;;;;;;;;;;;;;;;;;;AFt6CA;;;;;;;;;;;;AqBwnBA;Ad25CA;Ac9mBA;;;;;;;;;;;;;;AsBl7CA;AACA;;;;AvBuzBA;;;;;;;;;;AlBqnBA;AoB3wCA;ApBu5GA;AAiOA;;;;;;;;;;;AiCpuHA;;;;;;ApBoVA;AAAA;;AAlCA;AF9KA;;;;;;;AXqpCA;;;;;;;;;;;;;;;AAAA;;;;;AmBisBA;;;;;AkDpzCA;;;;;ArEmnBA;;;;;AAkFA;AAAA;AAqzEA;;;;;;;;;;;AMl9GA;AAAA;;;;;;;AElNA;AACA;;;;;;;AwBonBA;AAAA;;;;;AALA;AAAA;;;;;;AoDnrBA;;;;;AjEqiEA;;;;;AdtTA;;;;;;;;;;;Ac0BA;AdxGA;;Ac6GA;;;;;;A6Bj6BA;;;;;;;;;;AlDrpBA;;AACA;;;;;;;;;;AwCunBA;AAAA;;;;;AfxzBA;;;;;;AAAA;;;;;;;ASqoCA;A7B/rBA;A+BqHA;;;;;;;;;;;;;;;A1B48CA;AAAA;AAAA;;;;;;;;;;;;ARjoBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AuC7jCA;AAAA;;;;;AjCxFA;AAAA;;;;;;;;;;;;;;A0B8cA;;;;;;;;;;;;;;;;;;;;;Ab8QA;;;;;;AazSA;AAAA;;;;;AO3VA;AAAA;;;;;AjCxFA;AAAA;;;;;;;;;ANkiHA;;AmBh3DA;;;;;;;AqBmBA;AACA;;;;;AlCtsDA;AAAA;;;;;;;;;;;;;A+DhCA;;;;;;AhD8sBA;AAAA;ACjWA;;;;;;;AxBlkBA;AAAA;AAAA;;;;;;A0C07DA;AACA;;;;;;;;;;;;ApCp9DA;AH85BA;ADyhBA;;;;;;A+BrvCA;AC2iBA;;;;;;;A5BvvBA;;;;;;;AJuvHA;;AACA;;;;;;;;;;;;;;;;;;;;;AQl/FA;;;;;;AwB4RA;;AD5zBA;;;;;AbojBA;;;;;Ac4JA;;;;;;A5Bn7BA;;;;;;;;;Acg6BA;;;;;;;;;;;;;;;;APvmBA;A2BwrCA;;;;;;;A3Cp7CA;AAAA;AAAA;AAAA;;;;;;;AkB6sCA;Af7nCA;;;;;;;;;;;;;;AoBwsBA;;;;;;AC/nBA;;;;;;;;;;;;;;AlBVA;AGvMA;;;;;;AJ0wBA;A+CjZA;;;;;AJvYA;AAAA;;;;;;;;A3C8vHA;;;;;;;;;;;;;;;AuDtvHA;AAAA;AAFA;;;;;;APiZA;;AAAA;;AAAA;;;;;;;AsBuBA;;;;;ArEzNA;;;;;;;;;;;AH5DA;;;;;;;AU+uEA;ARnhCA;AA8DA;;;;;;;;;;;;;;;ACnkBA;AC9sBA;AADA;;;;;;AMzEA;;;;;;;;;;;;;;;;;;;;;;;;;;A6DoqBA;;;;;A7D+mDA;AAAA;AHycA;AGxcA;;;;;;AgC7VA;;AACA;;;;;;ArB5PA;;;;;;;;;;;A2B/qDA;AAAA;AAAA;;;;;AtCmuEA;;;AIroEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AmC+NA;;;;;;AAAA;;;;;;A/C21GA;AAAA;;;;;;;;;;;;;;;;;;;;AAx4EA;;;;;;AuC9zBA;;;;;AvC43BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Aah0BA;AAAA;AAAA;;;AA82CA;;;;;;AA92CA;AAAA;AAAA;;;;;;;;;;Abs2BA;AACA;;;;;;;AQy/BA;AACA;;;;;;AF1qEA;AAAA;;;;;;;;;;;;AkBdA;;;;;;;;;;;AgB8rDA;;;;;;;;;;;;;;;AMr2DA;AAAA;;;;;;;;;;;;;;;;AvC0OA;;;;;;;;;;;;;;AsE/VA;AAAA;;;;;;AvD62BA;AAAA;AU4GA;;;;;;AAEA;AAAA;;;;;;A1BhrBA;AAAA;;;;;;;AOqmBA;;;;;;;;;Af7vBA;AAAA;;;;;AyDzJA;AAPA;AAOA;AALA;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;AsBkEA;AAAA;;;;;;A9EoxCA;AAAA;;;;;;;;AMuwBA;AcxsCA;AwB/1BA;;;;;;;;;;;A0B0JA;;;;;;;;;;;;;;;;;A5C+rIA;AAAA;AAAA;AAAA;;;;;;ApBpzEA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AQl+CA;AAAA;AAAA;AAAA;;;;;;ARipCA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;A2C9xBA;AAAA;AAAA;AAAA;;;;;;;AlDj6BA;AAMA;;;;;;AUaA;AACA;;;;;;;;;;;;;;;;;;;A0CrFA;;;;;AACA;;;;;;A7CklEA;AQhwDA;;;;;Af7LA;AeoXA;;;;;;;;;;;;;;;;;ARwjDA;APp7DA;AAAA;;;;;AuBirBA;;;;;AFxJA;Ad25CA;Ac9mBA;;;;;AdgmBA;;;;;;;;Act6DA;;;;;;AqBu2DA;AAAA;;;;;AlC3tDA;AAAA;;;;;;;AuEvRA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AxE6yFA;;;;AyCtsFA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;A9CuwCA;;;;;;;;;;;;;;;;AAAA;AAAA;;AA8DA;;;;;;;;;;;AuCp0BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AtCjGA;;AS+6DA;;;AT96DA;;AAAA;;;;;;;;;;;;;;A2BhYA;;AAAA;AAAA;;AAGA;;;;;A1BeA;;;;;;;;;;;;AsCw1DA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AlC/sDA;AAAA;;;;;;AsBpGA;AACA;;;;;;;;;;A5BilBA;;AqFrvBA;;;;;;;AhF+kDA;;ALzJA;;AACA;;;;;AkD59CA;;;;;AACA;;;;;ArConBA;;;;;;;A4BtkBA;;;;;;AxCyKA;A+C4qBA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AjBlvBA;;;;;;;;;;;;;AjB0IA;;;;;;;;;;;;AD2HA;AACA;ARgrDA;APp7DA;;;;;;;;;;;;;;;;;;;;;;;;;;;AEiyCA;;;;;;;;;;;;;;;;;AgC7bA;;;;;;;AQyhCA;;AACA;;;;;;;;;;;;;;;;;;;;;A7C/gEA;AAAA;;;;;;;;;;;;;A0EwOA;;;;;A7BsyDA;;AACA;;;;;;;;;;;;;;;;;;;;AnC8CA;AAAA;AAAA;ALtyCA;;;;;A8C1qBA;AAAA;;;;;;;AtBoHA;;AAAA;;;;;;;;;;;;;;;;;;;;AXmLA;AACA;ARgrDA;APp7DA;;;;;AkB/CA;AH2aA;;;;;;;AW9SA;;AAAA;;;;;;;;;;;;;;;;;;AeiHA;;;;;;AAAA;;;;;;;;;;;;AzCvLA;AeoXA;;;;;;;;;;;;;AV0IA;AACA;;;;;;A4CzPA;;;;;;AAAA;;;;;;AvCxUA;;;;;;;AWiyBA;;;;;AlBnqBA;;;;;;;;;;;;;;;;;;;;;;AD+pCA;;;;;;;AwBvmCA;;;;;;;AA3CA;;AAAA;;;;;;;;AeqJA;;AAAA;AAAA;;AlCssDA;;;;;;AwEriEA;AAAA;AAAA;AAAA;;;;;;;;ArE6gEA;;;;;;;;;;;;;;;;;;;;AqE9gEA;AAAA;AAAA;AAAA;;;;;;ArDyMA;;AAAA;;;;;;;ALNA;;;;;;AfnNA;;;;;;;;;;;;;;;;;;;AEsRA;AAAA;;;;;;AiB5NA;;;;AjBwOA;;;;;;;;;;;;;;;;;AkB7BA;;;;;AxB2gBA;;;;;;AAq+FA;;;;;;;;;;;;;;;AwC1xDA;AACA;AnC0GA;;;;;;AmC3GA;AACA;AnC0GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ALztBA;;AA8DA;;AAgCA;;AoB3wCA;;;;;AP2uBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A2B0nCA;;;;;;ANx5DA;;;;;;AOxGA;;;;;AtBgyBA;;;;;;AsBhyBA;;;;;;AzC66CA;;;;;;;;;;;;;AQ0lBA;;;;;;;;;;;;;;;;;;;;;;;AR1lBA;;;;;;;;;;;;;;;;ACrwCA;;;;;;;;;;;;;AHnJA;;AACA;;AEkzCA;;AAAA;;;;;AwB5zBA;AAAA;;;;;;AQkJA;;;;;;A/BphBA;;;;;;;;AY4bA;AA8wBA;;AAAA;;;;;;;;;;;;;;;;;;;;AM0mBA;;;;;;;;A0Dp+DA;AAAA;AAAA;AAAA;;;;;A1D4/DA;AAEA;;;;;;AnBngDA;AAAA;;;;;;Aau9BA;AfzzCA;;;;;AmC1CA;;;;;AMgQA;;;;;AArCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA1UA;;AAAA;;;;;AvCixBA;AAAA;;;;;;;;;;;;;;;AQhsBA;;;;;;AqExFA;AAAA;;;;;;A7E6vHA;;;;;AiCnoHA;;;;;AaLA;AAAA;;;;;AAFA;AAAA;;;;;;;A3CqiBA;;;;;;;;;;;;;;;;;;;;;;;;AqC20CA;AACA;;;;;AZ5yDA;AAAA;;;;;;;;;;;;;;;;;AYq3DA;;;;;ArBphCA;;;;Ad4jCA;;AAiwBA;AAEA;;;;;;;;;;;;AL93CA;AADA;;;;;;A4Bx1CA;;;;;;AApBA;AAAA;;;;;;AAAA;;;;;;A5BwwCA;;;;;;;A6Er3CA;AAAA;;;;;;;;;;;;;;;A7EmlHA;;;;;;;;;A0C9iHA;AAAA;;;;;;AtBmKA;;;;;;;;;;;AG9DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AVoYA;;;;;;;;;;AqBxPA;;AAHA;;;;;;;;ApCrNA;AAEA;;;;;;;;;;;AeqVA;AACA;ARgrDA;APp7DA;;;;;;AEmuCA;AAAA;AA8FA;AIl8CA;;;;;;;;;;;;ARmCA;AAAA;AACA;;;;;;AsC+FA;;;;;AKiUA;;;;;A1BhEA;AACA;ARgrDA;APp7DA;;;;;;AeieA;AAAA;AAAA;AfrbA;;;;AOu5DA;Ac7nBA;;;;;AnBsyEA;;;;;;;;;;;;;;;AmBruFA;;;;A4BvnBA;;AAAA;AAAA;;;;;;;;;;;;;;;;;AuBzNA;AACA;;;;;AxB5FA;AAAA;;;;;;;;;;;;;;;;;;A9Cq0CA;;;;;AmB1ZA;;;;AAAA;;;;;;A0Dx+BA;AAAA;;;;;;;;;;ApCJA;;;;;;;;;;;;;;;;;;ADguEA;;;;AxCr/CA;AAAA;AAAA;;;;;;;;;;;;;;;;AwCuvCA;;AACA;;;;;;;;;;;;;;;;;;;AsCv7DA;;;;;;AlEiBA;AAyFA;;;;;;;AiEnMA;AAAA;;;;;;;;;;A7Em9CA;AoB3wCA;ApBu5GA;AmBr/BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A+BnnFA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;;;;;AlDiyBA;AIzwBA;;;;;A0CsFA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AlB4FA;;;;;;;;;;;;;;;;;;;;;;;AApJA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AvBuwFA;AGrbA;;;;;;;;;AG9qEA;;;;;;AsDvNA;;;;;;;;;;;;;AnDgSA;AAAA;;;;;;;;;;AcrHA;;;;;;;;;;AAlDA;;;;;;;;;;A7BswCA;;;;;A6BztCA;;;;;;;;;;AYm0DA;AACA;;;;;AlCtsDA;;;;;;AawxDA;;;;;AuB5iEA;AAAA;AAAA;;;;;;;;;;;A1Cy6CA;AAAA;;;;;;;;;;AK2oBA;;;;;;;;;;;;;;;;;;AD7iEA;AAAA;AAAA;AAWA;;;;;;;;;AJy1CA;AAAA;;;;;;AuCxkCA;;;;;;;;;;;;;;A/Bi1EA;;;;;AqEljFA;;;;;A/EgFA;;;;;AEskEA;;;;;;;;;AJpsEA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AU8PA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AX3LA;AAAA;AAAA;;;;;;;;;;;;;;;;;AkB8lDA;;AAAA;;;;;A0BtmCA;;;;;;;;;AtCtYA;AACA;;;;A4DnCA;AAAA;;;;;;A7D+iEA;;;;;;;;;;;;;;;;;;;;;;;;;AgFnqEA;;;;;;;;;A9CsTA;AAAA;;;;;;AKmOA;AAAA;;;;;;AADA;;;;;;;;;;;;;AiD+NA;;;;;A1F1pBA;;;;AM3IA;;AAWA;;;;;ANgIA;;;;;;;A0B0aA;;;;;;;;AHsYA;;;;;;;;;;;;;;;;ArByaA;AAkFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AQrsBA;AA1qBA;AAAA;;;;;;;;;;;;;;;;;;AbLA;AAAA;AAAA;;;;;AKqsBA;AAAA;;;;;;;A0FxxBA;AAAA;;;;;;;;;;;;ArFs1FA;AACA;;;;;;A0BroFA;AACA;;;;;AlB6uDA;AACA;;;;;;;;;;;;;;;;;APnqDA;;;;;A4BjPA;AAAA;AAAA;;;;;;;;;;;AkD7CA;;;;;;AtFmJA;AAAA;;;;;;AUg0EA;AACA;;;;;AuC3iEA;;;;;;A5B8tDA;;;;;ArBvlEA;;;;;;;;;;;;AyCwgBA;;;;;;;;;;AEnjBA;;;;;ArCYA;AAWA;;;;;;;;;;;AuCoBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AwClDA;;;;;;;;;;;;;A5C+SA;AAAA;;;;;;ApB8tDA;;;;;;;AxBp7DA;;;;;AgBiKA;;;;;AX2tCA;;;;;;;;;;ADj4BA;;;;;;;AMo/CA;;;;;;;;;;AuBliEA;AAAA;;;;;AkBiFA;AAAA;;;;;AlBoEA;AAAA;;;;;AkBtEA;AAAA;;;;;;;;;;;AlBNA;AAMA;;;;;A7Bs2CA;;;;;;;;;;;;AiC7mCA;AAAA;;;;;;;;;;AgBwgBA;;;;;AhDigBA;;;;;AajaA;AAAA;;;;AWzZA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AVjgBA;;;;;;AbwzBA;AAAA;;;;;A6C/vBA;;;;;ApBtHA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;A3B43CA;AA0LA;;;;;;;;;;;AJljDA;;;;;;;;AmD6GA;;;;;;;;;;;;;;;;;A7CwGA;A+C4qBA;;;;;A1BvRA;AAAA;;;;;;;;;;;;AjB0+CA;;;;;;;AkBvlEA;AAAA;;;;;A+B2CA;;;;;AlDjCA;;;;;;;;;;;;;AH+MA;;;;AuBoWA;AAAA;;;;;;AxB0zBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Aa7YA;;;;;AlBr5BA;AAAA;;;;;;;;;;;;;;;;;;;;;;AkBm3DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF9sDA;;;;;;;;;;;;;;;;;;;;A8ExJA;;;;;;;;;;;;;;;;;;;AC/FA;AAAA;;;;;;AlEoFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AIwGA;;;;;;;;;;AxB/KA;;;;ASu8DA;;;;;;;;;;AM57BA;;;;Af1gCA;;;;AoC6+DA;;;;;;;A6C/9DA;;;;;;;;;;AtCyYA;AAAA;;;;AlCskBA;;;;AWjbA;AAAA;;;;;AbnQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN8wDA;;APp7DA;;;;AasKA;;;;AAAA;;;;AAAA;;;;;;;;;;AEgpBA;;;;Ab2eA;;;;;;;;;;;;;;;AgC1dA;AAAA;;;;;ATp3BA;AAAA;;;;;;;;;;;;AiE8sBA;;;;;A7E3fA;;;;AAAA;;;;AQiwDA;AAAA;;;;;;ALhzDA;;;;;;;;;;;;;;;AhB/GA;AeoXA;;;;;AAymCA;;;;;;AGphDA;AH2aA;;;;;;AwDsPA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AvE5oBA;AAAA;;;;;AG0vBA;AAAA;;;;;AuBvTA;AAAA;;;;;;AcqDA;;;;;;;;;;;;;;;AzBlGA;;;;;;;;;AAqGA;;;;A6BtkBA;AAAA;;;;;A1Cs4CA;AA5BA;;;;;;AL14CA;;;;;AyB2LA;AAAA;;;;;;;;;;;;;;;APqiCA;;;;;;;;;;;;;;;;;;;;;;;;AW3pBA;;;;;;;;AuB9NA;;;;;;;;;;ApC5DA;;;;AAAA;;;;;;;;;AiB1BA;AAAA;;;;;;ApBrMA;;;;;;;;;;;;;;;AgBofA;;;;AbrRA;;;;AAAA;;;;;;;;;;;;;;;;;;;;AKxNA;;AAAA;;;;;;;;;;ARwwEA;;;;;AWjqEA;AACA;;;;;;;;AnB+vCA;AApBA;;;;;A4BryCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A5BgnHA;;;;;AFlmHA;;;;;;;;;;;;;;;A0BoEA;;;;;AxBqpCA;;;;;AKitBA;;;;Aax7CA;AP5UA;;;;;;;;;;;;AbtKA;;;;AAtDA;;;;;;AE+wCA;AAkFA;;;;;;;;;;;;;;AgCrtBA;;;;;AEhmBA;AAAA;;;;;;;;;;;AnCu0CA;;;;;;;;;;AmCv0CA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;ArBiwBA;;;;;;ALkkDA;;;;;AAhiCA;;;;;AW1uCA;;;;;AfrMA;AAAA;;;;;;AmBuGA;;;;;;;;;;ACogBA;;;;;;ArBsCA;;;;AkEiKA;AAAA;;;;;AlDzmBA;AAHA;;;;;AEgwBA;AAAA;;;;;;AEh2BA;;;;;AZqGA;ANqoFA;;;;;;;;;;AL0+BA;;;;;AAt2EA;;;;;AIp9CA;;;;;AkBsMA;AA+ZA;;;;;;A+CxbA;;;;;AxDqxBA;;;;;;;;AqBplBA;AAAA;;;;;AvB5DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHgoCA;;;;AGhoCA;;;;;;;;;;AXmrFA;AA5lDA;;;;;;;;;;;;;;;;;;;;;;;;AQqqBA;;;;AJxjEA;AAAA;AAAA;;;;AiEq2BA;;;;;;;;;;;;A1DziBA;;;;AAAA;;;;;;;;AuB3QA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AvB2QA;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AyEnSA;;;;;AhFPA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ATyEA;AAAA;;;;;A0FlDA;;;;;;;;;;;;;;A7E2DA;;;;;APkxBA;;;;AY/PA;AAAA;;;;;AlBtiBA;;;;;;;;;;;;AkByUA;;;;;;;;;;AwDjOA;;;;AxDkKA;AAAA;;;;;AAoDA;AAAA;;;;;;;;;;;AbwuFA;AgD9vFA;;;;;;A7BonDA;;;;Afz8DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJwvBA;;;;;AwFZA;;;;;A7F5sBA;;;;;;;;AQylBA;AFyNA;;;;;;;;AqD/2BA;;;;;;;Ae6MA;;;;;;;;AhCvNA;;;;;;;;AKiBA;AAAA;;;;;;;;;;;;;;;;;;A7B87BA;;;;;AbihBA;;;;ALz5CA;AAAA;;;;;;;;;;AQwlBA;;;;;;;;;AADA;;;;;;;;;ADrfA;;;;;;;;;ADgtBA;;;;;;;;;;;;;;;;;;;;;;AGn2BA;;;;;;;;;;A4BkWA;AAOA;;;;;;;;;;;;;;;;;;;AR9CA;;;;;;;;;;AG1SA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A3BmlGA;;;;AG15EA;;;;;;;;;AK61CA;;;;;;;;;;;;;;;;;;;;;AsCn8DA;;;;AtC4tEA;;;;;;;;;;;;;;;;;AJ/yEA;;;;;;;;;AP6EA;;;;;AO/FA;AAAA;;;;;;;;;;;;;;;;;;;;;AyCuSA;;;;;;;;;;;;;;;;A/CrPA;;;;A0BgjBA;;;;;;;;;;;;;;;;;;;;;;;;;;;AxBu1BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;Aa/fA;;;;AW9WA;AAAA;;;;;;;;;;;;;;;;;;;;;AhBs+CA;AH+dA;;;;;A6Bp/DA;;;;;;;;;;;AcyUA;;;;;AhD5FA;;;;;AgC0QA;;;;;AxBk7CA;;;;;AwChmDA;;;;;;;;;;AAAA;;;;;A3Cg8DA;;;;;;;;;;AG9uBA;;;;;AH6dA;;;;;A2C/qDA;;;;;;;;;;AAAA;;;;;AqCh1BA;;;;;;;;;;A9DiEA;AAAA;;;;;AVm2BA;;;;AL4nCA;;;;;;;;;ARjnBA;;;;;AgD/lBA;;;;;;;;;;AhB1fA;;;;;A7B+RA;;;;;AgBuoCA;;;;AduTA;;;;;A6BluDA;;;;;;;;;;;;;;;AjC8KA;;;;;;;;;AuCo/CA;;;;;;;;;AGx/DA;;;;;ATsVA;;;;;AH1JA;;;;;;;;;;;;;;;;;;;AgBwJA;AACA;;;;;;;;;;;;;;;;;;;;;;ACggBA;;;;;;;;AT72BA;;;;;;;;;;AS62BA;;;;A7C5NA;AAAA;;;;;A4CvRA;AAAA;;;;;;AlD1RA;;;;;AG40CA;;;;;;;;;;;;;;AgD/jBA;;;;;AhDglBA;;;;;AgDlkBA;;;;;;;;;AnDh4BA;;;;;;;;;;;AgBs8BA;;;;;;;;;;;;;;;;A6B35BA;AAAA;;;;;A1Cw0CA;;;;;;;;;;AAk4EA;;;;;A6E/tHA;AAAA;;;;;;;;;;;;;;;;;;ArEoSA;;;;;;;;;;;;;;AAscA;A8BsnBA;;;;;;;;;AtChmBA;;;;;;;;AgC3EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ArB3YA;;;;AaoQA;;;;;;;;;;;;;A7BrfA;;;;;;;;;;;;;;;;;;;;AkBkiBA;;;;;AmB+VA;;;;;AAlIA;;;;;;;;;;;;;;;;;;;;;;AiB3wBA;AAAA;;;;;AjDmtBA;;;;;AagLA;;;;A6B17BA;;;;;;;;;;;;;A9CmDA;;;;;;ACvEA;;;;;AM+pBA;;;;;;;;;;;;;;;;;;AH+HA;;;;;AmB3uBA;;;;;Ad2gEA;;;;;Ac+aA;;;;;;;;;;;;;;AApjEA;;;;;AnBo+BA;;;;;AKgsBA;;;;;;;;;;;;;;;;;;;;A6Bj1DA;;;;;AF4aA;;;;;;;;;;;;;;;AUnqBA;;;;;;;;;;AlCkEA;;;;;AHohDA;;;;;;;;;;ALypEA;;;;;;;;;;AAvzEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AsEpwCA;;;;;;;;;;AAoGA;;;;;;;;;;;;;;;;;;;;AzD4qBA;;;;;;;;;;;;;;;;;;;;;;;;ASxWA;;;;;AdmvDA;;;;;AV5qEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AsBsBA;;;;;ApBglBA;;;;;AQ9tBA;;;;;;;;;;AAugEA;;;;;;;;;;;;;;;;;;;;AqEr/DA;;;;AlFCA;;;;AOoFA;;;;;;;;;;;;;;;;;;;A8BupCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AR7tCA;;;;;;;;;;;;;AwB/DA;;;;;;;;;;;;;;;;;;;;ArCsSA;;;;;;;;;;AXsdA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AwF2EA;;;;;;;;;;;;;;;;;AxFkhBA;;;;;;;;AAimCA;;;;;;;;;;;;;;;;;;AQ93EA;;;;AP8HA;;;;;AU4GA;;;;;AAhCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AkEtNA;;;;;;;;;ArCoxCA;;;;;A3BsNA;;;;AA9lBA;;;;AR+nCA;;;;AQ1sDA;;;;Abw+BA;;;;;;;;;AsEvuCA;;;;;AzD0zBA;;;;;;;;;;;;;;A+BjdA;;;;;;;AADA;;;;;;;AAAA;;;;;;;AAAA;;;;;A/BsZA;;;;;;;;ARkrCA;;;;;;;;;;;;;;;;A+CrlEA;;;;;;;;;;;;;;;;;;;;;;;;AoCyyBA;;;;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AtD7tBA;;;;AkBzEA;;;;AAAA;;;;;;;;;;;;;;;;;;;;AzDoCA;;;;;;;;;;;;;;;;A4BsEA;;;;;;;;;;AQ8IA;;;;;;AsCrBA;;;;;;;;;;;;A9C1HA;;;;;;;;ATwMA;;;;AuD5EA;;;;A7Di4DA;;;;AcvvCA;;;AgC/1BA;;;;;;;;AemMA;;;;AnC3IA;;;;AAyUA;;;;;;;;;AVnVA;;;;;;;;AnB4kDA;;;;APp7CA;;;;AOu4DA;;;;AL7mBA;;;;;;;;;;;;AmBoUA;;;;;;;;;;;;AN7wBA;;;;;Ae53BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A5BooBA;;;;AuC5cA;;;;AL5RA;;;;;;;;;;ArBmkBA;;;;AqBpkBA;;;;;;;AA4GA;;;;;;;;;;;;;;AU+ZA;;;;;;AyB1WA;;;;;;;;;;;;;;AnE9CA;;;;;;;;;;;AoDtKA;;;;;;;;A1DiBA;;;;;;;;;;;;;;;;A2B6FA;;;;;;;;;;;;;;AqByYA;;;;;;A5CqSA;;;;;;AAAA;;;;;;A4CrSA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A9CpTA;;;;;;AADA;;;;;;AAAA;;;;;;AeqbA;;;;;;AbqKA;;;;;;AAAA;;;;;;;;;;;;;;;;;;AarKA;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AfnaA;;;;;;AADA;;;;;;Ae84CA;;;;;;AAHA;;;;;;;;;;;;;;;;;;;;;AwErjDA;;;;;;;;;;;;;;;;ArFg1CA;;;;ALx2CA;;;A+BRA;;;;A4BdA;;;;;;;;;;;;;ApBsDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJiIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AwBjLA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AtD49CA;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;AApGA;;;;;AAy4EA;;;;AkCn4GA;;;;;;;;;;AlC+lCA;;;;;;;;;;;;;;;AayHA;;;;;AAAA;;;;;;;;;;;;;;;AqDhlCA;;;;;AANA;;;;;AlE+ZA;;;;;AAuhBA;;;;;AA9DA;;;;;AkEt3BA;;;;;A7D+jDA;;;;;;;;;;A6DjkDA;;;;;AAvBA;;;;;;;;;;;;;;;;;;;;AhD0TA;;;;;;;;;;AAwpBA;;;;;AApzBA;;;;;AAszBA;;;;;;;;;;;;;;;;;;;;AgD55CA;;;;;AlE0vBA;;;;;AkE3vBA;;;;;AlE2vBA;;;;;AiBjoBA;;;;;AiD3HA;;;;;A7DkiEA;;;;;AL3tCA;;;;;AA3EA;;;;;AkE9vBA;;;;;AlE8vBA;;;;;AiBjoBA;;;;;AiD9HA;;;;;A7DqiEA;;;;;AL3tCA;;;;;;;;;AA3EA;;;;;AkEjwBA;;;;;AlEiwBA;;;;;AiBjoBA;;;;;AiDjIA;;;;;A7DwiEA;;;;;AL3tCA;;;;;AA3EA;;;;;AkEpwBA;;;;;AlEowBA;;;;;AiBjoBA;;;;;AiDpIA;;;;;A7D2iEA;;;;;AL3tCA;;;;;AA3EA;;;;;AkEvwBA;;;;;AlEuwBA;;;;;AiBjoBA;;;;;;;;;;;;;;;;;;;;AgD7JA;;;;;AjE23CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AIr1CA;;;;;;;;;;;;;;;;;;;;AIs8CA;;;;;;AW8cA;;;AN99BA;;;;;;;;AZhbA;;;AA4UA;;;AUhlBA;;;;;;;A4CnRA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AsBRA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A/E8IA;;;;;;AY08CA;;;A6BvuCA;;;AS4gBA;;;;;;;;;;;;;;;A3C0rCA","file":"web/chemical-ecology.js","sourcesContent":["/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2017\n *\n *  @file CanvasShape.hpp\n *  @brief Define simple shapes to draw on a canvas.\n *\n *  Canvas shapes can be definied in detail, describing how they modify a canvas.\n *\n *  Other, more specific actions defined here are:\n *    CanvasCircle\n *    CanvasRect\n */\n\n#ifndef EMP_WEB_CANVASSHAPE_HPP_INCLUDE\n#define EMP_WEB_CANVASSHAPE_HPP_INCLUDE\n\n\n#include <string>\n\n#include \"../base/vector.hpp\"\n#include \"../geometry/Circle2D.hpp\"\n\n#include \"CanvasAction.hpp\"\n\nnamespace emp {\nnamespace web {\n\n  /// Define an arbitrary shape to draw on a canvas (base clase)\n  class CanvasShape : public CanvasAction {\n  protected:\n    Point p;                 ///< Anchor point for this shape.\n    std::string fill_color;  ///< Internal color to fill shape with.\n    std::string line_color;  ///< Border color for shape.\n    double line_width;       ///< How wide should lines be?\n\n  public:\n    CanvasShape(double _x, double _y, const std::string & fc=\"\", const std::string & lc=\"\", double lw=1.0)\n      : p(_x,_y), fill_color(fc), line_color(lc), line_width(lw) { ; }\n    CanvasShape(Point _p, const std::string & fc=\"\", const std::string & lc=\"\", double lw=1.0)\n      : p(_p), fill_color(fc), line_color(lc), line_width(lw) { ; }\n    virtual ~CanvasShape() { ; }\n\n    /// Shift the position of this shape to a point.\n    void MoveTo(Point _p) { p  = _p; }\n\n    /// Shift the position of this shape to coordinates.\n    void MoveTo(double _x, double _y) { p.Set(_x,_y); }\n\n    /// Setup details needed before drawing lines.\n    void SetLineWidth(double lw = 1.0) { line_width = lw; }\n\n    /// Change the fill color of this shape.\n    void SetFillColor(const std::string & color) { fill_color = color; }\n\n    /// Change the stroke color of this shape.\n    void SetLineColor(const std::string & color) { line_color = color; }\n\n    /// Actually change the color on screen.\n    void ApplyColor() {\n      LineWidth(line_width);\n      Fill(fill_color);\n      Stroke(line_color);\n    }\n  };\n\n  /// Track a circle shape to be drawn on a canvas.\n  class CanvasCircle : public CanvasShape {\n    double radius;  ///< Circle radius\n  public:\n    CanvasCircle(double _x, double _y, double _r,\n                 const std::string & fc=\"\", const std::string & lc=\"\", double lw=1.0)\n      : CanvasShape(_x, _y, fc, lc, lw), radius(_r) { ; }\n\n    CanvasCircle(Point _p, double _r, const std::string & fc=\"\", const std::string & lc=\"\", double lw=1.0)\n      : CanvasShape(_p, fc, lc, lw), radius(_r) { ; }\n\n    CanvasCircle(emp::Circle circle, const std::string & fc=\"\", const std::string & lc=\"\", double lw=1.0)\n      : CanvasShape(circle.GetCenterX(), circle.GetCenterY(), fc, lc, lw)\n      , radius(circle.GetRadius()) { ; }\n\n    void Apply() {\n      EM_ASM({\n          emp_i.ctx.beginPath();\n          emp_i.ctx.arc($0, $1, $2, 0, Math.PI*2);\n        }, p.GetX(), p.GetY(), radius);  // Draw the circle\n        ApplyColor();\n    }\n    CanvasAction * Clone() const { return new CanvasCircle(*this); }\n  };\n\n  /// Track a rectangle shape to be drawn on a canvas.\n  class CanvasRect : public CanvasShape {\n    double w;  ///< Rectangle widgth.\n    double h;  ///< Rectangle height.\n  public:\n    CanvasRect(Point _p, double _w, double _h,\n               const std::string & fc=\"\", const std::string & lc=\"\")\n      : CanvasShape(_p, fc, lc), w(_w), h(_h) { ; }\n\n    CanvasRect(double _x, double _y, double _w, double _h,\n               const std::string & fc=\"\", const std::string & lc=\"\")\n      : CanvasShape(_x, _y, fc, lc), w(_w), h(_h) { ; }\n\n    void Apply() {\n      EM_ASM({\n          emp_i.ctx.beginPath();\n          emp_i.ctx.rect($0, $1, $2, $3);\n        }, p.GetX(), p.GetY(), w, h);  // Draw the rectangle\n      ApplyColor();\n    }\n    CanvasAction * Clone() const { return new CanvasRect(*this); }\n  };\n\n  /// Clear a rectangular area in a canvas.\n  class CanvasClearRect : public CanvasShape {\n    double w;  ///< Rectangle widgth.\n    double h;  ///< Rectangle height.\n  public:\n    CanvasClearRect(Point _p, double _w, double _h)\n      : CanvasShape(_p), w(_w), h(_h) { ; }\n\n    void Apply() {\n      EM_ASM({\n          emp_i.ctx.clearRect($0, $1, $2, $3);\n        }, p.GetX(), p.GetY(), w, h);  // Draw the rectangle\n    }\n    CanvasAction * Clone() const { return new CanvasClearRect(*this); }\n  };\n\n  /// An arbitrary-sized polygon to be drawn on a canvas.\n  class CanvasPolygon : public CanvasShape {\n  private:\n    emp::vector<Point> points;  ///< Series of points defining the perimiter of the Polygon.\n  public:\n    CanvasPolygon(const std::string & fc=\"\", const std::string & lc=\"\")\n      : CanvasShape(0, 0, fc, lc) { ; }\n    CanvasPolygon(const emp::vector<Point> & p, const std::string & fc=\"\", const std::string & lc=\"\")\n      : CanvasShape(0, 0, fc, lc), points(p) { ; }\n    CanvasPolygon(Point _p, const std::string & fc=\"\", const std::string & lc=\"\")\n      : CanvasShape(_p, fc, lc) { ; }\n    CanvasPolygon(double _x, double _y, const std::string & fc=\"\", const std::string & lc=\"\")\n      : CanvasShape(_x, _y, fc, lc) { ; }\n\n    CanvasPolygon & AddPoint(double x, double y) { points.emplace_back(x,y); return *this; }\n    CanvasPolygon & AddPoint(Point p) { points.emplace_back(p); return *this; }\n\n    void Apply() {\n      EM_ASM({\n        emp_i.ctx.translate($0,$1);\n        emp_i.ctx.beginPath();\n        emp_i.ctx.moveTo($2, $3);\n      }, p.GetX(), p.GetY(), points[0].GetX(), points[0].GetY());  // Setup the polygon\n      for (size_t i = 1; i < points.size(); i++) {\n        EM_ASM({\n          emp_i.ctx.lineTo($0, $1);\n        }, points[i].GetX(), points[i].GetY());  // Draw the lines for the polygon\n      }\n      EM_ASM({\n        emp_i.ctx.closePath();\n        emp_i.ctx.translate($0,$1);\n      }, -p.GetX(), -p.GetY());  // Close the polygon\n      ApplyColor();\n    }\n    CanvasAction * Clone() const { return new CanvasPolygon(*this); }\n  };\n\n  /// A line segment on the canvas.\n  class CanvasLine : public CanvasShape {\n  private:\n    double x2;  /// X-position for second point of line segment.\n    double y2;  /// Y-position for second point of line segment.\n  public:\n    CanvasLine(double _x1, double _y1, double _x2, double _y2,\n               const std::string & lc=\"\", double lw=1.0)\n      : CanvasShape(_x1, _y1, \"\", lc, lw), x2(_x2), y2(_y2) { ; }\n    CanvasLine(Point p1, Point p2, const std::string & lc=\"\", double lw=1.0)\n      : CanvasLine(p1.GetX(), p1.GetY(), p2.GetX(), p2.GetY(), lc, lw) { ; }\n\n    void Apply() {\n      EM_ASM({\n        emp_i.ctx.beginPath();\n        emp_i.ctx.moveTo($0, $1);\n        emp_i.ctx.lineTo($2, $3);\n//        emp_i.ctx.closePath();\n      }, p.GetX(), p.GetY(), x2, y2);\n      // ApplyColor();\n      LineWidth(line_width);\n      Stroke(line_color);\n    }\n    CanvasAction * Clone() const { return new CanvasLine(*this); }\n  };\n\n  /// A whole series of line segments on the canvas.\n  /// Currently not working...\n  class CanvasMultiLine : public CanvasShape {\n  private:\n    emp::vector<Point> points;\n\n  public:\n    CanvasMultiLine(double _x1, double _y1, const emp::vector<Point> & _points,\n                    const std::string & lc=\"\", double lw=1.0)\n      : CanvasShape(_x1, _y1, \"\", lc, lw), points(_points) { ; }\n    CanvasMultiLine(Point p1, const emp::vector<Point> & _points,\n                    const std::string & lc=\"\", double lw=1.0)\n      : CanvasMultiLine(p1.GetX(), p1.GetY(), _points, lc, lw) { ; }\n\n    void Apply() {\n      // Startup the line path.\n      EM_ASM({\n        emp_i.ctx.beginPath();\n        emp_i.ctx.moveTo($0, $1);\n      }, p.GetX(), p.GetY());\n      // Loop through all internal points...\n      for (auto p : points) {\n        EM_ASM({ emp_i.ctx.lineTo($0, $1); }, p.GetX(), p.GetY());\n      }\n\n      LineWidth(line_width);\n      Stroke(line_color);\n    }\n    CanvasAction * Clone() const { return new CanvasMultiLine(*this); }\n  };\n\n  /// Text to be written on a canvas.\n  class CanvasText : public CanvasShape {\n  protected:\n    std::string text;  ///< Specific text to be written.\n    bool center;       ///< Should this text be centered (or is anchor on left side)?\n  public:\n    CanvasText(Point p, const std::string & _text,\n               const std::string & fc=\"\", const std::string & lc=\"\")\n      : CanvasShape(p, fc, lc), text(_text), center(false) { ; }\n\n    void Apply() {\n      if (center) {\n        EM_ASM({ emp_i.ctx.textAlign = \"center\"; });\n        EM_ASM({ emp_i.ctx.textBaseline = \"middle\"; });\n      }\n      EM_ASM({\n        emp_i.ctx.fillStyle = UTF8ToString($3);\n        var text = UTF8ToString($2);\n        emp_i.ctx.fillText(text,$0,$1);\n      }, p.GetX(), p.GetY(), text.c_str(), fill_color.c_str());\n    }\n\n    /// Center this text.\n    void Center(bool c=true) { center = c; }\n\n    /// Identify if text is centered.\n    bool GetCenter() const { return center; }\n\n    CanvasAction * Clone() const { return new CanvasText(*this); }\n  };\n\n}\n}\n\n#endif // #ifndef EMP_WEB_CANVASSHAPE_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2021\n *\n *  @file d3_init.hpp\n *  @brief TODO.\n */\n\n#ifndef EMP_WEB_D3_D3_INIT_HPP_INCLUDE\n#define EMP_WEB_D3_D3_INIT_HPP_INCLUDE\n\n#include <iostream>\n\n#include \"../../base/errors.hpp\"\n\n#include \"../init.hpp\"\n#include \"../JSWrap.hpp\"\n\n#include \"utils.hpp\"\n\n// #ifdef __EMSCRIPTEN__\n// extern \"C\" {\n//     extern void D3_Initialize();\n// }\n// #endif\n\nnamespace D3 {\n\n\n    // #ifdef __EMSCRIPTEN__\n    // static void InitD3() {\n    //     static bool init = false;\n    //     if (!init) {\n    //         D3_Initialize();\n    //         init = true;\n    //     }\n    // }\n    //\n    // #endif\n\n    int NextD3ID() {\n        return MAIN_THREAD_EM_ASM_INT({\n            id = js.next_id++;\n            js.counts[id] = 0;\n            js.objects[id] = -1;\n            return id;\n        });\n    }\n\n  /// A base object that all D3 objects inherit from. Handles storing the object in Javascript\n  /// You probably don't want to instantiate this directly\n\n  class D3_Base {\n  protected:\n    int id;\n\n    /// Default constructor - adds placeholder to js.objects array in Javascript\n    D3_Base(){\n      this->id = NextD3ID();\n    //   std::cout << \"Default constructor: \" << this->id << std::endl;\n      EM_ASM_ARGS({\n          js.counts[$0] = 1;\n      }, this->id);\n    }\n\n    /// Construct an object pointing to a pre-determined location in js.objects.\n    /// Warning: This trusts that you know what you're doing in choosing an id.\n    D3_Base(int id){\n      this->id = id;\n    //   std::cout << \"Int constructor: \" << id << std::endl;\n      emp_assert(EM_ASM_INT({return $0 in js.counts;}, this->id));\n\n      EM_ASM_ARGS({\n          js.counts[$0]++;\n      }, this->id);\n    }\n\n    D3_Base(const D3_Base & other) {\n        //TODO: Make this a deep copy\n        // std::cout << \"Copying: \" << other.id << std::endl;\n        this->id = other.id;\n        EM_ASM_ARGS({js.counts[$0]++;}, this->id);\n    }\n\n    D3_Base& operator= (const D3_Base & other) {\n        // std::cout << \"Calling assingment: \" << this->id << \" \" << other.id << std::endl;\n        this->id = other.id;\n        EM_ASM_ARGS({js.counts[$0]++;}, this->id);\n        return (*this);\n    }\n\n    ~D3_Base() {\n        // std::cout << \"Destructing: \" <<this->id << std::endl;\n        EM_ASM_ARGS({\n            js.counts[$0]--;\n            if (js.counts[$0] == 0) {\n                // console.log(\"Deleting: \", $0);\n                delete js.objects[$0];\n                delete js.counts[$0];\n            }\n        }, this->id);\n    }\n\n  public:\n    // Get this object's ID (i.e. it's location in the js.objects array in Javascript)\n    int GetID() const {\n      return this->id;\n    }\n\n    void Log() const {\n        EM_ASM_ARGS({console.log($0+\":\", js.objects[$0]);}, id);\n    }\n  };\n\n  /// Create a tooltup using the d3.tip Javascript library\n  class ToolTip : public D3_Base {\n  public:\n    /// Default constructor - displays whatever data is bound on mouseover\n    ToolTip() {\n      EM_ASM_ARGS({\n          js.objects[$0] = d3.tip().attr('class', 'd3-tip')\n                                    .offset([-10, 0])\n                                    .html(function(d, i) { return d; });\n      }, this->id);\n    }\n\n    /// Cosntructor that allows you to specify a function that returns the html for the tooltip.\n    /// As input, this function should take 3 parameters: the bound data, the index of this item\n    /// in the selection (int), and a placeholder (int).\n    ///\n    /// Example:\n    ///\n    ///\n    /// `D3::FormatFunction rounded = D3::FormatFunction(\".2f\");\n    ///\n    ///  std::function<double, int, int)> tooltip_display =\n    ///    [this](double d, int i, int k) {return \"Data: \" + to_string(rounded(d));}\n    ///\n    ///  D3::ToolTip tip = D3::ToolTip(tooltip_display);\n    ///\n    ///  D3::Selection example_selection = D3::SelectAll(\"circle\");\n    ///\n    ///  example_selection.SetupToolTip(tip);'\n    ///\n    ///\n    /// Mousing over a circle in the example selection will display\n    /// \"Data: \" followed by the value of d, rounded to two decimal points.\n    ToolTip(std::string func) {\n      EM_ASM_ARGS({\n        var in_string = UTF8ToString($1);\n        if (typeof window[\"d3\"][in_string] === \"function\"){\n          in_string = window[\"d3\"][in_string];\n        } else if (typeof window[\"emp\"][in_string] === \"function\"){\n          in_string = window[\"emp\"][in_string];\n        } else if (typeof window[in_string] === \"function\"){\n          in_string = window[in_string];\n        }\n\n        js.objects[$0] = d3.tip().attr('class', 'd3-tip').offset([-10, 0]).html(in_string);\n      }, this->id, func.c_str());\n    }\n\n    /// @cond TEMPLATES\n    template <typename T>\n    ToolTip(T func) {\n      emp::JSWrap(func, emp::to_string(this->id)+\"_html_func\");\n      EM_ASM_ARGS({\n          js.objects[$0] = d3.tip().attr('class', 'd3-tip')\n                                   .offset([-10, 0])\n                                   .html(emp[$0+\"_html_func\"]);\n      }, id);\n\n    }\n    /// @endcond\n\n    void SetHtml(std::string func) {\n      EM_ASM_ARGS({\n        var in_string = UTF8ToString($1);\n        if (typeof window[\"d3\"][in_string] === \"function\"){\n          in_string = window[\"d3\"][in_string];\n        } else if (typeof window[\"emp\"][in_string] === \"function\"){\n          in_string = window[\"emp\"][in_string];\n        } else if (typeof window[in_string] === \"function\"){\n          in_string = window[in_string];\n        }\n\n        js.objects[$0].html(in_string);\n      }, this->id, func.c_str());\n    }\n\n    /// @cond TEMPLATES\n    template <typename T>\n    emp::sfinae_decoy<void, decltype(&T::operator())>\n    SetHtml(T func) {\n      emp::JSWrap(func, emp::to_string(id)+\"_html_func\");\n      EM_ASM_ARGS({js.objects[$0].html(emp[$0+\"_html_func\"]);}, id);\n    }\n    /// @endcond\n\n  };\n\n  /// A callable string d3.format() string formatting function\n  class FormatFunction : public D3_Base {\n  public:\n      FormatFunction(std::string format = \"\") {\n        EM_ASM_ARGS({\n          js.objects[$1] = d3.format(UTF8ToString($0));\n        }, format.c_str(), this->id);\n      }\n\n      std::string operator() (double d){\n        char * buffer = (char *) EM_ASM_INT({\n          var text = js.objects[$0]($1);\n          var buffer = Module._malloc(text.length+1);\n          Module.stringToUTF8(text, buffer, lengthBytesUTF8(text)+1);\n          return buffer;\n        }, this->id, d);\n        std::string result = std::string(buffer);\n        free(buffer);\n        return result;\n      }\n  };\n\n  /// Catch-all object for storing references to things created in JS\n  class JSObject : public D3_Base {\n  public:\n    JSObject(){;};\n};\n\n  /// Wrapper for creating functions in javascript and calling them there\n  class JSFunction : public D3_Base {\n  public:\n    JSFunction() {;}\n    JSFunction(std::string name) {\n      int fail = EM_ASM_INT({\n        var fn = window[\"d3\"][UTF8ToString($2)];\n        if (typeof fn === \"function\") {\n          js.objects[$0] = fn;\n          return 0;\n        } else {\n          var fn = window[\"emp\"][UTF8ToString($2)];\n          if (typeof fn === \"function\") {\n            js.objects[$0] = fn;\n            return 0;\n          } else {\n            var fn = window[UTF8ToString($2)];\n            if (typeof fn === \"function\") {\n              js.objects[$0] = fn;\n              return 0;\n            }\n          }\n        }\n        return 1;\n      }, this->id, name.c_str());\n\n      if (fail) {\n        emp::NotifyWarning(\"Invalid function name passed to JSFunction\");\n      }\n    }\n\n    /// Only works if function has no arguments or returns\n    void operator() () {\n        EM_ASM_ARGS({\n          js.objects[$0]();\n      }, this->id);\n    }\n\n  };\n}\n\n#endif // #ifndef EMP_WEB_D3_D3_INIT_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2016-2018\n *\n *  @file scales.hpp\n *  @brief Tools for scaling graph axes in D3.\n */\n\n#ifndef EMP_WEB_D3_SCALES_HPP_INCLUDE\n#define EMP_WEB_D3_SCALES_HPP_INCLUDE\n\n#include \"d3_init.hpp\"\n#include \"utils.hpp\"\n\n#include \"../js_utils.hpp\"\n\nnamespace D3 {\n\n  /// Scales in D3 are functions that take input values and map them to output based on\n  /// a scaling function. They are often used to map data calues to x, y coordinates in pixels\n  /// describing where on the screen elements should be placed.\n  /// This is a base class to inherit from - should never be made stand-alone\n  class Scale : public D3_Base {\n  protected:\n    Scale(int id) : D3_Base(id){;};\n\n  public:\n    Scale() {;}\n\n    /// Decoy constructor so we don't construct extra base scales\n    Scale(bool derived){;};\n\n    /// Set the output values corresponding to values in the domain. Output for values in between\n    /// will be interpolated with a function determined by the type of the scale.\n    /// Array should contain same number of elements as the one used to set the domain.\n    template <typename T, size_t SIZE>\n    Scale& SetRange(emp::array<T,SIZE> values) {\n      emp::pass_array_to_javascript(values);\n      MAIN_THREAD_EM_ASM({js.objects[$0].range(emp_i.__incoming_array);}, this->id);\n      return *this;\n    }\n\n    Scale& SetRange(double min, double max) {\n      MAIN_THREAD_EM_ASM({js.objects[$0].range([$1, $2]);}, this->id, min, max);\n      return *this;\n    }\n\n    /// Set the input values corresponding to values in the range.\n    /// Array should contain same number of elements as the one used to set the range.\n    template <typename T, size_t SIZE>\n    Scale& SetDomain(emp::array<T,SIZE> values) {\n      emp::pass_array_to_javascript(values);\n      MAIN_THREAD_EM_ASM({js.objects[$0].domain(emp_i.__incoming_array);}, this->id);\n      return *this;\n    }\n\n    Scale& SetDomain(double min, double max) {\n      MAIN_THREAD_EM_ASM({js.objects[$0].domain([$1, $2]);}, this->id, min, max);\n      return *this;\n    }\n\n    /// Make a copy of this scale\n    Scale Copy() {\n      int new_id = EM_ASM_INT_V({return js.objects.next_id++});\n      MAIN_THREAD_EM_ASM({\n        js.objects[$1] = js.objects[$0].copy();\n      }, this->id, new_id);\n      return Scale(new_id);\n    }\n\n    /// Calculate the ouput for [input], based on the scale's scaling function\n    double ApplyScale(double input) {\n      //TODO: make this work for other types\n      return EM_ASM_DOUBLE({return js.objects[$0]($1);},this->id, input);\n    }\n\n    int ApplyScale(int input) {\n      return EM_ASM_INT({return js.objects[$0]($1);},this->id, input);\n    }\n\n    /// Calculate the ouput for [input], based on the scale's scaling function\n    std::string ApplyScaleString(double input) {\n      //TODO: make this work for other types\n      char * buffer = (char *) EM_ASM_INT({\n        result = js.objects[$0]($1);\n        // console.log(result);\n        var buffer = Module._malloc(result.length+1);\n        Module.stringToUTF8(result, buffer, result.length*4+1);\n        return buffer;\n\n      },this->id, input);\n\n      std::string result = std::string(buffer);\n      free(buffer);\n      return result;\n\n    }\n\n\n    //TODO:Getters\n\n  };\n\n\n  class QuantizeScale : public Scale {\n  public:\n    QuantizeScale() : Scale(true) {MAIN_THREAD_EM_ASM({js.objects[$0]=d3.scaleQuantize()},this->id);}\n    QuantizeScale(bool derived) : Scale(true) {;}\n\n    template <typename T>\n    double InvertExtent(T y) {\n      return EM_ASM_DOUBLE({return js.objects[$0].invertExtent($1);},\n         this->id, y);\n    }\n  };\n\n  class QuantileScale : public QuantizeScale {\n  public:\n    QuantileScale() : QuantizeScale(true) { MAIN_THREAD_EM_ASM({js.objects[$0] = d3.scaleQuantile();}, this->id);}\n    QuantileScale(bool derived) : QuantizeScale(true) {;}\n    //TODO: Quantiles()\n  };\n\n  class ThresholdScale : public QuantizeScale {\n  public:\n    ThresholdScale() : QuantizeScale(true) {\n      MAIN_THREAD_EM_ASM({js.objects[$0] = d3.scaleThreshold()}, this->id);\n    }\n    ThresholdScale(bool derived) : QuantizeScale(true) {;}\n  };\n\n  class IdentityScale : public Scale {\n  public:\n    IdentityScale() : Scale(true) {\n      MAIN_THREAD_EM_ASM({js.objects[$0] = d3.scaleIdentity();}, this->id);\n    }\n\n    IdentityScale(bool derived) : Scale(true){;}\n\n    template <typename T>\n    double Invert(T y) {\n      return EM_ASM_DOUBLE({return js.objects[$0].invert($1);}, this->id, y);\n    }\n\n    IdentityScale& SetTicks(int count) {\n      MAIN_THREAD_EM_ASM({js.objects[$0].ticks($1);}, this->id, count);\n      return *this;\n    }\n\n    IdentityScale& SetTickFormat(int count, std::string format) {\n      //TODO: format is technically optional, but what is the point of this\n      //function without it?\n      MAIN_THREAD_EM_ASM({js.objects[$0].tick($1, UTF8ToString($2));},\n      this->id, count, format.c_str());\n      return *this;\n    }\n  };\n\n  class LinearScale : public IdentityScale {\n  public:\n    LinearScale() : IdentityScale(true) {\n      MAIN_THREAD_EM_ASM({js.objects[$0] = d3.scaleLinear();}, this->id);\n    }\n\n    LinearScale(bool derived) : IdentityScale(true) {;}\n\n    template <typename T, size_t SIZE>\n    LinearScale& SetRangeRound(emp::array<T,SIZE> values) {\n      emp::pass_array_to_javascript(values);\n      MAIN_THREAD_EM_ASM({js.objects[$0].rangeRound(emp.__incoming_array);}, this->id);\n      return *this;\n    }\n\n    LinearScale& SetRangeRound(double min, double max) {\n      MAIN_THREAD_EM_ASM({js.objects[$0].rangeRound([$1, $2]);}, this->id, min, max);\n      return *this;\n    }\n\n\n    LinearScale& SetInterpolate(std::string factory) {\n      D3_CALLBACK_METHOD_1_ARG(interpolate, factory.c_str())\n      return *this;\n    }\n\n    LinearScale& Clamp(bool clamp) {\n      MAIN_THREAD_EM_ASM({js.objects[$0].clamp($1);}, this->id, clamp);\n      return *this;\n    }\n\n    LinearScale& Nice(int count = -1) {\n      if (count != -1){\n        MAIN_THREAD_EM_ASM({js.objects[$0].nice($1);}, this->id, count);\n      } else {\n        MAIN_THREAD_EM_ASM({js.objects[$0].nice();}, this->id);\n      }\n      return *this;\n    }\n\n  };\n\n  class LogScale : public LinearScale {\n  public:\n    LogScale() : LinearScale(true) {\n      MAIN_THREAD_EM_ASM({js.objects[$0] = d3.scaleLog();}, this->id);\n    }\n\n    LogScale(bool derived) : LinearScale(true){;};\n\n  };\n\n  class PowScale : public LinearScale {\n  public:\n    PowScale() : LinearScale(true) {\n      MAIN_THREAD_EM_ASM({js.objects[$0] = d3.scalePow();}, this->id);\n    }\n\n    PowScale(bool derived) : LinearScale(true){;};\n\n    PowScale& Exponent(double ex) {\n        MAIN_THREAD_EM_ASM({js.objects[$0].exponent($1);}, this->id, ex);\n        return *this;\n    }\n  };\n\n  PowScale SqrtScale() {\n      return PowScale().Exponent(.5);\n  }\n\n  class TimeScale : public LinearScale {\n  public:\n    TimeScale() : LinearScale(true) {\n      MAIN_THREAD_EM_ASM({js.objects[$0] = d3.scaleTime();}, this->id);\n    }\n\n    TimeScale(bool derived) : LinearScale(true){;};\n  };\n\n  class OrdinalScale : public QuantizeScale {\n  public:\n    OrdinalScale() : QuantizeScale(true) {\n      EM_ASM({js.objects[$0]= d3.scaleOrdinal();}, this->id);\n    }\n\n    OrdinalScale(bool derived) : QuantizeScale(true){;}\n  };\n\n\n  class Category10Scale : D3_Base{\n  public:\n    Category10Scale() {\n      EM_ASM({js.objects[$0] = d3.scaleCategory10();}, this->id);\n    }\n  };\n\n  class Category20Scale : D3_Base {\n  public:\n    Category20Scale() {\n      EM_ASM({js.objects[$0] = d3.scaleCategory20();}, this->id);\n    }\n  };\n\n  class Category20bScale : D3_Base {\n  public:\n    Category20bScale() {\n      EM_ASM({js.objects[$0] = d3.scaleCategory20b();}, this->id);\n    }\n  };\n\n  class Category20cScale : D3_Base {\n  protected:\n    int id;\n  public:\n    Category20cScale() {\n      EM_ASM({js.objects[$0] = d3.scaleCategory20c();}, this->id);\n    }\n  };\n}\n\n#endif // #ifndef EMP_WEB_D3_SCALES_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2016-2019.\n *\n *  @file vector.hpp\n *  @brief A drop-in wrapper for std::vector; adds on bounds checking in debug mode.\n *  @note Status: BETA\n *\n *  This class is a drop-in wrapper for std::vector, adding on bounds checking, both for the\n *  indexing operator and for the use of iterators (ensure that iterators do not outlive the\n *  version of vector for which it was created.)\n *  If EMP_NDEBUG is set then it reverts back to std::vector.\n *\n *  @todo Debug code: member functions that take iterators should also take emp iterators that verify\n *        whether those iterators are valid.\n */\n\n#ifndef EMP_BASE_VECTOR_HPP_INCLUDE\n#define EMP_BASE_VECTOR_HPP_INCLUDE\n\n\n#include <initializer_list>\n#include <iterator>\n#include <utility>\n#include <vector>\n\n#include \"assert.hpp\"\n\n#ifdef EMP_NDEBUG\n\n// Seemlessly translate emp::vector to std::vector\nnamespace emp {\n  template <typename T, typename... Ts> using vector = std::vector<T, Ts...>;\n}\n\n\n#else // #EMP_NDEBUG *not* set\n\nnamespace emp {\n\n  /// Build a debug wrapper emp::vector around std::vector.\n  template <typename T, typename... Ts>\n  class vector : public std::vector<T,Ts...> {\n  private:\n    using this_t = emp::vector<T,Ts...>;\n    using stdv_t = std::vector<T,Ts...>;\n\n    /// Setup a threshold; if we try to make a vector bigger than MAX_SIZE, throw a warning.\n    constexpr static const size_t MAX_SIZE = 2000000001; // 2x10^9 + 1\n\n  public:\n    /// Setup a revision number - iterators must match the revision of their vector.\n    int revision;\n\n    /// Setup an iterator wrapper to make sure that they're not used again after a vector changes.\n    template<typename ITERATOR_T>\n    struct iterator_wrapper : public ITERATOR_T {\n      using this_t = iterator_wrapper<ITERATOR_T>;\n      using wrapped_t = ITERATOR_T;\n      using vec_t = emp::vector<T,Ts...>;\n\n      /// What vector and revision was this iterator created from?\n      const vec_t * v_ptr;\n      int revision;\n\n      // @CAO: For the moment cannot create an emp iterator from a base since we don't know vector to use.\n      // iterator_wrapper(const ITERATOR_T & _in)\n      //   : ITERATOR_T(_in), v_ptr(nullptr), revision(0) { ; }\n      iterator_wrapper(const ITERATOR_T & _in, const vec_t * _v)\n        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }\n      iterator_wrapper(const this_t &) = default;\n      iterator_wrapper(this_t &&) = default;\n      iterator_wrapper() = default;\n      ~iterator_wrapper() { ; }\n\n      // Debug tools to make sure this iterator is okay.\n      static std::string & ErrorCode() { static std::string code=\"No Errors Found.\"; return code; }\n\n      bool OK(bool begin_ok=true, bool end_ok=true) const {\n        if (v_ptr == nullptr) { ErrorCode() = \"Invalid Vector! (set to nullptr)\"; return false; }\n        if (v_ptr->revision == 0) { ErrorCode() = \"Vector deleted! (revision==0)\"; return false; }\n        if (revision != v_ptr->revision) { ErrorCode() = \"Vector has changed memeory!\"; return false; }\n        int64_t pos = 0;\n        if constexpr (std::is_same<ITERATOR_T, typename stdv_t::reverse_iterator>() ||\n                      std::is_same<ITERATOR_T, typename stdv_t::const_reverse_iterator>()) {\n          // pos = std::distance(*((ITERATOR_T *) this), ((stdv_t *) v_ptr)->rend()) - 1;\n          pos = ((stdv_t *) v_ptr)->rend() - *((ITERATOR_T *) this) - 1;\n        }\n        else {\n          // pos = std::distance(((stdv_t *) v_ptr)->begin(), *((ITERATOR_T *) this));\n          pos = *((ITERATOR_T *) this) - ((stdv_t *) v_ptr)->begin();\n        }\n        if (pos < 0 || ((size_t) pos) > v_ptr->size()) {\n          ErrorCode() = \"Iterator out of range.\";\n          ErrorCode() += \" size=\";\n          ErrorCode() += std::to_string(v_ptr->size());\n          ErrorCode() += \"  pos=\";\n          ErrorCode() += std::to_string(pos);\n          return false;\n        }\n        if (!begin_ok && pos == 0) { ErrorCode() = \"Iterator not allowed at begin().\"; return false; }\n        if (!end_ok && ((size_t) pos) == v_ptr->size()) { ErrorCode() = \"Iterator not allowed at end().\"; return false; }\n        return true;\n      }\n\n      this_t & operator=(const this_t &) = default;\n      this_t & operator=(this_t &&) = default;\n\n      operator ITERATOR_T() { return *this; }\n      operator const ITERATOR_T() const { return *this; }\n\n      auto & operator*() {\n        emp_assert(OK(true, false), ErrorCode());  // Ensure vector hasn't changed since making iterator.\n        return wrapped_t::operator*();\n      }\n      const auto & operator*() const {\n        emp_assert(OK(true, false), ErrorCode());  // Ensure vector hasn't changed since making iterator.\n        return wrapped_t::operator*();\n      }\n\n      auto operator->() {\n        emp_assert(OK(true, false), ErrorCode());  // Ensure vector hasn't changed since making iterator.\n        return wrapped_t::operator->();\n      }\n      auto operator->() const {\n        emp_assert(OK(true, false), ErrorCode());  // Ensure vector hasn't changed since making iterator.\n        return wrapped_t::operator->();\n      }\n\n      this_t & operator++() {\n        emp_assert(OK(true,false), ErrorCode());\n        wrapped_t::operator++();\n        return *this;\n      }\n      this_t operator++(int x) {\n        emp_assert(OK(true,false), ErrorCode());\n        return this_t(wrapped_t::operator++(x), v_ptr);\n      }\n      this_t & operator--() {\n        emp_assert(OK(false,true), ErrorCode());\n        wrapped_t::operator--();\n        return *this;\n      }\n      this_t operator--(int x) {\n        emp_assert(OK(false,true), ErrorCode());\n        return this_t(wrapped_t::operator--(x), v_ptr);\n      }\n\n      auto operator+(int in) { emp_assert(OK(), ErrorCode()); return this_t(wrapped_t::operator+(in), v_ptr); }\n      auto operator-(int in) { emp_assert(OK(), ErrorCode()); return this_t(wrapped_t::operator-(in), v_ptr); }\n      auto operator-(const this_t & in) { emp_assert(OK(), ErrorCode()); return ((wrapped_t) *this) - (wrapped_t) in; }\n\n      this_t & operator+=(int in) { emp_assert(OK(), ErrorCode()); wrapped_t::operator+=(in); return *this; }\n      this_t & operator-=(int in) { emp_assert(OK(), ErrorCode()); wrapped_t::operator-=(in); return *this; }\n      auto & operator[](int offset) { emp_assert(OK(), ErrorCode()); return wrapped_t::operator[](offset); }\n\n      //bool operator==(const wrapped_t & in) const { emp_assert(OK(), ErrorCode()); return wrapped_t::operator==(in); }\n      //bool operator!=(const wrapped_t & in) const { emp_assert(OK(), ErrorCode()); return wrapped_t::operator!=(in); }\n\n      //bool operator< (const wrapped_t & in) const { emp_assert(OK(), ErrorCode()); return wrapped_t::operator< (in); }\n      //bool operator<=(const wrapped_t & in) const { emp_assert(OK(), ErrorCode()); return wrapped_t::operator<=(in); }\n      //bool operator> (const wrapped_t & in) const { emp_assert(OK(), ErrorCode()); return wrapped_t::operator> (in); }\n      //bool operator>=(const wrapped_t & in) const { emp_assert(OK(), ErrorCode()); return wrapped_t::operator>=(in); }\n    };\n\n    using iterator = iterator_wrapper< typename stdv_t::iterator >;\n    using const_iterator = iterator_wrapper< typename stdv_t::const_iterator >;\n    using reverse_iterator = iterator_wrapper< typename stdv_t::reverse_iterator >;\n    using const_reverse_iterator = iterator_wrapper< typename stdv_t::const_reverse_iterator >;\n    using value_type = T;\n    using size_type = typename stdv_t::size_type;\n    using reference = typename stdv_t::reference;\n    using const_reference = typename stdv_t::const_reference;\n\n    vector() : stdv_t(), revision(1) {};\n    vector(const this_t & _in) : stdv_t(_in), revision(1) {};\n    vector(size_t size) : stdv_t(size), revision(1) { emp_assert(size < MAX_SIZE, size); }\n    vector(size_t size, const T & val) : stdv_t(size, val), revision(1) { emp_assert(size < MAX_SIZE, size); }\n    vector(std::initializer_list<T> in_list) : stdv_t(in_list), revision(1) { ; }\n    vector(const stdv_t & in) : stdv_t(in), revision(1) { ; }         // Emergency fallback conversion.\n    template <typename InputIt>\n    vector(InputIt first, InputIt last) : stdv_t(first, last), revision(1) { ; }\n    ~vector() { revision = 0; } // Clear out revision when vector is deleted.\n\n    size_t size() const { return stdv_t::size(); }\n\n    iterator begin() noexcept { return iterator(stdv_t::begin(), this); }\n    const_iterator begin() const noexcept { return const_iterator(stdv_t::begin(), this); }\n    iterator end() noexcept { return iterator(stdv_t::end(), this); }\n    const_iterator end() const noexcept { return const_iterator(stdv_t::end(), this); }\n\n    const_iterator cbegin() const noexcept { return const_iterator(stdv_t::cbegin(), this); }\n    const_iterator cend() const noexcept { return const_iterator(stdv_t::cend(), this); }\n\n    reverse_iterator rbegin() noexcept { return reverse_iterator(stdv_t::rbegin(), this); }\n    const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(stdv_t::rbegin(), this); }\n    reverse_iterator rend() noexcept { return reverse_iterator(stdv_t::rend(), this); }\n    const_reverse_iterator rend() const noexcept { return const_reverse_iterator(stdv_t::rend(), this); }\n\n    const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(stdv_t::crbegin(), this); }\n    const_reverse_iterator crend() const noexcept { return const_reverse_iterator(stdv_t::crend(), this); }\n\n    // operator stdv_t &() { return v; }\n    // operator const stdv_t &() const { return v; }\n\n    void resize(size_t new_size) {\n      emp_assert(new_size < MAX_SIZE, new_size);\n      stdv_t::resize(new_size);\n      revision++;\n    }\n    void resize(size_t new_size, const T & val) {\n      emp_assert(new_size < MAX_SIZE, new_size);\n      stdv_t::resize(new_size, val);\n      revision++;\n    }\n    this_t & operator=(const this_t &) = default;\n\n    T & operator[](size_t pos) {\n      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());\n      return stdv_t::operator[](pos);\n    }\n\n    const T & operator[](size_t pos) const {\n      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());\n      return stdv_t::operator[](pos);\n    }\n\n    T & back() { emp_assert(stdv_t::size() > 0); return stdv_t::back(); }\n    const T & back() const { emp_assert(stdv_t::size() > 0); return stdv_t::back(); }\n    T & front() { emp_assert(stdv_t::size() > 0); return stdv_t::front(); }\n    const T & front() const { emp_assert(stdv_t::size() > 0); return stdv_t::front(); }\n\n    template <typename... PB_Ts>\n    void push_back(PB_Ts &&... args) {\n      stdv_t::push_back(std::forward<PB_Ts>(args)...);\n      revision++;\n    }\n\n    void pop_back() {\n      emp_assert(stdv_t::size() > 0, stdv_t::size());\n      stdv_t::pop_back();\n      revision++;           // Technically reducing size can cause memory reallocation, but less likely.\n    }\n\n    template <typename... ARGS>\n    iterator insert(ARGS &&... args) {\n      ++revision;\n      return iterator( stdv_t::insert(std::forward<ARGS>(args)...), this );\n    }\n\n    template <typename... ARGS>\n    iterator erase(ARGS &&... args) {\n      ++revision;\n      return iterator( stdv_t::erase(std::forward<ARGS>(args)...), this );\n    }\n\n    template <typename... ARGS>\n    iterator emplace(ARGS &&... args) {\n      ++revision;\n      return iterator( stdv_t::emplace(std::forward<ARGS>(args)...), this );\n    }\n\n    template <typename... ARGS>\n    void emplace_back(ARGS &&... args) {\n      stdv_t::emplace_back(std::forward<ARGS>(args)...);\n      revision++;\n    }\n  };\n\n  /// Build a specialized debug wrapper for emp::vector<bool>\n  template <typename... Ts>\n  class vector<bool, Ts...> : public std::vector<bool,Ts...> {\n  private:\n    using this_t = emp::vector<bool,Ts...>;\n    using stdv_t = std::vector<bool,Ts...>;\n\n    /// Setup a threshold; if we try to make a vector bigger than MAX_SIZE, throw a warning.\n    constexpr static const size_t MAX_SIZE = 2000000001;\n\n  public:\n    using iterator = typename stdv_t::iterator;\n    using const_iterator = typename stdv_t::const_iterator;\n    using value_type = bool;\n    using size_type = typename stdv_t::size_type;\n    using reference = typename stdv_t::reference;\n    using const_reference = typename stdv_t::const_reference;\n\n    vector() : stdv_t() {};\n    vector(const this_t & _in) : stdv_t(_in) {};\n    vector(size_t size) : stdv_t(size) { emp_assert(size < MAX_SIZE, size); }\n    vector(size_t size, bool val) : stdv_t(size, val) { emp_assert(size < MAX_SIZE, size); }\n    vector(std::initializer_list<bool> in_list) : stdv_t(in_list) { ; }\n    vector(const stdv_t & in) : stdv_t(in) { ; }         // Emergency fallback conversion.\n    template <typename InputIt>\n    vector(InputIt first, InputIt last) : stdv_t(first, last){;}\n\n\n    // operator stdv_t &() { return v; }\n    // operator const stdv_t &() const { return v; }\n\n    void resize(size_t new_size) { emp_assert(new_size < MAX_SIZE, new_size); stdv_t::resize(new_size); }\n    void resize(size_t new_size, bool val) {\n      emp_assert(new_size < MAX_SIZE, new_size);\n      stdv_t::resize(new_size, val);\n    }\n    this_t & operator=(const this_t &) = default;\n\n    auto operator[](size_t pos) -> decltype(stdv_t::operator[](pos)) {\n      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());\n      return stdv_t::operator[](pos);\n    }\n\n    bool operator[](size_t pos) const {\n      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());\n      return stdv_t::operator[](pos);\n    }\n\n    auto & back() { emp_assert(stdv_t::size() > 0); return stdv_t::back(); }\n    bool back() const { emp_assert(stdv_t::size() > 0); return stdv_t::back(); }\n    auto & front() { emp_assert(stdv_t::size() > 0); return stdv_t::front(); }\n    bool front() const { emp_assert(stdv_t::size() > 0); return stdv_t::front(); }\n\n    void pop_back() {\n      emp_assert(stdv_t::size() > 0, stdv_t::size());\n      stdv_t::pop_back();\n    }\n  };\n\n  // A crude, generic printing function for vectors.\n  template <typename T, typename... Ts>\n  std::ostream & operator<<(std::ostream & out, const emp::vector<T,Ts...> & v) {\n    for (const T & x : v) out << x << \" \";\n    return out;\n  }\n\n  template <typename T, typename... Ts>\n  std::istream & operator>>(std::istream & is, emp::vector<T,Ts...> & v) {\n    for (T & x : v) is >> x;\n    return is;\n  }\n}\n\n#endif\n\n// namespace emp {\n//   template<typename T, typename... Ts> struct TypeID< emp::vector<T,Ts...> > {\n//     static std::string GetName() {\n//       using simple_vt = emp::vector<T>;\n//       using full_vt = emp::vector<T,Ts...>;\n//       if (std::is_same<simple_vt,full_vt>::value) {\n//         return \"emp::vector<\" + TypeID<T>::GetName() + \">\";\n//       }\n//       return \"emp::vector<\" + TypeID<TypePack<T,Ts...>>::GetTypes() + \">\";\n//     }\n//   };\n// }\n\n#endif // #ifndef EMP_BASE_VECTOR_HPP_INCLUDE\n","// -*- C++ -*-\n//===-------------------------- iterator ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ITERATOR\n#define _LIBCPP_ITERATOR\n\n/*\n    iterator synopsis\n\nnamespace std\n{\n\ntemplate<class Iterator>\nstruct iterator_traits\n{\n    typedef typename Iterator::difference_type difference_type;\n    typedef typename Iterator::value_type value_type;\n    typedef typename Iterator::pointer pointer;\n    typedef typename Iterator::reference reference;\n    typedef typename Iterator::iterator_category iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef T* pointer;\n    typedef T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class Category, class T, class Distance = ptrdiff_t,\n         class Pointer = T*, class Reference = T&>\nstruct iterator\n{\n    typedef T         value_type;\n    typedef Distance  difference_type;\n    typedef Pointer   pointer;\n    typedef Reference reference;\n    typedef Category  iterator_category;\n};\n\nstruct input_iterator_tag  {};\nstruct output_iterator_tag {};\nstruct forward_iterator_tag       : public input_iterator_tag         {};\nstruct bidirectional_iterator_tag : public forward_iterator_tag       {};\nstruct random_access_iterator_tag : public bidirectional_iterator_tag {};\n\n// 27.4.3, iterator operations\n// extension: second argument not conforming to C++03\ntemplate <class InputIterator>  // constexpr in C++17\n  constexpr void advance(InputIterator& i,\n             typename iterator_traits<InputIterator>::difference_type n);\n\ntemplate <class InputIterator>  // constexpr in C++17\n  constexpr typename iterator_traits<InputIterator>::difference_type\n    distance(InputIterator first, InputIterator last);\n\ntemplate <class InputIterator>  // constexpr in C++17\n  constexpr InputIterator next(InputIterator x,\ntypename iterator_traits<InputIterator>::difference_type n = 1);\n\ntemplate <class BidirectionalIterator>  // constexpr in C++17\n  constexpr BidirectionalIterator prev(BidirectionalIterator x,\n    typename iterator_traits<BidirectionalIterator>::difference_type n = 1);    \n\ntemplate <class Iterator>\nclass reverse_iterator\n    : public iterator<typename iterator_traits<Iterator>::iterator_category,\n                      typename iterator_traits<Iterator>::value_type,\n                      typename iterator_traits<Iterator>::difference_type,\n                      typename iterator_traits<Iterator>::pointer,\n                      typename iterator_traits<Iterator>::reference>\n{\nprotected:\n    Iterator current;\npublic:\n    typedef Iterator                                            iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type difference_type;\n    typedef typename iterator_traits<Iterator>::reference       reference;\n    typedef typename iterator_traits<Iterator>::pointer         pointer;\n\n    constexpr reverse_iterator();\n    constexpr explicit reverse_iterator(Iterator x);\n    template <class U> constexpr reverse_iterator(const reverse_iterator<U>& u);\n    template <class U> constexpr reverse_iterator& operator=(const reverse_iterator<U>& u);\n    constexpr Iterator base() const;\n    constexpr reference operator*() const;\n    constexpr pointer   operator->() const;\n    constexpr reverse_iterator& operator++();\n    constexpr reverse_iterator  operator++(int);\n    constexpr reverse_iterator& operator--();\n    constexpr reverse_iterator  operator--(int);\n    constexpr reverse_iterator  operator+ (difference_type n) const;\n    constexpr reverse_iterator& operator+=(difference_type n);\n    constexpr reverse_iterator  operator- (difference_type n) const;\n    constexpr reverse_iterator& operator-=(difference_type n);\n    constexpr reference         operator[](difference_type n) const;\n};\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr auto\noperator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y)\n-> decltype(__y.base() - __x.base());   // constexpr in C++17\n\ntemplate <class Iterator>\nconstexpr reverse_iterator<Iterator>\noperator+(typename reverse_iterator<Iterator>::difference_type n, \n          const reverse_iterator<Iterator>& x);   // constexpr in C++17\n\ntemplate <class Iterator>\nconstexpr reverse_iterator<Iterator> make_reverse_iterator(Iterator i); // C++14, constexpr in C++17\n\ntemplate <class Container>\nclass back_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                   container_type;\n    typedef void                        value_type;\n    typedef void                        difference_type;\n    typedef void                        reference;\n    typedef void                        pointer;\n\n    explicit back_insert_iterator(Container& x);\n    back_insert_iterator& operator=(const typename Container::value_type& value);\n    back_insert_iterator& operator*();\n    back_insert_iterator& operator++();\n    back_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> back_insert_iterator<Container> back_inserter(Container& x);\n\ntemplate <class Container>\nclass front_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                    container_type;\n    typedef void                         value_type;\n    typedef void                         difference_type;\n    typedef void                         reference;\n    typedef void                         pointer;\n\n    explicit front_insert_iterator(Container& x);\n    front_insert_iterator& operator=(const typename Container::value_type& value);\n    front_insert_iterator& operator*();\n    front_insert_iterator& operator++();\n    front_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> front_insert_iterator<Container> front_inserter(Container& x);\n\ntemplate <class Container>\nclass insert_iterator\n{\nprotected:\n    Container* container;\n    typename Container::iterator iter;\npublic:\n    typedef Container              container_type;\n    typedef void                   value_type;\n    typedef void                   difference_type;\n    typedef void                   reference;\n    typedef void                   pointer;\n\n    insert_iterator(Container& x, typename Container::iterator i);\n    insert_iterator& operator=(const typename Container::value_type& value);\n    insert_iterator& operator*();\n    insert_iterator& operator++();\n    insert_iterator& operator++(int);\n};\n\ntemplate <class Container, class Iterator>\ninsert_iterator<Container> inserter(Container& x, Iterator i);\n\ntemplate <class Iterator>\nclass move_iterator {\npublic:\n    typedef Iterator                                              iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type   difference_type;\n    typedef Iterator                                              pointer;\n    typedef typename iterator_traits<Iterator>::value_type        value_type;\n    typedef typename iterator_traits<Iterator>::iterator_category iterator_category;\n    typedef value_type&&                                          reference;\n \n    constexpr move_iterator();  // all the constexprs are in C++17\n    constexpr explicit move_iterator(Iterator i);\n    template <class U>\n      constexpr move_iterator(const move_iterator<U>& u);\n    template <class U>\n      constexpr move_iterator& operator=(const move_iterator<U>& u);\n    constexpr iterator_type base() const;\n    constexpr reference operator*() const;\n    constexpr pointer operator->() const;\n    constexpr move_iterator& operator++();\n    constexpr move_iterator operator++(int);\n    constexpr move_iterator& operator--();\n    constexpr move_iterator operator--(int);\n    constexpr move_iterator operator+(difference_type n) const; \n    constexpr move_iterator& operator+=(difference_type n); \n    constexpr move_iterator operator-(difference_type n) const; \n    constexpr move_iterator& operator-=(difference_type n); \n    constexpr unspecified operator[](difference_type n) const;\nprivate:\n    Iterator current; // exposition only\n};\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator==(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator!=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator<(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator<=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator>(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator>=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr auto   // constexpr in C++17\noperator-(const move_iterator<Iterator1>& x,\n          const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());\n\ntemplate <class Iterator>\nconstexpr move_iterator<Iterator> operator+(   // constexpr in C++17\n            typename move_iterator<Iterator>::difference_type n, \n            const move_iterator<Iterator>& x);\n\ntemplate <class Iterator>   // constexpr in C++17\nconstexpr  move_iterator<Iterator> make_move_iterator(const Iterator& i);\n\n\ntemplate <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>\nclass istream_iterator\n    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_istream<charT,traits> istream_type;\n\n    constexpr istream_iterator();\n    istream_iterator(istream_type& s);\n    istream_iterator(const istream_iterator& x);\n    ~istream_iterator();\n\n    const T& operator*() const;\n    const T* operator->() const;\n    istream_iterator& operator++();\n    istream_iterator  operator++(int);\n};\n\ntemplate <class T, class charT, class traits, class Distance>\nbool operator==(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\ntemplate <class T, class charT, class traits, class Distance>\nbool operator!=(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT> >\nclass ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void ,void>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_ostream<charT,traits> ostream_type;\n\n    ostream_iterator(ostream_type& s);\n    ostream_iterator(ostream_type& s, const charT* delimiter);\n    ostream_iterator(const ostream_iterator& x);\n    ~ostream_iterator();\n    ostream_iterator& operator=(const T& value);\n\n    ostream_iterator& operator*();\n    ostream_iterator& operator++();\n    ostream_iterator& operator++(int);\n};\n\ntemplate<class charT, class traits = char_traits<charT> >\nclass istreambuf_iterator\n    : public iterator<input_iterator_tag, charT,\n                      typename traits::off_type, unspecified,\n                      charT>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef typename traits::int_type     int_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_istream<charT,traits>   istream_type;\n\n    istreambuf_iterator() noexcept;\n    istreambuf_iterator(istream_type& s) noexcept;\n    istreambuf_iterator(streambuf_type* s) noexcept;\n    istreambuf_iterator(a-private-type) noexcept;\n\n    charT                operator*() const;\n    pointer operator->() const;\n    istreambuf_iterator& operator++();\n    a-private-type       operator++(int);\n\n    bool equal(const istreambuf_iterator& b) const;\n};\n\ntemplate <class charT, class traits>\nbool operator==(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\ntemplate <class charT, class traits>\nbool operator!=(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_ostream<charT,traits>   ostream_type;\n\n    ostreambuf_iterator(ostream_type& s) noexcept;\n    ostreambuf_iterator(streambuf_type* s) noexcept;\n    ostreambuf_iterator& operator=(charT c);\n    ostreambuf_iterator& operator*();\n    ostreambuf_iterator& operator++();\n    ostreambuf_iterator& operator++(int);\n    bool failed() const noexcept;\n};\n\ntemplate <class C> constexpr auto begin(C& c) -> decltype(c.begin());\ntemplate <class C> constexpr auto begin(const C& c) -> decltype(c.begin());\ntemplate <class C> constexpr auto end(C& c) -> decltype(c.end());\ntemplate <class C> constexpr auto end(const C& c) -> decltype(c.end());\ntemplate <class T, size_t N> constexpr T* begin(T (&array)[N]);\ntemplate <class T, size_t N> constexpr T* end(T (&array)[N]);\n\ntemplate <class C> auto constexpr cbegin(const C& c) -> decltype(std::begin(c));        // C++14\ntemplate <class C> auto constexpr cend(const C& c) -> decltype(std::end(c));            // C++14\ntemplate <class C> auto constexpr rbegin(C& c) -> decltype(c.rbegin());                 // C++14\ntemplate <class C> auto constexpr rbegin(const C& c) -> decltype(c.rbegin());           // C++14\ntemplate <class C> auto constexpr rend(C& c) -> decltype(c.rend());                     // C++14\ntemplate <class C> constexpr auto rend(const C& c) -> decltype(c.rend());               // C++14\ntemplate <class E> reverse_iterator<const E*> constexpr rbegin(initializer_list<E> il); // C++14\ntemplate <class E> reverse_iterator<const E*> constexpr rend(initializer_list<E> il);   // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> constexpr rbegin(T (&array)[N]);      // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> constexpr rend(T (&array)[N]);        // C++14\ntemplate <class C> constexpr auto crbegin(const C& c) -> decltype(std::rbegin(c));      // C++14\ntemplate <class C> constexpr auto crend(const C& c) -> decltype(std::rend(c));          // C++14\n\n// 24.8, container access:\ntemplate <class C> constexpr auto size(const C& c) -> decltype(c.size());         // C++17\ntemplate <class T, size_t N> constexpr size_t size(const T (&array)[N]) noexcept; // C++17\ntemplate <class C> constexpr auto empty(const C& c) -> decltype(c.empty());       // C++17\ntemplate <class T, size_t N> constexpr bool empty(const T (&array)[N]) noexcept;  // C++17\ntemplate <class E> constexpr bool empty(initializer_list<E> il) noexcept;         // C++17\ntemplate <class C> constexpr auto data(C& c) -> decltype(c.data());               // C++17\ntemplate <class C> constexpr auto data(const C& c) -> decltype(c.data());         // C++17\ntemplate <class T, size_t N> constexpr T* data(T (&array)[N]) noexcept;           // C++17\ntemplate <class E> constexpr const E* data(initializer_list<E> il) noexcept;      // C++17\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd> // for forward declarations of vector and string.\n#include <__functional_base>\n#include <type_traits>\n#include <cstddef>\n#include <initializer_list>\n#include <version>\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nstruct _LIBCPP_TEMPLATE_VIS input_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS output_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS forward_iterator_tag       : public input_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS bidirectional_iterator_tag : public forward_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS random_access_iterator_tag : public bidirectional_iterator_tag {};\n\ntemplate <class _Tp>\nstruct __has_iterator_typedefs\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename std::__void_t<typename _Up::iterator_category>::type* = 0,\n    \t\t\t\t\t\t\t\t\t\ttypename std::__void_t<typename _Up::difference_type>::type* = 0,\n    \t\t\t\t\t\t\t\t\t\ttypename std::__void_t<typename _Up::value_type>::type* = 0,\n    \t\t\t\t\t\t\t\t\t\ttypename std::__void_t<typename _Up::reference>::type* = 0,\n    \t\t\t\t\t\t\t\t\t\ttypename std::__void_t<typename _Up::pointer>::type* = 0\n    \t\t\t\t\t\t\t\t\t\t);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0,0,0,0,0)) == 1;\n};\n\n\ntemplate <class _Tp>\nstruct __has_iterator_category\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::iterator_category* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits_impl {};\n\ntemplate <class _Iter>\nstruct __iterator_traits_impl<_Iter, true>\n{\n    typedef typename _Iter::difference_type   difference_type;\n    typedef typename _Iter::value_type        value_type;\n    typedef typename _Iter::pointer           pointer;\n    typedef typename _Iter::reference         reference;\n    typedef typename _Iter::iterator_category iterator_category;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits {};\n\ntemplate <class _Iter>\nstruct __iterator_traits<_Iter, true>\n    :  __iterator_traits_impl\n      <\n        _Iter,\n        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||\n        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value\n      >\n{};\n\n// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category\n//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a\n//    conforming extension which allows some programs to compile and behave as\n//    the client expects instead of failing at compile time.\n\ntemplate <class _Iter>\nstruct _LIBCPP_TEMPLATE_VIS iterator_traits\n    : __iterator_traits<_Iter, __has_iterator_typedefs<_Iter>::value> {};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS iterator_traits<_Tp*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef typename remove_cv<_Tp>::type value_type;\n    typedef _Tp* pointer;\n    typedef _Tp& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>\nstruct __has_iterator_category_convertible_to\n    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>\n{};\n\ntemplate <class _Tp, class _Up>\nstruct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};\n\ntemplate <class _Tp>\nstruct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_exactly_input_iterator\n    : public integral_constant<bool, \n         __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value && \n        !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> {};\n\ntemplate<class _Category, class _Tp, class _Distance = ptrdiff_t,\n         class _Pointer = _Tp*, class _Reference = _Tp&>\nstruct _LIBCPP_TEMPLATE_VIS iterator\n{\n    typedef _Tp        value_type;\n    typedef _Distance  difference_type;\n    typedef _Pointer   pointer;\n    typedef _Reference reference;\n    typedef _Category  iterator_category;\n};\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nvoid __advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)\n{\n    for (; __n > 0; --__n)\n        ++__i;\n}\n\ntemplate <class _BiDirIter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nvoid __advance(_BiDirIter& __i,\n             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)\n{\n    if (__n >= 0)\n        for (; __n > 0; --__n)\n            ++__i;\n    else\n        for (; __n < 0; ++__n)\n            --__i;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nvoid __advance(_RandIter& __i,\n             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)\n{\n   __i += __n;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nvoid advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n)\n{\n    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\ntypename iterator_traits<_InputIter>::difference_type\n__distance(_InputIter __first, _InputIter __last, input_iterator_tag)\n{\n    typename iterator_traits<_InputIter>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        ++__r;\n    return __r;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\ntypename iterator_traits<_RandIter>::difference_type\n__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)\n{\n    return __last - __first;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\ntypename iterator_traits<_InputIter>::difference_type\ndistance(_InputIter __first, _InputIter __last)\n{\n    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\ntypename enable_if\n<\n    __is_input_iterator<_InputIter>::value, \n    _InputIter\n>::type\nnext(_InputIter __x,\n     typename iterator_traits<_InputIter>::difference_type __n = 1)\n{\n    _VSTD::advance(__x, __n);\n    return __x;\n}\n\ntemplate <class _BidirectionalIter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\ntypename enable_if\n<\n    __is_bidirectional_iterator<_BidirectionalIter>::value, \n    _BidirectionalIter\n>::type\nprev(_BidirectionalIter __x,\n     typename iterator_traits<_BidirectionalIter>::difference_type __n = 1)\n{\n    _VSTD::advance(__x, -__n);\n    return __x;\n}\n\n\ntemplate <class _Tp, class = void>\nstruct __is_stashing_iterator : false_type {};\n\ntemplate <class _Tp>\nstruct __is_stashing_iterator<_Tp, typename __void_t<typename _Tp::__stashing_iterator_tag>::type>\n  : true_type {};\n\ntemplate <class _Iter>\nclass _LIBCPP_TEMPLATE_VIS reverse_iterator\n    : public iterator<typename iterator_traits<_Iter>::iterator_category,\n                      typename iterator_traits<_Iter>::value_type,\n                      typename iterator_traits<_Iter>::difference_type,\n                      typename iterator_traits<_Iter>::pointer,\n                      typename iterator_traits<_Iter>::reference>\n{\nprivate:\n    /*mutable*/ _Iter __t;  // no longer used as of LWG #2360, not removed due to ABI break\n\n    static_assert(!__is_stashing_iterator<_Iter>::value,\n      \"The specified iterator type cannot be used with reverse_iterator; \"\n      \"Using stashing iterators with reverse_iterator causes undefined behavior\");\n\nprotected:\n    _Iter current;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<_Iter>::difference_type difference_type;\n    typedef typename iterator_traits<_Iter>::reference       reference;\n    typedef typename iterator_traits<_Iter>::pointer         pointer;\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator() : __t(), current() {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n        reverse_iterator(const reverse_iterator<_Up>& __u) : __t(__u.base()), current(__u.base()) {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n        reverse_iterator& operator=(const reverse_iterator<_Up>& __u)\n            { __t = current = __u.base(); return *this; }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    _Iter base() const {return current;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reference operator*() const {_Iter __tmp = current; return *--__tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    pointer  operator->() const {return _VSTD::addressof(operator*());}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator++() {--current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator++(int) {reverse_iterator __tmp(*this); --current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator--() {++current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator--(int) {reverse_iterator __tmp(*this); ++current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator+ (difference_type __n) const {return reverse_iterator(current - __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator+=(difference_type __n) {current -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator- (difference_type __n) const {return reverse_iterator(current + __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator-=(difference_type __n) {current += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reference         operator[](difference_type __n) const {return *(*this + __n);}\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n-> decltype(__y.base() - __x.base())\n{\n    return __y.base() - __x.base();\n}\n#else\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename reverse_iterator<_Iter1>::difference_type\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __y.base() - __x.base();\n}\n#endif\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Iter>\noperator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)\n{\n    return reverse_iterator<_Iter>(__x.base() - __n);\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Iter> make_reverse_iterator(_Iter __i)\n{\n    return reverse_iterator<_Iter>(__i);\n}\n#endif\n\ntemplate <class _Container>\nclass _LIBCPP_TEMPLATE_VIS back_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      void>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit back_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_back(__value_); return *this;}\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_back(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nback_insert_iterator<_Container>\nback_inserter(_Container& __x)\n{\n    return back_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TEMPLATE_VIS front_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      void>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit front_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_front(__value_); return *this;}\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_front(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nfront_insert_iterator<_Container>\nfront_inserter(_Container& __x)\n{\n    return front_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TEMPLATE_VIS insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      void>\n{\nprotected:\n    _Container* container;\n    typename _Container::iterator iter;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY insert_iterator(_Container& __x, typename _Container::iterator __i)\n        : container(_VSTD::addressof(__x)), iter(__i) {}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {iter = container->insert(iter, __value_); ++iter; return *this;}\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {iter = container->insert(iter, _VSTD::move(__value_)); ++iter; return *this;}\n#endif  // _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator*()        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++()       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++(int)    {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\ninsert_iterator<_Container>\ninserter(_Container& __x, typename _Container::iterator __i)\n{\n    return insert_iterator<_Container>(__x, __i);\n}\n\ntemplate <class _Tp, class _CharT = char,\n          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>\nclass _LIBCPP_TEMPLATE_VIS istream_iterator\n    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_istream<_CharT,_Traits> istream_type;\nprivate:\n    istream_type* __in_stream_;\n    _Tp __value_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istream_iterator() : __in_stream_(0), __value_() {}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator(istream_type& __s) : __in_stream_(_VSTD::addressof(__s))\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY const _Tp& operator*() const {return __value_;}\n    _LIBCPP_INLINE_VISIBILITY const _Tp* operator->() const {return _VSTD::addressof((operator*()));}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator& operator++()\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY istream_iterator  operator++(int)\n        {istream_iterator __t(*this); ++(*this); return __t;}\n\n    template <class _Up, class _CharU, class _TraitsU, class _DistanceU>\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool\n    operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __x,\n               const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __y);\n\n    template <class _Up, class _CharU, class _TraitsU, class _DistanceU>\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool\n    operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __x,\n               const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __y);\n};\n\ntemplate <class _Tp, class _CharT, class _Traits, class _Distance>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __x,\n           const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __y)\n{\n    return __x.__in_stream_ == __y.__in_stream_;\n}\n\ntemplate <class _Tp, class _CharT, class _Traits, class _Distance>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __x,\n           const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_ostream<_CharT,_Traits> ostream_type;\nprivate:\n    ostream_type* __out_stream_;\n    const char_type* __delim_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s) _NOEXCEPT\n        : __out_stream_(_VSTD::addressof(__s)), __delim_(0) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s, const _CharT* __delimiter) _NOEXCEPT\n        : __out_stream_(_VSTD::addressof(__s)), __delim_(__delimiter) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator=(const _Tp& __value_)\n        {\n            *__out_stream_ << __value_;\n            if (__delim_)\n                *__out_stream_ << __delim_;\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++(int) {return *this;}\n};\n\ntemplate<class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS istreambuf_iterator\n    : public iterator<input_iterator_tag, _CharT,\n                      typename _Traits::off_type, _CharT*,\n                      _CharT>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef typename _Traits::int_type      int_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_istream<_CharT,_Traits>   istream_type;\nprivate:\n    mutable streambuf_type* __sbuf_;\n\n    class __proxy\n    {\n        char_type __keep_;\n        streambuf_type* __sbuf_;\n        _LIBCPP_INLINE_VISIBILITY __proxy(char_type __c, streambuf_type* __s)\n            : __keep_(__c), __sbuf_(__s) {}\n        friend class istreambuf_iterator;\n    public:\n        _LIBCPP_INLINE_VISIBILITY char_type operator*() const {return __keep_;}\n    };\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __test_for_eof() const\n    {\n        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))\n            __sbuf_ = 0;\n        return __sbuf_ == 0;\n    }\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator() _NOEXCEPT : __sbuf_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(istream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(const __proxy& __p) _NOEXCEPT\n        : __sbuf_(__p.__sbuf_) {}\n\n    _LIBCPP_INLINE_VISIBILITY char_type  operator*() const\n        {return static_cast<char_type>(__sbuf_->sgetc());}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator& operator++()\n        {\n            __sbuf_->sbumpc();\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY __proxy              operator++(int)\n        {\n            return __proxy(__sbuf_->sbumpc(), __sbuf_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY bool equal(const istreambuf_iterator& __b) const\n        {return __test_for_eof() == __b.__test_for_eof();}\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return __a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return !__a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_ostream<_CharT,_Traits>   ostream_type;\nprivate:\n    streambuf_type* __sbuf_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(ostream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator=(_CharT __c)\n        {\n            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))\n                __sbuf_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++(int) {return *this;}\n    _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\n    template <class _Ch, class _Tr>\n    friend\n    _LIBCPP_HIDDEN\n    ostreambuf_iterator<_Ch, _Tr>\n    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,\n                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,\n                     ios_base& __iob, _Ch __fl);\n#endif\n};\n\ntemplate <class _Iter>\nclass _LIBCPP_TEMPLATE_VIS move_iterator\n{\nprivate:\n    _Iter __i;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type difference_type;\n    typedef iterator_type pointer;\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename iterator_traits<iterator_type>::reference __reference;\n    typedef typename conditional<\n            is_reference<__reference>::value,\n            typename remove_reference<__reference>::type&&,\n            __reference\n        >::type reference;\n#else\n    typedef typename iterator_traits<iterator_type>::reference reference;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator() : __i() {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    explicit move_iterator(_Iter __x) : __i(__x) {}\n    template <class _Up>\n      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n      move_iterator(const move_iterator<_Up>& __u) : __i(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 _Iter base() const {return __i;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 \n    reference operator*() const { return static_cast<reference>(*__i); }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    pointer  operator->() const { return __i;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator++() {++__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator++(int) {move_iterator __tmp(*this); ++__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator--() {--__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator--(int) {move_iterator __tmp(*this); --__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator+ (difference_type __n) const {return move_iterator(__i + __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator+=(difference_type __n) {__i += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator- (difference_type __n) const {return move_iterator(__i - __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator-=(difference_type __n) {__i -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reference operator[](difference_type __n) const { return static_cast<reference>(__i[__n]); }\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n-> decltype(__x.base() - __y.base())\n{\n    return __x.base() - __y.base();\n}\n#else\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename move_iterator<_Iter1>::difference_type\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() - __y.base();\n}\n#endif\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nmove_iterator<_Iter>\noperator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)\n{\n    return move_iterator<_Iter>(__x.base() + __n);\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nmove_iterator<_Iter>\nmake_move_iterator(_Iter __i)\n{\n    return move_iterator<_Iter>(__i);\n}\n\n// __wrap_iter\n\ntemplate <class _Iter> class __wrap_iter;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\nbool\noperator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\nbool\noperator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\nbool\noperator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\nbool\noperator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\nbool\noperator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\nbool\noperator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\nauto\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n-> decltype(__x.base() - __y.base());\n#else\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n#endif\n\ntemplate <class _Iter>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) _NOEXCEPT_DEBUG;\n\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY copy(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY copy_backward(_B1, _B1, _B2);\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY move(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY move_backward(_B1, _B1, _B2);\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*>);\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    __wrap_iter<_Tp*>\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i);\n\n#endif\n\ntemplate <class _Iter>\nclass __wrap_iter\n{\npublic:\n    typedef _Iter                                                      iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type        value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer           pointer;\n    typedef typename iterator_traits<iterator_type>::reference         reference;\nprivate:\n    iterator_type __i;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter() _NOEXCEPT_DEBUG\n#if _LIBCPP_STD_VER > 11\n                : __i{}\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\n        __wrap_iter(const __wrap_iter<_Up>& __u,\n            typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) _NOEXCEPT_DEBUG\n            : __i(__u.base())\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__u);\n#endif\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\n    __wrap_iter(const __wrap_iter& __x)\n        : __i(__x.base())\n    {\n        __get_db()->__iterator_copy(this, &__x);\n    }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\n    __wrap_iter& operator=(const __wrap_iter& __x)\n    {\n        if (this != &__x)\n        {\n            __get_db()->__iterator_copy(this, &__x);\n            __i = __x.__i;\n        }\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\n    ~__wrap_iter()\n    {\n        __get_db()->__erase_i(this);\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG reference operator*() const _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return *__i;\n    }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG pointer  operator->() const _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return (pointer)_VSTD::addressof(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter& operator++() _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable iterator\");\n#endif\n        ++__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter  operator++(int) _NOEXCEPT_DEBUG\n        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter& operator--() _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable iterator\");\n#endif\n        --__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter  operator--(int) _NOEXCEPT_DEBUG\n        {__wrap_iter __tmp(*this); --(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter  operator+ (difference_type __n) const _NOEXCEPT_DEBUG\n        {__wrap_iter __w(*this); __w += __n; return __w;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter& operator+=(difference_type __n) _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),\n                   \"Attempted to add/subtract iterator outside of valid range\");\n#endif\n        __i += __n;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter  operator- (difference_type __n) const _NOEXCEPT_DEBUG\n        {return *this + (-__n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter& operator-=(difference_type __n) _NOEXCEPT_DEBUG\n        {*this += -__n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG reference    operator[](difference_type __n) const _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),\n                   \"Attempted to subscript iterator outside of valid range\");\n#endif\n        return __i[__n];\n    }\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG iterator_type base() const _NOEXCEPT_DEBUG {return __i;}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter(const void* __p, iterator_type __x) : __i(__x)\n    {\n        __get_db()->__insert_ic(this, __p);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter(iterator_type __x) _NOEXCEPT_DEBUG : __i(__x) {}\n#endif\n\n    template <class _Up> friend class __wrap_iter;\n    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;\n    template <class _Tp, class _Alloc> friend class _LIBCPP_TEMPLATE_VIS vector;\n    template <class _Tp, ptrdiff_t> friend class _LIBCPP_TEMPLATE_VIS span;\n\n    template <class _Iter1, class _Iter2>\n    _LIBCPP_CONSTEXPR_IF_NODEBUG friend\n    bool\n    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    _LIBCPP_CONSTEXPR_IF_NODEBUG friend\n    bool\n    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    _LIBCPP_CONSTEXPR_IF_NODEBUG friend\n    bool\n    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    _LIBCPP_CONSTEXPR_IF_NODEBUG friend\n    bool\n    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    _LIBCPP_CONSTEXPR_IF_NODEBUG friend\n    bool\n    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    _LIBCPP_CONSTEXPR_IF_NODEBUG friend\n    bool\n    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Iter1, class _Iter2>\n    _LIBCPP_CONSTEXPR_IF_NODEBUG friend\n    auto\n    operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n    -> decltype(__x.base() - __y.base());\n#else\n    template <class _Iter1, class _Iter2>\n    _LIBCPP_CONSTEXPR_IF_NODEBUG friend\n    typename __wrap_iter<_Iter1>::difference_type\n    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n#endif\n\n    template <class _Iter1>\n    _LIBCPP_CONSTEXPR_IF_NODEBUG friend\n    __wrap_iter<_Iter1>\n    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) _NOEXCEPT_DEBUG;\n\n    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);\n    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_IF_NODEBUG friend\n    typename enable_if\n    <\n        is_trivially_copy_assignable<_Tp>::value,\n        _Tp*\n    >::type\n    __unwrap_iter(__wrap_iter<_Tp*>);\n#else\n  template <class _Tp>\n  inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\n  typename enable_if\n  <\n      is_trivially_copy_assignable<_Tp>::value,\n      __wrap_iter<_Tp*>\n  >::type\n  __unwrap_iter(__wrap_iter<_Tp*> __i);\n#endif\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\nbool\noperator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\nbool\noperator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to compare incomparable iterators\");\n#endif\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__y < __x);\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\nauto\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n-> decltype(__x.base() - __y.base())\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n#else\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n#endif\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type __n,\n          __wrap_iter<_Iter> __x) _NOEXCEPT_DEBUG\n{\n    __x += __n;\n    return __x;\n}\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator\n    : public _LIBCPP_BOOL_CONSTANT(is_pointer<_Iter>::value) {};\n    \ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<move_iterator<_Iter> >\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<reverse_iterator<_Iter> >\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nbegin(_Tp (&__array)[_Np])\n{\n    return __array;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nend(_Tp (&__array)[_Np])\n{\n    return __array + _Np;\n}\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nbegin(_Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nbegin(const _Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nend(_Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nend(const _Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array + _Np);\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array);\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.end());\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.begin());\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cbegin(const _Cp& __c) -> decltype(_VSTD::begin(__c))\n{\n    return _VSTD::begin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cend(const _Cp& __c) -> decltype(_VSTD::end(__c))\n{\n    return _VSTD::end(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rbegin(_Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rbegin(const _Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rend(_Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rend(const _Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto crbegin(const _Cp& __c) -> decltype(_VSTD::rbegin(__c))\n{\n    return _VSTD::rbegin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto crend(const _Cp& __c) -> decltype(_VSTD::rend(__c))\n{\n    return _VSTD::rend(__c);\n}\n\n#endif\n\n\n#else  // defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nbegin(_Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nbegin(const _Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nend(_Cp& __c)\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nend(const _Cp& __c)\n{\n    return __c.end();\n}\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\n#if _LIBCPP_STD_VER > 14\n\n// #if _LIBCPP_STD_VER > 11\n// template <>\n// struct _LIBCPP_TEMPLATE_VIS plus<void>\n// {\n//     template <class _T1, class _T2>\n//     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n//     auto operator()(_T1&& __t, _T2&& __u) const\n//     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u)))\n//     -> decltype        (_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u))\n//         { return        _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u); }\n//     typedef void is_transparent;\n// };\n// #endif\n\ntemplate <class _Cont>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr auto size(const _Cont& __c)\n_NOEXCEPT_(noexcept(__c.size()))\n-> decltype        (__c.size())\n{ return            __c.size(); }\n\ntemplate <class _Tp, size_t _Sz>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr size_t size(const _Tp (&)[_Sz]) noexcept { return _Sz; }\n\ntemplate <class _Cont>\n_LIBCPP_NODISCARD_AFTER_CXX17 inline _LIBCPP_INLINE_VISIBILITY\nconstexpr auto empty(const _Cont& __c)\n_NOEXCEPT_(noexcept(__c.empty()))\n-> decltype        (__c.empty())\n{ return            __c.empty(); }\n\ntemplate <class _Tp, size_t _Sz>\n_LIBCPP_NODISCARD_AFTER_CXX17 inline _LIBCPP_INLINE_VISIBILITY\nconstexpr bool empty(const _Tp (&)[_Sz]) noexcept { return false; }\n\ntemplate <class _Ep>\n_LIBCPP_NODISCARD_AFTER_CXX17 inline _LIBCPP_INLINE_VISIBILITY\nconstexpr bool empty(initializer_list<_Ep> __il) noexcept { return __il.size() == 0; }\n\ntemplate <class _Cont> constexpr\ninline _LIBCPP_INLINE_VISIBILITY\nauto data(_Cont& __c)\n_NOEXCEPT_(noexcept(__c.data()))\n-> decltype        (__c.data())\n{ return            __c.data(); }\n\ntemplate <class _Cont> constexpr\ninline _LIBCPP_INLINE_VISIBILITY\nauto data(const _Cont& __c)\n_NOEXCEPT_(noexcept(__c.data()))\n-> decltype        (__c.data()) \n{ return            __c.data(); }\n\ntemplate <class _Tp, size_t _Sz>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _Tp* data(_Tp (&__array)[_Sz]) noexcept { return __array; }\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr const _Ep* data(initializer_list<_Ep> __il) noexcept { return __il.begin(); }\n#endif\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ITERATOR\n","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const basic_string& str, size_type pos, size_type n,\n                 const Allocator& a = Allocator());\n    template<class T>\n        basic_string(const T& t, size_type pos, size_type n, const Allocator& a = Allocator()); // C++17\n    template <class T>\n        explicit basic_string(const T& t, const Allocator& a = Allocator()); // C++17\n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    operator basic_string_view<charT, traits>() const noexcept;\n\n    basic_string& operator=(const basic_string& str);\n    template <class T>\n        basic_string& operator=(const T& t); // C++17\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value ); // C++17\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    template <class T>\n        basic_string& operator+=(const T& t);              // C++17\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    template <class T>\n        basic_string& append(const T& t);                 // C++17\n    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14\n    template <class T>\n        basic_string& append(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    template <class T>\n        basic_string& assign(const T& t);  // C++17\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14\n    template <class T>\n        basic_string& assign(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    template <class T>\n        basic_string& insert(size_type pos1, const T& t);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    template <class T>\n        basic_string& insert(size_type pos1, const T& t, size_type pos2, size_type n); // C++17\n    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    template <class T>\n    basic_string& replace(size_type pos1, size_type n1, const T& t);  // C++17\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2=npos); // C++14\n    template <class T>\n        basic_string& replace(size_type pos1, size_type n1, const T& t,\n                              size_type pos2, size_type n); // C++17\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    template <class T>\n        basic_string& replace(const_iterator i1, const_iterator i2, const T& t);  // C++17\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n          value_type* data()       noexcept;   // C++17\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    template <class T>\n        size_type find(const T& t, size_type pos = 0) const;  // C++17\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    template <class T>\n        size_type rfind(const T& t, size_type pos = npos) const;  // C++17\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    template <class T>\n        size_type find_first_of(const T& t, size_type pos = 0) const; // C++17\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    template <class T>\n        size_type find_last_of(const T& t, size_type pos = npos) const noexcept;  // C++17\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    template <class T>\n        size_type find_first_not_of(const T& t, size_type pos = 0) const; // C++17\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    template <class T>\n        size_type find_last_not_of(const T& t, size_type pos = npos) const; // C++17\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    template <class T>\n        int compare(const T& t) const noexcept;  // C++17\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    template <class T>\n        int compare(size_type pos1, size_type n1, const T& t) const;  // C++17\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2=npos) const; // C++14\n    template <class T>\n        int compare(size_type pos1, size_type n1, const T& t,\n                    size_type pos2, size_type n2=npos) const; // C++17\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool starts_with(basic_string_view<charT, traits> sv) const noexcept; // C++2a\n    bool starts_with(charT c) const noexcept;                             // C++2a\n    bool starts_with(const charT* s) const;                               // C++2a\n    bool ends_with(basic_string_view<charT, traits> sv) const noexcept;   // C++2a\n    bool ends_with(charT c) const noexcept;                               // C++2a\n    bool ends_with(const charT* s) const;                                 // C++2a\n\n    bool __invariants() const;\n};\n\ntemplate<class InputIterator,\n         class Allocator = allocator<typename iterator_traits<InputIterator>::value_type>>\nbasic_string(InputIterator, InputIterator, Allocator = Allocator())\n   -> basic_string<typename iterator_traits<InputIterator>::value_type,\n                  char_traits<typename iterator_traits<InputIterator>::value_type>,\n                  Allocator>;   // C++17\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator, class U>\nvoid erase(basic_string<charT, traits, Allocator>& c, const U& value); // C++20\ntemplate<class charT, class traits, class Allocator, class Predicate>\nvoid erase_if(basic_string<charT, traits, Allocator>& c, Predicate pred); // C++20\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <string_view>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#include <version>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TEMPLATE_VIS fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))\n\ntemplate <bool>\nclass _LIBCPP_TEMPLATE_VIS __basic_string_common\n{\nprotected:\n    _LIBCPP_NORETURN void __throw_length_error() const;\n    _LIBCPP_NORETURN void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n    _VSTD::__throw_length_error(\"basic_string\");\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n    _VSTD::__throw_out_of_range(\"basic_string\");\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __basic_string_common<true>)\n\n#ifdef _LIBCPP_NO_EXCEPTIONS\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public true_type {};\n#elif defined(_LIBCPP_HAS_NO_NOEXCEPT)\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public false_type {};\n#else\ntemplate <class _Iter, bool = __is_forward_iterator<_Iter>::value>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public _LIBCPP_BOOL_CONSTANT((\n    noexcept(++(declval<_Iter&>())) && \n    is_nothrow_assignable<_Iter&, _Iter>::value && \n    noexcept(declval<_Iter>() == declval<_Iter>()) && \n    noexcept(*declval<_Iter>())\n)) {};\n\ntemplate <class _Iter> \nstruct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false> : public false_type {};\n#endif\n\n\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value) {};\n\ntemplate <class _CharT, class _Traits, class _Tp>\nstruct __can_be_converted_to_string_view : public _LIBCPP_BOOL_CONSTANT(\n    ( is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&\n     !is_convertible<const _Tp&, const _CharT*>::value)) {};\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef basic_string_view<_CharT, _Traits>           __self_view;\n    typedef _Traits                                      traits_type;\n    typedef _CharT                                       value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n\n    static_assert((!is_array<value_type>::value), \"Character type of basic_string must not be an array\");\n    static_assert(( is_standard_layout<value_type>::value), \"Character type of basic_string must be standard-layout\");\n    static_assert(( is_trivial<value_type>::value), \"Character type of basic_string must be trivial\");\n    static_assert(( is_same<_CharT, typename traits_type::char_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n    static_assert(( is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n#if defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#ifdef _LIBCPP_BIG_ENDIAN\n    static const size_type __short_mask = 0x01;\n    static const size_type __long_mask  = 0x1ul;\n#else  // _LIBCPP_BIG_ENDIAN\n    static const size_type __short_mask = 0x80;\n    static const size_type __long_mask  = ~(size_type(~0) >> 1);\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#ifdef _LIBCPP_BIG_ENDIAN\n    static const size_type __short_mask = 0x80;\n    static const size_type __long_mask  = ~(size_type(~0) >> 1);\n#else  // _LIBCPP_BIG_ENDIAN\n    static const size_type __short_mask = 0x01;\n    static const size_type __long_mask  = 0x1ul;\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    union __ulx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_CXX03_LANG\n\n#ifndef _LIBCPP_HAS_NO_DEDUCTION_GUIDES\n    template <class = typename enable_if<__is_allocator<_Allocator>::value, nullptr_t>::type>\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const _CharT* __s) {\n      _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*) detected nullptr\");\n      __init(__s, traits_type::length(__s));\n#   if _LIBCPP_DEBUG_LEVEL >= 2\n      __get_db()->__insert_c(this);\n#   endif\n    }\n\n#ifndef _LIBCPP_HAS_NO_DEDUCTION_GUIDES\n    template <class = typename enable_if<__is_allocator<_Allocator>::value, nullptr_t>::type>\n#endif\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(const _CharT* __s, const _Allocator& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const _CharT* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const _CharT* __s, size_type __n, const _Allocator& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, _CharT __c);\n\n#ifndef _LIBCPP_HAS_NO_DEDUCTION_GUIDES\n    template <class = typename enable_if<__is_allocator<_Allocator>::value, nullptr_t>::type>\n#endif\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(size_type __n, _CharT __c, const _Allocator& __a);\n\n    basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                 const _Allocator& __a = _Allocator());\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const basic_string& __str, size_type __pos,\n                 const _Allocator& __a = _Allocator());\n\n    template<class _Tp, class = typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type>\n        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n        basic_string(const _Tp& __t, size_type __pos, size_type __n,\n                              const allocator_type& __a = allocator_type());\n\n    template<class _Tp, class = typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type>\n        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n        explicit basic_string(const _Tp& __t);\n\n    template<class _Tp, class = typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type>\n        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n        explicit basic_string(const _Tp& __t, const allocator_type& __a);\n\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<_CharT> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<_CharT> __il, const _Allocator& __a);\n#endif  // _LIBCPP_CXX03_LANG\n\n    inline ~basic_string();\n\n    _LIBCPP_INLINE_VISIBILITY\n    operator __self_view() const _NOEXCEPT { return __self_view(data(), size()); }\n\n    basic_string& operator=(const basic_string& __str);\n\n    template <class _Tp, class = typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type>\n    basic_string& operator=(const _Tp& __t)\n        {__self_view __sv = __t; return assign(__sv);}\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n     _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer() + size());}\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap()\n                             : static_cast<size_type>(__min_cap)) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type __res_arg);\n    _LIBCPP_INLINE_VISIBILITY void __resize_default_init(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void reserve() _NOEXCEPT {reserve(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos)       _NOEXCEPT;\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                                            operator+=(const _Tp& __t)            {__self_view __sv = __t; return append(__sv);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)     {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  append(const _Tp& __t) { __self_view __sv = __t; return append(__sv.data(), __sv.size()); }\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);\n\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  append(const _Tp& __t, size_type __pos, size_type __n=npos);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __append_default_init(size_type __n);\n\n    template <class _ForwardIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    basic_string& __append_forward_unsafe(_ForwardIterator, _ForwardIterator);\n    template<class _InputIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_InputIterator __first, _InputIterator __last) {\n      const basic_string __temp (__first, __last, __alloc());\n      append(__temp.data(), __temp.size());\n      return *this;\n    }\n    template<class _ForwardIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_ForwardIterator __first, _ForwardIterator __last) {\n      return __append_forward_unsafe(__first, __last);\n    }\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_CXX03_LANG\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                 assign(const _Tp & __t) { __self_view __sv = __t; return assign(__sv.data(), __sv.size()); }\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str) { return *this = __str; }\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& __str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n        {*this = _VSTD::move(__str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  assign(const _Tp & __t, size_type __pos, size_type __n=npos);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                 insert(size_type __pos1, const _Tp& __t)\n    { __self_view __sv = __t; return insert(__pos1, __sv.data(), __sv.size()); }\n\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_CXX03_LANG\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  replace(size_type __pos1, size_type __n1, const _Tp& __t) { __self_view __sv = __t; return replace(__pos1, __n1, __sv.data(), __sv.size()); }\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  replace(const_iterator __i1, const_iterator __i2, const _Tp& __t) { __self_view __sv = __t; return replace(__i1 - begin(), __i2 - __i1, __sv); }\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_CXX03_LANG\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG;\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#if _LIBCPP_STD_VER > 14 || defined(_LIBCPP_BUILDING_LIBRARY)\n    _LIBCPP_INLINE_VISIBILITY\n    value_type* data()             _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            size_type\n        >::type\n              find(const _Tp& __t, size_type __pos = 0) const;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            size_type\n        >::type\n              rfind(const _Tp& __t, size_type __pos = npos) const;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            size_type\n        >::type\n              find_first_of(const _Tp& __t, size_type __pos = 0) const;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            size_type\n        >::type\n              find_last_of(const _Tp& __t, size_type __pos = npos) const;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            size_type\n        >::type\n              find_first_not_of(const _Tp &__t, size_type __pos = 0) const;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            size_type\n        >::type\n              find_last_not_of(const _Tp& __t, size_type __pos = npos) const;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            int\n        >::type\n        compare(const _Tp &__t) const;\n\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            int\n        >::type\n         compare(size_type __pos1, size_type __n1, const _Tp& __t) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;\n\n    template <class _Tp>\n    inline _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            int\n        >::type\n        compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n#if _LIBCPP_STD_VER > 17\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool starts_with(__self_view __sv) const _NOEXCEPT\n    { return __self_view(data(), size()).starts_with(__sv); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool starts_with(value_type __c) const _NOEXCEPT\n    { return !empty() && _Traits::eq(front(), __c); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool starts_with(const value_type* __s) const _NOEXCEPT\n    { return starts_with(__self_view(__s)); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool ends_with(__self_view __sv) const _NOEXCEPT\n    { return __self_view(data(), size()).ends_with( __sv); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool ends_with(value_type __c) const _NOEXCEPT\n    { return !empty() && _Traits::eq(back(), __c); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool ends_with(const value_type* __s) const _NOEXCEPT\n    { return ends_with(__self_view(__s)); }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY void __clear_and_shrink() _NOEXCEPT;\n    \n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   ifdef _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   ifdef _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   ifdef _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   ifdef _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align_it(size_type __s) _NOEXCEPT\n            {return (__s + (__a-1)) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {\n        if (__s < __min_cap) return static_cast<size_type>(__min_cap) - 1;\n        size_type __guess = __align_it<sizeof(value_type) < __alignment ?\n                     __alignment/sizeof(value_type) : 1 > (__s+1) - 1;\n        if (__guess == __min_cap) ++__guess;\n        return __guess;\n        }\n\n    inline\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    inline\n    void __init(const value_type* __s, size_type __sz);\n    inline\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    inline\n    typename enable_if\n    <\n        __is_exactly_input_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    inline\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() == __str.__alloc())\n                __alloc() = __str.__alloc();\n            else\n            {\n                if (!__str.__is_long())\n                {\n                    __clear_and_shrink();\n                    __alloc() = __str.__alloc();\n                }\n                else\n                {\n                    allocator_type __a = __str.__alloc();\n                    pointer __p = __alloc_traits::allocate(__a, __str.__get_long_cap());\n                    __clear_and_shrink();\n                    __alloc() = _VSTD::move(__a);\n                    __set_long_pointer(__p);\n                    __set_long_cap(__str.__get_long_cap());\n                    __set_long_size(__str.size());\n                }\n            }\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\n#ifndef _LIBCPP_HAS_NO_DEDUCTION_GUIDES\ntemplate<class _InputIterator,\n         class _CharT = typename iterator_traits<_InputIterator>::value_type,\n         class _Allocator = allocator<_CharT>,\n         class = typename enable_if<__is_input_iterator<_InputIterator>::value, void>::type,\n         class = typename enable_if<__is_allocator<_Allocator>::value, void>::type\n         >\nbasic_string(_InputIterator, _InputIterator, _Allocator = _Allocator())\n  -> basic_string<_CharT, char_traits<_CharT>, _Allocator>;\n\ntemplate<class _CharT,\n         class _Traits,\n         class _Allocator = allocator<_CharT>,\n         class = typename enable_if<__is_allocator<_Allocator>::value, void>::type\n         >\nexplicit basic_string(basic_string_view<_CharT, _Traits>, const _Allocator& = _Allocator())\n  -> basic_string<_CharT, _Traits, _Allocator>;\n\ntemplate<class _CharT,\n         class _Traits,\n         class _Allocator = allocator<_CharT>,\n         class = typename enable_if<__is_allocator<_Allocator>::value, void>::type,\n         class _Sz = typename allocator_traits<_Allocator>::size_type\n         >\nbasic_string(basic_string_view<_CharT, _Traits>, _Sz, _Sz, const _Allocator& = _Allocator())\n  -> basic_string<_CharT, _Traits, _Allocator>;\n#endif\n\n                  \ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                                                                        __pos\n#endif\n                                                                      )\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    if (__c)\n    {\n        const_pointer __new_last = __get_pointer() + __pos;\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n: __r_(__second_tag(), __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,\n                                                       size_type __sz,\n                                                       size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n#ifndef _LIBCPP_HAS_NO_DEDUCTION_GUIDES\ntemplate <class>\n#endif\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*, allocator) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n, const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n, allocator) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__second_tag(), __alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(\n    const basic_string& __str, const allocator_type& __a)\n    : __r_(__second_tag(), __a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__second_tag(), __a)\n{\n    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    else\n    {\n        __r_.first().__r = __str.__r_.first().__r;\n        __str.__zero();\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n#ifndef _LIBCPP_HAS_NO_DEDUCTION_GUIDES\ntemplate <class>\n#endif\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c, const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str,\n                                                        size_type __pos, size_type __n,\n                                                        const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,\n                                                        const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, __str_sz - __pos);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp, class>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(\n             const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a)\n    : __r_(__second_tag(), __a)\n{\n    __self_view __sv0 = __t;\n    __self_view __sv = __sv0.substr(__pos, __n);\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp, class>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const _Tp & __t)\n{\n    __self_view __sv = __t;\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp, class>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const _Tp & __t, const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    __self_view __sv = __t;\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_exactly_input_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, (void) ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__second_tag(), __a)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(\n    initializer_list<_CharT> __il)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\n\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(\n    initializer_list<_CharT> __il, const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::assign received nullptr\");\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str.data(), __str.size());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n#endif\n{\n    __clear_and_shrink();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_exactly_input_iterator <_InputIterator>::value\n          || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    const basic_string __temp(__first, __last, __alloc());\n    assign(__temp.data(), __temp.size());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n         && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::assign received nullptr\");\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::append received nullptr\");\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline void\nbasic_string<_CharT, _Traits, _Allocator>::__append_default_init(size_type __n)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _Tp>\nbool __ptr_in_range (const _Tp* __p, const _Tp* __first, const _Tp* __last)\n{\n    return __first <= __p && __p < __last;\n}\n\ntemplate <class _Tp1, class _Tp2>\nbool __ptr_in_range (const _Tp1*, const _Tp2*, const _Tp2*)\n{\n    return false;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::__append_forward_unsafe(\n    _ForwardIterator __first, _ForwardIterator __last)\n{\n    static_assert(__is_forward_iterator<_ForwardIterator>::value,\n                  \"function requires a ForwardIterator\");\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_ref = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_ref), data(), data() + size()))\n        {\n            const basic_string __temp (__first, __last, __alloc());\n            append(__temp.data(), __temp.size());\n        }\n        else \n        {\n            if (__cap - __sz < __n)\n                __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n            pointer __p = __get_pointer() + __sz;\n            for (; __first != __last; ++__p, ++__first)\n                traits_type::assign(*__p, *__first);\n            traits_type::assign(*__p, value_type());\n            __set_size(__sz + __n);\n        }\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\n    typename enable_if\n    <\n        __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n        basic_string<_CharT, _Traits, _Allocator>&\n    >::type\nbasic_string<_CharT, _Traits, _Allocator>::append(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::insert received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n   __is_exactly_input_iterator<_InputIterator>::value\n        || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n   typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    const basic_string __temp(__first, __last, __alloc());\n    return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n        && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_char = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_char), data(), data() + size()))\n        {\n            const basic_string __temp(__first, __last, __alloc());\n            return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n        }\n\n        size_type __sz = size();\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t,\n                                                  size_type __pos2, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __sv.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::insert received nullptr\");\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, n, value) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n    _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::replace received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n// __sz += __n2 - __n1; in this and the below function below can cause unsigned integer overflow,\n// but this is a safe operation, so we disable the check.\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n    _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    const basic_string __temp(__j1, __j2, __alloc());\n    return this->replace(__i1, __i2, __temp);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const _Tp& __t,\n                                                   size_type __pos2, size_type __n2)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __sv.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::replace received nullptr\");\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::erase(iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__pos != end(),\n        \"string::erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"string::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"string::erase(first, last) called with invalid range\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::pop_back(): string is already empty\");\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline void\nbasic_string<_CharT, _Traits, _Allocator>::__resize_default_init(size_type __n)\n{\n    size_type __sz = size();\n    if (__n > __sz) {\n       __append_default_init(__n - __sz);\n    } else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#ifdef _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;\n#else\n    return __m - __alignment;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    if (!__is_long())\n        __get_db()->__invalidate_all(this);\n    if (!__str.__is_long())\n        __get_db()->__invalidate_all(&__str);\n    __get_db()->swap(this, &__str);\n#endif\n    _LIBCPP_ASSERT(\n        __alloc_traits::propagate_on_container_swap::value ||\n        __alloc_traits::is_always_equal::value ||\n        __alloc() == __str.__alloc(), \"swapping non-equal allocators\");\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_allocator(__alloc(), __str.__alloc());\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::find(const _Tp &__t,\n                                                size_type __pos) const\n{\n    __self_view __sv = __t;\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const _Tp& __t,\n                                                size_type __pos) const\n{\n    __self_view __sv = __t;\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const _Tp& __t,\n                                                size_type __pos) const\n{\n    __self_view __sv = __t;\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const _Tp& __t,\n                                                size_type __pos) const\n{\n    __self_view __sv = __t;\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const _Tp& __t,\n                                                size_type __pos) const\n{\n    __self_view __sv = __t;\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const _Tp& __t,\n                                                size_type __pos) const\n{\n    __self_view __sv = __t;\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    int\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::compare(const _Tp& __t) const\n{\n    __self_view __sv = __t;\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __sv.size();\n    int __result = traits_type::compare(data(), __sv.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    return compare(__self_view(__str));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::compare(): received nullptr\");\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    int\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const _Tp& __t) const\n{\n    __self_view __sv = __t;\n    return compare(__pos1, __n1, __sv.data(), __sv.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    int\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const _Tp& __t,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    __self_view __sv = __t;\n    return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n        return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// __clear_and_shrink\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline\nvoid \nbasic_string<_CharT, _Traits, _Allocator>::__clear_and_shrink() _NOEXCEPT\n{\n    clear();\n    if(__is_long())\n    {\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), capacity() + 1);\n        __set_long_cap(0);\n        __set_short_size(0);\n    }\n} \n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__lhs != nullptr, \"operator==(char*, basic_string): received nullptr\");\n    size_t __lhs_len = _Traits::length(__lhs);\n    if (__lhs_len != __rhs.size()) return false;\n    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__rhs != nullptr, \"operator==(basic_string, char*): received nullptr\");\n    size_t __rhs_len = _Traits::length(__rhs);\n    if (__rhs_len != __lhs.size()) return false;\n    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_NO_HAS_CHAR8_T\ntypedef basic_string<char8_t> u8string;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS string to_string(int __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned __val);\n_LIBCPP_FUNC_VIS string to_string(long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long __val);\n_LIBCPP_FUNC_VIS string to_string(long long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);\n_LIBCPP_FUNC_VIS string to_string(float __val);\n_LIBCPP_FUNC_VIS string to_string(double __val);\n_LIBCPP_FUNC_VIS string to_string(long double __val);\n\n_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS wstring to_wstring(int __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(float __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(double __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TEMPLATE_VIS hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 17\ntemplate<class _CharT, class _Traits, class _Allocator, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid erase(basic_string<_CharT, _Traits, _Allocator>& __str, const _Up& __v)\n{ __str.erase(_VSTD::remove(__str.begin(), __str.end(), __v), __str.end()); }\n\ntemplate<class _CharT, class _Traits, class _Allocator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid erase_if(basic_string<_CharT, _Traits, _Allocator>& __str, _Predicate __pred)\n{ __str.erase(_VSTD::remove_if(__str.begin(), __str.end(), __pred), __str.end()); }\n#endif\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p < this->data() + this->size();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<wchar_t>)\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\ninline namespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n#ifndef _LIBCPP_NO_HAS_CHAR8_T\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char8_t> operator \"\" s(const char8_t *__str, size_t __len) _NOEXCEPT\n    {\n        return basic_string<char8_t> (__str, __len);\n    }\n#endif\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_STRING\n","// -*- C++ -*-\n//===--------------------------- sstream ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_SSTREAM\n#define _LIBCPP_SSTREAM\n\n/*\n    sstream synopsis\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_stringbuf\n    : public basic_streambuf<charT, traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // 27.8.1.1 Constructors:\n    explicit basic_stringbuf(ios_base::openmode which = ios_base::in | ios_base::out);\n    explicit basic_stringbuf(const basic_string<char_type, traits_type, allocator_type>& str,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    basic_stringbuf(basic_stringbuf&& rhs);\n\n    // 27.8.1.2 Assign and swap:\n    basic_stringbuf& operator=(basic_stringbuf&& rhs);\n    void swap(basic_stringbuf& rhs);\n\n    // 27.8.1.3 Get and set:\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& s);\n\nprotected:\n    // 27.8.1.4 Overridden virtual functions:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n    virtual int_type overflow (int_type c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type*, streamsize);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_stringbuf<charT, traits, Allocator>& x,\n            basic_stringbuf<charT, traits, Allocator>& y);\n\ntypedef basic_stringbuf<char>    stringbuf;\ntypedef basic_stringbuf<wchar_t> wstringbuf;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_istringstream\n    : public basic_istream<charT, traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // 27.8.2.1 Constructors:\n    explicit basic_istringstream(ios_base::openmode which = ios_base::in);\n    explicit basic_istringstream(const basic_string<char_type, traits_type,allocator_type>& str,\n                                 ios_base::openmode which = ios_base::in);\n    basic_istringstream(basic_istringstream&& rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_istringstream& operator=(basic_istringstream&& rhs);\n    void swap(basic_istringstream& rhs);\n\n    // 27.8.2.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& s);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_istringstream<charT, traits, Allocator>& x,\n            basic_istringstream<charT, traits, Allocator>& y);\n\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_istringstream<wchar_t> wistringstream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_ostringstream\n    : public basic_ostream<charT, traits>\n{\npublic:\n    // types:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // 27.8.3.1 Constructors/destructor:\n    explicit basic_ostringstream(ios_base::openmode which = ios_base::out);\n    explicit basic_ostringstream(const basic_string<char_type, traits_type, allocator_type>& str,\n                                 ios_base::openmode which = ios_base::out);\n    basic_ostringstream(basic_ostringstream&& rhs);\n\n    // 27.8.3.2 Assign/swap:\n    basic_ostringstream& operator=(basic_ostringstream&& rhs);\n    void swap(basic_ostringstream& rhs);\n\n    // 27.8.3.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& s);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_ostringstream<charT, traits, Allocator>& x,\n            basic_ostringstream<charT, traits, Allocator>& y);\n\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_stringstream\n    : public basic_iostream<charT, traits>\n{\npublic:\n    // types:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // constructors/destructor\n    explicit basic_stringstream(ios_base::openmode which = ios_base::out|ios_base::in);\n    explicit basic_stringstream(const basic_string<char_type, traits_type, allocator_type>& str,\n                                ios_base::openmode which = ios_base::out|ios_base::in);\n    basic_stringstream(basic_stringstream&& rhs);\n\n    // 27.8.5.1 Assign/swap:\n    basic_stringstream& operator=(basic_stringstream&& rhs);\n    void swap(basic_stringstream& rhs);\n\n    // Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& str);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_stringstream<charT, traits, Allocator>& x,\n            basic_stringstream<charT, traits, Allocator>& y);\n\ntypedef basic_stringstream<char>    stringstream;\ntypedef basic_stringstream<wchar_t> wstringstream;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ostream>\n#include <istream>\n#include <string>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// basic_stringbuf\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS basic_stringbuf\n    : public basic_streambuf<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n\n    string_type __str_;\n    mutable char_type* __hm_;\n    ios_base::openmode __mode_;\n\npublic:\n    // 27.8.1.1 Constructors:\n    inline _LIBCPP_INLINE_VISIBILITY\n    explicit basic_stringbuf(ios_base::openmode __wch = ios_base::in | ios_base::out);\n    inline _LIBCPP_INLINE_VISIBILITY\n    explicit basic_stringbuf(const string_type& __s,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n#ifndef _LIBCPP_CXX03_LANG\n    basic_stringbuf(basic_stringbuf&& __rhs);\n\n    // 27.8.1.2 Assign and swap:\n    basic_stringbuf& operator=(basic_stringbuf&& __rhs);\n#endif\n    void swap(basic_stringbuf& __rhs);\n\n    // 27.8.1.3 Get and set:\n    string_type str() const;\n    void str(const string_type& __s);\n\nprotected:\n    // 27.8.1.4 Overridden virtual functions:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    inline _LIBCPP_INLINE_VISIBILITY\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(ios_base::openmode __wch)\n    : __hm_(0),\n      __mode_(__wch)\n{\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(const string_type& __s,\n                             ios_base::openmode __wch)\n    : __str_(__s.get_allocator()),\n      __hm_(0),\n      __mode_(__wch)\n{\n    str(__s);\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(basic_stringbuf&& __rhs)\n    : __mode_(__rhs.__mode_)\n{\n    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());\n    ptrdiff_t __binp = -1;\n    ptrdiff_t __ninp = -1;\n    ptrdiff_t __einp = -1;\n    if (__rhs.eback() != nullptr)\n    {\n        __binp = __rhs.eback() - __p;\n        __ninp = __rhs.gptr() - __p;\n        __einp = __rhs.egptr() - __p;\n    }\n    ptrdiff_t __bout = -1;\n    ptrdiff_t __nout = -1;\n    ptrdiff_t __eout = -1;\n    if (__rhs.pbase() != nullptr)\n    {\n        __bout = __rhs.pbase() - __p;\n        __nout = __rhs.pptr() - __p;\n        __eout = __rhs.epptr() - __p;\n    }\n    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;\n    __str_ = _VSTD::move(__rhs.__str_);\n    __p = const_cast<char_type*>(__str_.data());\n    if (__binp != -1)\n        this->setg(__p + __binp, __p + __ninp, __p + __einp);\n    if (__bout != -1)\n    {\n        this->setp(__p + __bout, __p + __eout);\n        this->__pbump(__nout);\n    }\n    __hm_ = __hm == -1 ? nullptr : __p + __hm;\n    __p = const_cast<char_type*>(__rhs.__str_.data());\n    __rhs.setg(__p, __p, __p);\n    __rhs.setp(__p, __p);\n    __rhs.__hm_ = __p;\n    this->pubimbue(__rhs.getloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>&\nbasic_stringbuf<_CharT, _Traits, _Allocator>::operator=(basic_stringbuf&& __rhs)\n{\n    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());\n    ptrdiff_t __binp = -1;\n    ptrdiff_t __ninp = -1;\n    ptrdiff_t __einp = -1;\n    if (__rhs.eback() != nullptr)\n    {\n        __binp = __rhs.eback() - __p;\n        __ninp = __rhs.gptr() - __p;\n        __einp = __rhs.egptr() - __p;\n    }\n    ptrdiff_t __bout = -1;\n    ptrdiff_t __nout = -1;\n    ptrdiff_t __eout = -1;\n    if (__rhs.pbase() != nullptr)\n    {\n        __bout = __rhs.pbase() - __p;\n        __nout = __rhs.pptr() - __p;\n        __eout = __rhs.epptr() - __p;\n    }\n    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;\n    __str_ = _VSTD::move(__rhs.__str_);\n    __p = const_cast<char_type*>(__str_.data());\n    if (__binp != -1)\n        this->setg(__p + __binp, __p + __ninp, __p + __einp);\n    else\n        this->setg(nullptr, nullptr, nullptr);\n    if (__bout != -1)\n    {\n        this->setp(__p + __bout, __p + __eout);\n        this->__pbump(__nout);\n    }\n    else\n        this->setp(nullptr, nullptr);\n\n    __hm_ = __hm == -1 ? nullptr : __p + __hm;\n    __mode_ = __rhs.__mode_;\n    __p = const_cast<char_type*>(__rhs.__str_.data());\n    __rhs.setg(__p, __p, __p);\n    __rhs.setp(__p, __p);\n    __rhs.__hm_ = __p;\n    this->pubimbue(__rhs.getloc());\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_stringbuf<_CharT, _Traits, _Allocator>::swap(basic_stringbuf& __rhs)\n{\n    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());\n    ptrdiff_t __rbinp = -1;\n    ptrdiff_t __rninp = -1;\n    ptrdiff_t __reinp = -1;\n    if (__rhs.eback() != nullptr)\n    {\n        __rbinp = __rhs.eback() - __p;\n        __rninp = __rhs.gptr() - __p;\n        __reinp = __rhs.egptr() - __p;\n    }\n    ptrdiff_t __rbout = -1;\n    ptrdiff_t __rnout = -1;\n    ptrdiff_t __reout = -1;\n    if (__rhs.pbase() != nullptr)\n    {\n        __rbout = __rhs.pbase() - __p;\n        __rnout = __rhs.pptr() - __p;\n        __reout = __rhs.epptr() - __p;\n    }\n    ptrdiff_t __rhm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;\n    __p = const_cast<char_type*>(__str_.data());\n    ptrdiff_t __lbinp = -1;\n    ptrdiff_t __lninp = -1;\n    ptrdiff_t __leinp = -1;\n    if (this->eback() != nullptr)\n    {\n        __lbinp = this->eback() - __p;\n        __lninp = this->gptr() - __p;\n        __leinp = this->egptr() - __p;\n    }\n    ptrdiff_t __lbout = -1;\n    ptrdiff_t __lnout = -1;\n    ptrdiff_t __leout = -1;\n    if (this->pbase() != nullptr)\n    {\n        __lbout = this->pbase() - __p;\n        __lnout = this->pptr() - __p;\n        __leout = this->epptr() - __p;\n    }\n    ptrdiff_t __lhm = __hm_ == nullptr ? -1 : __hm_ - __p;\n    _VSTD::swap(__mode_, __rhs.__mode_);\n    __str_.swap(__rhs.__str_);\n    __p = const_cast<char_type*>(__str_.data());\n    if (__rbinp != -1)\n        this->setg(__p + __rbinp, __p + __rninp, __p + __reinp);\n    else\n        this->setg(nullptr, nullptr, nullptr);\n    if (__rbout != -1)\n    {\n        this->setp(__p + __rbout, __p + __reout);\n        this->__pbump(__rnout);\n    }\n    else\n        this->setp(nullptr, nullptr);\n    __hm_ = __rhm == -1 ? nullptr : __p + __rhm;\n    __p = const_cast<char_type*>(__rhs.__str_.data());\n    if (__lbinp != -1)\n        __rhs.setg(__p + __lbinp, __p + __lninp, __p + __leinp);\n    else\n        __rhs.setg(nullptr, nullptr, nullptr);\n    if (__lbout != -1)\n    {\n        __rhs.setp(__p + __lbout, __p + __leout);\n        __rhs.__pbump(__lnout);\n    }\n    else\n        __rhs.setp(nullptr, nullptr);\n    __rhs.__hm_ = __lhm == -1 ? nullptr : __p + __lhm;\n    locale __tl = __rhs.getloc();\n    __rhs.pubimbue(this->getloc());\n    this->pubimbue(__tl);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,\n     basic_stringbuf<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>::str() const\n{\n    if (__mode_ & ios_base::out)\n    {\n        if (__hm_ < this->pptr())\n            __hm_ = this->pptr();\n        return string_type(this->pbase(), __hm_, __str_.get_allocator());\n    }\n    else if (__mode_ & ios_base::in)\n        return string_type(this->eback(), this->egptr(), __str_.get_allocator());\n    return string_type(__str_.get_allocator());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_stringbuf<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __str_ = __s;\n    __hm_ = 0;\n    if (__mode_ & ios_base::in)\n    {\n        __hm_ = const_cast<char_type*>(__str_.data()) + __str_.size();\n        this->setg(const_cast<char_type*>(__str_.data()),\n                   const_cast<char_type*>(__str_.data()),\n                   __hm_);\n    }\n    if (__mode_ & ios_base::out)\n    {\n        typename string_type::size_type __sz = __str_.size();\n        __hm_ = const_cast<char_type*>(__str_.data()) + __sz;\n        __str_.resize(__str_.capacity());\n        this->setp(const_cast<char_type*>(__str_.data()),\n                   const_cast<char_type*>(__str_.data()) + __str_.size());\n        if (__mode_ & (ios_base::app | ios_base::ate))\n        {\n            while (__sz > INT_MAX)\n            {\n                this->pbump(INT_MAX);\n                __sz -= INT_MAX;\n            }\n            if (__sz > 0)\n                this->pbump(__sz);\n        }\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::underflow()\n{\n    if (__hm_ < this->pptr())\n        __hm_ = this->pptr();\n    if (__mode_ & ios_base::in)\n    {\n        if (this->egptr() < __hm_)\n            this->setg(this->eback(), this->gptr(), __hm_);\n        if (this->gptr() < this->egptr())\n            return traits_type::to_int_type(*this->gptr());\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::pbackfail(int_type __c)\n{\n    if (__hm_ < this->pptr())\n        __hm_ = this->pptr();\n    if (this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->setg(this->eback(), this->gptr()-1, __hm_);\n            return traits_type::not_eof(__c);\n        }\n        if ((__mode_ & ios_base::out) ||\n            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->setg(this->eback(), this->gptr()-1, __hm_);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::overflow(int_type __c)\n{\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        ptrdiff_t __ninp = this->gptr()  - this->eback();\n        if (this->pptr() == this->epptr())\n        {\n            if (!(__mode_ & ios_base::out))\n                return traits_type::eof();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                ptrdiff_t __nout = this->pptr()  - this->pbase();\n                ptrdiff_t __hm = __hm_ - this->pbase();\n                __str_.push_back(char_type());\n                __str_.resize(__str_.capacity());\n                char_type* __p = const_cast<char_type*>(__str_.data());\n                this->setp(__p, __p + __str_.size());\n                this->__pbump(__nout);\n                __hm_ = this->pbase() + __hm;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                return traits_type::eof();\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        }\n        __hm_ = _VSTD::max(this->pptr() + 1, __hm_);\n        if (__mode_ & ios_base::in)\n        {\n            char_type* __p = const_cast<char_type*>(__str_.data());\n            this->setg(__p, __p + __ninp, __hm_);\n        }\n        return this->sputc(__c);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::seekoff(off_type __off,\n                                                      ios_base::seekdir __way,\n                                                      ios_base::openmode __wch)\n{\n    if (__hm_ < this->pptr())\n        __hm_ = this->pptr();\n    if ((__wch & (ios_base::in | ios_base::out)) == 0)\n        return pos_type(-1);\n    if ((__wch & (ios_base::in | ios_base::out)) == (ios_base::in | ios_base::out)\n        && __way == ios_base::cur)\n        return pos_type(-1);\n    const ptrdiff_t __hm = __hm_ == nullptr ? 0 : __hm_ - __str_.data();\n    off_type __noff;\n    switch (__way)\n    {\n    case ios_base::beg:\n        __noff = 0;\n        break;\n    case ios_base::cur:\n        if (__wch & ios_base::in)\n            __noff = this->gptr() - this->eback();\n        else\n            __noff = this->pptr() - this->pbase();\n        break;\n    case ios_base::end:\n        __noff = __hm;\n        break;\n    default:\n        return pos_type(-1);\n    }\n    __noff += __off;\n    if (__noff < 0 || __hm < __noff)\n        return pos_type(-1);\n    if (__noff != 0)\n    {\n        if ((__wch & ios_base::in) && this->gptr() == 0)\n            return pos_type(-1);\n        if ((__wch & ios_base::out) && this->pptr() == 0)\n            return pos_type(-1);\n    }\n    if (__wch & ios_base::in)\n        this->setg(this->eback(), this->eback() + __noff, __hm_);\n    if (__wch & ios_base::out)\n    {\n        this->setp(this->pbase(), this->epptr());\n        this->pbump(__noff);\n    }\n    return pos_type(__noff);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::seekpos(pos_type __sp,\n                                                      ios_base::openmode __wch)\n{\n    return seekoff(__sp, ios_base::beg, __wch);\n}\n\n// basic_istringstream\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS basic_istringstream\n    : public basic_istream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;\n\npublic:\n    // 27.8.2.1 Constructors:\n    inline _LIBCPP_INLINE_VISIBILITY\n    explicit basic_istringstream(ios_base::openmode __wch = ios_base::in);\n    inline _LIBCPP_INLINE_VISIBILITY\n    explicit basic_istringstream(const string_type& __s,\n                                 ios_base::openmode __wch = ios_base::in);\n#ifndef _LIBCPP_CXX03_LANG\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_istringstream(basic_istringstream&& __rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_istringstream& operator=(basic_istringstream&& __rhs);\n#endif  // _LIBCPP_CXX03_LANG\n    inline _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_istringstream& __rhs);\n\n    // 27.8.2.3 Members:\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    inline _LIBCPP_INLINE_VISIBILITY\n    string_type str() const;\n    inline _LIBCPP_INLINE_VISIBILITY\n    void str(const string_type& __s);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(ios_base::openmode __wch)\n    : basic_istream<_CharT, _Traits>(&__sb_),\n      __sb_(__wch | ios_base::in)\n{\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(const string_type& __s,\n                                                                      ios_base::openmode __wch)\n    : basic_istream<_CharT, _Traits>(&__sb_),\n      __sb_(__s, __wch | ios_base::in)\n{\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(basic_istringstream&& __rhs)\n    : basic_istream<_CharT, _Traits>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_istringstream<_CharT, _Traits, _Allocator>&\nbasic_istringstream<_CharT, _Traits, _Allocator>::operator=(basic_istringstream&& __rhs)\n{\n    basic_istream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid basic_istringstream<_CharT, _Traits, _Allocator>::swap(basic_istringstream& __rhs)\n{\n    basic_istream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,\n     basic_istringstream<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>*\nbasic_istringstream<_CharT, _Traits, _Allocator>::rdbuf() const\n{\n    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_istringstream<_CharT, _Traits, _Allocator>::str() const\n{\n    return __sb_.str();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid basic_istringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __sb_.str(__s);\n}\n\n// basic_ostringstream\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS basic_ostringstream\n    : public basic_ostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;\n\npublic:\n    // 27.8.2.1 Constructors:\n    inline _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ostringstream(ios_base::openmode __wch = ios_base::out);\n    inline _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ostringstream(const string_type& __s,\n                                 ios_base::openmode __wch = ios_base::out);\n#ifndef _LIBCPP_CXX03_LANG\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_ostringstream(basic_ostringstream&& __rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_ostringstream& operator=(basic_ostringstream&& __rhs);\n#endif  // _LIBCPP_CXX03_LANG\n    inline _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_ostringstream& __rhs);\n\n    // 27.8.2.3 Members:\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    inline _LIBCPP_INLINE_VISIBILITY\n    string_type str() const;\n    inline _LIBCPP_INLINE_VISIBILITY\n    void str(const string_type& __s);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(ios_base::openmode __wch)\n    : basic_ostream<_CharT, _Traits>(&__sb_),\n      __sb_(__wch | ios_base::out)\n{\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(const string_type& __s,\n                                                                      ios_base::openmode __wch)\n    : basic_ostream<_CharT, _Traits>(&__sb_),\n      __sb_(__s, __wch | ios_base::out)\n{\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(basic_ostringstream&& __rhs)\n    : basic_ostream<_CharT, _Traits>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    basic_ostream<_CharT, _Traits>::set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_ostringstream<_CharT, _Traits, _Allocator>&\nbasic_ostringstream<_CharT, _Traits, _Allocator>::operator=(basic_ostringstream&& __rhs)\n{\n    basic_ostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_ostringstream<_CharT, _Traits, _Allocator>::swap(basic_ostringstream& __rhs)\n{\n    basic_ostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,\n     basic_ostringstream<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>*\nbasic_ostringstream<_CharT, _Traits, _Allocator>::rdbuf() const\n{\n    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_ostringstream<_CharT, _Traits, _Allocator>::str() const\n{\n    return __sb_.str();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_ostringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __sb_.str(__s);\n}\n\n// basic_stringstream\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS basic_stringstream\n    : public basic_iostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;\n\npublic:\n    // 27.8.2.1 Constructors:\n    inline _LIBCPP_INLINE_VISIBILITY\n    explicit basic_stringstream(ios_base::openmode __wch = ios_base::in | ios_base::out);\n    inline _LIBCPP_INLINE_VISIBILITY\n    explicit basic_stringstream(const string_type& __s,\n                                ios_base::openmode __wch = ios_base::in | ios_base::out);\n#ifndef _LIBCPP_CXX03_LANG\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_stringstream(basic_stringstream&& __rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_stringstream& operator=(basic_stringstream&& __rhs);\n#endif  // _LIBCPP_CXX03_LANG\n    inline _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_stringstream& __rhs);\n\n    // 27.8.2.3 Members:\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    inline _LIBCPP_INLINE_VISIBILITY\n    string_type str() const;\n    inline _LIBCPP_INLINE_VISIBILITY\n    void str(const string_type& __s);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(ios_base::openmode __wch)\n    : basic_iostream<_CharT, _Traits>(&__sb_),\n      __sb_(__wch)\n{\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(const string_type& __s,\n                                                                    ios_base::openmode __wch)\n    : basic_iostream<_CharT, _Traits>(&__sb_),\n      __sb_(__s, __wch)\n{\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(basic_stringstream&& __rhs)\n    : basic_iostream<_CharT, _Traits>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringstream<_CharT, _Traits, _Allocator>&\nbasic_stringstream<_CharT, _Traits, _Allocator>::operator=(basic_stringstream&& __rhs)\n{\n    basic_iostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_stringstream<_CharT, _Traits, _Allocator>::swap(basic_stringstream& __rhs)\n{\n    basic_iostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,\n     basic_stringstream<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>*\nbasic_stringstream<_CharT, _Traits, _Allocator>::rdbuf() const\n{\n    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_stringstream<_CharT, _Traits, _Allocator>::str() const\n{\n    return __sb_.str();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_stringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __sb_.str(__s);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_SSTREAM\n","// -*- C++ -*-\n//===--------------------------- istream ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ISTREAM\n#define _LIBCPP_ISTREAM\n\n/*\n    istream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_istream\n    : virtual public basic_ios<charT,traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.1.1.1 Constructor/destructor:\n    explicit basic_istream(basic_streambuf<char_type, traits_type>* sb);\n    basic_istream(basic_istream&& rhs);\n    virtual ~basic_istream();\n\n    // 27.7.1.1.2 Assign/swap:\n    basic_istream& operator=(basic_istream&& rhs);\n    void swap(basic_istream& rhs);\n\n    // 27.7.1.1.3 Prefix/suffix:\n    class sentry;\n\n    // 27.7.1.2 Formatted input:\n    basic_istream& operator>>(basic_istream& (*pf)(basic_istream&));\n    basic_istream& operator>>(basic_ios<char_type, traits_type>&\n                              (*pf)(basic_ios<char_type, traits_type>&));\n    basic_istream& operator>>(ios_base& (*pf)(ios_base&));\n    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* sb);\n    basic_istream& operator>>(bool& n);\n    basic_istream& operator>>(short& n);\n    basic_istream& operator>>(unsigned short& n);\n    basic_istream& operator>>(int& n);\n    basic_istream& operator>>(unsigned int& n);\n    basic_istream& operator>>(long& n);\n    basic_istream& operator>>(unsigned long& n);\n    basic_istream& operator>>(long long& n);\n    basic_istream& operator>>(unsigned long long& n);\n    basic_istream& operator>>(float& f);\n    basic_istream& operator>>(double& f);\n    basic_istream& operator>>(long double& f);\n    basic_istream& operator>>(void*& p);\n\n    // 27.7.1.3 Unformatted input:\n    streamsize gcount() const;\n    int_type get();\n    basic_istream& get(char_type& c);\n    basic_istream& get(char_type* s, streamsize n);\n    basic_istream& get(char_type* s, streamsize n, char_type delim);\n    basic_istream& get(basic_streambuf<char_type,traits_type>& sb);\n    basic_istream& get(basic_streambuf<char_type,traits_type>& sb, char_type delim);\n\n    basic_istream& getline(char_type* s, streamsize n);\n    basic_istream& getline(char_type* s, streamsize n, char_type delim);\n\n    basic_istream& ignore(streamsize n = 1, int_type delim = traits_type::eof());\n    int_type peek();\n    basic_istream& read (char_type* s, streamsize n);\n    streamsize readsome(char_type* s, streamsize n);\n\n    basic_istream& putback(char_type c);\n    basic_istream& unget();\n    int sync();\n\n    pos_type tellg();\n    basic_istream& seekg(pos_type);\n    basic_istream& seekg(off_type, ios_base::seekdir);\nprotected:\n    basic_istream(const basic_istream& rhs) = delete;\n    basic_istream(basic_istream&& rhs);\n    // 27.7.2.1.2 Assign/swap:\n    basic_istream& operator=(const basic_istream& rhs) = delete;\n    basic_istream& operator=(basic_istream&& rhs);\n    void swap(basic_istream& rhs);\n};\n\n// 27.7.1.2.3 character extraction templates:\ntemplate<class charT, class traits>\n  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT&);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char&);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char&);\n\ntemplate<class charT, class traits>\n  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT*);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char*);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char*);\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_istream<charT, traits>& x, basic_istream<charT, traits>& y);\n\ntypedef basic_istream<char> istream;\ntypedef basic_istream<wchar_t> wistream;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_iostream :\n    public basic_istream<charT,traits>,\n    public basic_ostream<charT,traits>\n{\npublic:\n    // types:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // constructor/destructor\n    explicit basic_iostream(basic_streambuf<char_type, traits_type>* sb);\n    basic_iostream(basic_iostream&& rhs);\n    virtual ~basic_iostream();\n\n    // assign/swap\n    basic_iostream& operator=(basic_iostream&& rhs);\n    void swap(basic_iostream& rhs);\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_iostream<charT, traits>& x, basic_iostream<charT, traits>& y);\n\ntypedef basic_iostream<char> iostream;\ntypedef basic_iostream<wchar_t> wiostream;\n\ntemplate <class charT, class traits>\n  basic_istream<charT,traits>&\n  ws(basic_istream<charT,traits>& is);\n\ntemplate <class charT, class traits, class T>\n  basic_istream<charT, traits>&\n  operator>>(basic_istream<charT, traits>&& is, T& x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <version>\n#include <ostream>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_istream\n    : virtual public basic_ios<_CharT, _Traits>\n{\n    streamsize __gc_;\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.1.1.1 Constructor/destructor:\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    explicit basic_istream(basic_streambuf<char_type, traits_type>* __sb) : __gc_(0)\n    { this->init(__sb); }\n    virtual ~basic_istream();\nprotected:\n#ifndef _LIBCPP_CXX03_LANG\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_istream(basic_istream&& __rhs);\n\n    // 27.7.1.1.2 Assign/swap:\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_istream& operator=(basic_istream&& __rhs);\n#endif\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    void swap(basic_istream& __rhs) {\n      _VSTD::swap(__gc_, __rhs.__gc_);\n      basic_ios<char_type, traits_type>::swap(__rhs);\n    }\n\n#ifndef _LIBCPP_CXX03_LANG\n    basic_istream           (const basic_istream& __rhs) = delete;\n    basic_istream& operator=(const basic_istream& __rhs) = delete;\n#endif\npublic:\n\n    // 27.7.1.1.3 Prefix/suffix:\n    class _LIBCPP_TEMPLATE_VIS sentry;\n\n    // 27.7.1.2 Formatted input:\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    basic_istream& operator>>(basic_istream& (*__pf)(basic_istream&))\n    { return __pf(*this); }\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    basic_istream& operator>>(basic_ios<char_type, traits_type>&\n                              (*__pf)(basic_ios<char_type, traits_type>&))\n    { __pf(*this); return *this; }\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    basic_istream& operator>>(ios_base& (*__pf)(ios_base&))\n    { __pf(*this); return *this; }\n\n    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* __sb);\n    basic_istream& operator>>(bool& __n);\n    basic_istream& operator>>(short& __n);\n    basic_istream& operator>>(unsigned short& __n);\n    basic_istream& operator>>(int& __n);\n    basic_istream& operator>>(unsigned int& __n);\n    basic_istream& operator>>(long& __n);\n    basic_istream& operator>>(unsigned long& __n);\n    basic_istream& operator>>(long long& __n);\n    basic_istream& operator>>(unsigned long long& __n);\n    basic_istream& operator>>(float& __f);\n    basic_istream& operator>>(double& __f);\n    basic_istream& operator>>(long double& __f);\n    basic_istream& operator>>(void*& __p);\n\n    // 27.7.1.3 Unformatted input:\n    _LIBCPP_INLINE_VISIBILITY\n    streamsize gcount() const {return __gc_;}\n    int_type get();\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    basic_istream& get(char_type& __c) {\n      int_type __ch = get();\n      if (__ch != traits_type::eof())\n        __c = traits_type::to_char_type(__ch);\n      return *this;\n    }\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    basic_istream& get(char_type* __s, streamsize __n)\n    { return get(__s, __n, this->widen('\\n')); }\n\n    basic_istream& get(char_type* __s, streamsize __n, char_type __dlm);\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb)\n    { return get(__sb, this->widen('\\n')); }\n\n    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb, char_type __dlm);\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    basic_istream& getline(char_type* __s, streamsize __n)\n    { return getline(__s, __n, this->widen('\\n')); }\n\n    basic_istream& getline(char_type* __s, streamsize __n, char_type __dlm);\n\n    basic_istream& ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());\n    int_type peek();\n    basic_istream& read (char_type* __s, streamsize __n);\n    streamsize readsome(char_type* __s, streamsize __n);\n\n    basic_istream& putback(char_type __c);\n    basic_istream& unget();\n    int sync();\n\n    pos_type tellg();\n    basic_istream& seekg(pos_type __pos);\n    basic_istream& seekg(off_type __off, ios_base::seekdir __dir);\n};\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_istream<_CharT, _Traits>::sentry\n{\n    bool __ok_;\n\n    sentry(const sentry&); // = delete;\n    sentry& operator=(const sentry&); // = delete;\n\npublic:\n    explicit sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);\n//    ~sentry() = default;\n\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT\n        operator bool() const {return __ok_;}\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits>& __is,\n                                               bool __noskipws)\n    : __ok_(false)\n{\n    if (__is.good())\n    {\n        if (__is.tie())\n            __is.tie()->flush();\n        if (!__noskipws && (__is.flags() & ios_base::skipws))\n        {\n            typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            _Ip __i(__is);\n            _Ip __eof;\n            for (; __i != __eof; ++__i)\n                if (!__ct.is(__ct.space, *__i))\n                    break;\n            if (__i == __eof)\n                __is.setstate(ios_base::failbit | ios_base::eofbit);\n        }\n        __ok_ = __is.good();\n    }\n    else\n        __is.setstate(ios_base::failbit);\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>::basic_istream(basic_istream&& __rhs)\n    : __gc_(__rhs.__gc_)\n{\n    __rhs.__gc_ = 0;\n    this->move(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator=(basic_istream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>::~basic_istream()\n{\n}\n\ntemplate <class _Tp, class _CharT, class _Traits>\n_LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\n__input_arithmetic(basic_istream<_CharT, _Traits>& __is, _Tp& __n) {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __s(__is);\n        if (__s)\n        {\n            typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n            typedef num_get<_CharT, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(__is.getloc()).get(_Ip(__is), _Ip(), __is, __err, __n);\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned short& __n)\n{\n    return _VSTD::__input_arithmetic<unsigned short>(*this, __n);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned int& __n)\n{\n    return _VSTD::__input_arithmetic<unsigned int>(*this, __n);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(long& __n)\n{\n    return _VSTD::__input_arithmetic<long>(*this, __n);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned long& __n)\n{\n    return _VSTD::__input_arithmetic<unsigned long>(*this, __n);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(long long& __n)\n{\n    return _VSTD::__input_arithmetic<long long>(*this, __n);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned long long& __n)\n{\n    return _VSTD::__input_arithmetic<unsigned long long>(*this, __n);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(float& __n)\n{\n    return _VSTD::__input_arithmetic<float>(*this, __n);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(double& __n)\n{\n    return _VSTD::__input_arithmetic<double>(*this, __n);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(long double& __n)\n{\n    return _VSTD::__input_arithmetic<long double>(*this, __n);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(bool& __n)\n{\n    return _VSTD::__input_arithmetic<bool>(*this, __n);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(void*& __n)\n{\n    return _VSTD::__input_arithmetic<void*>(*this, __n);\n}\n\ntemplate <class _Tp, class _CharT, class _Traits>\n_LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\n__input_arithmetic_with_numeric_limits(basic_istream<_CharT, _Traits>& __is, _Tp& __n) {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __s(__is);\n        if (__s)\n        {\n            typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n            typedef num_get<_CharT, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            long __temp;\n            use_facet<_Fp>(__is.getloc()).get(_Ip(__is), _Ip(), __is, __err, __temp);\n            if (__temp < numeric_limits<_Tp>::min())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<_Tp>::min();\n            }\n            else if (__temp > numeric_limits<_Tp>::max())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<_Tp>::max();\n            }\n            else\n                __n = static_cast<_Tp>(__temp);\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(short& __n)\n{\n    return _VSTD::__input_arithmetic_with_numeric_limits<short>(*this, __n);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(int& __n)\n{\n    return _VSTD::__input_arithmetic_with_numeric_limits<int>(*this, __n);\n}\n\ntemplate<class _CharT, class _Traits>\n_LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\n__input_c_string(basic_istream<_CharT, _Traits>& __is, _CharT* __p, size_t __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            auto __s = __p;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            ios_base::iostate __err = ios_base::goodbit;\n            while (__s != __p + (__n-1))\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (__ct.is(__ct.space, __ch))\n                    break;\n                *__s++ = __ch;\n                 __is.rdbuf()->sbumpc();\n            }\n            *__s = _CharT();\n            __is.width(0);\n            if (__s == __p)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\n#if _LIBCPP_STD_VER > 17\n\ntemplate<class _CharT, class _Traits, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, _CharT (&__buf)[_Np])\n{\n    auto __n = _Np;\n    if (__is.width() > 0)\n        __n = _VSTD::min(size_t(__is.width()), _Np);\n    return _VSTD::__input_c_string(__is, __buf, __n);\n}\n\ntemplate<class _Traits, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, unsigned char (&__buf)[_Np])\n{\n    return __is >> (char(&)[_Np])__buf;\n}\n\ntemplate<class _Traits, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, signed char (&__buf)[_Np])\n{\n    return __is >> (char(&)[_Np])__buf;\n}\n\n#else\n\ntemplate<class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, _CharT* __s)\n{\n    streamsize __n = __is.width();\n    if (__n <= 0)\n        __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;\n    return _VSTD::__input_c_string(__is, __s, size_t(__n));\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, unsigned char* __s)\n{\n    return __is >> (char*)__s;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, signed char* __s)\n{\n    return __is >> (char*)__s;\n}\n\n#endif  // _LIBCPP_STD_VER > 17\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, _CharT& __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            typename _Traits::int_type __i = __is.rdbuf()->sbumpc();\n            if (_Traits::eq_int_type(__i, _Traits::eof()))\n                __is.setstate(ios_base::eofbit | ios_base::failbit);\n            else\n                __c = _Traits::to_char_type(__i);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, unsigned char& __c)\n{\n    return __is >> (char&)__c;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, signed char& __c)\n{\n    return __is >> (char&)__c;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(basic_streambuf<char_type, traits_type>* __sb)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this, true);\n        if (__s)\n        {\n            if (__sb)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                    ios_base::iostate __err = ios_base::goodbit;\n                    while (true)\n                    {\n                        typename traits_type::int_type __i = this->rdbuf()->sgetc();\n                        if (traits_type::eq_int_type(__i, _Traits::eof()))\n                        {\n                           __err |= ios_base::eofbit;\n                           break;\n                        }\n                        if (traits_type::eq_int_type(\n                                __sb->sputc(traits_type::to_char_type(__i)),\n                                traits_type::eof()))\n                            break;\n                        ++__gc_;\n                        this->rdbuf()->sbumpc();\n                    }\n                    if (__gc_ == 0)\n                       __err |= ios_base::failbit;\n                    this->setstate(__err);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    if (__gc_ == 0)\n                        this->__set_failbit_and_consider_rethrow();\n                }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            else\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ntypename basic_istream<_CharT, _Traits>::int_type\nbasic_istream<_CharT, _Traits>::get()\n{\n    __gc_ = 0;\n    int_type __r = traits_type::eof();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this, true);\n        if (__s)\n        {\n            __r = this->rdbuf()->sbumpc();\n            if (traits_type::eq_int_type(__r, traits_type::eof()))\n               this->setstate(ios_base::failbit | ios_base::eofbit);\n            else\n                __gc_ = 1;\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n, char_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (__n > 0)\n            {\n                ios_base::iostate __err = ios_base::goodbit;\n                while (__gc_ < __n-1)\n                {\n                    int_type __i = this->rdbuf()->sgetc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    char_type __ch = traits_type::to_char_type(__i);\n                    if (traits_type::eq(__ch, __dlm))\n                        break;\n                    *__s++ = __ch;\n                    ++__gc_;\n                     this->rdbuf()->sbumpc();\n                }\n                if (__gc_ == 0)\n                   __err |= ios_base::failbit;\n                this->setstate(__err);\n            }\n            else\n                this->setstate(ios_base::failbit);\n        }\n        if (__n > 0)\n            *__s = char_type();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__n > 0)\n            *__s = char_type();\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb,\n                                    char_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            ios_base::iostate __err = ios_base::goodbit;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                while (true)\n                {\n                    typename traits_type::int_type __i = this->rdbuf()->sgetc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    char_type __ch = traits_type::to_char_type(__i);\n                    if (traits_type::eq(__ch, __dlm))\n                        break;\n                    if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))\n                        break;\n                    ++__gc_;\n                    this->rdbuf()->sbumpc();\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__gc_ == 0)\n               __err |= ios_base::failbit;\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n, char_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            ios_base::iostate __err = ios_base::goodbit;\n            while (true)\n            {\n                typename traits_type::int_type __i = this->rdbuf()->sgetc();\n                if (traits_type::eq_int_type(__i, traits_type::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                char_type __ch = traits_type::to_char_type(__i);\n                if (traits_type::eq(__ch, __dlm))\n                {\n                    this->rdbuf()->sbumpc();\n                    ++__gc_;\n                    break;\n                }\n                if (__gc_ >= __n-1)\n                {\n                    __err |= ios_base::failbit;\n                    break;\n                }\n                *__s++ = __ch;\n                this->rdbuf()->sbumpc();\n                ++__gc_;\n            }\n            if (__gc_ == 0)\n               __err |= ios_base::failbit;\n            this->setstate(__err);\n        }\n        if (__n > 0)\n            *__s = char_type();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__n > 0)\n            *__s = char_type();\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            ios_base::iostate __err = ios_base::goodbit;\n            if (__n == numeric_limits<streamsize>::max())\n            {\n                while (true)\n                {\n                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    ++__gc_;\n                    if (traits_type::eq_int_type(__i, __dlm))\n                        break;\n                }\n            }\n            else\n            {\n                while (__gc_ < __n)\n                {\n                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    ++__gc_;\n                    if (traits_type::eq_int_type(__i, __dlm))\n                        break;\n                }\n            }\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ntypename basic_istream<_CharT, _Traits>::int_type\nbasic_istream<_CharT, _Traits>::peek()\n{\n    __gc_ = 0;\n    int_type __r = traits_type::eof();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            __r = this->rdbuf()->sgetc();\n            if (traits_type::eq_int_type(__r, traits_type::eof()))\n                this->setstate(ios_base::eofbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            __gc_ = this->rdbuf()->sgetn(__s, __n);\n            if (__gc_ != __n)\n                this->setstate(ios_base::failbit | ios_base::eofbit);\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nstreamsize\nbasic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __n)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            streamsize __c = this->rdbuf()->in_avail();\n            switch (__c)\n            {\n            case -1:\n                this->setstate(ios_base::eofbit);\n                break;\n            case 0:\n                break;\n            default:\n                read(__s, _VSTD::min(__c, __n));\n                break;\n            }\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __gc_;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::putback(char_type __c)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf() == 0 || this->rdbuf()->sputbackc(__c) == traits_type::eof())\n                this->setstate(ios_base::badbit);\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::unget()\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf() == 0 || this->rdbuf()->sungetc() == traits_type::eof())\n                this->setstate(ios_base::badbit);\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nint\nbasic_istream<_CharT, _Traits>::sync()\n{\n    int __r = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf() == 0)\n                return -1;\n            if (this->rdbuf()->pubsync() == -1)\n            {\n                this->setstate(ios_base::badbit);\n                return -1;\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\ntypename basic_istream<_CharT, _Traits>::pos_type\nbasic_istream<_CharT, _Traits>::tellg()\n{\n    pos_type __r(-1);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n            __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::seekg(pos_type __pos)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == pos_type(-1))\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nws(basic_istream<_CharT, _Traits>& __is)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);\n        if (__sen)\n        {\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            while (true)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __is.setstate(ios_base::eofbit);\n                   break;\n                }\n                if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))\n                    break;\n                __is.rdbuf()->sbumpc();\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>&& __is, _Tp&& __x)\n{\n    __is >> _VSTD::forward<_Tp>(__x);\n    return __is;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_iostream\n    : public basic_istream<_CharT, _Traits>,\n      public basic_ostream<_CharT, _Traits>\n{\npublic:\n    // types:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // constructor/destructor\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    explicit basic_iostream(basic_streambuf<char_type, traits_type>* __sb)\n      : basic_istream<_CharT, _Traits>(__sb)\n    {}\n\n    virtual ~basic_iostream();\nprotected:\n#ifndef _LIBCPP_CXX03_LANG\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_iostream(basic_iostream&& __rhs);\n\n    // assign/swap\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_iostream& operator=(basic_iostream&& __rhs);\n#endif\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    void swap(basic_iostream& __rhs)\n    { basic_istream<char_type, traits_type>::swap(__rhs); }\npublic:\n};\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits>\nbasic_iostream<_CharT, _Traits>::basic_iostream(basic_iostream&& __rhs)\n    : basic_istream<_CharT, _Traits>(_VSTD::move(__rhs))\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_iostream<_CharT, _Traits>&\nbasic_iostream<_CharT, _Traits>::operator=(basic_iostream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits>\nbasic_iostream<_CharT, _Traits>::~basic_iostream()\n{\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            __str.clear();\n            streamsize __n = __is.width();\n            if (__n <= 0)\n                __n = __str.max_size();\n            if (__n <= 0)\n                __n = numeric_limits<streamsize>::max();\n            streamsize __c = 0;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            ios_base::iostate __err = ios_base::goodbit;\n            while (__c < __n)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (__ct.is(__ct.space, __ch))\n                    break;\n                __str.push_back(__ch);\n                ++__c;\n                 __is.rdbuf()->sbumpc();\n            }\n            __is.width(0);\n            if (__c == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n        else\n            __is.setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);\n        if (__sen)\n        {\n            __str.clear();\n            ios_base::iostate __err = ios_base::goodbit;\n            streamsize __extr = 0;\n            while (true)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sbumpc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                ++__extr;\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (_Traits::eq(__ch, __dlm))\n                    break;\n                __str.push_back(__ch);\n                if (__str.size() == __str.max_size())\n                {\n                    __err |= ios_base::failbit;\n                    break;\n                }\n            }\n            if (__extr == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return getline(__is, __str, __is.widen('\\n'));\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)\n{\n    return getline(__is, __str, __dlm);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return getline(__is, __str, __is.widen('\\n'));\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, size_t _Size>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            basic_string<_CharT, _Traits> __str;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            size_t __c = 0;\n            ios_base::iostate __err = ios_base::goodbit;\n            _CharT __zero = __ct.widen('0');\n            _CharT __one = __ct.widen('1');\n            while (__c < _Size)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))\n                    break;\n                __str.push_back(__ch);\n                ++__c;\n                 __is.rdbuf()->sbumpc();\n            }\n            __x = bitset<_Size>(__str);\n            if (__c == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n        else\n            __is.setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\n#ifndef _LIBCPP_DO_NOT_ASSUME_STREAMS_EXPLICIT_INSTANTIATION_IN_DYLIB\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_istream<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_istream<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_iostream<char>)\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_ISTREAM\n","// -*- C++ -*-\n//===---------------------------- ios -------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOS\n#define _LIBCPP_IOS\n\n/*\n    ios synopsis\n\n#include <iosfwd>\n\nnamespace std\n{\n\ntypedef OFF_T streamoff;\ntypedef SZ_T streamsize;\ntemplate <class stateT> class fpos;\n\nclass ios_base\n{\npublic:\n    class failure;\n\n    typedef T1 fmtflags;\n    static constexpr fmtflags boolalpha;\n    static constexpr fmtflags dec;\n    static constexpr fmtflags fixed;\n    static constexpr fmtflags hex;\n    static constexpr fmtflags internal;\n    static constexpr fmtflags left;\n    static constexpr fmtflags oct;\n    static constexpr fmtflags right;\n    static constexpr fmtflags scientific;\n    static constexpr fmtflags showbase;\n    static constexpr fmtflags showpoint;\n    static constexpr fmtflags showpos;\n    static constexpr fmtflags skipws;\n    static constexpr fmtflags unitbuf;\n    static constexpr fmtflags uppercase;\n    static constexpr fmtflags adjustfield;\n    static constexpr fmtflags basefield;\n    static constexpr fmtflags floatfield;\n\n    typedef T2 iostate;\n    static constexpr iostate badbit;\n    static constexpr iostate eofbit;\n    static constexpr iostate failbit;\n    static constexpr iostate goodbit;\n\n    typedef T3 openmode;\n    static constexpr openmode app;\n    static constexpr openmode ate;\n    static constexpr openmode binary;\n    static constexpr openmode in;\n    static constexpr openmode out;\n    static constexpr openmode trunc;\n\n    typedef T4 seekdir;\n    static constexpr seekdir beg;\n    static constexpr seekdir cur;\n    static constexpr seekdir end;\n\n    class Init;\n\n    // 27.5.2.2 fmtflags state:\n    fmtflags flags() const;\n    fmtflags flags(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl, fmtflags mask);\n    void unsetf(fmtflags mask);\n\n    streamsize precision() const;\n    streamsize precision(streamsize prec);\n    streamsize width() const;\n    streamsize width(streamsize wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int index);\n    void*& pword(int index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int index);\n    void register_callback(event_callback fn, int index);\n\n    ios_base(const ios_base&) = delete;\n    ios_base& operator=(const ios_base&) = delete;\n\n    static bool sync_with_stdio(bool sync = true);\n\nprotected:\n    ios_base();\n};\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef typename traits::int_type int_type;  // removed in C++17\n    typedef typename traits::pos_type pos_type;  // removed in C++17\n    typedef typename traits::off_type off_type;  // removed in C++17\n    typedef traits traits_type;\n\n    operator unspecified-bool-type() const;\n    bool operator!() const;\n    iostate rdstate() const;\n    void clear(iostate state = goodbit);\n    void setstate(iostate state);\n    bool good() const;\n    bool eof() const;\n    bool fail() const;\n    bool bad() const;\n\n    iostate exceptions() const;\n    void exceptions(iostate except);\n\n    // 27.5.4.1 Constructor/destructor:\n    explicit basic_ios(basic_streambuf<charT,traits>* sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    basic_ostream<charT,traits>* tie() const;\n    basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);\n\n    basic_streambuf<charT,traits>* rdbuf() const;\n    basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);\n\n    basic_ios& copyfmt(const basic_ios& rhs);\n\n    char_type fill() const;\n    char_type fill(char_type ch);\n\n    locale imbue(const locale& loc);\n\n    char narrow(char_type c, char dfault) const;\n    char_type widen(char c) const;\n\n    basic_ios(const basic_ios& ) = delete;\n    basic_ios& operator=(const basic_ios&) = delete;\n\nprotected:\n    basic_ios();\n    void init(basic_streambuf<charT,traits>* sb);\n    void move(basic_ios& rhs);\n    void swap(basic_ios& rhs) noexcept;\n    void set_rdbuf(basic_streambuf<charT, traits>* sb);\n};\n\n// 27.5.5, manipulators:\nios_base& boolalpha (ios_base& str);\nios_base& noboolalpha(ios_base& str);\nios_base& showbase (ios_base& str);\nios_base& noshowbase (ios_base& str);\nios_base& showpoint (ios_base& str);\nios_base& noshowpoint(ios_base& str);\nios_base& showpos (ios_base& str);\nios_base& noshowpos (ios_base& str);\nios_base& skipws (ios_base& str);\nios_base& noskipws (ios_base& str);\nios_base& uppercase (ios_base& str);\nios_base& nouppercase(ios_base& str);\nios_base& unitbuf (ios_base& str);\nios_base& nounitbuf (ios_base& str);\n\n// 27.5.5.2 adjustfield:\nios_base& internal (ios_base& str);\nios_base& left (ios_base& str);\nios_base& right (ios_base& str);\n\n// 27.5.5.3 basefield:\nios_base& dec (ios_base& str);\nios_base& hex (ios_base& str);\nios_base& oct (ios_base& str);\n\n// 27.5.5.4 floatfield:\nios_base& fixed (ios_base& str);\nios_base& scientific (ios_base& str);\nios_base& hexfloat (ios_base& str);\nios_base& defaultfloat(ios_base& str);\n\n// 27.5.5.5 error reporting:\nenum class io_errc\n{\n    stream = 1\n};\n\nconcept_map ErrorCodeEnum<io_errc> { };\nerror_code make_error_code(io_errc e) noexcept; \nerror_condition make_error_condition(io_errc e) noexcept; \nstorage-class-specifier const error_category& iostream_category() noexcept;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <__locale>\n#include <system_error>\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#include <atomic>     // for __xindex_\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntypedef ptrdiff_t streamsize;\n\nclass _LIBCPP_TYPE_VIS ios_base\n{\npublic:\n    class _LIBCPP_EXCEPTION_ABI failure;\n\n    typedef unsigned int fmtflags;\n    static const fmtflags boolalpha   = 0x0001;\n    static const fmtflags dec         = 0x0002;\n    static const fmtflags fixed       = 0x0004;\n    static const fmtflags hex         = 0x0008;\n    static const fmtflags internal    = 0x0010;\n    static const fmtflags left        = 0x0020;\n    static const fmtflags oct         = 0x0040;\n    static const fmtflags right       = 0x0080;\n    static const fmtflags scientific  = 0x0100;\n    static const fmtflags showbase    = 0x0200;\n    static const fmtflags showpoint   = 0x0400;\n    static const fmtflags showpos     = 0x0800;\n    static const fmtflags skipws      = 0x1000;\n    static const fmtflags unitbuf     = 0x2000;\n    static const fmtflags uppercase   = 0x4000;\n    static const fmtflags adjustfield = left | right | internal;\n    static const fmtflags basefield   = dec | oct | hex;\n    static const fmtflags floatfield  = scientific | fixed;\n\n    typedef unsigned int iostate;\n    static const iostate badbit  = 0x1;\n    static const iostate eofbit  = 0x2;\n    static const iostate failbit = 0x4;\n    static const iostate goodbit = 0x0;\n\n    typedef unsigned int openmode;\n    static const openmode app    = 0x01;\n    static const openmode ate    = 0x02;\n    static const openmode binary = 0x04;\n    static const openmode in     = 0x08;\n    static const openmode out    = 0x10;\n    static const openmode trunc  = 0x20;\n\n    enum seekdir {beg, cur, end};\n\n#if _LIBCPP_STD_VER <= 14\n    typedef iostate      io_state;\n    typedef openmode     open_mode;\n    typedef seekdir      seek_dir;\n\n    typedef _VSTD::streamoff streamoff;\n    typedef _VSTD::streampos streampos;\n#endif\n\n    class _LIBCPP_TYPE_VIS Init;\n\n    // 27.5.2.2 fmtflags state:\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags() const;\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl, fmtflags __mask);\n    _LIBCPP_INLINE_VISIBILITY void unsetf(fmtflags __mask);\n\n    _LIBCPP_INLINE_VISIBILITY streamsize precision() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize precision(streamsize __prec);\n    _LIBCPP_INLINE_VISIBILITY streamsize width() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize width(streamsize __wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int __index);\n    void*& pword(int __index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int __index);\n    void register_callback(event_callback __fn, int __index);\n\nprivate:\n    ios_base(const ios_base&); // = delete;\n    ios_base& operator=(const ios_base&); // = delete;\n\npublic:\n    static bool sync_with_stdio(bool __sync = true);\n\n    _LIBCPP_INLINE_VISIBILITY iostate rdstate() const;\n    void clear(iostate __state = goodbit);\n    _LIBCPP_INLINE_VISIBILITY void setstate(iostate __state);\n\n    _LIBCPP_INLINE_VISIBILITY bool good() const;\n    _LIBCPP_INLINE_VISIBILITY bool eof() const;\n    _LIBCPP_INLINE_VISIBILITY bool fail() const;\n    _LIBCPP_INLINE_VISIBILITY bool bad() const;\n\n    _LIBCPP_INLINE_VISIBILITY iostate exceptions() const;\n    _LIBCPP_INLINE_VISIBILITY void exceptions(iostate __iostate);\n\n    void __set_badbit_and_consider_rethrow();\n    void __set_failbit_and_consider_rethrow();\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ios_base() {// purposefully does no initialization\n               }\n\n    void init(void* __sb);\n    _LIBCPP_INLINE_VISIBILITY void* rdbuf() const {return __rdbuf_;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n        clear();\n    }\n\n    void __call_callbacks(event);\n    void copyfmt(const ios_base&);\n    void move(ios_base&);\n    void swap(ios_base&) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void set_rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n    }\n\nprivate:\n    // All data members must be scalars\n    fmtflags        __fmtflags_;\n    streamsize      __precision_;\n    streamsize      __width_;\n    iostate         __rdstate_;\n    iostate         __exceptions_;\n    void*           __rdbuf_;\n    void*           __loc_;\n    event_callback* __fn_;\n    int*            __index_;\n    size_t          __event_size_;\n    size_t          __event_cap_;\n// TODO(EricWF): Enable this for both Clang and GCC. Currently it is only\n// enabled with clang.\n#if defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_NO_THREADS)\n    static atomic<int> __xindex_;\n#else\n    static int      __xindex_;\n#endif\n    long*           __iarray_;\n    size_t          __iarray_size_;\n    size_t          __iarray_cap_;\n    void**          __parray_;\n    size_t          __parray_size_;\n    size_t          __parray_cap_;\n};\n\n//enum class io_errc\n_LIBCPP_DECLARE_STRONG_ENUM(io_errc)\n{\n    stream = 1\n};\n_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(io_errc)\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS is_error_code_enum<io_errc> : public true_type { };\n\n#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS is_error_code_enum<io_errc::__lx> : public true_type { };\n#endif\n\n_LIBCPP_FUNC_VIS\nconst error_category& iostream_category() _NOEXCEPT;\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_code\nmake_error_code(io_errc __e) _NOEXCEPT\n{\n    return error_code(static_cast<int>(__e), iostream_category());\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_condition\nmake_error_condition(io_errc __e) _NOEXCEPT\n{\n    return error_condition(static_cast<int>(__e), iostream_category());\n}\n\nclass _LIBCPP_EXCEPTION_ABI ios_base::failure\n    : public system_error\n{\npublic:\n    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);\n    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);\n    virtual ~failure() throw();\n};\n\nclass _LIBCPP_TYPE_VIS ios_base::Init\n{\npublic:\n    Init();\n    ~Init();\n};\n\n// fmtflags\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags() const\n{\n    return __fmtflags_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ = __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ |= __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::unsetf(fmtflags __mask)\n{\n    __fmtflags_ &= ~__mask;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl, fmtflags __mask)\n{\n    fmtflags __r = __fmtflags_;\n    unsetf(__mask);\n    __fmtflags_ |= __fmtfl & __mask;\n    return __r;\n}\n\n// precision\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision() const\n{\n    return __precision_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision(streamsize __prec)\n{\n    streamsize __r = __precision_;\n    __precision_ = __prec;\n    return __r;\n}\n\n// width\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width() const\n{\n    return __width_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width(streamsize __wide)\n{\n    streamsize __r = __width_;\n    __width_ = __wide;\n    return __r;\n}\n\n// iostate\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::rdstate() const\n{\n    return __rdstate_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::setstate(iostate __state)\n{\n    clear(__rdstate_ | __state);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::good() const\n{\n    return __rdstate_ == 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::eof() const\n{\n    return (__rdstate_ & eofbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::fail() const\n{\n    return (__rdstate_ & (failbit | badbit)) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::bad() const\n{\n    return (__rdstate_ & badbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::exceptions() const\n{\n    return __exceptions_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::exceptions(iostate __iostate)\n{\n    __exceptions_ = __iostate;\n    clear(__rdstate_);\n}\n\n#if defined(_LIBCPP_CXX03_LANG)\nstruct _LIBCPP_TYPE_VIS __cxx03_bool {\n  typedef void (__cxx03_bool::*__bool_type)();\n  void __true_value() {}\n};\n#endif\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    static_assert((is_same<_CharT, typename traits_type::char_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n\n  // __true_value will generate undefined references when linking unless\n  // we give it internal linkage.\n\n#if defined(_LIBCPP_CXX03_LANG)\n    _LIBCPP_INLINE_VISIBILITY\n    operator __cxx03_bool::__bool_type() const {\n        return !fail() ? &__cxx03_bool::__true_value : nullptr;\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const {return !fail();}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY bool operator!() const    {return  fail();}\n    _LIBCPP_INLINE_VISIBILITY iostate rdstate() const   {return ios_base::rdstate();}\n    _LIBCPP_INLINE_VISIBILITY void clear(iostate __state = goodbit) {ios_base::clear(__state);}\n    _LIBCPP_INLINE_VISIBILITY void setstate(iostate __state) {ios_base::setstate(__state);}\n    _LIBCPP_INLINE_VISIBILITY bool good() const {return ios_base::good();}\n    _LIBCPP_INLINE_VISIBILITY bool eof() const  {return ios_base::eof();}\n    _LIBCPP_INLINE_VISIBILITY bool fail() const {return ios_base::fail();}\n    _LIBCPP_INLINE_VISIBILITY bool bad() const  {return ios_base::bad();}\n\n    _LIBCPP_INLINE_VISIBILITY iostate exceptions() const {return ios_base::exceptions();}\n    _LIBCPP_INLINE_VISIBILITY void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}\n\n    // 27.5.4.1 Constructor/destructor:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);\n\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);\n\n    basic_ios& copyfmt(const basic_ios& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill() const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill(char_type __ch);\n\n    _LIBCPP_INLINE_VISIBILITY \n    locale imbue(const locale& __loc);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char narrow(char_type __c, char __dfault) const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type widen(char __c) const;\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ios() {// purposefully does no initialization\n                }\n    _LIBCPP_INLINE_VISIBILITY \n    void init(basic_streambuf<char_type, traits_type>* __sb);\n\n    _LIBCPP_INLINE_VISIBILITY \n    void move(basic_ios& __rhs);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    void move(basic_ios&& __rhs) {move(__rhs);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY \n    void swap(basic_ios& __rhs) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY \n    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);\nprivate:\n    basic_ostream<char_type, traits_type>* __tie_;\n    mutable int_type __fill_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)\n{\n    init(__sb);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>::~basic_ios()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::init(__sb);\n    __tie_ = 0;\n    __fill_ = traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie() const\n{\n    return __tie_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)\n{\n    basic_ostream<char_type, traits_type>* __r = __tie_;\n    __tie_ = __tiestr;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf() const\n{\n    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    basic_streambuf<char_type, traits_type>* __r = rdbuf();\n    ios_base::rdbuf(__sb);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_ios<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    locale __r = getloc();\n    ios_base::imbue(__loc);\n    if (rdbuf())\n        rdbuf()->pubimbue(__loc);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nchar\nbasic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const\n{\n    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::widen(char __c) const\n{\n    return use_facet<ctype<char_type> >(getloc()).widen(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill() const\n{\n    if (traits_type::eq_int_type(traits_type::eof(), __fill_))\n        __fill_ = widen(' ');\n    return __fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill(char_type __ch)\n{\n    char_type __r = __fill_;\n    __fill_ = __ch;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>&\nbasic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)\n{\n    if (this != &__rhs)\n    {\n        __call_callbacks(erase_event);\n        ios_base::copyfmt(__rhs);\n        __tie_ = __rhs.__tie_;\n        __fill_ = __rhs.__fill_;\n        __call_callbacks(copyfmt_event);\n        exceptions(__rhs.exceptions());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::move(basic_ios& __rhs)\n{\n    ios_base::move(__rhs);\n    __tie_ = __rhs.__tie_;\n    __rhs.__tie_ = 0;\n    __fill_ = __rhs.__fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) _NOEXCEPT\n{\n    ios_base::swap(__rhs);\n    _VSTD::swap(__tie_, __rhs.__tie_);\n    _VSTD::swap(__fill_, __rhs.__fill_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::set_rdbuf(__sb);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nboolalpha(ios_base& __str)\n{\n    __str.setf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoboolalpha(ios_base& __str)\n{\n    __str.unsetf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowbase(ios_base& __str)\n{\n    __str.setf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowbase(ios_base& __str)\n{\n    __str.unsetf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpoint(ios_base& __str)\n{\n    __str.setf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpoint(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpos(ios_base& __str)\n{\n    __str.setf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpos(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nskipws(ios_base& __str)\n{\n    __str.setf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoskipws(ios_base& __str)\n{\n    __str.unsetf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nuppercase(ios_base& __str)\n{\n    __str.setf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnouppercase(ios_base& __str)\n{\n    __str.unsetf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nunitbuf(ios_base& __str)\n{\n    __str.setf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnounitbuf(ios_base& __str)\n{\n    __str.unsetf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ninternal(ios_base& __str)\n{\n    __str.setf(ios_base::internal, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nleft(ios_base& __str)\n{\n    __str.setf(ios_base::left, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nright(ios_base& __str)\n{\n    __str.setf(ios_base::right, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndec(ios_base& __str)\n{\n    __str.setf(ios_base::dec, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhex(ios_base& __str)\n{\n    __str.setf(ios_base::hex, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\noct(ios_base& __str)\n{\n    __str.setf(ios_base::oct, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nfixed(ios_base& __str)\n{\n    __str.setf(ios_base::fixed, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nscientific(ios_base& __str)\n{\n    __str.setf(ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhexfloat(ios_base& __str)\n{\n    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndefaultfloat(ios_base& __str)\n{\n    __str.unsetf(ios_base::floatfield);\n    return __str;\n}\n\ntemplate <class _CharT, class _Traits>\nclass __save_flags\n{\n    typedef basic_ios<_CharT, _Traits> __stream_type;\n    typedef typename __stream_type::fmtflags fmtflags;\n\n    __stream_type& __stream_;\n    fmtflags       __fmtflags_;\n    _CharT         __fill_;\n\n    __save_flags(const __save_flags&);\n    __save_flags& operator=(const __save_flags&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __save_flags(__stream_type& __stream)\n        : __stream_(__stream),\n          __fmtflags_(__stream.flags()),\n          __fill_(__stream.fill())\n        {}\n    _LIBCPP_INLINE_VISIBILITY\n    ~__save_flags()\n    {\n        __stream_.flags(__fmtflags_);\n        __stream_.fill(__fill_);\n    }\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOS\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2020.\n *\n *  @file _emscripten_assert_trigger.hpp\n *  @brief Assert trigger implementation.\n *  @note For internal use.\n */\n\n#ifndef EMP_BASE__EMSCRIPTEN_ASSERT_TRIGGER_HPP_INCLUDE\n#define EMP_BASE__EMSCRIPTEN_ASSERT_TRIGGER_HPP_INCLUDE\n\n#include <iostream>\n#include <sstream>\n#include <string>\n\n#include <emscripten.h>\n\n#include \"_is_streamable.hpp\"\n\nnamespace emp {\n\n  static int TripAssert() {\n    static int trip_count = 0;\n    return ++trip_count;\n  }\n\n  /// Base case for assert_print...\n  inline void assert_print(std::stringstream &) { ; }\n\n  /// Print out information about the next variable and recurse...\n  template <typename T, typename... EXTRA>\n  void assert_print(std::stringstream & ss, std::string name, T && val, EXTRA &&... extra) {\n    if constexpr ( emp::is_streamable<std::stringstream, T>::value ) {\n      ss << name << \": [\" << val << \"]\" << std::endl;\n    } else ss << name << \": (non-streamable type)\" << std::endl;\n    assert_print(ss, std::forward<EXTRA>(extra)...);\n  }\n\n  template <typename... EXTRA>\n  bool assert_trigger(std::string filename, size_t line, std::string expr, EXTRA &&... extra) {\n    std::stringstream ss;\n    ss << \"Assert Error (In \" << filename << \" line \" << line << \"): \" << expr << '\\n';\n    assert_print(ss, std::forward<EXTRA>(extra)...);\n    if (emp::TripAssert() <= 3) {\n      EM_ASM({\n        msg = UTF8ToString($0);\n        if (typeof alert == \"undefined\") {\n          // node polyfill\n          globalThis.alert = console.log;\n        }\n        alert(msg);\n      }, ss.str().c_str());\n    }\n\n    // Print the current state of the stack.\n    EM_ASM( console.log('Callstack:\\n' + stackTrace()); );\n\n    return false;\n\n  }\n\n} // namespace emp\n\n#endif // #ifndef EMP_BASE__EMSCRIPTEN_ASSERT_TRIGGER_HPP_INCLUDE\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\ninline constexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept; // constexpr in C++20\n};\n\ntemplate <class T> constexpr T* to_address(T* p) noexcept; // C++20\ntemplate <class Ptr> auto to_address(const Ptr& p) noexcept; // C++20\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n    typedef Alloc::is_always_equal\n          | is_empty                     is_always_equal;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);                          // [[nodiscard]] in C++20\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint); // [[nodiscard]] in C++20\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    constexpr allocator() noexcept;                      // constexpr in C++20\n    constexpr allocator(const allocator&) noexcept;      // constexpr in C++20\n    template <class U>\n      constexpr allocator(const allocator<U>&) noexcept; // constexpr in C++20\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\ntemplate <class T> T* addressof(const T&& r) noexcept = delete;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class T>\nvoid destroy_at(T* location);\n\ntemplate <class ForwardIterator>\n void destroy(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator destroy_n(ForwardIterator first, Size n);\n\ntemplate <class InputIterator, class ForwardIterator>\n ForwardIterator uninitialized_move(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\n pair<InputIterator,ForwardIterator> uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator>\n void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);\n\ntemplate <class ForwardIterator>\n void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);\n\ntemplate <class Y> struct auto_ptr_ref {};      // deprecated in C++11, removed in C++17\n\ntemplate<class X>\nclass auto_ptr                                  // deprecated in C++11, removed in C++17\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;       // removed in C++17\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class E, class T, class Y, class D>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, unique_ptr<Y, D> const& p);\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n    typedef weak_ptr<T> weak_type; // C++17\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);          // removed in C++17\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r); // removed in C++17\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const noexcept;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const noexcept;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const noexcept;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const noexcept;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const noexcept;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const noexcept;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const noexcept;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const noexcept;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const noexcept;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const noexcept;\n};\n\ntemplate <>  // Added in C++14\nstruct owner_less<void>\n{\n    template <class _Tp, class _Up>\n    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept;\n    template <class _Tp, class _Up>\n    bool operator()( shared_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const noexcept;\n    template <class _Tp, class _Up>\n    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept;\n    template <class _Tp, class _Up>\n    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const noexcept;\n\n    typedef void is_transparent;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\ntemplate <class T, class Alloc>\n  inline constexpr bool uses_allocator_v = uses_allocator<T, Alloc>::value;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <stdexcept>\n#include <cstring>\n#include <cassert>\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#  include <atomic>\n#endif\n#include <version>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _ValueType>\ninline _LIBCPP_INLINE_VISIBILITY\n_ValueType __libcpp_relaxed_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_RELAXED) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_RELAXED);\n#else\n    return *__value;\n#endif\n}\n\ntemplate <class _ValueType>\ninline _LIBCPP_INLINE_VISIBILITY\n_ValueType __libcpp_acquire_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_ACQUIRE) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_ACQUIRE);\n#else\n    return *__value;\n#endif\n}\n\n// addressof moved to <type_traits>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp, class = void>\nstruct __has_element_type : false_type {};\n\ntemplate <class _Tp>\nstruct __has_element_type<_Tp,\n              typename __void_t<typename _Tp::element_type>::type> : true_type {};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class = void>\nstruct __has_difference_type : false_type {};\n\ntemplate <class _Tp>\nstruct __has_difference_type<_Tp,\n            typename __void_t<typename _Tp::difference_type>::type> : true_type {};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_CXX03_LANG\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\ntemplate <class _From, class _To>\nstruct __rebind_pointer {\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_From>::template rebind<_To>        type;\n#else\n    typedef typename pointer_traits<_From>::template rebind<_To>::other type;\n#endif\n};\n\n// allocator_traits\n\ntemplate <class _Tp, class = void>\nstruct __has_pointer_type : false_type {};\n\ntemplate <class _Tp>\nstruct __has_pointer_type<_Tp,\n          typename __void_t<typename _Tp::pointer>::type> : true_type {};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_const_pointer : false_type {};\n\ntemplate <class _Tp>\nstruct __has_const_pointer<_Tp,\n            typename __void_t<typename _Tp::const_pointer>::type> : true_type {};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_void_pointer : false_type {};\n\ntemplate <class _Tp>\nstruct __has_void_pointer<_Tp,\n               typename __void_t<typename _Tp::void_pointer>::type> : true_type {};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_const_void_pointer : false_type {};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer<_Tp,\n            typename __void_t<typename _Tp::const_void_pointer>::type> : true_type {};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\n#if _LIBCPP_STD_VER <= 17\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n#else\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__to_raw_pointer(const _Pointer& __p) _NOEXCEPT\n-> decltype(pointer_traits<_Pointer>::to_address(__p))\n{\n    return pointer_traits<_Pointer>::to_address(__p);\n}\n\ntemplate <class _Pointer, class... _None>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__to_raw_pointer(const _Pointer& __p, _None...) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY constexpr\n_Tp*\nto_address(_Tp* __p) _NOEXCEPT\n{\n    static_assert(!is_function_v<_Tp>, \"_Tp is a function type\");\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nto_address(const _Pointer& __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p);\n}\n#endif\n\ntemplate <class _Tp, class = void>\nstruct __has_size_type : false_type {};\n\ntemplate <class _Tp>\nstruct __has_size_type<_Tp,\n               typename __void_t<typename _Tp::size_type>::type> : true_type {};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_propagate_on_container_copy_assignment : false_type {};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment<_Tp,\n    typename __void_t<typename _Tp::propagate_on_container_copy_assignment>::type>\n        : true_type {};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_propagate_on_container_move_assignment : false_type {};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment<_Tp,\n           typename __void_t<typename _Tp::propagate_on_container_move_assignment>::type>\n               : true_type {};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_propagate_on_container_swap : false_type {};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap<_Tp,\n           typename __void_t<typename _Tp::propagate_on_container_swap>::type>\n               : true_type {};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_is_always_equal : false_type {};\n\ntemplate <class _Tp>\nstruct __has_is_always_equal<_Tp,\n           typename __void_t<typename _Tp::is_always_equal>::type>\n               : true_type {};\n\ntemplate <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>\nstruct __is_always_equal\n{\n    typedef typename _VSTD::is_empty<_Alloc>::type type;\n};\n\ntemplate <class _Alloc>\nstruct __is_always_equal<_Alloc, true>\n{\n    typedef typename _Alloc::is_always_equal type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype((void)__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(_VSTD::__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(_VSTD::__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(_VSTD::__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(_VSTD::__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(_VSTD::__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _Pointer, class _Tp, class = void>\nstruct __has_construct : std::false_type {};\n\ntemplate <class _Alloc, class _Pointer, class _Tp>\nstruct __has_construct<_Alloc, _Pointer, _Tp, typename __void_t<\n    decltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Pointer>(), _VSTD::declval<_Tp>()))\n>::type> : std::true_type {};\n\ntemplate <class _Alloc, class _Pointer, class = void>\nstruct __has_destroy : false_type {};\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy<_Alloc, _Pointer, typename __void_t<\n    decltype(_VSTD::declval<_Alloc>().destroy(_VSTD::declval<_Pointer>()))\n>::type> : std::true_type {};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Tp>\nstruct __is_default_allocator : false_type {};\n\ntemplate <class _Tp>\nstruct __is_default_allocator<_VSTD::allocator<_Tp> > : true_type {};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TEMPLATE_VIS allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n    typedef typename __is_always_equal<allocator_type>::type\n                     is_always_equal;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_CXX03_LANG\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return __allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type&, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                __construct(__has_construct<allocator_type, _Tp*, const _A0&>(),\n                            __a, __p, __a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type&, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type&, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return __select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, (void) ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (__is_default_allocator<allocator_type>::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Iter, class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_range_forward(allocator_type& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, (void) ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), *__begin1);\n        }\n\n    template <class _SourceTp, class _DestTp,\n              class _RawSourceTp = typename remove_const<_SourceTp>::type,\n              class _RawDestTp = typename remove_const<_DestTp>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            is_trivially_move_constructible<_DestTp>::value &&\n            is_same<_RawSourceTp, _RawDestTp>::value &&\n            (__is_default_allocator<allocator_type>::value ||\n             !__has_construct<allocator_type, _DestTp*, _SourceTp&>::value),\n            void\n        >::type\n        __construct_range_forward(allocator_type&, _SourceTp* __begin1, _SourceTp* __end1, _DestTp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(const_cast<_RawDestTp*>(__begin2), __begin1, _Np * sizeof(_DestTp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (__is_default_allocator<allocator_type>::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            if (_Np > 0)\n                _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer __allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer __allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p,\n                                const _A0& __a0)\n            {__a.construct(__p, __a0);}\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p,\n                                const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a) _NOEXCEPT\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&) _NOEXCEPT\n            {return numeric_limits<size_type>::max() / sizeof(value_type);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        __select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        __select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\ntemplate <class _Traits, class _Tp>\nstruct __rebind_alloc_helper\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Traits::template rebind_alloc<_Tp>        type;\n#else\n    typedef typename _Traits::template rebind_alloc<_Tp>::other type;\n#endif\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n    allocator() _NOEXCEPT {}\n\n    template <class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n    allocator(const allocator<_Up>&) _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__libcpp_allocate(__n * sizeof(_Tp), _LIBCPP_ALIGNOF(_Tp)));\n        }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type __n) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*)__p, __n * sizeof(_Tp), _LIBCPP_ALIGNOF(_Tp));}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n    allocator() _NOEXCEPT {}\n\n    template <class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n    allocator(const allocator<_Up>&) _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n    {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<const T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__libcpp_allocate(__n * sizeof(_Tp), _LIBCPP_ALIGNOF(_Tp)));\n    }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type __n) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*) const_cast<_Tp *>(__p), __n * sizeof(_Tp), _LIBCPP_ALIGNOF(_Tp));}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(_VSTD::addressof(*__x_)) _Tp(__element); return *this;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(_Tp&& __element)\n        {::new(_VSTD::addressof(*__x_)) _Tp(_VSTD::move(__element)); return *this;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY _OutputIterator base() const { return __x_; }\n#endif\n};\n\ntemplate <class _Tp>\n_LIBCPP_NODISCARD_EXT _LIBCPP_NO_CFI\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION)\n    if (__is_overaligned_for_new(_LIBCPP_ALIGNOF(_Tp)))\n        {\n            std::align_val_t __al =\n                std::align_val_t(std::alignment_of<_Tp>::value);\n            __r.first = static_cast<_Tp*>(::operator new(\n                __n * sizeof(_Tp), __al, nothrow));\n        } else {\n            __r.first = static_cast<_Tp*>(::operator new(\n                __n * sizeof(_Tp), nothrow));\n        }\n#else\n    if (__is_overaligned_for_new(_LIBCPP_ALIGNOF(_Tp)))\n        {\n            // Since aligned operator new is unavailable, return an empty\n            // buffer rather than one with invalid alignment.\n            return __r;\n        }\n\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n#endif\n\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT\n{\n  _VSTD::__libcpp_deallocate_unsized((void*)__p, _LIBCPP_ALIGNOF(_Tp));\n}\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\ntemplate <class _Tp>\nstruct _LIBCPP_DEPRECATED_IN_CXX11 auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n#endif\n\ntemplate <class _Tp, int _Idx,\n          bool _CanBeEmptyBase =\n              is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value>\nstruct __compressed_pair_elem {\n  typedef _Tp _ParamT;\n  typedef _Tp& reference;\n  typedef const _Tp& const_reference;\n\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY constexpr __compressed_pair_elem() : __value_() {}\n\n  template <class _Up, class = typename enable_if<\n      !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value\n  >::type>\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr explicit\n  __compressed_pair_elem(_Up&& __u)\n      : __value_(_VSTD::forward<_Up>(__u))\n    {\n    }\n\n  template <class... _Args, size_t... _Indexes>\n  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,\n                         __tuple_indices<_Indexes...>)\n      : __value_(_VSTD::forward<_Args>(_VSTD::get<_Indexes>(__args))...) {}\n#else\n  _LIBCPP_INLINE_VISIBILITY __compressed_pair_elem() : __value_() {}\n  _LIBCPP_INLINE_VISIBILITY\n  __compressed_pair_elem(_ParamT __p) : __value_(std::forward<_ParamT>(__p)) {}\n#endif\n\n  _LIBCPP_INLINE_VISIBILITY reference __get() _NOEXCEPT { return __value_; }\n  _LIBCPP_INLINE_VISIBILITY\n  const_reference __get() const _NOEXCEPT { return __value_; }\n\nprivate:\n  _Tp __value_;\n};\n\ntemplate <class _Tp, int _Idx>\nstruct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {\n  typedef _Tp _ParamT;\n  typedef _Tp& reference;\n  typedef const _Tp& const_reference;\n  typedef _Tp __value_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY constexpr __compressed_pair_elem() = default;\n\n  template <class _Up, class = typename enable_if<\n        !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value\n  >::type>\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr explicit\n  __compressed_pair_elem(_Up&& __u)\n      : __value_type(_VSTD::forward<_Up>(__u))\n  {}\n\n  template <class... _Args, size_t... _Indexes>\n  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,\n                         __tuple_indices<_Indexes...>)\n      : __value_type(_VSTD::forward<_Args>(_VSTD::get<_Indexes>(__args))...) {}\n#else\n  _LIBCPP_INLINE_VISIBILITY __compressed_pair_elem() : __value_type() {}\n  _LIBCPP_INLINE_VISIBILITY\n  __compressed_pair_elem(_ParamT __p)\n      : __value_type(std::forward<_ParamT>(__p)) {}\n#endif\n\n  _LIBCPP_INLINE_VISIBILITY reference __get() _NOEXCEPT { return *this; }\n  _LIBCPP_INLINE_VISIBILITY\n  const_reference __get() const _NOEXCEPT { return *this; }\n};\n\n// Tag used to construct the second element of the compressed pair.\nstruct __second_tag {};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair : private __compressed_pair_elem<_T1, 0>,\n                          private __compressed_pair_elem<_T2, 1> {\n  typedef __compressed_pair_elem<_T1, 0> _Base1;\n  typedef __compressed_pair_elem<_T2, 1> _Base2;\n\n  // NOTE: This static assert should never fire because __compressed_pair\n  // is *almost never* used in a scenario where it's possible for T1 == T2.\n  // (The exception is std::function where it is possible that the function\n  //  object and the allocator have the same type).\n  static_assert((!is_same<_T1, _T2>::value),\n    \"__compressed_pair cannot be instantated when T1 and T2 are the same type; \"\n    \"The current implementation is NOT ABI-compatible with the previous \"\n    \"implementation for this configuration\");\n\npublic:\n#ifndef _LIBCPP_CXX03_LANG\n  template <bool _Dummy = true,\n      class = typename enable_if<\n          __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&\n          __dependent_type<is_default_constructible<_T2>, _Dummy>::value\n      >::type\n  >\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr __compressed_pair() {}\n\n  template <class _Tp, typename enable_if<!is_same<typename decay<_Tp>::type,\n                                                   __compressed_pair>::value,\n                                          bool>::type = true>\n  _LIBCPP_INLINE_VISIBILITY constexpr explicit\n  __compressed_pair(_Tp&& __t)\n      : _Base1(std::forward<_Tp>(__t)), _Base2() {}\n\n  template <class _Tp>\n  _LIBCPP_INLINE_VISIBILITY constexpr\n  __compressed_pair(__second_tag, _Tp&& __t)\n      : _Base1(), _Base2(std::forward<_Tp>(__t)) {}\n\n  template <class _U1, class _U2>\n  _LIBCPP_INLINE_VISIBILITY constexpr\n  __compressed_pair(_U1&& __t1, _U2&& __t2)\n      : _Base1(std::forward<_U1>(__t1)), _Base2(std::forward<_U2>(__t2)) {}\n\n  template <class... _Args1, class... _Args2>\n  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n  __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                    tuple<_Args2...> __second_args)\n      : _Base1(__pc, _VSTD::move(__first_args),\n               typename __make_tuple_indices<sizeof...(_Args1)>::type()),\n        _Base2(__pc, _VSTD::move(__second_args),\n               typename __make_tuple_indices<sizeof...(_Args2)>::type()) {}\n\n#else\n  _LIBCPP_INLINE_VISIBILITY\n  __compressed_pair() {}\n\n  _LIBCPP_INLINE_VISIBILITY explicit\n  __compressed_pair(_T1 __t1) : _Base1(_VSTD::forward<_T1>(__t1)) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  __compressed_pair(__second_tag, _T2 __t2)\n      : _Base1(), _Base2(_VSTD::forward<_T2>(__t2)) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  __compressed_pair(_T1 __t1, _T2 __t2)\n      : _Base1(_VSTD::forward<_T1>(__t1)), _Base2(_VSTD::forward<_T2>(__t2)) {}\n#endif\n\n  _LIBCPP_INLINE_VISIBILITY\n  typename _Base1::reference first() _NOEXCEPT {\n    return static_cast<_Base1&>(*this).__get();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  typename _Base1::const_reference first() const _NOEXCEPT {\n    return static_cast<_Base1 const&>(*this).__get();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  typename _Base2::reference second() _NOEXCEPT {\n    return static_cast<_Base2&>(*this).__get();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  typename _Base2::const_reference second() const _NOEXCEPT {\n    return static_cast<_Base2 const&>(*this).__get();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void swap(__compressed_pair& __x)\n    _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n               __is_nothrow_swappable<_T2>::value)\n  {\n    using std::swap;\n    swap(first(), __x.first());\n    swap(second(), __x.second());\n  }\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n    _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n               __is_nothrow_swappable<_T2>::value) {\n  __x.swap(__y);\n}\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete {\n    static_assert(!is_function<_Tp>::value,\n                  \"default_delete cannot be instantiated for function types\");\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY constexpr default_delete() noexcept = default;\n#else\n  _LIBCPP_INLINE_VISIBILITY default_delete() {}\n#endif\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  default_delete(const default_delete<_Up>&,\n                 typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* =\n                     0) _NOEXCEPT {}\n\n  _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __ptr) const _NOEXCEPT {\n    static_assert(sizeof(_Tp) > 0,\n                  \"default_delete can not delete incomplete type\");\n    static_assert(!is_void<_Tp>::value,\n                  \"default_delete can not delete incomplete type\");\n    delete __ptr;\n  }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete<_Tp[]> {\nprivate:\n  template <class _Up>\n  struct _EnableIfConvertible\n      : enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value> {};\n\npublic:\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY constexpr default_delete() noexcept = default;\n#else\n  _LIBCPP_INLINE_VISIBILITY default_delete() {}\n#endif\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  default_delete(const default_delete<_Up[]>&,\n                 typename _EnableIfConvertible<_Up>::type* = 0) _NOEXCEPT {}\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  typename _EnableIfConvertible<_Up>::type\n  operator()(_Up* __ptr) const _NOEXCEPT {\n    static_assert(sizeof(_Tp) > 0,\n                  \"default_delete can not delete incomplete type\");\n    static_assert(!is_void<_Tp>::value,\n                  \"default_delete can not delete void type\");\n    delete[] __ptr;\n  }\n};\n\n\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Deleter>\nstruct __unique_ptr_deleter_sfinae {\n  static_assert(!is_reference<_Deleter>::value, \"incorrect specialization\");\n  typedef const _Deleter& __lval_ref_type;\n  typedef _Deleter&& __good_rval_ref_type;\n  typedef true_type __enable_rval_overload;\n};\n\ntemplate <class _Deleter>\nstruct __unique_ptr_deleter_sfinae<_Deleter const&> {\n  typedef const _Deleter& __lval_ref_type;\n  typedef const _Deleter&& __bad_rval_ref_type;\n  typedef false_type __enable_rval_overload;\n};\n\ntemplate <class _Deleter>\nstruct __unique_ptr_deleter_sfinae<_Deleter&> {\n  typedef _Deleter& __lval_ref_type;\n  typedef _Deleter&& __bad_rval_ref_type;\n  typedef false_type __enable_rval_overload;\n};\n#endif // !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TEMPLATE_VIS unique_ptr {\npublic:\n  typedef _Tp element_type;\n  typedef _Dp deleter_type;\n  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\n\n  static_assert(!is_rvalue_reference<deleter_type>::value,\n                \"the specified deleter type cannot be an rvalue reference\");\n\nprivate:\n  __compressed_pair<pointer, deleter_type> __ptr_;\n\n  struct __nat { int __for_bool_; };\n\n#ifndef _LIBCPP_CXX03_LANG\n  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;\n\n  template <bool _Dummy>\n  using _LValRefType =\n      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;\n\n  template <bool _Dummy>\n  using _GoodRValRefType =\n      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;\n\n  template <bool _Dummy>\n  using _BadRValRefType =\n      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;\n\n  template <bool _Dummy, class _Deleter = typename __dependent_type<\n                             __identity<deleter_type>, _Dummy>::type>\n  using _EnableIfDeleterDefaultConstructible =\n      typename enable_if<is_default_constructible<_Deleter>::value &&\n                         !is_pointer<_Deleter>::value>::type;\n\n  template <class _ArgType>\n  using _EnableIfDeleterConstructible =\n      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;\n\n  template <class _UPtr, class _Up>\n  using _EnableIfMoveConvertible = typename enable_if<\n      is_convertible<typename _UPtr::pointer, pointer>::value &&\n      !is_array<_Up>::value\n  >::type;\n\n  template <class _UDel>\n  using _EnableIfDeleterConvertible = typename enable_if<\n      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||\n      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)\n    >::type;\n\n  template <class _UDel>\n  using _EnableIfDeleterAssignable = typename enable_if<\n      is_assignable<_Dp&, _UDel&&>::value\n    >::type;\n\npublic:\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterDefaultConstructible<_Dummy>>\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr unique_ptr() noexcept : __ptr_(pointer()) {}\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterDefaultConstructible<_Dummy>>\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) {}\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterDefaultConstructible<_Dummy>>\n  _LIBCPP_INLINE_VISIBILITY\n  explicit unique_ptr(pointer __p) noexcept : __ptr_(__p) {}\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(pointer __p, _LValRefType<_Dummy> __d) noexcept\n      : __ptr_(__p, __d) {}\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) noexcept\n      : __ptr_(__p, _VSTD::move(__d)) {\n    static_assert(!is_reference<deleter_type>::value,\n                  \"rvalue deleter bound to reference\");\n  }\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d) = delete;\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(unique_ptr&& __u) noexcept\n      : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {\n  }\n\n  template <class _Up, class _Ep,\n      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,\n      class = _EnableIfDeleterConvertible<_Ep>\n  >\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n      : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(auto_ptr<_Up>&& __p,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value &&\n                                    is_same<_Dp, default_delete<_Tp>>::value,\n                                __nat>::type = __nat()) _NOEXCEPT\n      : __ptr_(__p.release()) {}\n#endif\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT {\n    reset(__u.release());\n    __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n    return *this;\n  }\n\n  template <class _Up, class _Ep,\n      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,\n      class = _EnableIfDeleterAssignable<_Ep>\n  >\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT {\n    reset(__u.release());\n    __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n    return *this;\n  }\n\n#else  // _LIBCPP_CXX03_LANG\nprivate:\n  unique_ptr(unique_ptr&);\n  template <class _Up, class _Ep> unique_ptr(unique_ptr<_Up, _Ep>&);\n\n  unique_ptr& operator=(unique_ptr&);\n  template <class _Up, class _Ep> unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n\npublic:\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr() : __ptr_(pointer())\n  {\n    static_assert(!is_pointer<deleter_type>::value,\n                  \"unique_ptr constructed with null function pointer deleter\");\n    static_assert(is_default_constructible<deleter_type>::value,\n                  \"unique_ptr::deleter_type is not default constructible\");\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(nullptr_t) : __ptr_(pointer())\n  {\n    static_assert(!is_pointer<deleter_type>::value,\n                  \"unique_ptr constructed with null function pointer deleter\");\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  explicit unique_ptr(pointer __p)\n      : __ptr_(_VSTD::move(__p)) {\n    static_assert(!is_pointer<deleter_type>::value,\n                  \"unique_ptr constructed with null function pointer deleter\");\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  operator __rv<unique_ptr>() {\n    return __rv<unique_ptr>(*this);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(__rv<unique_ptr> __u)\n      : __ptr_(__u->release(),\n               _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n  template <class _Up, class _Ep>\n  _LIBCPP_INLINE_VISIBILITY\n  typename enable_if<\n      !is_array<_Up>::value &&\n          is_convertible<typename unique_ptr<_Up, _Ep>::pointer,\n                         pointer>::value &&\n          is_assignable<deleter_type&, _Ep&>::value,\n      unique_ptr&>::type\n  operator=(unique_ptr<_Up, _Ep> __u) {\n    reset(__u.release());\n    __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n    return *this;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(pointer __p, deleter_type __d)\n      : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n#endif // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n      typename enable_if<is_convertible<_Up*, _Tp*>::value &&\n                             is_same<_Dp, default_delete<_Tp> >::value,\n                         unique_ptr&>::type\n      operator=(auto_ptr<_Up> __p) {\n    reset(__p.release());\n    return *this;\n  }\n#endif\n\n  _LIBCPP_INLINE_VISIBILITY\n  ~unique_ptr() { reset(); }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr& operator=(nullptr_t) _NOEXCEPT {\n    reset();\n    return *this;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  typename add_lvalue_reference<_Tp>::type\n  operator*() const {\n    return *__ptr_.first();\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  pointer operator->() const _NOEXCEPT {\n    return __ptr_.first();\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  pointer get() const _NOEXCEPT {\n    return __ptr_.first();\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  deleter_type& get_deleter() _NOEXCEPT {\n    return __ptr_.second();\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  const deleter_type& get_deleter() const _NOEXCEPT {\n    return __ptr_.second();\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {\n    return __ptr_.first() != nullptr;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  pointer release() _NOEXCEPT {\n    pointer __t = __ptr_.first();\n    __ptr_.first() = pointer();\n    return __t;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void reset(pointer __p = pointer()) _NOEXCEPT {\n    pointer __tmp = __ptr_.first();\n    __ptr_.first() = __p;\n    if (__tmp)\n      __ptr_.second()(__tmp);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void swap(unique_ptr& __u) _NOEXCEPT {\n    __ptr_.swap(__u.__ptr_);\n  }\n};\n\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TEMPLATE_VIS unique_ptr<_Tp[], _Dp> {\npublic:\n  typedef _Tp element_type;\n  typedef _Dp deleter_type;\n  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\n\nprivate:\n  __compressed_pair<pointer, deleter_type> __ptr_;\n\n  template <class _From>\n  struct _CheckArrayPointerConversion : is_same<_From, pointer> {};\n\n  template <class _FromElem>\n  struct _CheckArrayPointerConversion<_FromElem*>\n      : integral_constant<bool,\n          is_same<_FromElem*, pointer>::value ||\n            (is_same<pointer, element_type*>::value &&\n             is_convertible<_FromElem(*)[], element_type(*)[]>::value)\n      >\n  {};\n\n#ifndef _LIBCPP_CXX03_LANG\n  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;\n\n  template <bool _Dummy>\n  using _LValRefType =\n      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;\n\n  template <bool _Dummy>\n  using _GoodRValRefType =\n      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;\n\n  template <bool _Dummy>\n  using _BadRValRefType =\n      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;\n\n  template <bool _Dummy, class _Deleter = typename __dependent_type<\n                             __identity<deleter_type>, _Dummy>::type>\n  using _EnableIfDeleterDefaultConstructible =\n      typename enable_if<is_default_constructible<_Deleter>::value &&\n                         !is_pointer<_Deleter>::value>::type;\n\n  template <class _ArgType>\n  using _EnableIfDeleterConstructible =\n      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;\n\n  template <class _Pp>\n  using _EnableIfPointerConvertible = typename enable_if<\n      _CheckArrayPointerConversion<_Pp>::value\n  >::type;\n\n  template <class _UPtr, class _Up,\n        class _ElemT = typename _UPtr::element_type>\n  using _EnableIfMoveConvertible = typename enable_if<\n      is_array<_Up>::value &&\n      is_same<pointer, element_type*>::value &&\n      is_same<typename _UPtr::pointer, _ElemT*>::value &&\n      is_convertible<_ElemT(*)[], element_type(*)[]>::value\n    >::type;\n\n  template <class _UDel>\n  using _EnableIfDeleterConvertible = typename enable_if<\n      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||\n      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)\n    >::type;\n\n  template <class _UDel>\n  using _EnableIfDeleterAssignable = typename enable_if<\n      is_assignable<_Dp&, _UDel&&>::value\n    >::type;\n\npublic:\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterDefaultConstructible<_Dummy>>\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr unique_ptr() noexcept : __ptr_(pointer()) {}\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterDefaultConstructible<_Dummy>>\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) {}\n\n  template <class _Pp, bool _Dummy = true,\n            class = _EnableIfDeleterDefaultConstructible<_Dummy>,\n            class = _EnableIfPointerConvertible<_Pp>>\n  _LIBCPP_INLINE_VISIBILITY\n  explicit unique_ptr(_Pp __p) noexcept\n      : __ptr_(__p) {}\n\n  template <class _Pp, bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>,\n            class = _EnableIfPointerConvertible<_Pp>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(_Pp __p, _LValRefType<_Dummy> __d) noexcept\n      : __ptr_(__p, __d) {}\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(nullptr_t, _LValRefType<_Dummy> __d) noexcept\n      : __ptr_(nullptr, __d) {}\n\n  template <class _Pp, bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>,\n            class = _EnableIfPointerConvertible<_Pp>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) noexcept\n      : __ptr_(__p, _VSTD::move(__d)) {\n    static_assert(!is_reference<deleter_type>::value,\n                  \"rvalue deleter bound to reference\");\n  }\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) noexcept\n      : __ptr_(nullptr, _VSTD::move(__d)) {\n    static_assert(!is_reference<deleter_type>::value,\n                  \"rvalue deleter bound to reference\");\n  }\n\n  template <class _Pp, bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>,\n            class = _EnableIfPointerConvertible<_Pp>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(_Pp __p, _BadRValRefType<_Dummy> __d) = delete;\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(unique_ptr&& __u) noexcept\n      : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr& operator=(unique_ptr&& __u) noexcept {\n    reset(__u.release());\n    __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n    return *this;\n  }\n\n  template <class _Up, class _Ep,\n      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,\n      class = _EnableIfDeleterConvertible<_Ep>\n  >\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept\n      : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {\n  }\n\n  template <class _Up, class _Ep,\n      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,\n      class = _EnableIfDeleterAssignable<_Ep>\n  >\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr&\n  operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {\n    reset(__u.release());\n    __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n    return *this;\n  }\n\n#else // _LIBCPP_CXX03_LANG\nprivate:\n  template <class _Up> explicit unique_ptr(_Up);\n\n  unique_ptr(unique_ptr&);\n  template <class _Up> unique_ptr(unique_ptr<_Up>&);\n\n  unique_ptr& operator=(unique_ptr&);\n  template <class _Up> unique_ptr& operator=(unique_ptr<_Up>&);\n\n  template <class _Up>\n  unique_ptr(_Up __u,\n             typename conditional<\n                 is_reference<deleter_type>::value, deleter_type,\n                 typename add_lvalue_reference<const deleter_type>::type>::type,\n             typename enable_if<is_convertible<_Up, pointer>::value,\n                                __nat>::type = __nat());\npublic:\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr() : __ptr_(pointer()) {\n    static_assert(!is_pointer<deleter_type>::value,\n                  \"unique_ptr constructed with null function pointer deleter\");\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(nullptr_t) : __ptr_(pointer()) {\n    static_assert(!is_pointer<deleter_type>::value,\n                  \"unique_ptr constructed with null function pointer deleter\");\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  explicit unique_ptr(pointer __p) : __ptr_(__p) {\n    static_assert(!is_pointer<deleter_type>::value,\n                  \"unique_ptr constructed with null function pointer deleter\");\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(pointer __p, deleter_type __d)\n      : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(nullptr_t, deleter_type __d)\n      : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  operator __rv<unique_ptr>() {\n    return __rv<unique_ptr>(*this);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(__rv<unique_ptr> __u)\n      : __ptr_(__u->release(),\n               _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr& operator=(__rv<unique_ptr> __u) {\n    reset(__u->release());\n    __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n    return *this;\n  }\n\n#endif // _LIBCPP_CXX03_LANG\n\npublic:\n  _LIBCPP_INLINE_VISIBILITY\n  ~unique_ptr() { reset(); }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr& operator=(nullptr_t) _NOEXCEPT {\n    reset();\n    return *this;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  typename add_lvalue_reference<_Tp>::type\n  operator[](size_t __i) const {\n    return __ptr_.first()[__i];\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  pointer get() const _NOEXCEPT {\n    return __ptr_.first();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  deleter_type& get_deleter() _NOEXCEPT {\n    return __ptr_.second();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  const deleter_type& get_deleter() const _NOEXCEPT {\n    return __ptr_.second();\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {\n    return __ptr_.first() != nullptr;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  pointer release() _NOEXCEPT {\n    pointer __t = __ptr_.first();\n    __ptr_.first() = pointer();\n    return __t;\n  }\n\n  template <class _Pp>\n  _LIBCPP_INLINE_VISIBILITY\n  typename enable_if<\n      _CheckArrayPointerConversion<_Pp>::value\n  >::type\n  reset(_Pp __p) _NOEXCEPT {\n    pointer __tmp = __ptr_.first();\n    __ptr_.first() = __p;\n    if (__tmp)\n      __ptr_.second()(__tmp);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void reset(nullptr_t = nullptr) _NOEXCEPT {\n    pointer __tmp = __ptr_.first();\n    __ptr_.first() = nullptr;\n    if (__tmp)\n      __ptr_.second()(__tmp);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void swap(unique_ptr& __u) _NOEXCEPT {\n    __ptr_.swap(__u.__ptr_);\n  }\n\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Dp>::value,\n    void\n>::type\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, class _Dp>\n#ifdef _LIBCPP_CXX03_LANG\nstruct _LIBCPP_TEMPLATE_VIS hash<unique_ptr<_Tp, _Dp> >\n#else\nstruct _LIBCPP_TEMPLATE_VIS hash<__enable_hash_helper<\n    unique_ptr<_Tp, _Dp>, typename unique_ptr<_Tp, _Dp>::pointer>>\n#endif\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t __size_;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < __size_; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++__size_;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : __size_(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, (void) ++__r)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy_at(_Tp* __loc) {\n    _LIBCPP_ASSERT(__loc, \"null pointer given to destroy_at\");\n    __loc->~_Tp();\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy(_ForwardIterator __first, _ForwardIterator __last) {\n    for (; __first != __last; ++__first)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator destroy_n(_ForwardIterator __first, _Size __n) {\n    for (; __n > 0; (void)++__first, --__n)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_default_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_value_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _InputIt, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIt uninitialized_move(_InputIt __first, _InputIt __last, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __first != __last; (void)++__idx, ++__first)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _InputIt, class _Size, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIt, _ForwardIt>\nuninitialized_move_n(_InputIt __first, _Size __n, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; ++__idx, (void)++__first, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return {__first, __idx};\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\n\n#endif // _LIBCPP_STD_VER > 14\n\n// NOTE: Relaxed and acq/rel atomics (for increment and decrement respectively)\n// should be sufficient for thread safety.\n// See https://bugs.llvm.org/show_bug.cgi?id=22803\n#if defined(__clang__) && __has_builtin(__atomic_add_fetch)          \\\n                       && defined(__ATOMIC_RELAXED)                  \\\n                       && defined(__ATOMIC_ACQ_REL)\n#   define _LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT\n#elif !defined(__clang__) && defined(_GNUC_VER) && _GNUC_VER >= 407\n#   define _LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _Tp\n__libcpp_atomic_refcount_increment(_Tp& __t) _NOEXCEPT\n{\n#if defined(_LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT) && !defined(_LIBCPP_HAS_NO_THREADS)\n    return __atomic_add_fetch(&__t, 1, __ATOMIC_RELAXED);\n#else\n    return __t += 1;\n#endif\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _Tp\n__libcpp_atomic_refcount_decrement(_Tp& __t) _NOEXCEPT\n{\n#if defined(_LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT) && !defined(_LIBCPP_HAS_NO_THREADS)\n    return __atomic_add_fetch(&__t, -1, __ATOMIC_ACQ_REL);\n#else\n    return __t -= 1;\n#endif\n}\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\n_LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY\nvoid __throw_bad_weak_ptr()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_weak_ptr();\n#else\n    _VSTD::abort();\n#endif\n}\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n#if defined(_LIBCPP_BUILDING_LIBRARY) && \\\n    defined(_LIBCPP_DEPRECATED_ABI_LEGACY_LIBRARY_DEFINITIONS_FOR_INLINE_FUNCTIONS)\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    void __add_shared() _NOEXCEPT {\n      __libcpp_atomic_refcount_increment(__shared_owners_);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    bool __release_shared() _NOEXCEPT {\n      if (__libcpp_atomic_refcount_decrement(__shared_owners_) == -1) {\n        __on_zero_shared();\n        return true;\n      }\n      return false;\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {\n        return __libcpp_relaxed_load(&__shared_owners_) + 1;\n    }\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n#if defined(_LIBCPP_BUILDING_LIBRARY) && \\\n    defined(_LIBCPP_DEPRECATED_ABI_LEGACY_LIBRARY_DEFINITIONS_FOR_INLINE_FUNCTIONS)\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    void __add_shared() _NOEXCEPT {\n      __shared_count::__add_shared();\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    void __add_weak() _NOEXCEPT {\n      __libcpp_atomic_refcount_increment(__shared_weak_owners_);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    void __release_shared() _NOEXCEPT {\n      if (__shared_count::__release_shared())\n        __release_weak();\n    }\n#endif\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? _VSTD::addressof(__data_.first().second()) : nullptr;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n\n    _Al __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return _VSTD::addressof(__data_.second());}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n    _Al __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\nstruct __shared_ptr_dummy_rebind_allocator_type;\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<__shared_ptr_dummy_rebind_allocator_type>\n{\npublic:\n    template <class _Other>\n    struct rebind\n    {\n        typedef allocator<_Other> other;\n    };\n};\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS shared_ptr\n{\npublic:\n    typedef _Tp element_type;\n\n#if _LIBCPP_STD_VER > 14\n    typedef weak_ptr<_Tp> weak_type;\n#endif\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp>\n        explicit shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp>\n        shared_ptr(_Yp* __p, _Dp __d,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp, class _Alloc>\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY  shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type= __nat());\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#else\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp> __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#endif\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp>&& __r);\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#endif\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const _NOEXCEPT\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const _NOEXCEPT\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return static_cast<_Dp*>(__cntrl_\n                    ? const_cast<void *>(__cntrl_->__get_deleter(typeid(_Dp)))\n                      : nullptr);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    template <class _Yp, bool = is_function<_Yp>::value>\n        struct __shared_ptr_default_allocator\n        {\n            typedef allocator<_Yp> type;\n        };\n\n    template <class _Yp>\n        struct __shared_ptr_default_allocator<_Yp, true>\n        {\n            typedef allocator<__shared_ptr_dummy_rebind_allocator_type> type;\n        };\n\n    template <class _Yp, class _OrigPtr>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if<is_convertible<_OrigPtr*,\n                                          const enable_shared_from_this<_Yp>*\n        >::value,\n            void>::type\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e,\n                           _OrigPtr* __ptr) _NOEXCEPT\n        {\n            typedef typename remove_cv<_Yp>::type _RawYp;\n            if (__e && __e->__weak_this_.expired())\n            {\n                __e->__weak_this_ = shared_ptr<_RawYp>(*this,\n                    const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));\n            }\n        }\n\n    _LIBCPP_INLINE_VISIBILITY void __enable_weak_this(...) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n};\n\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, _AllocT > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), _AllocT());\n    __hold.release();\n    __enable_weak_this(__p, __p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef typename __shared_ptr_default_allocator<_Tp>::type _AllocT;\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _AllocT > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\ntemplate<class _Tp>\ntemplate<class _Yp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,\n#endif\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get(), __r.get());\n    __r.release();\n}\n#endif\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                !is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), _AllocT());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;\n        typedef __shared_ptr_pointer<_Yp*,\n                                     reference_wrapper<typename remove_reference<_Dp>::type>,\n                                     _AllocT > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), _AllocT());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    static_assert( is_constructible<_Tp, _Args...>::value, \"Can't construct object in make_shared\" );\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    static_assert( is_constructible<_Tp, _Args...>::value, \"Can't construct object in allocate_shared\" );\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    static_assert((is_constructible<_Tp>::value), \"Can't construct object in make_shared\" );\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    static_assert((is_constructible<_Tp, _A0>::value), \"Can't construct object in make_shared\" );\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    static_assert((is_constructible<_Tp, _A0, _A1>::value), \"Can't construct object in make_shared\" );\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    static_assert((is_constructible<_Tp, _A0, _A1, _A2>::value), \"Can't construct object in make_shared\" );\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    static_assert((is_constructible<_Tp>::value), \"Can't construct object in allocate_shared\" );\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    static_assert((is_constructible<_Tp, _A0>::value), \"Can't construct object in allocate_shared\" );\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    static_assert((is_constructible<_Tp, _A0, _A1>::value), \"Can't construct object in allocate_shared\" );\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    static_assert((is_constructible<_Tp, _A0, _A1, _A2>::value), \"Can't construct object in allocate_shared\" );\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n#endif\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,\n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n#endif\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,\n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n#if _LIBCPP_STD_VER <= 11\n    typedef typename common_type<_Tp*, _Up*>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n#else\n    return less<>()(__x.get(), __y.get());\n#endif\n\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const _NOEXCEPT\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const _NOEXCEPT\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n        __throw_bad_weak_ptr();\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp = void> struct owner_less;\n#else\ntemplate <class _Tp> struct owner_less;\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<void>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    typedef void is_transparent;\n};\n#endif\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<_Tp> weak_from_this() _NOEXCEPT\n       { return __weak_this_; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<const _Tp> weak_from_this() const _NOEXCEPT\n        { return __weak_this_; }\n#endif // _LIBCPP_STD_VER > 14\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\n__sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    shared_ptr<_Tp> __temp;\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        _VSTD::swap(__temp, *__p);\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    _VSTD::swap(__temp, *__v);\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\n//enum class\n#if defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE)\n# ifndef _LIBCPP_CXX03_LANG\nenum class pointer_safety : unsigned char {\n  relaxed,\n  preferred,\n  strict\n};\n# endif\n#else\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety() : __v_() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n#endif\n\n#if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) && \\\n    defined(_LIBCPP_BUILDING_LIBRARY)\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n#else\n// This function is only offered in C++03 under ABI v1.\n# if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) || !defined(_LIBCPP_CXX03_LANG)\ninline _LIBCPP_INLINE_VISIBILITY\npointer_safety get_pointer_safety() _NOEXCEPT {\n  return pointer_safety::relaxed;\n}\n# endif\n#endif\n\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n// --- Helper for container swap --\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    __swap_allocator(__a1, __a2,\n      integral_constant<bool, _VSTD::allocator_traits<_Alloc>::propagate_on_container_swap::value>());\n}\n\ntemplate <typename _Alloc>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    using _VSTD::swap;\n    swap(__a1, __a2);\n}\n\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc &, _Alloc &, false_type) _NOEXCEPT {}\n\ntemplate <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >\nstruct __noexcept_move_assign_container : public integral_constant<bool,\n    _Traits::propagate_on_container_move_assignment::value\n#if _LIBCPP_STD_VER > 14\n        || _Traits::is_always_equal::value\n#else\n        && is_nothrow_move_assignable<_Alloc>::value\n#endif\n    > {};\n\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class _Tp, class _Alloc>\nstruct __temp_value {\n    typedef allocator_traits<_Alloc> _Traits;\n\n    typename aligned_storage<sizeof(_Tp), _LIBCPP_ALIGNOF(_Tp)>::type __v;\n    _Alloc &__a;\n\n    _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }\n    _Tp &   get() { return *__addr(); }\n\n    template<class... _Args>\n    _LIBCPP_NO_CFI\n    __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc) {\n      _Traits::construct(__a, reinterpret_cast<_Tp*>(addressof(__v)),\n                         _VSTD::forward<_Args>(__args)...);\n    }\n\n    ~__temp_value() { _Traits::destroy(__a, __addr()); }\n    };\n#endif\n\ntemplate<typename _Alloc, typename = void, typename = void>\nstruct __is_allocator : false_type {};\n\ntemplate<typename _Alloc>\nstruct __is_allocator<_Alloc,\n       typename __void_t<typename _Alloc::value_type>::type,\n       typename __void_t<decltype(_VSTD::declval<_Alloc&>().allocate(size_t(0)))>::type\n     >\n   : true_type {};\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_MEMORY\n","// -*- C++ -*-\n//===-------------------------- utility -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UTILITY\n#define _LIBCPP_UTILITY\n\n/*\n    utility synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class T>\n    void\n    swap(T& a, T& b);\n\nnamespace rel_ops\n{\n    template<class T> bool operator!=(const T&, const T&);\n    template<class T> bool operator> (const T&, const T&);\n    template<class T> bool operator<=(const T&, const T&);\n    template<class T> bool operator>=(const T&, const T&);\n}\n\ntemplate<class T>\nvoid\nswap(T& a, T& b) noexcept(is_nothrow_move_constructible<T>::value &&\n                          is_nothrow_move_assignable<T>::value);\n\ntemplate <class T, size_t N>\nvoid\nswap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));\n\ntemplate <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;  // constexpr in C++14\ntemplate <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept; // constexpr in C++14\n\ntemplate <class T> typename remove_reference<T>::type&& move(T&&) noexcept;      // constexpr in C++14\n\ntemplate <class T>\n    typename conditional\n    <\n        !is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,\n        const T&,\n        T&&\n    >::type\n    move_if_noexcept(T& x) noexcept; // constexpr in C++14\n\ntemplate <class T> constexpr add_const_t<T>& as_const(T& t) noexcept;      // C++17\ntemplate <class T>                      void as_const(const T&&) = delete; // C++17\n\ntemplate <class T> typename add_rvalue_reference<T>::type declval() noexcept;\n\ntemplate <class T1, class T2>\nstruct pair\n{\n    typedef T1 first_type;\n    typedef T2 second_type;\n\n    T1 first;\n    T2 second;\n\n    pair(const pair&) = default;\n    pair(pair&&) = default;\n    constexpr pair();\n    pair(const T1& x, const T2& y);                          // constexpr in C++14\n    template <class U, class V> pair(U&& x, V&& y);          // constexpr in C++14\n    template <class U, class V> pair(const pair<U, V>& p);   // constexpr in C++14\n    template <class U, class V> pair(pair<U, V>&& p);        // constexpr in C++14\n    template <class... Args1, class... Args2>\n        pair(piecewise_construct_t, tuple<Args1...> first_args,\n             tuple<Args2...> second_args);\n\n    template <class U, class V> pair& operator=(const pair<U, V>& p);\n    pair& operator=(pair&& p) noexcept(is_nothrow_move_assignable<T1>::value &&\n                                       is_nothrow_move_assignable<T2>::value);\n    template <class U, class V> pair& operator=(pair<U, V>&& p);\n\n    void swap(pair& p) noexcept(is_nothrow_swappable_v<T1> &&\n                                is_nothrow_swappable_v<T2>);\n};\n\ntemplate <class T1, class T2> bool operator==(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator< (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator> (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\n\ntemplate <class T1, class T2> pair<V1, V2> make_pair(T1&&, T2&&);   // constexpr in C++14\ntemplate <class T1, class T2>\nvoid\nswap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));\n\nstruct piecewise_construct_t { };\ninline constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n\ntemplate <class T> struct tuple_size;\ntemplate <size_t I, class T> class tuple_element;\n\ntemplate <class T1, class T2> struct tuple_size<pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<0, pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<1, pair<T1, T2> >;\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&\n    get(pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename tuple_element<I, pair<T1, T2> >::type&\n    get(const pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&&\n    get(pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename tuple_element<I, pair<T1, T2> >::type&&\n    get(const pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(pair<T1, T2>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1& get(const pair<T1, T2>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr T1&& get(pair<T1, T2>&&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1&& get(const pair<T1, T2>&&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(pair<T2, T1>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1& get(const pair<T2, T1>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr T1&& get(pair<T2, T1>&&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1&& get(const pair<T2, T1>&&) noexcept; // C++14\n\n// C++14\n\ntemplate<class T, T... I>\nstruct integer_sequence\n{\n    typedef T value_type;\n\n    static constexpr size_t size() noexcept;\n};\n\ntemplate<size_t... I>\n  using index_sequence = integer_sequence<size_t, I...>;\n\ntemplate<class T, T N>\n  using make_integer_sequence = integer_sequence<T, 0, 1, ..., N-1>;\ntemplate<size_t N>\n  using make_index_sequence = make_integer_sequence<size_t, N>;\n\ntemplate<class... T>\n  using index_sequence_for = make_index_sequence<sizeof...(T)>;\n\ntemplate<class T, class U=T>\n    T exchange(T& obj, U&& new_value);\n\n// 20.2.7, in-place construction // C++17\nstruct in_place_t {\n  explicit in_place_t() = default;\n};\ninline constexpr in_place_t in_place{};\ntemplate <class T>\n  struct in_place_type_t {\n    explicit in_place_type_t() = default;\n  };\ntemplate <class T>\n  inline constexpr in_place_type_t<T> in_place_type{};\ntemplate <size_t I>\n  struct in_place_index_t {\n    explicit in_place_index_t() = default;\n  };\ntemplate <size_t I>\n  inline constexpr in_place_index_t<I> in_place_index{};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <type_traits>\n#include <initializer_list>\n#include <cstddef>\n#include <cstring>\n#include <cstdint>\n#include <version>\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nnamespace rel_ops\n{\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _Tp& __x, const _Tp& __y)\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x < __y);\n}\n\n}  // rel_ops\n\n// swap_ranges\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator2\nswap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)\n{\n    for(; __first1 != __last1; ++__first1, (void) ++__first2)\n        swap(*__first1, *__first2);\n    return __first2;\n}\n\n// forward declared in <type_traits>\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Tp>::value\n>::type\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value)\n{\n    _VSTD::swap_ranges(__a, __a + _Np, __b);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n#ifndef _LIBCPP_CXX03_LANG\ntypename conditional\n<\n    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,\n    const _Tp&,\n    _Tp&&\n>::type\n#else  // _LIBCPP_CXX03_LANG\nconst _Tp&\n#endif\nmove_if_noexcept(_Tp& __x) _NOEXCEPT\n{\n    return _VSTD::move(__x);\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp> constexpr add_const_t<_Tp>& as_const(_Tp& __t) noexcept { return __t; }\ntemplate <class _Tp>                        void as_const(const _Tp&&) = delete;\n#endif\n\nstruct _LIBCPP_TEMPLATE_VIS piecewise_construct_t { };\n#if defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_LIBRARY)\nextern _LIBCPP_EXPORTED_FROM_ABI const piecewise_construct_t piecewise_construct;// = piecewise_construct_t();\n#else\n/* _LIBCPP_INLINE_VAR */ constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n#endif\n\n#if defined(_LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR)\ntemplate <class, class>\nstruct __non_trivially_copyable_base {\n  _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n  __non_trivially_copyable_base() _NOEXCEPT {}\n  _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n  __non_trivially_copyable_base(__non_trivially_copyable_base const&) _NOEXCEPT {}\n};\n#endif\n\ntemplate <class _T1, class _T2>\nstruct _LIBCPP_TEMPLATE_VIS pair\n#if defined(_LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR)\n: private __non_trivially_copyable_base<_T1, _T2>\n#endif\n{\n    typedef _T1 first_type;\n    typedef _T2 second_type;\n\n    _T1 first;\n    _T2 second;\n\n#if !defined(_LIBCPP_CXX03_LANG)\n    pair(pair const&) = default;\n    pair(pair&&) = default;\n#else\n  // Use the implicitly declared copy constructor in C++03\n#endif\n\n#ifdef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    pair() : first(), second() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair(_T1 const& __t1, _T2 const& __t2) : first(__t1), second(__t2) {}\n\n    template <class _U1, class _U2>\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(pair const& __p) {\n        first = __p.first;\n        second = __p.second;\n        return *this;\n    }\n#else\n    template <bool _Val>\n    using _EnableB = typename enable_if<_Val, bool>::type;\n\n    struct _CheckArgs {\n      template <class _U1, class _U2>\n      static constexpr bool __enable_default() {\n          return is_default_constructible<_U1>::value\n              && is_default_constructible<_U2>::value;\n      }\n\n      template <class _U1, class _U2>\n      static constexpr bool __enable_explicit() {\n          return is_constructible<first_type, _U1>::value\n              && is_constructible<second_type, _U2>::value\n              && (!is_convertible<_U1, first_type>::value\n                  || !is_convertible<_U2, second_type>::value);\n      }\n\n      template <class _U1, class _U2>\n      static constexpr bool __enable_implicit() {\n          return is_constructible<first_type, _U1>::value\n              && is_constructible<second_type, _U2>::value\n              && is_convertible<_U1, first_type>::value\n              && is_convertible<_U2, second_type>::value;\n      }\n    };\n\n    template <bool _MaybeEnable>\n    using _CheckArgsDep = typename conditional<\n      _MaybeEnable, _CheckArgs, __check_tuple_constructor_fail>::type;\n\n    struct _CheckTupleLikeConstructor {\n        template <class _Tuple>\n        static constexpr bool __enable_implicit() {\n            return __tuple_convertible<_Tuple, pair>::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_explicit() {\n            return __tuple_constructible<_Tuple, pair>::value\n               && !__tuple_convertible<_Tuple, pair>::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_assign() {\n            return __tuple_assignable<_Tuple, pair>::value;\n        }\n    };\n\n    template <class _Tuple>\n    using _CheckTLC = typename conditional<\n        __tuple_like_with_size<_Tuple, 2>::value\n            && !is_same<typename decay<_Tuple>::type, pair>::value,\n        _CheckTupleLikeConstructor,\n        __check_tuple_constructor_fail\n    >::type;\n\n    template<bool _Dummy = true, _EnableB<\n            _CheckArgsDep<_Dummy>::template __enable_default<_T1, _T2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    pair() _NOEXCEPT_(is_nothrow_default_constructible<first_type>::value &&\n                      is_nothrow_default_constructible<second_type>::value)\n        : first(), second() {}\n\n    template <bool _Dummy = true, _EnableB<\n             _CheckArgsDep<_Dummy>::template __enable_explicit<_T1 const&, _T2 const&>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(_T1 const& __t1, _T2 const& __t2)\n        _NOEXCEPT_(is_nothrow_copy_constructible<first_type>::value &&\n                   is_nothrow_copy_constructible<second_type>::value)\n        : first(__t1), second(__t2) {}\n\n    template<bool _Dummy = true, _EnableB<\n            _CheckArgsDep<_Dummy>::template __enable_implicit<_T1 const&, _T2 const&>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(_T1 const& __t1, _T2 const& __t2)\n        _NOEXCEPT_(is_nothrow_copy_constructible<first_type>::value &&\n                   is_nothrow_copy_constructible<second_type>::value)\n        : first(__t1), second(__t2) {}\n\n    template<class _U1, class _U2, _EnableB<\n             _CheckArgs::template __enable_explicit<_U1, _U2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(_U1&& __u1, _U2&& __u2)\n        _NOEXCEPT_((is_nothrow_constructible<first_type, _U1>::value &&\n                    is_nothrow_constructible<second_type, _U2>::value))\n        : first(_VSTD::forward<_U1>(__u1)), second(_VSTD::forward<_U2>(__u2)) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_implicit<_U1, _U2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(_U1&& __u1, _U2&& __u2)\n        _NOEXCEPT_((is_nothrow_constructible<first_type, _U1>::value &&\n                    is_nothrow_constructible<second_type, _U2>::value))\n        : first(_VSTD::forward<_U1>(__u1)), second(_VSTD::forward<_U2>(__u2)) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_explicit<_U1 const&, _U2 const&>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(pair<_U1, _U2> const& __p)\n        _NOEXCEPT_((is_nothrow_constructible<first_type, _U1 const&>::value &&\n                    is_nothrow_constructible<second_type, _U2 const&>::value))\n        : first(__p.first), second(__p.second) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_implicit<_U1 const&, _U2 const&>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(pair<_U1, _U2> const& __p)\n        _NOEXCEPT_((is_nothrow_constructible<first_type, _U1 const&>::value &&\n                    is_nothrow_constructible<second_type, _U2 const&>::value))\n        : first(__p.first), second(__p.second) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_explicit<_U1, _U2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(pair<_U1, _U2>&&__p)\n        _NOEXCEPT_((is_nothrow_constructible<first_type, _U1&&>::value &&\n                    is_nothrow_constructible<second_type, _U2&&>::value))\n        : first(_VSTD::forward<_U1>(__p.first)), second(_VSTD::forward<_U2>(__p.second)) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_implicit<_U1, _U2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(pair<_U1, _U2>&& __p)\n        _NOEXCEPT_((is_nothrow_constructible<first_type, _U1&&>::value &&\n                    is_nothrow_constructible<second_type, _U2&&>::value))\n        : first(_VSTD::forward<_U1>(__p.first)), second(_VSTD::forward<_U2>(__p.second)) {}\n\n    template<class _Tuple, _EnableB<\n            _CheckTLC<_Tuple>::template __enable_explicit<_Tuple>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(_Tuple&& __p)\n        : first(_VSTD::get<0>(_VSTD::forward<_Tuple>(__p))),\n          second(_VSTD::get<1>(_VSTD::forward<_Tuple>(__p))) {}\n\n    template<class _Tuple, _EnableB<\n            _CheckTLC<_Tuple>::template __enable_implicit<_Tuple>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(_Tuple&& __p)\n        : first(_VSTD::get<0>(_VSTD::forward<_Tuple>(__p))),\n          second(_VSTD::get<1>(_VSTD::forward<_Tuple>(__p))) {}\n\n    template <class... _Args1, class... _Args2>\n    _LIBCPP_INLINE_VISIBILITY\n    pair(piecewise_construct_t __pc,\n         tuple<_Args1...> __first_args, tuple<_Args2...> __second_args)\n        _NOEXCEPT_((is_nothrow_constructible<first_type, _Args1...>::value &&\n                    is_nothrow_constructible<second_type, _Args2...>::value))\n        : pair(__pc, __first_args, __second_args,\n                typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                typename __make_tuple_indices<sizeof...(_Args2) >::type()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(typename conditional<\n                        is_copy_assignable<first_type>::value &&\n                        is_copy_assignable<second_type>::value,\n                    pair, __nat>::type const& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<first_type>::value &&\n                   is_nothrow_copy_assignable<second_type>::value)\n    {\n        first = __p.first;\n        second = __p.second;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(typename conditional<\n                        is_move_assignable<first_type>::value &&\n                        is_move_assignable<second_type>::value,\n                    pair, __nat>::type&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<first_type>::value &&\n                   is_nothrow_move_assignable<second_type>::value)\n    {\n        first = _VSTD::forward<first_type>(__p.first);\n        second = _VSTD::forward<second_type>(__p.second);\n        return *this;\n    }\n\n    template <class _Tuple, _EnableB<\n            _CheckTLC<_Tuple>::template __enable_assign<_Tuple>()\n     > = false>\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(_Tuple&& __p) {\n        first = _VSTD::get<0>(_VSTD::forward<_Tuple>(__p));\n        second = _VSTD::get<1>(_VSTD::forward<_Tuple>(__p));\n        return *this;\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    swap(pair& __p) _NOEXCEPT_(__is_nothrow_swappable<first_type>::value &&\n                               __is_nothrow_swappable<second_type>::value)\n    {\n        using _VSTD::swap;\n        swap(first,  __p.first);\n        swap(second, __p.second);\n    }\nprivate:\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t,\n             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n             __tuple_indices<_I1...>, __tuple_indices<_I2...>);\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_DEDUCTION_GUIDES\ntemplate<class _T1, class _T2>\npair(_T1, _T2) -> pair<_T1, _T2>;\n#endif // _LIBCPP_HAS_NO_DEDUCTION_GUIDES\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first == __y.first && __x.second == __y.second;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_swappable<_T1>::value &&\n    __is_swappable<_T2>::value,\n    void\n>::type\nswap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)\n                     _NOEXCEPT_((__is_nothrow_swappable<_T1>::value &&\n                                 __is_nothrow_swappable<_T2>::value))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Tp>\nstruct __unwrap_reference { typedef _Tp type; };\n\ntemplate <class _Tp>\nstruct __unwrap_reference<reference_wrapper<_Tp> > { typedef _Tp& type; };\n\n#if _LIBCPP_STD_VER > 17\ntemplate <class _Tp>\nstruct unwrap_reference : __unwrap_reference<_Tp> { };\n\ntemplate <class _Tp>\nstruct unwrap_ref_decay : unwrap_reference<typename decay<_Tp>::type> { };\n#endif // > C++17\n\ntemplate <class _Tp>\nstruct __unwrap_ref_decay\n#if _LIBCPP_STD_VER > 17\n    : unwrap_ref_decay<_Tp>\n#else\n    : __unwrap_reference<typename decay<_Tp>::type>\n#endif\n{ };\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>\nmake_pair(_T1&& __t1, _T2&& __t2)\n{\n    return pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>\n               (_VSTD::forward<_T1>(__t1), _VSTD::forward<_T2>(__t2));\n}\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1,_T2>\nmake_pair(_T1 __x, _T2 __y)\n{\n    return pair<_T1, _T2>(__x, __y);\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _T1, class _T2>\n  struct _LIBCPP_TEMPLATE_VIS tuple_size<pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <size_t _Ip, class _T1, class _T2>\nclass _LIBCPP_TEMPLATE_VIS tuple_element<_Ip, pair<_T1, _T2> >\n{\n    static_assert(_Ip < 2, \"Index out of bounds in std::tuple_element<std::pair<T1, T2>>\");\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TEMPLATE_VIS tuple_element<0, pair<_T1, _T2> >\n{\npublic:\n    typedef _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TEMPLATE_VIS tuple_element<1, pair<_T1, _T2> >\n{\npublic:\n    typedef _T2 type;\n};\n\ntemplate <size_t _Ip> struct __get_pair;\n\ntemplate <>\nstruct __get_pair<0>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T1>(__p.first);}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&&\n    get(const pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<const _T1>(__p.first);}\n#endif  // _LIBCPP_CXX03_LANG\n};\n\ntemplate <>\nstruct __get_pair<1>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T2>(__p.second);}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&&\n    get(const pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<const _T2>(__p.second);}\n#endif  // _LIBCPP_CXX03_LANG\n};\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(const pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(const pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T1, _T2> const& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const && get(pair<_T1, _T2> const&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T2, _T1>& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T2, _T1> const& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T2, _T1>&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const && get(pair<_T2, _T1> const&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp, _Tp... _Ip>\nstruct _LIBCPP_TEMPLATE_VIS integer_sequence\n{\n    typedef _Tp value_type;\n    static_assert( is_integral<_Tp>::value,\n                  \"std::integer_sequence can only be instantiated with an integral type\" );\n    static\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    size_t\n    size() noexcept { return sizeof...(_Ip); }\n};\n\ntemplate<size_t... _Ip>\n    using index_sequence = integer_sequence<size_t, _Ip...>;\n\n#if __has_builtin(__make_integer_seq) && !defined(_LIBCPP_TESTING_FALLBACK_MAKE_INTEGER_SEQUENCE)\n\ntemplate <class _Tp, _Tp _Ep>\nusing __make_integer_sequence = __make_integer_seq<integer_sequence, _Tp, _Ep>;\n\n#else\n\ntemplate<typename _Tp, _Tp _Np> using __make_integer_sequence_unchecked =\n  typename __detail::__make<_Np>::type::template __convert<integer_sequence, _Tp>;\n\ntemplate <class _Tp, _Tp _Ep>\nstruct __make_integer_sequence_checked\n{\n    static_assert(is_integral<_Tp>::value,\n                  \"std::make_integer_sequence can only be instantiated with an integral type\" );\n    static_assert(0 <= _Ep, \"std::make_integer_sequence must have a non-negative sequence length\");\n    // Workaround GCC bug by preventing bad installations when 0 <= _Ep\n    // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68929\n    typedef __make_integer_sequence_unchecked<_Tp, 0 <= _Ep ? _Ep : 0> type;\n};\n\ntemplate <class _Tp, _Tp _Ep>\nusing __make_integer_sequence = typename __make_integer_sequence_checked<_Tp, _Ep>::type;\n\n#endif\n\ntemplate<class _Tp, _Tp _Np>\n    using make_integer_sequence = __make_integer_sequence<_Tp, _Np>;\n\ntemplate<size_t _Np>\n    using make_index_sequence = make_integer_sequence<size_t, _Np>;\n\ntemplate<class... _Tp>\n    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;\n\n#endif  // _LIBCPP_STD_VER > 11\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _T1, class _T2 = _T1>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_T1 exchange(_T1& __obj, _T2 && __new_value)\n{\n    _T1 __old_value = _VSTD::move(__obj);\n    __obj = _VSTD::forward<_T2>(__new_value);\n    return __old_value;\n}\n#endif  // _LIBCPP_STD_VER > 11\n\n#if _LIBCPP_STD_VER > 14\n\nstruct _LIBCPP_TYPE_VIS in_place_t {\n    explicit in_place_t() = default;\n};\n_LIBCPP_INLINE_VAR constexpr in_place_t in_place{};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS in_place_type_t {\n    explicit in_place_type_t() = default;\n};\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR constexpr in_place_type_t<_Tp> in_place_type{};\n\ntemplate <size_t _Idx>\nstruct _LIBCPP_TYPE_VIS in_place_index_t {\n    explicit in_place_index_t() = default;\n};\ntemplate <size_t _Idx>\n_LIBCPP_INLINE_VAR constexpr in_place_index_t<_Idx> in_place_index{};\n\ntemplate <class _Tp> struct __is_inplace_type_imp : false_type {};\ntemplate <class _Tp> struct __is_inplace_type_imp<in_place_type_t<_Tp>> : true_type {};\n\ntemplate <class _Tp>\nusing __is_inplace_type = __is_inplace_type_imp<__uncvref_t<_Tp>>;\n\ntemplate <class _Tp> struct __is_inplace_index_imp : false_type {};\ntemplate <size_t _Idx> struct __is_inplace_index_imp<in_place_index_t<_Idx>> : true_type {};\n\ntemplate <class _Tp>\nusing __is_inplace_index = __is_inplace_index_imp<__uncvref_t<_Tp>>;\n\n#endif // _LIBCPP_STD_VER > 14\n\ntemplate <class _Arg, class _Result>\nstruct _LIBCPP_TEMPLATE_VIS unary_function\n{\n    typedef _Arg    argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_Size\n__loadword(const void* __p)\n{\n    _Size __r;\n    std::memcpy(&__r, __p, sizeof(__r));\n    return __r;\n}\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    inline _Size operator()(const void* __key, _Size __len)\n         _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK;\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)\n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = __loadword<_Size>(__data);\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n        _LIBCPP_FALLTHROUGH();\n    case 2:\n        __h ^= __data[1] << 8;\n        _LIBCPP_FALLTHROUGH();\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    inline _Size operator()(const void* __key, _Size __len)  _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK;\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v)\n     _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK\n  {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len)\n     _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK\n  {\n    if (__len > 8) {\n      const _Size __a = __loadword<_Size>(__s);\n      const _Size __b = __loadword<_Size>(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = __loadword<uint32_t>(__s);\n      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len)\n     _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK\n  {\n    const _Size __a = __loadword<_Size>(__s) * __k1;\n    const _Size __b = __loadword<_Size>(__s + 8);\n    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;\n    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b)\n        _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK\n  {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b)\n    _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK\n  {\n    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),\n                                         __loadword<_Size>(__s + 8),\n                                         __loadword<_Size>(__s + 16),\n                                         __loadword<_Size>(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len)\n    _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK\n  {\n    _Size __z = __loadword<_Size>(__s + 24);\n    _Size __a = __loadword<_Size>(__s) +\n                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);\n    __z += __loadword<_Size>(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)\n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = __loadword<_Size>(__s + __len - 40);\n  _Size __y = __loadword<_Size>(__s + __len - 16) +\n              __loadword<_Size>(__s + __len - 56);\n  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,\n                          __loadword<_Size>(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + __loadword<_Size>(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + __loadword<_Size>(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + __loadword<_Size>(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\nstruct _PairT {\n  size_t first;\n  size_t second;\n};\n\n_LIBCPP_INLINE_VISIBILITY\ninline size_t __hash_combine(size_t __lhs, size_t __rhs) _NOEXCEPT {\n    typedef __scalar_hash<_PairT> _HashT;\n    const _PairT __p = {__lhs, __rhs};\n    return _HashT()(__p);\n}\n\ntemplate<class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<bool>\n    : public unary_function<bool, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(bool __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<char>\n    : public unary_function<char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<signed char>\n    : public unary_function<signed char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(signed char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned char>\n    : public unary_function<unsigned char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<char16_t>\n    : public unary_function<char16_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char16_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<char32_t>\n    : public unary_function<char32_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char32_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<wchar_t>\n    : public unary_function<wchar_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(wchar_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<short>\n    : public unary_function<short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned short>\n    : public unary_function<unsigned short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<int>\n    : public unary_function<int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned int>\n    : public unary_function<unsigned int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<long>\n    : public unary_function<long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned long>\n    : public unary_function<unsigned long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<long long>\n    : public __scalar_hash<long long>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned long long>\n    : public __scalar_hash<unsigned long long>\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_INT128\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<__int128_t>\n    : public __scalar_hash<__int128_t>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<__uint128_t>\n    : public __scalar_hash<__uint128_t>\n{\n};\n\n#endif\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<float>\n    : public __scalar_hash<float>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(float __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0.0)\n           return 0;\n        return __scalar_hash<float>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<double>\n    : public __scalar_hash<double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0.0)\n           return 0;\n        return __scalar_hash<double>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<long double>\n    : public __scalar_hash<long double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n        if (__v == 0.0)\n            return 0;\n#if defined(__i386__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            } __s;\n        } __u;\n        __u.__s.__a = 0;\n        __u.__s.__b = 0;\n        __u.__s.__c = 0;\n        __u.__s.__d = 0;\n        __u.__t = __v;\n        return __u.__s.__a ^ __u.__s.__b ^ __u.__s.__c ^ __u.__s.__d;\n#elif defined(__x86_64__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            } __s;\n        } __u;\n        __u.__s.__a = 0;\n        __u.__s.__b = 0;\n        __u.__t = __v;\n        return __u.__s.__a ^ __u.__s.__b;\n#else\n        return __scalar_hash<long double>::operator()(__v);\n#endif\n    }\n};\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, bool = is_enum<_Tp>::value>\nstruct _LIBCPP_TEMPLATE_VIS __enum_hash\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        typedef typename underlying_type<_Tp>::type type;\n        return hash<type>{}(static_cast<type>(__v));\n    }\n};\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS __enum_hash<_Tp, false> {\n    __enum_hash() = delete;\n    __enum_hash(__enum_hash const&) = delete;\n    __enum_hash& operator=(__enum_hash const&) = delete;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash : public __enum_hash<_Tp>\n{\n};\n#endif\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<nullptr_t>\n  : public unary_function<nullptr_t, size_t>\n{\n  _LIBCPP_INLINE_VISIBILITY\n  size_t operator()(nullptr_t) const _NOEXCEPT {\n    return 662607004ull;\n  }\n};\n#endif\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Hash>\nusing __check_hash_requirements = integral_constant<bool,\n    is_copy_constructible<_Hash>::value &&\n    is_move_constructible<_Hash>::value &&\n    __invokable_r<size_t, _Hash, _Key const&>::value\n>;\n\ntemplate <class _Key, class _Hash = std::hash<_Key> >\nusing __has_enabled_hash = integral_constant<bool,\n    __check_hash_requirements<_Key, _Hash>::value &&\n    is_default_constructible<_Hash>::value\n>;\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Type, class>\nusing __enable_hash_helper_imp = _Type;\n\ntemplate <class _Type, class ..._Keys>\nusing __enable_hash_helper = __enable_hash_helper_imp<_Type,\n  typename enable_if<__all<__has_enabled_hash<_Keys>::value...>::value>::type\n>;\n#else\ntemplate <class _Type, class ...>\nusing __enable_hash_helper = _Type;\n#endif\n\n#endif // !_LIBCPP_CXX03_LANG\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UTILITY\n","// -*- C++ -*-\n//===-------------------------- unordered_set -----------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UNORDERED_SET\n#define _LIBCPP_UNORDERED_SET\n\n/*\n\n    unordered_set synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class Value, class Hash = hash<Value>, class Pred = equal_to<Value>,\n          class Alloc = allocator<Value>>\nclass unordered_set\n{\npublic:\n    // types\n    typedef Value                                                      key_type;\n    typedef key_type                                                   value_type;\n    typedef Hash                                                       hasher;\n    typedef Pred                                                       key_equal;\n    typedef Alloc                                                      allocator_type;\n    typedef value_type&                                                reference;\n    typedef const value_type&                                          const_reference;\n    typedef typename allocator_traits<allocator_type>::pointer         pointer;\n    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;\n    typedef typename allocator_traits<allocator_type>::size_type       size_type;\n    typedef typename allocator_traits<allocator_type>::difference_type difference_type;\n\n    typedef /unspecified/ iterator;\n    typedef /unspecified/ const_iterator;\n    typedef /unspecified/ local_iterator;\n    typedef /unspecified/ const_local_iterator;\n\n    typedef unspecified node_type unspecified;                            // C++17\n    typedef INSERT_RETURN_TYPE<iterator, node_type> insert_return_type;   // C++17\n\n    unordered_set()\n        noexcept(\n            is_nothrow_default_constructible<hasher>::value &&\n            is_nothrow_default_constructible<key_equal>::value &&\n            is_nothrow_default_constructible<allocator_type>::value);\n    explicit unordered_set(size_type n, const hasher& hf = hasher(),\n                           const key_equal& eql = key_equal(),\n                           const allocator_type& a = allocator_type());\n    template <class InputIterator>\n        unordered_set(InputIterator f, InputIterator l,\n                      size_type n = 0, const hasher& hf = hasher(),\n                      const key_equal& eql = key_equal(),\n                      const allocator_type& a = allocator_type());\n    explicit unordered_set(const allocator_type&);\n    unordered_set(const unordered_set&);\n    unordered_set(const unordered_set&, const Allocator&);\n    unordered_set(unordered_set&&)\n        noexcept(\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value &&\n            is_nothrow_move_constructible<allocator_type>::value);\n    unordered_set(unordered_set&&, const Allocator&);\n    unordered_set(initializer_list<value_type>, size_type n = 0,\n                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),\n                  const allocator_type& a = allocator_type());\n    unordered_set(size_type n, const allocator_type& a); // C++14\n    unordered_set(size_type n, const hasher& hf, const allocator_type& a); // C++14\n    template <class InputIterator>\n      unordered_set(InputIterator f, InputIterator l, size_type n, const allocator_type& a); // C++14\n    template <class InputIterator>\n      unordered_set(InputIterator f, InputIterator l, size_type n, \n                    const hasher& hf,  const allocator_type& a); // C++14\n    unordered_set(initializer_list<value_type> il, size_type n, const allocator_type& a); // C++14\n    unordered_set(initializer_list<value_type> il, size_type n,\n                  const hasher& hf,  const allocator_type& a); // C++14\n    ~unordered_set();\n    unordered_set& operator=(const unordered_set&);\n    unordered_set& operator=(unordered_set&&)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n    unordered_set& operator=(initializer_list<value_type>);\n\n    allocator_type get_allocator() const noexcept;\n\n    bool      empty() const noexcept;\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n\n    iterator       begin() noexcept;\n    iterator       end() noexcept;\n    const_iterator begin()  const noexcept;\n    const_iterator end()    const noexcept;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend()   const noexcept;\n\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator, bool> insert(const value_type& obj);\n    pair<iterator, bool> insert(value_type&& obj);\n    iterator insert(const_iterator hint, const value_type& obj);\n    iterator insert(const_iterator hint, value_type&& obj);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type>);\n\n    node_type extract(const_iterator position);                       // C++17\n    node_type extract(const key_type& x);                             // C++17\n    insert_return_type insert(node_type&& nh);                        // C++17\n    iterator           insert(const_iterator hint, node_type&& nh);   // C++17\n\n    iterator erase(const_iterator position);\n    iterator erase(iterator position);  // C++14\n    size_type erase(const key_type& k);\n    iterator erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    template<class H2, class P2>\n      void merge(unordered_set<Key, H2, P2, Allocator>& source);         // C++17\n    template<class H2, class P2>\n      void merge(unordered_set<Key, H2, P2, Allocator>&& source);        // C++17\n    template<class H2, class P2>\n      void merge(unordered_multiset<Key, H2, P2, Allocator>& source);    // C++17\n    template<class H2, class P2>\n      void merge(unordered_multiset<Key, H2, P2, Allocator>&& source);   // C++17\n\n    void swap(unordered_set&)\n       noexcept(allocator_traits<Allocator>::is_always_equal::value &&\n                 noexcept(swap(declval<hasher&>(), declval<hasher&>())) &&\n                 noexcept(swap(declval<key_equal&>(), declval<key_equal&>()))); // C++17\n\n    hasher hash_function() const;\n    key_equal key_eq() const;\n\n    iterator       find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    size_type count(const key_type& k) const;\n    pair<iterator, iterator>             equal_range(const key_type& k);\n    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;\n\n    size_type bucket_count() const noexcept;\n    size_type max_bucket_count() const noexcept;\n\n    size_type bucket_size(size_type n) const;\n    size_type bucket(const key_type& k) const;\n\n    local_iterator       begin(size_type n);\n    local_iterator       end(size_type n);\n    const_local_iterator begin(size_type n) const;\n    const_local_iterator end(size_type n) const;\n    const_local_iterator cbegin(size_type n) const;\n    const_local_iterator cend(size_type n) const;\n\n    float load_factor() const noexcept;\n    float max_load_factor() const noexcept;\n    void max_load_factor(float z);\n    void rehash(size_type n);\n    void reserve(size_type n);\n};\n\ntemplate <class Value, class Hash, class Pred, class Alloc>\n    void swap(unordered_set<Value, Hash, Pred, Alloc>& x,\n              unordered_set<Value, Hash, Pred, Alloc>& y)\n              noexcept(noexcept(x.swap(y)));\n\ntemplate <class Value, class Hash, class Pred, class Alloc>\n    bool\n    operator==(const unordered_set<Value, Hash, Pred, Alloc>& x,\n               const unordered_set<Value, Hash, Pred, Alloc>& y);\n\ntemplate <class Value, class Hash, class Pred, class Alloc>\n    bool\n    operator!=(const unordered_set<Value, Hash, Pred, Alloc>& x,\n               const unordered_set<Value, Hash, Pred, Alloc>& y);\n\ntemplate <class Value, class Hash = hash<Value>, class Pred = equal_to<Value>,\n          class Alloc = allocator<Value>>\nclass unordered_multiset\n{\npublic:\n    // types\n    typedef Value                                                      key_type;\n    typedef key_type                                                   value_type;\n    typedef Hash                                                       hasher;\n    typedef Pred                                                       key_equal;\n    typedef Alloc                                                      allocator_type;\n    typedef value_type&                                                reference;\n    typedef const value_type&                                          const_reference;\n    typedef typename allocator_traits<allocator_type>::pointer         pointer;\n    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;\n    typedef typename allocator_traits<allocator_type>::size_type       size_type;\n    typedef typename allocator_traits<allocator_type>::difference_type difference_type;\n\n    typedef /unspecified/ iterator;\n    typedef /unspecified/ const_iterator;\n    typedef /unspecified/ local_iterator;\n    typedef /unspecified/ const_local_iterator;\n\n    typedef unspecified node_type unspecified;   // C++17\n\n    unordered_multiset()\n        noexcept(\n            is_nothrow_default_constructible<hasher>::value &&\n            is_nothrow_default_constructible<key_equal>::value &&\n            is_nothrow_default_constructible<allocator_type>::value);\n    explicit unordered_multiset(size_type n, const hasher& hf = hasher(),\n                           const key_equal& eql = key_equal(),\n                           const allocator_type& a = allocator_type());\n    template <class InputIterator>\n        unordered_multiset(InputIterator f, InputIterator l,\n                      size_type n = 0, const hasher& hf = hasher(),\n                      const key_equal& eql = key_equal(),\n                      const allocator_type& a = allocator_type());\n    explicit unordered_multiset(const allocator_type&);\n    unordered_multiset(const unordered_multiset&);\n    unordered_multiset(const unordered_multiset&, const Allocator&);\n    unordered_multiset(unordered_multiset&&)\n        noexcept(\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value &&\n            is_nothrow_move_constructible<allocator_type>::value);\n    unordered_multiset(unordered_multiset&&, const Allocator&);\n    unordered_multiset(initializer_list<value_type>, size_type n = /see below/,\n                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),\n                  const allocator_type& a = allocator_type());\n    unordered_multiset(size_type n, const allocator_type& a); // C++14\n    unordered_multiset(size_type n, const hasher& hf, const allocator_type& a); // C++14\n    template <class InputIterator>\n      unordered_multiset(InputIterator f, InputIterator l, size_type n, const allocator_type& a); // C++14\n    template <class InputIterator>\n      unordered_multiset(InputIterator f, InputIterator l, size_type n,\n                         const hasher& hf, const allocator_type& a); // C++14\n    unordered_multiset(initializer_list<value_type> il, size_type n, const allocator_type& a); // C++14\n    unordered_multiset(initializer_list<value_type> il, size_type n, \n                       const hasher& hf,  const allocator_type& a); // C++14\n    ~unordered_multiset();\n    unordered_multiset& operator=(const unordered_multiset&);\n    unordered_multiset& operator=(unordered_multiset&&)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n    unordered_multiset& operator=(initializer_list<value_type>);\n\n    allocator_type get_allocator() const noexcept;\n\n    bool      empty() const noexcept;\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n\n    iterator       begin() noexcept;\n    iterator       end() noexcept;\n    const_iterator begin()  const noexcept;\n    const_iterator end()    const noexcept;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend()   const noexcept;\n\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& obj);\n    iterator insert(value_type&& obj);\n    iterator insert(const_iterator hint, const value_type& obj);\n    iterator insert(const_iterator hint, value_type&& obj);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type>);\n\n    node_type extract(const_iterator position);             // C++17\n    node_type extract(const key_type& x);                   // C++17\n    iterator insert(node_type&& nh);                        // C++17\n    iterator insert(const_iterator hint, node_type&& nh);   // C++17\n\n    iterator erase(const_iterator position);\n    iterator erase(iterator position);  // C++14\n    size_type erase(const key_type& k);\n    iterator erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    template<class H2, class P2>\n      void merge(unordered_multiset<Key, H2, P2, Allocator>& source);    // C++17\n    template<class H2, class P2>\n      void merge(unordered_multiset<Key, H2, P2, Allocator>&& source);   // C++17\n    template<class H2, class P2>\n      void merge(unordered_set<Key, H2, P2, Allocator>& source);         // C++17\n    template<class H2, class P2>\n      void merge(unordered_set<Key, H2, P2, Allocator>&& source);        // C++17\n\n    void swap(unordered_multiset&)\n       noexcept(allocator_traits<Allocator>::is_always_equal::value &&\n                 noexcept(swap(declval<hasher&>(), declval<hasher&>())) &&\n                 noexcept(swap(declval<key_equal&>(), declval<key_equal&>()))); // C++17\n\n    hasher hash_function() const;\n    key_equal key_eq() const;\n\n    iterator       find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    size_type count(const key_type& k) const;\n    pair<iterator, iterator>             equal_range(const key_type& k);\n    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;\n\n    size_type bucket_count() const noexcept;\n    size_type max_bucket_count() const noexcept;\n\n    size_type bucket_size(size_type n) const;\n    size_type bucket(const key_type& k) const;\n\n    local_iterator       begin(size_type n);\n    local_iterator       end(size_type n);\n    const_local_iterator begin(size_type n) const;\n    const_local_iterator end(size_type n) const;\n    const_local_iterator cbegin(size_type n) const;\n    const_local_iterator cend(size_type n) const;\n\n    float load_factor() const noexcept;\n    float max_load_factor() const noexcept;\n    void max_load_factor(float z);\n    void rehash(size_type n);\n    void reserve(size_type n);\n};\n\ntemplate <class Value, class Hash, class Pred, class Alloc>\n    void swap(unordered_multiset<Value, Hash, Pred, Alloc>& x,\n              unordered_multiset<Value, Hash, Pred, Alloc>& y)\n              noexcept(noexcept(x.swap(y)));\n\ntemplate <class K, class T, class H, class P, class A, class Predicate>\n    void erase_if(unordered_set<K, T, H, P, A>& c, Predicate pred);       // C++20\n\ntemplate <class K, class T, class H, class P, class A, class Predicate>\n    void erase_if(unordered_multiset<K, T, H, P, A>& c, Predicate pred);  // C++20\n\n\ntemplate <class Value, class Hash, class Pred, class Alloc>\n    bool\n    operator==(const unordered_multiset<Value, Hash, Pred, Alloc>& x,\n               const unordered_multiset<Value, Hash, Pred, Alloc>& y);\n\ntemplate <class Value, class Hash, class Pred, class Alloc>\n    bool\n    operator!=(const unordered_multiset<Value, Hash, Pred, Alloc>& x,\n               const unordered_multiset<Value, Hash, Pred, Alloc>& y);\n}  // std\n\n*/\n\n#include <__config>\n#include <__hash_table>\n#include <__node_handle>\n#include <functional>\n#include <version>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nclass unordered_multiset;\n\ntemplate <class _Value, class _Hash = hash<_Value>, class _Pred = equal_to<_Value>,\n          class _Alloc = allocator<_Value> >\nclass _LIBCPP_TEMPLATE_VIS unordered_set\n{\npublic:\n    // types\n    typedef _Value                                                     key_type;\n    typedef key_type                                                   value_type;\n    typedef _Hash                                                      hasher;\n    typedef _Pred                                                      key_equal;\n    typedef _Alloc                                                     allocator_type;\n    typedef value_type&                                                reference;\n    typedef const value_type&                                          const_reference;\n    static_assert((is_same<value_type, typename allocator_type::value_type>::value),\n                  \"Invalid allocator::value_type\");\n    static_assert(sizeof(__diagnose_unordered_container_requirements<_Value, _Hash, _Pred>(0)), \"\");\n\nprivate:\n    typedef __hash_table<value_type, hasher, key_equal, allocator_type> __table;\n\n    __table __table_;\n\npublic:\n    typedef typename __table::pointer         pointer;\n    typedef typename __table::const_pointer   const_pointer;\n    typedef typename __table::size_type       size_type;\n    typedef typename __table::difference_type difference_type;\n\n    typedef typename __table::const_iterator       iterator;\n    typedef typename __table::const_iterator       const_iterator;\n    typedef typename __table::const_local_iterator local_iterator;\n    typedef typename __table::const_local_iterator const_local_iterator;\n\n#if _LIBCPP_STD_VER > 14\n    typedef __set_node_handle<typename __table::__node, allocator_type> node_type;\n    typedef __insert_return_type<iterator, node_type> insert_return_type;\n#endif\n\n    template <class _Value2, class _Hash2, class _Pred2, class _Alloc2>\n        friend class _LIBCPP_TEMPLATE_VIS unordered_set;\n    template <class _Value2, class _Hash2, class _Pred2, class _Alloc2>\n        friend class _LIBCPP_TEMPLATE_VIS unordered_multiset;\n\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_set()\n        _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    explicit unordered_set(size_type __n, const hasher& __hf = hasher(),\n                           const key_equal& __eql = key_equal());\n#if _LIBCPP_STD_VER > 11\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_set(size_type __n, const allocator_type& __a)\n        : unordered_set(__n, hasher(), key_equal(), __a) {}\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_set(size_type __n, const hasher& __hf, const allocator_type& __a)\n        : unordered_set(__n, __hf, key_equal(), __a) {}\n#endif\n    unordered_set(size_type __n, const hasher& __hf, const key_equal& __eql,\n                  const allocator_type& __a);\n    template <class _InputIterator>\n        unordered_set(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        unordered_set(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf = hasher(),\n                      const key_equal& __eql = key_equal());\n    template <class _InputIterator>\n        unordered_set(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf, const key_equal& __eql,\n                      const allocator_type& __a);\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    inline _LIBCPP_INLINE_VISIBILITY\n        unordered_set(_InputIterator __first, _InputIterator __last, \n                    size_type __n, const allocator_type& __a)\n            : unordered_set(__first, __last, __n, hasher(), key_equal(), __a) {}\n    template <class _InputIterator>\n        unordered_set(_InputIterator __first, _InputIterator __last, \n                      size_type __n, const hasher& __hf, const allocator_type& __a)\n            : unordered_set(__first, __last, __n, __hf, key_equal(), __a) {}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    explicit unordered_set(const allocator_type& __a);\n    unordered_set(const unordered_set& __u);\n    unordered_set(const unordered_set& __u, const allocator_type& __a);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_set(unordered_set&& __u)\n        _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);\n    unordered_set(unordered_set&& __u, const allocator_type& __a);\n    unordered_set(initializer_list<value_type> __il);\n    unordered_set(initializer_list<value_type> __il, size_type __n,\n                  const hasher& __hf = hasher(),\n                  const key_equal& __eql = key_equal());\n    unordered_set(initializer_list<value_type> __il, size_type __n,\n                  const hasher& __hf, const key_equal& __eql,\n                  const allocator_type& __a);\n#if _LIBCPP_STD_VER > 11\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_set(initializer_list<value_type> __il, size_type __n,\n                                                      const allocator_type& __a)\n        : unordered_set(__il, __n, hasher(), key_equal(), __a) {}\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_set(initializer_list<value_type> __il, size_type __n, \n                                  const hasher& __hf, const allocator_type& __a)\n        : unordered_set(__il, __n, __hf, key_equal(), __a) {}\n#endif\n#endif  // _LIBCPP_CXX03_LANG\n    // ~unordered_set() = default;\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_set& operator=(const unordered_set& __u)\n    {\n        __table_ = __u.__table_;\n        return *this;\n    }\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_set& operator=(unordered_set&& __u)\n        _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_set& operator=(initializer_list<value_type> __il);\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(__table_.__node_alloc());}\n\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __table_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT  {return __table_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __table_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       begin() _NOEXCEPT        {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       end() _NOEXCEPT          {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT {return __table_.end();}\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> emplace(_Args&&... __args)\n            {return __table_.__emplace_unique(_VSTD::forward<_Args>(__args)...);}\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        iterator emplace_hint(const_iterator __p, _Args&&... __args)\n        {\n            _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n                \"unordered_set::emplace_hint(const_iterator, args...) called with an iterator not\"\n                \" referring to this unordered_set\");\n            return __table_.__emplace_unique(_VSTD::forward<_Args>(__args)...).first;\n        }\n#else\n        iterator emplace_hint(const_iterator, _Args&&... __args)\n            {return __table_.__emplace_unique(_VSTD::forward<_Args>(__args)...).first;}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> insert(value_type&& __x)\n        {return __table_.__insert_unique(_VSTD::move(__x));}\n    _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    iterator insert(const_iterator __p, value_type&& __x)\n        {\n            _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n                \"unordered_set::insert(const_iterator, value_type&&) called with an iterator not\"\n                \" referring to this unordered_set\");\n            return insert(_VSTD::move(__x)).first;\n        }\n#else\n    iterator insert(const_iterator, value_type&& __x)\n        {return insert(_VSTD::move(__x)).first;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> insert(const value_type& __x)\n        {return __table_.__insert_unique(__x);}\n\n    _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    iterator insert(const_iterator __p, const value_type& __x)\n        {\n            _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n                \"unordered_set::insert(const_iterator, const value_type&) called with an iterator not\"\n                \" referring to this unordered_set\");\n            return insert(__x).first;\n        }\n#else\n    iterator insert(const_iterator, const value_type& __x)\n        {return insert(__x).first;}\n#endif\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __first, _InputIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __table_.erase(__p);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __table_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __first, const_iterator __last)\n        {return __table_.erase(__first, __last);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__table_.clear();}\n\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    insert_return_type insert(node_type&& __nh)\n    {\n        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),\n            \"node_type with incompatible allocator passed to unordered_set::insert()\");\n        return __table_.template __node_handle_insert_unique<\n            node_type, insert_return_type>(_VSTD::move(__nh));\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __h, node_type&& __nh)\n    {\n        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),\n            \"node_type with incompatible allocator passed to unordered_set::insert()\");\n        return __table_.template __node_handle_insert_unique<node_type>(\n            __h, _VSTD::move(__nh));\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    node_type extract(key_type const& __key)\n    {\n        return __table_.template __node_handle_extract<node_type>(__key);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    node_type extract(const_iterator __it)\n    {\n        return __table_.template __node_handle_extract<node_type>(__it);\n    }\n\n    template<class _H2, class _P2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(unordered_set<key_type, _H2, _P2, allocator_type>& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        __table_.__node_handle_merge_unique(__source.__table_);\n    }\n    template<class _H2, class _P2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(unordered_set<key_type, _H2, _P2, allocator_type>&& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        __table_.__node_handle_merge_unique(__source.__table_);\n    }\n    template<class _H2, class _P2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(unordered_multiset<key_type, _H2, _P2, allocator_type>& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        __table_.__node_handle_merge_unique(__source.__table_);\n    }\n    template<class _H2, class _P2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(unordered_multiset<key_type, _H2, _P2, allocator_type>&& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        __table_.__node_handle_merge_unique(__source.__table_);\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(unordered_set& __u)\n        _NOEXCEPT_(__is_nothrow_swappable<__table>::value)\n        {__table_.swap(__u.__table_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    hasher hash_function() const {return __table_.hash_function();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_equal key_eq() const {return __table_.key_eq();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       find(const key_type& __k)       {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type count(const key_type& __k) const {return __table_.__count_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, iterator>             equal_range(const key_type& __k)\n        {return __table_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const\n        {return __table_.__equal_range_unique(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_count() const _NOEXCEPT {return __table_.bucket_count();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_bucket_count() const _NOEXCEPT {return __table_.max_bucket_count();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_size(size_type __n) const {return __table_.bucket_size(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       begin(size_type __n)        {return __table_.begin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       end(size_type __n)          {return __table_.end(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator begin(size_type __n) const  {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator end(size_type __n) const    {return __table_.cend(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cend(size_type __n) const   {return __table_.cend(__n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    float load_factor() const _NOEXCEPT {return __table_.load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    float max_load_factor() const _NOEXCEPT {return __table_.max_load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}\n    _LIBCPP_INLINE_VISIBILITY\n    void rehash(size_type __n) {__table_.rehash(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    void reserve(size_type __n) {__table_.reserve(__n);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const\n        {return __table_.__dereferenceable(__i);}\n    bool __decrementable(const const_iterator* __i) const\n        {return __table_.__decrementable(__i);}\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(__i, __n);}\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(__i, __n);}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n};\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(size_type __n,\n        const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(size_type __n,\n        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__first, __last);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        const allocator_type& __a)\n    : __table_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        const unordered_set& __u)\n    : __table_(__u.__table_)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        const unordered_set& __u, const allocator_type& __a)\n    : __table_(__u.__table_, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        unordered_set&& __u)\n    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)\n    : __table_(_VSTD::move(__u.__table_))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        unordered_set&& __u, const allocator_type& __a)\n    : __table_(_VSTD::move(__u.__table_), __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a != __u.get_allocator())\n    {\n        iterator __i = __u.begin();\n        while (__u.size() != 0)\n            __table_.__insert_unique(_VSTD::move(__u.__table_.remove(__i++)->__value_));\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    else\n        __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_set<_Value, _Hash, _Pred, _Alloc>&\nunordered_set<_Value, _Hash, _Pred, _Alloc>::operator=(unordered_set&& __u)\n    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value)\n{\n    __table_ = _VSTD::move(__u.__table_);\n    return *this;\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_set<_Value, _Hash, _Pred, _Alloc>&\nunordered_set<_Value, _Hash, _Pred, _Alloc>::operator=(\n        initializer_list<value_type> __il)\n{\n    __table_.__assign_unique(__il.begin(), __il.end());\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\ninline\nvoid\nunordered_set<_Value, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,\n                                                    _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        __table_.__insert_unique(*__first);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n     unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n#if _LIBCPP_STD_VER > 17\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid erase_if(unordered_set<_Value, _Hash, _Pred, _Alloc>& __c, _Predicate __pred)\n{ __libcpp_erase_if_container(__c, __pred); }\n#endif\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nbool\noperator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n           const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n{\n    if (__x.size() != __y.size())\n        return false;\n    typedef typename unordered_set<_Value, _Hash, _Pred, _Alloc>::const_iterator\n                                                                 const_iterator;\n    for (const_iterator __i = __x.begin(), __ex = __x.end(), __ey = __y.end();\n            __i != __ex; ++__i)\n    {\n        const_iterator __j = __y.find(*__i);\n        if (__j == __ey || !(*__i == *__j))\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n           const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Value, class _Hash = hash<_Value>, class _Pred = equal_to<_Value>,\n          class _Alloc = allocator<_Value> >\nclass _LIBCPP_TEMPLATE_VIS unordered_multiset\n{\npublic:\n    // types\n    typedef _Value                                                     key_type;\n    typedef key_type                                                   value_type;\n    typedef _Hash                                                      hasher;\n    typedef _Pred                                                      key_equal;\n    typedef _Alloc                                                     allocator_type;\n    typedef value_type&                                                reference;\n    typedef const value_type&                                          const_reference;\n    static_assert((is_same<value_type, typename allocator_type::value_type>::value),\n                  \"Invalid allocator::value_type\");\n    static_assert(sizeof(__diagnose_unordered_container_requirements<_Value, _Hash, _Pred>(0)), \"\");\n\nprivate:\n    typedef __hash_table<value_type, hasher, key_equal, allocator_type> __table;\n\n    __table __table_;\n\npublic:\n    typedef typename __table::pointer         pointer;\n    typedef typename __table::const_pointer   const_pointer;\n    typedef typename __table::size_type       size_type;\n    typedef typename __table::difference_type difference_type;\n\n    typedef typename __table::const_iterator       iterator;\n    typedef typename __table::const_iterator       const_iterator;\n    typedef typename __table::const_local_iterator local_iterator;\n    typedef typename __table::const_local_iterator const_local_iterator;\n\n#if _LIBCPP_STD_VER > 14\n    typedef __set_node_handle<typename __table::__node, allocator_type> node_type;\n#endif\n\n    template <class _Value2, class _Hash2, class _Pred2, class _Alloc2>\n        friend class _LIBCPP_TEMPLATE_VIS unordered_set;\n    template <class _Value2, class _Hash2, class _Pred2, class _Alloc2>\n        friend class _LIBCPP_TEMPLATE_VIS unordered_multiset;\n\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multiset()\n        _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    explicit unordered_multiset(size_type __n, const hasher& __hf = hasher(),\n                                const key_equal& __eql = key_equal());\n    unordered_multiset(size_type __n, const hasher& __hf,\n                       const key_equal& __eql, const allocator_type& __a);\n#if _LIBCPP_STD_VER > 11\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_multiset(size_type __n, const allocator_type& __a)\n        : unordered_multiset(__n, hasher(), key_equal(), __a) {}\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_multiset(size_type __n, const hasher& __hf, const allocator_type& __a)\n        : unordered_multiset(__n, __hf, key_equal(), __a) {}\n#endif\n    template <class _InputIterator>\n        unordered_multiset(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        unordered_multiset(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf = hasher(),\n                      const key_equal& __eql = key_equal());\n    template <class _InputIterator>\n        unordered_multiset(_InputIterator __first, _InputIterator __last,\n                      size_type __n , const hasher& __hf,\n                      const key_equal& __eql, const allocator_type& __a);\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_multiset(_InputIterator __first, _InputIterator __last, \n                       size_type __n, const allocator_type& __a)\n        : unordered_multiset(__first, __last, __n, hasher(), key_equal(), __a) {}\n    template <class _InputIterator>\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_multiset(_InputIterator __first, _InputIterator __last,\n                       size_type __n, const hasher& __hf, const allocator_type& __a)\n        : unordered_multiset(__first, __last, __n, __hf, key_equal(), __a) {}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    explicit unordered_multiset(const allocator_type& __a);\n    unordered_multiset(const unordered_multiset& __u);\n    unordered_multiset(const unordered_multiset& __u, const allocator_type& __a);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multiset(unordered_multiset&& __u)\n        _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);\n    unordered_multiset(unordered_multiset&& __u, const allocator_type& __a);\n    unordered_multiset(initializer_list<value_type> __il);\n    unordered_multiset(initializer_list<value_type> __il, size_type __n,\n                       const hasher& __hf = hasher(),\n                       const key_equal& __eql = key_equal());\n    unordered_multiset(initializer_list<value_type> __il, size_type __n,\n                       const hasher& __hf, const key_equal& __eql,\n                       const allocator_type& __a);\n#if _LIBCPP_STD_VER > 11\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_multiset(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)\n      : unordered_multiset(__il, __n, hasher(), key_equal(), __a) {}\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_multiset(initializer_list<value_type> __il, size_type __n, const hasher& __hf, const allocator_type& __a)\n      : unordered_multiset(__il, __n, __hf, key_equal(), __a) {}\n#endif\n#endif  // _LIBCPP_CXX03_LANG\n    // ~unordered_multiset() = default;\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multiset& operator=(const unordered_multiset& __u)\n    {\n        __table_ = __u.__table_;\n        return *this;\n    }\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multiset& operator=(unordered_multiset&& __u)\n        _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);\n    unordered_multiset& operator=(initializer_list<value_type> __il);\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(__table_.__node_alloc());}\n\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __table_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT  {return __table_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __table_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       begin() _NOEXCEPT        {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       end() _NOEXCEPT          {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT {return __table_.end();}\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace(_Args&&... __args)\n            {return __table_.__emplace_multi(_VSTD::forward<_Args>(__args)...);}\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace_hint(const_iterator __p, _Args&&... __args)\n            {return __table_.__emplace_hint_multi(__p, _VSTD::forward<_Args>(__args)...);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(value_type&& __x) {return __table_.__insert_multi(_VSTD::move(__x));}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __x)\n        {return __table_.__insert_multi(__p, _VSTD::move(__x));}\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __x) {return __table_.__insert_multi(__x);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __x)\n        {return __table_.__insert_multi(__p, __x);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __first, _InputIterator __last);\n\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(node_type&& __nh)\n    {\n        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),\n            \"node_type with incompatible allocator passed to unordered_multiset::insert()\");\n        return __table_.template __node_handle_insert_multi<node_type>(\n            _VSTD::move(__nh));\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __hint, node_type&& __nh)\n    {\n        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),\n            \"node_type with incompatible allocator passed to unordered_multiset::insert()\");\n        return __table_.template __node_handle_insert_multi<node_type>(\n            __hint, _VSTD::move(__nh));\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    node_type extract(const_iterator __position)\n    {\n        return __table_.template __node_handle_extract<node_type>(\n            __position);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    node_type extract(key_type const& __key)\n    {\n        return __table_.template __node_handle_extract<node_type>(__key);\n    }\n\n    template <class _H2, class _P2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(unordered_multiset<key_type, _H2, _P2, allocator_type>& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        return __table_.__node_handle_merge_multi(__source.__table_);\n    }\n    template <class _H2, class _P2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(unordered_multiset<key_type, _H2, _P2, allocator_type>&& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        return __table_.__node_handle_merge_multi(__source.__table_);\n    }\n    template <class _H2, class _P2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(unordered_set<key_type, _H2, _P2, allocator_type>& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        return __table_.__node_handle_merge_multi(__source.__table_);\n    }\n    template <class _H2, class _P2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(unordered_set<key_type, _H2, _P2, allocator_type>&& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        return __table_.__node_handle_merge_multi(__source.__table_);\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __table_.erase(__p);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __table_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __first, const_iterator __last)\n        {return __table_.erase(__first, __last);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__table_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(unordered_multiset& __u)\n        _NOEXCEPT_(__is_nothrow_swappable<__table>::value)\n        {__table_.swap(__u.__table_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    hasher hash_function() const {return __table_.hash_function();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_equal key_eq() const {return __table_.key_eq();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       find(const key_type& __k)       {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type count(const key_type& __k) const {return __table_.__count_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, iterator>             equal_range(const key_type& __k)\n        {return __table_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const\n        {return __table_.__equal_range_multi(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_count() const _NOEXCEPT {return __table_.bucket_count();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_bucket_count() const _NOEXCEPT {return __table_.max_bucket_count();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_size(size_type __n) const {return __table_.bucket_size(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       begin(size_type __n)        {return __table_.begin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       end(size_type __n)          {return __table_.end(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator begin(size_type __n) const  {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator end(size_type __n) const    {return __table_.cend(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cend(size_type __n) const   {return __table_.cend(__n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    float load_factor() const _NOEXCEPT {return __table_.load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    float max_load_factor() const _NOEXCEPT {return __table_.max_load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}\n    _LIBCPP_INLINE_VISIBILITY\n    void rehash(size_type __n) {__table_.rehash(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    void reserve(size_type __n) {__table_.reserve(__n);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const\n        {return __table_.__dereferenceable(__i);}\n    bool __decrementable(const const_iterator* __i) const\n        {return __table_.__decrementable(__i);}\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(__i, __n);}\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(__i, __n);}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n};\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        size_type __n, const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        size_type __n, const hasher& __hf, const key_equal& __eql,\n        const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__first, __last);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        const allocator_type& __a)\n    : __table_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        const unordered_multiset& __u)\n    : __table_(__u.__table_)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        const unordered_multiset& __u, const allocator_type& __a)\n    : __table_(__u.__table_, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        unordered_multiset&& __u)\n    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)\n    : __table_(_VSTD::move(__u.__table_))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        unordered_multiset&& __u, const allocator_type& __a)\n    : __table_(_VSTD::move(__u.__table_), __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a != __u.get_allocator())\n    {\n        iterator __i = __u.begin();\n        while (__u.size() != 0)\n            __table_.__insert_multi(_VSTD::move(__u.__table_.remove(__i++)->__value_));\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    else\n        __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>&\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::operator=(\n        unordered_multiset&& __u)\n    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value)\n{\n    __table_ = _VSTD::move(__u.__table_);\n    return *this;\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>&\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::operator=(\n        initializer_list<value_type> __il)\n{\n    __table_.__assign_multi(__il.begin(), __il.end());\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\ninline\nvoid\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,\n                                                         _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        __table_.__insert_multi(*__first);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n     unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n#if _LIBCPP_STD_VER > 17\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid erase_if(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __c, _Predicate __pred)\n{ __libcpp_erase_if_container(__c, __pred); }\n#endif\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nbool\noperator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n           const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n{\n    if (__x.size() != __y.size())\n        return false;\n    typedef typename unordered_multiset<_Value, _Hash, _Pred, _Alloc>::const_iterator\n                                                                 const_iterator;\n    typedef pair<const_iterator, const_iterator> _EqRng;\n    for (const_iterator __i = __x.begin(), __ex = __x.end(); __i != __ex;)\n    {\n        _EqRng __xeq = __x.equal_range(*__i);\n        _EqRng __yeq = __y.equal_range(*__i);\n        if (_VSTD::distance(__xeq.first, __xeq.second) !=\n            _VSTD::distance(__yeq.first, __yeq.second) ||\n                  !_VSTD::is_permutation(__xeq.first, __xeq.second, __yeq.first))\n            return false;\n        __i = __xeq.second;\n    }\n    return true;\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n           const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n{\n    return !(__x == __y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UNORDERED_SET\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP__HASH_TABLE\n#define _LIBCPP__HASH_TABLE\n\n#include <__config>\n#include <initializer_list>\n#include <memory>\n#include <iterator>\n#include <algorithm>\n#include <cmath>\n#include <utility>\n#include <type_traits>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _Tp>\nstruct __hash_value_type;\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp>\nstruct __is_hash_value_type_imp : false_type {};\n\ntemplate <class _Key, class _Value>\nstruct __is_hash_value_type_imp<__hash_value_type<_Key, _Value>> : true_type {};\n\ntemplate <class ..._Args>\nstruct __is_hash_value_type : false_type {};\n\ntemplate <class _One>\nstruct __is_hash_value_type<_One> : __is_hash_value_type_imp<typename __uncvref<_One>::type> {};\n#endif\n\n_LIBCPP_FUNC_VIS\nsize_t __next_prime(size_t __n);\n\ntemplate <class _NodePtr>\nstruct __hash_node_base\n{\n    typedef typename pointer_traits<_NodePtr>::element_type __node_type;\n    typedef __hash_node_base __first_node;\n    typedef typename __rebind_pointer<_NodePtr, __first_node>::type __node_base_pointer;\n    typedef _NodePtr __node_pointer;\n\n#if defined(_LIBCPP_ABI_FIX_UNORDERED_NODE_POINTER_UB)\n  typedef __node_base_pointer __next_pointer;\n#else\n  typedef typename conditional<\n      is_pointer<__node_pointer>::value,\n      __node_base_pointer,\n      __node_pointer>::type   __next_pointer;\n#endif\n\n    __next_pointer    __next_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __next_pointer __ptr() _NOEXCEPT {\n        return static_cast<__next_pointer>(\n            pointer_traits<__node_base_pointer>::pointer_to(*this));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __upcast() _NOEXCEPT {\n        return static_cast<__node_pointer>(\n            pointer_traits<__node_base_pointer>::pointer_to(*this));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t __hash() const _NOEXCEPT {\n        return static_cast<__node_type const&>(*this).__hash_;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __hash_node_base() _NOEXCEPT : __next_(nullptr) {}\n};\n\ntemplate <class _Tp, class _VoidPtr>\nstruct __hash_node\n    : public __hash_node_base\n             <\n                 typename __rebind_pointer<_VoidPtr, __hash_node<_Tp, _VoidPtr> >::type\n             >\n{\n    typedef _Tp __node_value_type;\n\n    size_t            __hash_;\n    __node_value_type __value_;\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__is_hash_power2(size_t __bc)\n{\n    return __bc > 2 && !(__bc & (__bc - 1));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\n__constrain_hash(size_t __h, size_t __bc)\n{\n    return !(__bc & (__bc - 1)) ? __h & (__bc - 1) :\n        (__h < __bc ? __h : __h % __bc);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\n__next_hash_pow2(size_t __n)\n{\n    return __n < 2 ? __n : (size_t(1) << (std::numeric_limits<size_t>::digits - __clz(__n-1)));\n}\n\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc> class __hash_table;\n\ntemplate <class _NodePtr>      class _LIBCPP_TEMPLATE_VIS __hash_iterator;\ntemplate <class _ConstNodePtr> class _LIBCPP_TEMPLATE_VIS __hash_const_iterator;\ntemplate <class _NodePtr>      class _LIBCPP_TEMPLATE_VIS __hash_local_iterator;\ntemplate <class _ConstNodePtr> class _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator;\ntemplate <class _HashIterator> class _LIBCPP_TEMPLATE_VIS __hash_map_iterator;\ntemplate <class _HashIterator> class _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator;\n\ntemplate <class _Tp>\nstruct __hash_key_value_types {\n  static_assert(!is_reference<_Tp>::value && !is_const<_Tp>::value, \"\");\n  typedef _Tp key_type;\n  typedef _Tp __node_value_type;\n  typedef _Tp __container_value_type;\n  static const bool __is_map = false;\n\n  _LIBCPP_INLINE_VISIBILITY\n  static key_type const& __get_key(_Tp const& __v) {\n    return __v;\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type const& __get_value(__node_value_type const& __v) {\n    return __v;\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type* __get_ptr(__node_value_type& __n) {\n    return _VSTD::addressof(__n);\n  }\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type&& __move(__node_value_type& __v) {\n    return _VSTD::move(__v);\n  }\n#endif\n};\n\ntemplate <class _Key, class _Tp>\nstruct __hash_key_value_types<__hash_value_type<_Key, _Tp> > {\n  typedef _Key                                         key_type;\n  typedef _Tp                                          mapped_type;\n  typedef __hash_value_type<_Key, _Tp>                 __node_value_type;\n  typedef pair<const _Key, _Tp>                        __container_value_type;\n  typedef __container_value_type                       __map_value_type;\n  static const bool __is_map = true;\n\n  _LIBCPP_INLINE_VISIBILITY\n  static key_type const& __get_key(__container_value_type const& __v) {\n    return __v.first;\n  }\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  static typename enable_if<__is_same_uncvref<_Up, __node_value_type>::value,\n      __container_value_type const&>::type\n  __get_value(_Up& __t) {\n    return __t.__get_value();\n  }\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,\n      __container_value_type const&>::type\n  __get_value(_Up& __t) {\n    return __t;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type* __get_ptr(__node_value_type& __n) {\n    return _VSTD::addressof(__n.__get_value());\n  }\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY\n  static pair<key_type&&, mapped_type&&> __move(__node_value_type& __v) {\n    return __v.__move();\n  }\n#endif\n\n};\n\ntemplate <class _Tp, class _AllocPtr, class _KVTypes = __hash_key_value_types<_Tp>,\n          bool = _KVTypes::__is_map>\nstruct __hash_map_pointer_types {};\n\ntemplate <class _Tp, class _AllocPtr, class _KVTypes>\nstruct __hash_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {\n  typedef typename _KVTypes::__map_value_type   _Mv;\n  typedef typename __rebind_pointer<_AllocPtr, _Mv>::type\n                                                       __map_value_type_pointer;\n  typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type\n                                                 __const_map_value_type_pointer;\n};\n\ntemplate <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>\nstruct __hash_node_types;\n\ntemplate <class _NodePtr, class _Tp, class _VoidPtr>\nstruct __hash_node_types<_NodePtr, __hash_node<_Tp, _VoidPtr> >\n    : public __hash_key_value_types<_Tp>, __hash_map_pointer_types<_Tp, _VoidPtr>\n\n{\n  typedef __hash_key_value_types<_Tp>           __base;\n\npublic:\n  typedef ptrdiff_t difference_type;\n  typedef size_t size_type;\n\n  typedef typename __rebind_pointer<_NodePtr, void>::type       __void_pointer;\n\n  typedef typename pointer_traits<_NodePtr>::element_type       __node_type;\n  typedef _NodePtr                                              __node_pointer;\n\n  typedef __hash_node_base<__node_pointer>                      __node_base_type;\n  typedef typename __rebind_pointer<_NodePtr, __node_base_type>::type\n                                                             __node_base_pointer;\n\n  typedef typename __node_base_type::__next_pointer          __next_pointer;\n\n  typedef _Tp                                                 __node_value_type;\n  typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type\n                                                      __node_value_type_pointer;\n  typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type\n                                                __const_node_value_type_pointer;\n\nprivate:\n    static_assert(!is_const<__node_type>::value,\n                \"_NodePtr should never be a pointer to const\");\n    static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),\n                  \"_VoidPtr does not point to unqualified void type\");\n    static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,\n                          _NodePtr>::value), \"_VoidPtr does not rebind to _NodePtr.\");\n};\n\ntemplate <class _HashIterator>\nstruct __hash_node_types_from_iterator;\ntemplate <class _NodePtr>\nstruct __hash_node_types_from_iterator<__hash_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};\ntemplate <class _NodePtr>\nstruct __hash_node_types_from_iterator<__hash_const_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};\ntemplate <class _NodePtr>\nstruct __hash_node_types_from_iterator<__hash_local_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};\ntemplate <class _NodePtr>\nstruct __hash_node_types_from_iterator<__hash_const_local_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};\n\n\ntemplate <class _NodeValueTp, class _VoidPtr>\nstruct __make_hash_node_types {\n  typedef __hash_node<_NodeValueTp, _VoidPtr> _NodeTp;\n  typedef typename __rebind_pointer<_VoidPtr, _NodeTp>::type _NodePtr;\n  typedef __hash_node_types<_NodePtr> type;\n};\n\ntemplate <class _NodePtr>\nclass _LIBCPP_TEMPLATE_VIS __hash_iterator\n{\n    typedef __hash_node_types<_NodePtr> _NodeTypes;\n    typedef _NodePtr                            __node_pointer;\n    typedef typename _NodeTypes::__next_pointer __next_pointer;\n\n    __next_pointer            __node_;\n\npublic:\n    typedef forward_iterator_tag                           iterator_category;\n    typedef typename _NodeTypes::__node_value_type         value_type;\n    typedef typename _NodeTypes::difference_type           difference_type;\n    typedef value_type&                                    reference;\n    typedef typename _NodeTypes::__node_value_type_pointer pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __hash_iterator() _NOEXCEPT : __node_(nullptr) {\n        _LIBCPP_DEBUG_MODE(__get_db()->__insert_i(this));\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator(const __hash_iterator& __i)\n        : __node_(__i.__node_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator& operator=(const __hash_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n        }\n        return *this;\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                             \"Attempted to dereference a non-dereferenceable unordered container iterator\");\n        return __node_->__upcast()->__value_;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container iterator\");\n        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator& operator++() {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable unordered container iterator\");\n        __node_ = __node_->__next_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator operator++(int)\n    {\n        __hash_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_iterator& __x, const __hash_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_iterator& __x, const __hash_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator(__next_pointer __node, const void* __c) _NOEXCEPT\n        : __node_(__node)\n        {\n            __get_db()->__insert_ic(this, __c);\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator(__next_pointer __node) _NOEXCEPT\n        : __node_(__node)\n        {}\n#endif\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_iterator;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_map_iterator;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;\n};\n\ntemplate <class _NodePtr>\nclass _LIBCPP_TEMPLATE_VIS __hash_const_iterator\n{\n    static_assert(!is_const<typename pointer_traits<_NodePtr>::element_type>::value, \"\");\n    typedef __hash_node_types<_NodePtr> _NodeTypes;\n    typedef _NodePtr                            __node_pointer;\n    typedef typename _NodeTypes::__next_pointer __next_pointer;\n\n    __next_pointer __node_;\n\npublic:\n    typedef __hash_iterator<_NodePtr> __non_const_iterator;\n\n    typedef forward_iterator_tag                                 iterator_category;\n    typedef typename _NodeTypes::__node_value_type               value_type;\n    typedef typename _NodeTypes::difference_type                 difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;\n\n\n    _LIBCPP_INLINE_VISIBILITY __hash_const_iterator() _NOEXCEPT : __node_(nullptr) {\n        _LIBCPP_DEBUG_MODE(__get_db()->__insert_i(this));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator(const __non_const_iterator& __x) _NOEXCEPT\n        : __node_(__x.__node_)\n    {\n        _LIBCPP_DEBUG_MODE(__get_db()->__iterator_copy(this, &__x));\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator(const __hash_const_iterator& __i)\n        : __node_(__i.__node_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_const_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator& operator=(const __hash_const_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n        }\n        return *this;\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_iterator\");\n        return __node_->__upcast()->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_iterator\");\n        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator& operator++() {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                             \"Attempted to increment non-incrementable unordered container const_iterator\");\n        __node_ = __node_->__next_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator operator++(int)\n    {\n        __hash_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_const_iterator& __x, const __hash_const_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_const_iterator& __x, const __hash_const_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator(__next_pointer __node, const void* __c) _NOEXCEPT\n        : __node_(__node)\n        {\n            __get_db()->__insert_ic(this, __c);\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator(__next_pointer __node) _NOEXCEPT\n        : __node_(__node)\n        {}\n#endif\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;\n};\n\ntemplate <class _NodePtr>\nclass _LIBCPP_TEMPLATE_VIS __hash_local_iterator\n{\n    typedef __hash_node_types<_NodePtr> _NodeTypes;\n    typedef _NodePtr                            __node_pointer;\n    typedef typename _NodeTypes::__next_pointer __next_pointer;\n\n    __next_pointer         __node_;\n    size_t                 __bucket_;\n    size_t                 __bucket_count_;\n\npublic:\n    typedef forward_iterator_tag                                iterator_category;\n    typedef typename _NodeTypes::__node_value_type              value_type;\n    typedef typename _NodeTypes::difference_type                difference_type;\n    typedef value_type&                                         reference;\n    typedef typename _NodeTypes::__node_value_type_pointer      pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __hash_local_iterator() _NOEXCEPT : __node_(nullptr) {\n        _LIBCPP_DEBUG_MODE(__get_db()->__insert_i(this));\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator(const __hash_local_iterator& __i)\n        : __node_(__i.__node_),\n          __bucket_(__i.__bucket_),\n          __bucket_count_(__i.__bucket_count_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_local_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator& operator=(const __hash_local_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n            __bucket_ = __i.__bucket_;\n            __bucket_count_ = __i.__bucket_count_;\n        }\n        return *this;\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container local_iterator\");\n        return __node_->__upcast()->__value_;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                             \"Attempted to dereference a non-dereferenceable unordered container local_iterator\");\n        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator& operator++() {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable unordered container local_iterator\");\n        __node_ = __node_->__next_;\n        if (__node_ != nullptr && __constrain_hash(__node_->__hash(), __bucket_count_) != __bucket_)\n            __node_ = nullptr;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator operator++(int)\n    {\n        __hash_local_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_local_iterator& __x, const __hash_local_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_local_iterator& __x, const __hash_local_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator(__next_pointer __node, size_t __bucket,\n                          size_t __bucket_count, const void* __c) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            __get_db()->__insert_ic(this, __c);\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator(__next_pointer __node, size_t __bucket,\n                          size_t __bucket_count) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#endif\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_map_iterator;\n};\n\ntemplate <class _ConstNodePtr>\nclass _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator\n{\n    typedef __hash_node_types<_ConstNodePtr> _NodeTypes;\n    typedef _ConstNodePtr                       __node_pointer;\n    typedef typename _NodeTypes::__next_pointer __next_pointer;\n\n    __next_pointer         __node_;\n    size_t                 __bucket_;\n    size_t                 __bucket_count_;\n\n    typedef pointer_traits<__node_pointer>          __pointer_traits;\n    typedef typename __pointer_traits::element_type __node;\n    typedef typename remove_const<__node>::type     __non_const_node;\n    typedef typename __rebind_pointer<__node_pointer, __non_const_node>::type\n        __non_const_node_pointer;\npublic:\n    typedef __hash_local_iterator<__non_const_node_pointer>\n                                                    __non_const_iterator;\n\n    typedef forward_iterator_tag                                 iterator_category;\n    typedef typename _NodeTypes::__node_value_type               value_type;\n    typedef typename _NodeTypes::difference_type                 difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;\n\n\n    _LIBCPP_INLINE_VISIBILITY __hash_const_local_iterator() _NOEXCEPT : __node_(nullptr) {\n        _LIBCPP_DEBUG_MODE(__get_db()->__insert_i(this));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(const __non_const_iterator& __x) _NOEXCEPT\n        : __node_(__x.__node_),\n          __bucket_(__x.__bucket_),\n          __bucket_count_(__x.__bucket_count_)\n    {\n        _LIBCPP_DEBUG_MODE(__get_db()->__iterator_copy(this, &__x));\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(const __hash_const_local_iterator& __i)\n        : __node_(__i.__node_),\n          __bucket_(__i.__bucket_),\n          __bucket_count_(__i.__bucket_count_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_const_local_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator& operator=(const __hash_const_local_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n            __bucket_ = __i.__bucket_;\n            __bucket_count_ = __i.__bucket_count_;\n        }\n        return *this;\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_local_iterator\");\n        return __node_->__upcast()->__value_;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_local_iterator\");\n        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator& operator++() {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable unordered container const_local_iterator\");\n        __node_ = __node_->__next_;\n        if (__node_ != nullptr && __constrain_hash(__node_->__hash(), __bucket_count_) != __bucket_)\n            __node_ = nullptr;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator operator++(int)\n    {\n        __hash_const_local_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(__next_pointer __node, size_t __bucket,\n                                size_t __bucket_count, const void* __c) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            __get_db()->__insert_ic(this, __c);\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(__next_pointer __node, size_t __bucket,\n                                size_t __bucket_count) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#endif\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator;\n};\n\ntemplate <class _Alloc>\nclass __bucket_list_deallocator\n{\n    typedef _Alloc                                          allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n    typedef typename __alloc_traits::size_type              size_type;\n\n    __compressed_pair<size_type, allocator_type> __data_;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bucket_list_deallocator()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        : __data_(0) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bucket_list_deallocator(const allocator_type& __a, size_type __size)\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n        : __data_(__size, __a) {}\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    __bucket_list_deallocator(__bucket_list_deallocator&& __x)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n        : __data_(_VSTD::move(__x.__data_))\n    {\n        __x.size() = 0;\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& size() _NOEXCEPT {return __data_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type  size() const _NOEXCEPT {return __data_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT {return __data_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT {return __data_.second();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        __alloc_traits::deallocate(__alloc(), __p, size());\n    }\n};\n\ntemplate <class _Alloc> class __hash_map_node_destructor;\n\ntemplate <class _Alloc>\nclass __hash_node_destructor\n{\n    typedef _Alloc                                          allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n\npublic:\n    typedef typename __alloc_traits::pointer                pointer;\nprivate:\n    typedef __hash_node_types<pointer> _NodeTypes;\n\n    allocator_type& __na_;\n\n    __hash_node_destructor& operator=(const __hash_node_destructor&);\n\npublic:\n    bool __value_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __hash_node_destructor(allocator_type& __na,\n                                    bool __constructed = false) _NOEXCEPT\n        : __na_(__na),\n          __value_constructed(__constructed)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__value_constructed)\n            __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n\n    template <class> friend class __hash_map_node_destructor;\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _NodeType, class _Alloc>\nstruct __generic_container_node_destructor;\n\ntemplate <class _Tp, class _VoidPtr, class _Alloc>\nstruct __generic_container_node_destructor<__hash_node<_Tp, _VoidPtr>, _Alloc>\n    : __hash_node_destructor<_Alloc>\n{\n    using __hash_node_destructor<_Alloc>::__hash_node_destructor;\n};\n#endif\n\ntemplate <class _Key, class _Hash, class _Equal>\nstruct __enforce_unordered_container_requirements {\n#ifndef _LIBCPP_CXX03_LANG\n    static_assert(__check_hash_requirements<_Key, _Hash>::value,\n    \"the specified hash does not meet the Hash requirements\");\n    static_assert(is_copy_constructible<_Equal>::value,\n    \"the specified comparator is required to be copy constructible\");\n#endif\n    typedef int type;\n};\n\ntemplate <class _Key, class _Hash, class _Equal>\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_DIAGNOSE_WARNING(!__invokable<_Equal const&, _Key const&, _Key const&>::value,\n    \"the specified comparator type does not provide a const call operator\")\n    _LIBCPP_DIAGNOSE_WARNING(!__invokable<_Hash const&, _Key const&>::value,\n    \"the specified hash functor does not provide a const call operator\")\n#endif\ntypename __enforce_unordered_container_requirements<_Key, _Hash, _Equal>::type\n__diagnose_unordered_container_requirements(int);\n\n// This dummy overload is used so that the compiler won't emit a spurious\n// \"no matching function for call to __diagnose_unordered_xxx\" diagnostic\n// when the overload above causes a hard error.\ntemplate <class _Key, class _Hash, class _Equal>\nint __diagnose_unordered_container_requirements(void*);\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nclass __hash_table\n{\npublic:\n    typedef _Tp    value_type;\n    typedef _Hash  hasher;\n    typedef _Equal key_equal;\n    typedef _Alloc allocator_type;\n\nprivate:\n    typedef allocator_traits<allocator_type> __alloc_traits;\n    typedef typename\n      __make_hash_node_types<value_type, typename __alloc_traits::void_pointer>::type\n                                                                     _NodeTypes;\npublic:\n\n    typedef typename _NodeTypes::__node_value_type           __node_value_type;\n    typedef typename _NodeTypes::__container_value_type      __container_value_type;\n    typedef typename _NodeTypes::key_type                    key_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n#ifndef _LIBCPP_ABI_FIX_UNORDERED_CONTAINER_SIZE_TYPE\n    typedef typename __alloc_traits::size_type       size_type;\n#else\n    typedef typename _NodeTypes::size_type           size_type;\n#endif\n    typedef typename _NodeTypes::difference_type     difference_type;\npublic:\n    // Create __node\n\n    typedef typename _NodeTypes::__node_type __node;\n    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;\n    typedef allocator_traits<__node_allocator>       __node_traits;\n    typedef typename _NodeTypes::__void_pointer      __void_pointer;\n    typedef typename _NodeTypes::__node_pointer      __node_pointer;\n    typedef typename _NodeTypes::__node_pointer      __node_const_pointer;\n    typedef typename _NodeTypes::__node_base_type    __first_node;\n    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;\n    typedef typename _NodeTypes::__next_pointer      __next_pointer;\n\nprivate:\n    // check for sane allocator pointer rebinding semantics. Rebinding the\n    // allocator for a new pointer type should be exactly the same as rebinding\n    // the pointer using 'pointer_traits'.\n    static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),\n                  \"Allocator does not rebind pointers in a sane manner.\");\n    typedef typename __rebind_alloc_helper<__node_traits, __first_node>::type\n        __node_base_allocator;\n    typedef allocator_traits<__node_base_allocator> __node_base_traits;\n    static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),\n                 \"Allocator does not rebind pointers in a sane manner.\");\n\nprivate:\n\n    typedef typename __rebind_alloc_helper<__node_traits, __next_pointer>::type __pointer_allocator;\n    typedef __bucket_list_deallocator<__pointer_allocator> __bucket_list_deleter;\n    typedef unique_ptr<__next_pointer[], __bucket_list_deleter> __bucket_list;\n    typedef allocator_traits<__pointer_allocator>          __pointer_alloc_traits;\n    typedef typename __bucket_list_deleter::pointer       __node_pointer_pointer;\n\n    // --- Member data begin ---\n    __bucket_list                                         __bucket_list_;\n    __compressed_pair<__first_node, __node_allocator>     __p1_;\n    __compressed_pair<size_type, hasher>                  __p2_;\n    __compressed_pair<float, key_equal>                   __p3_;\n    // --- Member data end ---\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& size() _NOEXCEPT {return __p2_.first();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type  size() const _NOEXCEPT {return __p2_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    hasher& hash_function() _NOEXCEPT {return __p2_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const hasher& hash_function() const _NOEXCEPT {return __p2_.second();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    float& max_load_factor() _NOEXCEPT {return __p3_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    float  max_load_factor() const _NOEXCEPT {return __p3_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    key_equal& key_eq() _NOEXCEPT {return __p3_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const key_equal& key_eq() const _NOEXCEPT {return __p3_.second();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __node_allocator& __node_alloc() _NOEXCEPT {return __p1_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __p1_.second();}\n\npublic:\n    typedef __hash_iterator<__node_pointer>                   iterator;\n    typedef __hash_const_iterator<__node_pointer>             const_iterator;\n    typedef __hash_local_iterator<__node_pointer>             local_iterator;\n    typedef __hash_const_local_iterator<__node_pointer>       const_local_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_table()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__bucket_list>::value &&\n            is_nothrow_default_constructible<__first_node>::value &&\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_default_constructible<hasher>::value &&\n            is_nothrow_default_constructible<key_equal>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_table(const hasher& __hf, const key_equal& __eql);\n    __hash_table(const hasher& __hf, const key_equal& __eql,\n                 const allocator_type& __a);\n    explicit __hash_table(const allocator_type& __a);\n    __hash_table(const __hash_table& __u);\n    __hash_table(const __hash_table& __u, const allocator_type& __a);\n#ifndef _LIBCPP_CXX03_LANG\n    __hash_table(__hash_table&& __u)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__bucket_list>::value &&\n            is_nothrow_move_constructible<__first_node>::value &&\n            is_nothrow_move_constructible<__node_allocator>::value &&\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value);\n    __hash_table(__hash_table&& __u, const allocator_type& __a);\n#endif  // _LIBCPP_CXX03_LANG\n    ~__hash_table();\n\n    __hash_table& operator=(const __hash_table& __u);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_table& operator=(__hash_table&& __u)\n        _NOEXCEPT_(\n            __node_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<__node_allocator>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n#endif\n    template <class _InputIterator>\n        void __assign_unique(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        void __assign_multi(_InputIterator __first, _InputIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n    {\n        return std::min<size_type>(\n            __node_traits::max_size(__node_alloc()),\n            numeric_limits<difference_type >::max()\n        );\n    }\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    __next_pointer __node_insert_multi_prepare(size_t __cp_hash,\n                                               value_type& __cp_val);\n    _LIBCPP_INLINE_VISIBILITY\n    void __node_insert_multi_perform(__node_pointer __cp,\n                                     __next_pointer __pn) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __next_pointer __node_insert_unique_prepare(size_t __nd_hash,\n                                                value_type& __nd_val);\n    _LIBCPP_INLINE_VISIBILITY\n    void __node_insert_unique_perform(__node_pointer __ptr) _NOEXCEPT;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator             __node_insert_multi(__node_pointer __nd);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator             __node_insert_multi(const_iterator __p,\n                                             __node_pointer __nd);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Key, class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique_key_args(_Key const& __k, _Args&&... __args);\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique(_Pp&& __x) {\n      return __emplace_unique_extract_key(_VSTD::forward<_Pp>(__x),\n                                          __can_extract_key<_Pp, key_type>());\n    }\n\n    template <class _First, class _Second>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        __can_extract_map_key<_First, key_type, __container_value_type>::value,\n        pair<iterator, bool>\n    >::type __emplace_unique(_First&& __f, _Second&& __s) {\n        return __emplace_unique_key_args(__f, _VSTD::forward<_First>(__f),\n                                              _VSTD::forward<_Second>(__s));\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique(_Args&&... __args) {\n      return __emplace_unique_impl(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {\n      return __emplace_unique_impl(_VSTD::forward<_Pp>(__x));\n    }\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {\n      return __emplace_unique_key_args(__x, _VSTD::forward<_Pp>(__x));\n    }\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {\n      return __emplace_unique_key_args(__x.first, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_multi(_Args&&... __args);\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);\n\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __insert_unique(__container_value_type&& __x) {\n      return __emplace_unique_key_args(_NodeTypes::__get_key(__x), _VSTD::move(__x));\n    }\n\n    template <class _Pp, class = typename enable_if<\n            !__is_same_uncvref<_Pp, __container_value_type>::value\n        >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(_Pp&& __x) {\n      return __emplace_unique(_VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(_Pp&& __x) {\n      return __emplace_multi(_VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const_iterator __p, _Pp&& __x) {\n        return __emplace_hint_multi(__p, _VSTD::forward<_Pp>(__x));\n    }\n\n#else  // !defined(_LIBCPP_CXX03_LANG)\n    template <class _Key, class _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique_key_args(_Key const&, _Args& __args);\n\n    iterator __insert_multi(const __container_value_type& __x);\n    iterator __insert_multi(const_iterator __p, const __container_value_type& __x);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(const __container_value_type& __x) {\n        return __emplace_unique_key_args(_NodeTypes::__get_key(__x), __x);\n    }\n\n#if _LIBCPP_STD_VER > 14\n    template <class _NodeHandle, class _InsertReturnType>\n    _LIBCPP_INLINE_VISIBILITY\n    _InsertReturnType __node_handle_insert_unique(_NodeHandle&& __nh);\n    template <class _NodeHandle>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __node_handle_insert_unique(const_iterator __hint,\n                                         _NodeHandle&& __nh);\n    template <class _Table>\n    _LIBCPP_INLINE_VISIBILITY\n    void __node_handle_merge_unique(_Table& __source);\n\n    template <class _NodeHandle>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __node_handle_insert_multi(_NodeHandle&& __nh);\n    template <class _NodeHandle>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __node_handle_insert_multi(const_iterator __hint, _NodeHandle&& __nh);\n    template <class _Table>\n    _LIBCPP_INLINE_VISIBILITY\n    void __node_handle_merge_multi(_Table& __source);\n\n    template <class _NodeHandle>\n    _LIBCPP_INLINE_VISIBILITY\n    _NodeHandle __node_handle_extract(key_type const& __key);\n    template <class _NodeHandle>\n    _LIBCPP_INLINE_VISIBILITY\n    _NodeHandle __node_handle_extract(const_iterator __it);\n#endif\n\n    void clear() _NOEXCEPT;\n    void rehash(size_type __n);\n    _LIBCPP_INLINE_VISIBILITY void reserve(size_type __n)\n        {rehash(static_cast<size_type>(ceil(__n / max_load_factor())));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_count() const _NOEXCEPT\n    {\n        return __bucket_list_.get_deleter().size();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       begin() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       end() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT;\n\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        size_type bucket(const _Key& __k) const\n        {\n            _LIBCPP_ASSERT(bucket_count() > 0,\n                \"unordered container::bucket(key) called when bucket_count() == 0\");\n            return __constrain_hash(hash_function()(__k), bucket_count());\n        }\n\n    template <class _Key>\n        iterator       find(const _Key& __x);\n    template <class _Key>\n        const_iterator find(const _Key& __x) const;\n\n    typedef __hash_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __first, const_iterator __last);\n    template <class _Key>\n        size_type __erase_unique(const _Key& __k);\n    template <class _Key>\n        size_type __erase_multi(const _Key& __k);\n    __node_holder remove(const_iterator __p) _NOEXCEPT;\n\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __count_unique(const _Key& __k) const;\n    template <class _Key>\n        size_type __count_multi(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_unique(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_unique(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_multi(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_multi(const _Key& __k) const;\n\n    void swap(__hash_table& __u)\n#if _LIBCPP_STD_VER <= 11\n        _NOEXCEPT_DEBUG_(\n            __is_nothrow_swappable<hasher>::value && __is_nothrow_swappable<key_equal>::value\n            && (!allocator_traits<__pointer_allocator>::propagate_on_container_swap::value\n                  || __is_nothrow_swappable<__pointer_allocator>::value)\n            && (!__node_traits::propagate_on_container_swap::value\n                  || __is_nothrow_swappable<__node_allocator>::value)\n            );\n#else\n     _NOEXCEPT_DEBUG_(__is_nothrow_swappable<hasher>::value && __is_nothrow_swappable<key_equal>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_bucket_count() const _NOEXCEPT\n        {return max_size(); }\n    size_type bucket_size(size_type __n) const;\n    _LIBCPP_INLINE_VISIBILITY float load_factor() const _NOEXCEPT\n    {\n        size_type __bc = bucket_count();\n        return __bc != 0 ? (float)size() / __bc : 0.f;\n    }\n    _LIBCPP_INLINE_VISIBILITY void max_load_factor(float __mlf) _NOEXCEPT\n    {\n        _LIBCPP_ASSERT(__mlf > 0,\n            \"unordered container::max_load_factor(lf) called with lf <= 0\");\n        max_load_factor() = _VSTD::max(__mlf, load_factor());\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator\n    begin(size_type __n)\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::begin(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return local_iterator(__bucket_list_[__n], __n, bucket_count(), this);\n#else\n        return local_iterator(__bucket_list_[__n], __n, bucket_count());\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator\n    end(size_type __n)\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::end(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return local_iterator(nullptr, __n, bucket_count(), this);\n#else\n        return local_iterator(nullptr, __n, bucket_count());\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator\n    cbegin(size_type __n) const\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::cbegin(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_local_iterator(__bucket_list_[__n], __n, bucket_count(), this);\n#else\n        return const_local_iterator(__bucket_list_[__n], __n, bucket_count());\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator\n    cend(size_type __n) const\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::cend(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_local_iterator(nullptr, __n, bucket_count(), this);\n#else\n        return const_local_iterator(nullptr, __n, bucket_count());\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    void __rehash(size_type __n);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class ..._Args>\n    __node_holder __construct_node(_Args&& ...__args);\n\n    template <class _First, class ..._Rest>\n    __node_holder __construct_node_hash(size_t __hash, _First&& __f, _Rest&&... __rest);\n#else // _LIBCPP_CXX03_LANG\n    __node_holder __construct_node(const __container_value_type& __v);\n    __node_holder __construct_node_hash(size_t __hash, const __container_value_type& __v);\n#endif\n\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __hash_table& __u)\n        {__copy_assign_alloc(__u, integral_constant<bool,\n             __node_traits::propagate_on_container_copy_assignment::value>());}\n    void __copy_assign_alloc(const __hash_table& __u, true_type);\n    _LIBCPP_INLINE_VISIBILITY\n        void __copy_assign_alloc(const __hash_table&, false_type) {}\n\n#ifndef _LIBCPP_CXX03_LANG\n    void __move_assign(__hash_table& __u, false_type);\n    void __move_assign(__hash_table& __u, true_type)\n        _NOEXCEPT_(\n            is_nothrow_move_assignable<__node_allocator>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__hash_table& __u)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_move_assignment::value ||\n            (is_nothrow_move_assignable<__pointer_allocator>::value &&\n             is_nothrow_move_assignable<__node_allocator>::value))\n        {__move_assign_alloc(__u, integral_constant<bool,\n             __node_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__hash_table& __u, true_type)\n        _NOEXCEPT_(\n            is_nothrow_move_assignable<__pointer_allocator>::value &&\n            is_nothrow_move_assignable<__node_allocator>::value)\n    {\n        __bucket_list_.get_deleter().__alloc() =\n                _VSTD::move(__u.__bucket_list_.get_deleter().__alloc());\n        __node_alloc() = _VSTD::move(__u.__node_alloc());\n    }\n    _LIBCPP_INLINE_VISIBILITY\n        void __move_assign_alloc(__hash_table&, false_type) _NOEXCEPT {}\n#endif // _LIBCPP_CXX03_LANG\n\n    void __deallocate_node(__next_pointer __np) _NOEXCEPT;\n    __next_pointer __detach() _NOEXCEPT;\n\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;\n};\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table()\n    _NOEXCEPT_(\n        is_nothrow_default_constructible<__bucket_list>::value &&\n        is_nothrow_default_constructible<__first_node>::value &&\n        is_nothrow_default_constructible<__node_allocator>::value &&\n        is_nothrow_default_constructible<hasher>::value &&\n        is_nothrow_default_constructible<key_equal>::value)\n    : __p2_(0),\n      __p3_(1.0f)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,\n                                                       const key_equal& __eql)\n    : __bucket_list_(nullptr, __bucket_list_deleter()),\n      __p1_(),\n      __p2_(0, __hf),\n      __p3_(1.0f, __eql)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,\n                                                       const key_equal& __eql,\n                                                       const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__second_tag(), __node_allocator(__a)),\n      __p2_(0, __hf),\n      __p3_(1.0f, __eql)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__second_tag(), __node_allocator(__a)),\n      __p2_(0),\n      __p3_(1.0f)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u)\n    : __bucket_list_(nullptr,\n          __bucket_list_deleter(allocator_traits<__pointer_allocator>::\n              select_on_container_copy_construction(\n                  __u.__bucket_list_.get_deleter().__alloc()), 0)),\n      __p1_(__second_tag(), allocator_traits<__node_allocator>::\n          select_on_container_copy_construction(__u.__node_alloc())),\n      __p2_(0, __u.hash_function()),\n      __p3_(__u.__p3_)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u,\n                                                       const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__second_tag(), __node_allocator(__a)),\n      __p2_(0, __u.hash_function()),\n      __p3_(__u.__p3_)\n{\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__bucket_list>::value &&\n            is_nothrow_move_constructible<__first_node>::value &&\n            is_nothrow_move_constructible<__node_allocator>::value &&\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value)\n    : __bucket_list_(_VSTD::move(__u.__bucket_list_)),\n      __p1_(_VSTD::move(__u.__p1_)),\n      __p2_(_VSTD::move(__u.__p2_)),\n      __p3_(_VSTD::move(__u.__p3_))\n{\n    if (size() > 0)\n    {\n        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =\n            __p1_.first().__ptr();\n        __u.__p1_.first().__next_ = nullptr;\n        __u.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u,\n                                                       const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__second_tag(), __node_allocator(__a)),\n      __p2_(0, _VSTD::move(__u.hash_function())),\n      __p3_(_VSTD::move(__u.__p3_))\n{\n    if (__a == allocator_type(__u.__node_alloc()))\n    {\n        __bucket_list_.reset(__u.__bucket_list_.release());\n        __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();\n        __u.__bucket_list_.get_deleter().size() = 0;\n        if (__u.size() > 0)\n        {\n            __p1_.first().__next_ = __u.__p1_.first().__next_;\n            __u.__p1_.first().__next_ = nullptr;\n            __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =\n                __p1_.first().__ptr();\n            size() = __u.size();\n            __u.size() = 0;\n        }\n    }\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::~__hash_table()\n{\n#if defined(_LIBCPP_CXX03_LANG)\n    static_assert((is_copy_constructible<key_equal>::value),\n                 \"Predicate must be copy-constructible.\");\n    static_assert((is_copy_constructible<hasher>::value),\n                 \"Hasher must be copy-constructible.\");\n#endif\n\n    __deallocate_node(__p1_.first().__next_);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__copy_assign_alloc(\n        const __hash_table& __u, true_type)\n{\n    if (__node_alloc() != __u.__node_alloc())\n    {\n        clear();\n        __bucket_list_.reset();\n        __bucket_list_.get_deleter().size() = 0;\n    }\n    __bucket_list_.get_deleter().__alloc() = __u.__bucket_list_.get_deleter().__alloc();\n    __node_alloc() = __u.__node_alloc();\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>&\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(const __hash_table& __u)\n{\n    if (this != &__u)\n    {\n        __copy_assign_alloc(__u);\n        hash_function() = __u.hash_function();\n        key_eq() = __u.key_eq();\n        max_load_factor() = __u.max_load_factor();\n        __assign_multi(__u.begin(), __u.end());\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__deallocate_node(__next_pointer __np)\n    _NOEXCEPT\n{\n    __node_allocator& __na = __node_alloc();\n    while (__np != nullptr)\n    {\n        __next_pointer __next = __np->__next_;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __c_node* __c = __get_db()->__find_c_and_lock(this);\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            iterator* __i = static_cast<iterator*>((*__p)->__i_);\n            if (__i->__node_ == __np)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n#endif\n        __node_pointer __real_np = __np->__upcast();\n        __node_traits::destroy(__na, _NodeTypes::__get_ptr(__real_np->__value_));\n        __node_traits::deallocate(__na, __real_np, 1);\n        __np = __next;\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__next_pointer\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__detach() _NOEXCEPT\n{\n    size_type __bc = bucket_count();\n    for (size_type __i = 0; __i < __bc; ++__i)\n        __bucket_list_[__i] = nullptr;\n    size() = 0;\n    __next_pointer __cache = __p1_.first().__next_;\n    __p1_.first().__next_ = nullptr;\n    return __cache;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(\n        __hash_table& __u, true_type)\n    _NOEXCEPT_(\n        is_nothrow_move_assignable<__node_allocator>::value &&\n        is_nothrow_move_assignable<hasher>::value &&\n        is_nothrow_move_assignable<key_equal>::value)\n{\n    clear();\n    __bucket_list_.reset(__u.__bucket_list_.release());\n    __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();\n    __u.__bucket_list_.get_deleter().size() = 0;\n    __move_assign_alloc(__u);\n    size() = __u.size();\n    hash_function() = _VSTD::move(__u.hash_function());\n    max_load_factor() = __u.max_load_factor();\n    key_eq() = _VSTD::move(__u.key_eq());\n    __p1_.first().__next_ = __u.__p1_.first().__next_;\n    if (size() > 0)\n    {\n        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =\n            __p1_.first().__ptr();\n        __u.__p1_.first().__next_ = nullptr;\n        __u.size() = 0;\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(\n        __hash_table& __u, false_type)\n{\n    if (__node_alloc() == __u.__node_alloc())\n        __move_assign(__u, true_type());\n    else\n    {\n        hash_function() = _VSTD::move(__u.hash_function());\n        key_eq() = _VSTD::move(__u.key_eq());\n        max_load_factor() = __u.max_load_factor();\n        if (bucket_count() != 0)\n        {\n            __next_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                const_iterator __i = __u.begin();\n                while (__cache != nullptr && __u.size() != 0)\n                {\n                    __cache->__upcast()->__value_ =\n                        _VSTD::move(__u.remove(__i++)->__value_);\n                    __next_pointer __next = __cache->__next_;\n                    __node_insert_multi(__cache->__upcast());\n                    __cache = __next;\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                __deallocate_node(__cache);\n                throw;\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __deallocate_node(__cache);\n        }\n        const_iterator __i = __u.begin();\n        while (__u.size() != 0)\n        {\n            __node_holder __h = __construct_node(_NodeTypes::__move(__u.remove(__i++)->__value_));\n            __node_insert_multi(__h.get());\n            __h.release();\n        }\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\n__hash_table<_Tp, _Hash, _Equal, _Alloc>&\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(__hash_table&& __u)\n    _NOEXCEPT_(\n        __node_traits::propagate_on_container_move_assignment::value &&\n        is_nothrow_move_assignable<__node_allocator>::value &&\n        is_nothrow_move_assignable<hasher>::value &&\n        is_nothrow_move_assignable<key_equal>::value)\n{\n    __move_assign(__u, integral_constant<bool,\n                  __node_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _InputIterator>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_unique(_InputIterator __first,\n                                                          _InputIterator __last)\n{\n    typedef iterator_traits<_InputIterator> _ITraits;\n    typedef typename _ITraits::value_type _ItValueType;\n    static_assert((is_same<_ItValueType, __container_value_type>::value),\n                  \"__assign_unique may only be called with the containers value type\");\n\n    if (bucket_count() != 0)\n    {\n        __next_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__upcast()->__value_ = *__first;\n                __next_pointer __next = __cache->__next_;\n                __node_insert_unique(__cache->__upcast());\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            __deallocate_node(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __deallocate_node(__cache);\n    }\n    for (; __first != __last; ++__first)\n        __insert_unique(*__first);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _InputIterator>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_multi(_InputIterator __first,\n                                                         _InputIterator __last)\n{\n    typedef iterator_traits<_InputIterator> _ITraits;\n    typedef typename _ITraits::value_type _ItValueType;\n    static_assert((is_same<_ItValueType, __container_value_type>::value ||\n                  is_same<_ItValueType, __node_value_type>::value),\n                  \"__assign_multi may only be called with the containers value type\"\n                  \" or the nodes value type\");\n    if (bucket_count() != 0)\n    {\n        __next_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__upcast()->__value_ = *__first;\n                __next_pointer __next = __cache->__next_;\n                __node_insert_multi(__cache->__upcast());\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            __deallocate_node(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __deallocate_node(__cache);\n    }\n    for (; __first != __last; ++__first)\n        __insert_multi(_NodeTypes::__get_value(*__first));\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__p1_.first().__next_, this);\n#else\n    return iterator(__p1_.first().__next_);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(nullptr, this);\n#else\n    return iterator(nullptr);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(__p1_.first().__next_, this);\n#else\n    return const_iterator(__p1_.first().__next_);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(nullptr, this);\n#else\n    return const_iterator(nullptr);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::clear() _NOEXCEPT\n{\n    if (size() > 0)\n    {\n        __deallocate_node(__p1_.first().__next_);\n        __p1_.first().__next_ = nullptr;\n        size_type __bc = bucket_count();\n        for (size_type __i = 0; __i < __bc; ++__i)\n            __bucket_list_[__i] = nullptr;\n        size() = 0;\n    }\n}\n\n\n// Prepare the container for an insertion of the value __value with the hash\n// __hash. This does a lookup into the container to see if __value is already\n// present, and performs a rehash if necessary. Returns a pointer to the\n// existing element if it exists, otherwise nullptr.\n//\n// Note that this function does forward exceptions if key_eq() throws, and never\n// mutates __value or actually inserts into the map.\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n_LIBCPP_INLINE_VISIBILITY\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__next_pointer\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique_prepare(\n    size_t __hash, value_type& __value)\n{\n    size_type __bc = bucket_count();\n\n    if (__bc != 0)\n    {\n        size_t __chash = __constrain_hash(__hash, __bc);\n        __next_pointer __ndptr = __bucket_list_[__chash];\n        if (__ndptr != nullptr)\n        {\n            for (__ndptr = __ndptr->__next_; __ndptr != nullptr &&\n                                             __constrain_hash(__ndptr->__hash(), __bc) == __chash;\n                                                     __ndptr = __ndptr->__next_)\n            {\n                if (key_eq()(__ndptr->__upcast()->__value_, __value))\n                    return __ndptr;\n            }\n        }\n    }\n    if (size()+1 > __bc * max_load_factor() || __bc == 0)\n    {\n        rehash(_VSTD::max<size_type>(2 * __bc + !__is_hash_power2(__bc),\n                                     size_type(ceil(float(size() + 1) / max_load_factor()))));\n    }\n    return nullptr;\n}\n\n// Insert the node __nd into the container by pushing it into the right bucket,\n// and updating size(). Assumes that __nd->__hash is up-to-date, and that\n// rehashing has already occurred and that no element with the same key exists\n// in the map.\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n_LIBCPP_INLINE_VISIBILITY\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique_perform(\n    __node_pointer __nd) _NOEXCEPT\n{\n    size_type __bc = bucket_count();\n    size_t __chash = __constrain_hash(__nd->__hash(), __bc);\n    // insert_after __bucket_list_[__chash], or __first_node if bucket is null\n    __next_pointer __pn = __bucket_list_[__chash];\n    if (__pn == nullptr)\n    {\n        __pn =__p1_.first().__ptr();\n        __nd->__next_ = __pn->__next_;\n        __pn->__next_ = __nd->__ptr();\n        // fix up __bucket_list_\n        __bucket_list_[__chash] = __pn;\n        if (__nd->__next_ != nullptr)\n            __bucket_list_[__constrain_hash(__nd->__next_->__hash(), __bc)] = __nd->__ptr();\n    }\n    else\n    {\n        __nd->__next_ = __pn->__next_;\n        __pn->__next_ = __nd->__ptr();\n    }\n    ++size();\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique(__node_pointer __nd)\n{\n    __nd->__hash_ = hash_function()(__nd->__value_);\n    __next_pointer __existing_node =\n        __node_insert_unique_prepare(__nd->__hash(), __nd->__value_);\n\n    // Insert the node, unless it already exists in the container.\n    bool __inserted = false;\n    if (__existing_node == nullptr)\n    {\n        __node_insert_unique_perform(__nd);\n        __existing_node = __nd->__ptr();\n        __inserted = true;\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return pair<iterator, bool>(iterator(__existing_node, this), __inserted);\n#else\n    return pair<iterator, bool>(iterator(__existing_node), __inserted);\n#endif\n}\n\n// Prepare the container for an insertion of the value __cp_val with the hash\n// __cp_hash. This does a lookup into the container to see if __cp_value is\n// already present, and performs a rehash if necessary. Returns a pointer to the\n// last occurance of __cp_val in the map.\n//\n// Note that this function does forward exceptions if key_eq() throws, and never\n// mutates __value or actually inserts into the map.\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__next_pointer\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi_prepare(\n    size_t __cp_hash, value_type& __cp_val)\n{\n    size_type __bc = bucket_count();\n    if (size()+1 > __bc * max_load_factor() || __bc == 0)\n    {\n        rehash(_VSTD::max<size_type>(2 * __bc + !__is_hash_power2(__bc),\n                       size_type(ceil(float(size() + 1) / max_load_factor()))));\n        __bc = bucket_count();\n    }\n    size_t __chash = __constrain_hash(__cp_hash, __bc);\n    __next_pointer __pn = __bucket_list_[__chash];\n    if (__pn != nullptr)\n    {\n        for (bool __found = false; __pn->__next_ != nullptr &&\n                                   __constrain_hash(__pn->__next_->__hash(), __bc) == __chash;\n                                                           __pn = __pn->__next_)\n        {\n            //      __found    key_eq()     action\n            //      false       false       loop\n            //      true        true        loop\n            //      false       true        set __found to true\n            //      true        false       break\n            if (__found != (__pn->__next_->__hash() == __cp_hash &&\n                            key_eq()(__pn->__next_->__upcast()->__value_, __cp_val)))\n            {\n                if (!__found)\n                    __found = true;\n                else\n                    break;\n            }\n        }\n    }\n    return __pn;\n}\n\n// Insert the node __cp into the container after __pn (which is the last node in\n// the bucket that compares equal to __cp). Rehashing, and checking for\n// uniqueness has already been performed (in __node_insert_multi_prepare), so\n// all we need to do is update the bucket and size(). Assumes that __cp->__hash\n// is up-to-date.\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi_perform(\n    __node_pointer __cp, __next_pointer __pn) _NOEXCEPT\n{\n    size_type __bc = bucket_count();\n    size_t __chash = __constrain_hash(__cp->__hash_, __bc);\n    if (__pn == nullptr)\n    {\n        __pn =__p1_.first().__ptr();\n        __cp->__next_ = __pn->__next_;\n        __pn->__next_ = __cp->__ptr();\n        // fix up __bucket_list_\n        __bucket_list_[__chash] = __pn;\n        if (__cp->__next_ != nullptr)\n            __bucket_list_[__constrain_hash(__cp->__next_->__hash(), __bc)]\n                = __cp->__ptr();\n    }\n    else\n    {\n        __cp->__next_ = __pn->__next_;\n        __pn->__next_ = __cp->__ptr();\n        if (__cp->__next_ != nullptr)\n        {\n            size_t __nhash = __constrain_hash(__cp->__next_->__hash(), __bc);\n            if (__nhash != __chash)\n                __bucket_list_[__nhash] = __cp->__ptr();\n        }\n    }\n    ++size();\n}\n\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(__node_pointer __cp)\n{\n    __cp->__hash_ = hash_function()(__cp->__value_);\n    __next_pointer __pn = __node_insert_multi_prepare(__cp->__hash(), __cp->__value_);\n    __node_insert_multi_perform(__cp, __pn);\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__cp->__ptr(), this);\n#else\n    return iterator(__cp->__ptr());\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(\n        const_iterator __p, __node_pointer __cp)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container::emplace_hint(const_iterator, args...) called with an iterator not\"\n        \" referring to this unordered container\");\n#endif\n    if (__p != end() && key_eq()(*__p, __cp->__value_))\n    {\n        __next_pointer __np = __p.__node_;\n        __cp->__hash_ = __np->__hash();\n        size_type __bc = bucket_count();\n        if (size()+1 > __bc * max_load_factor() || __bc == 0)\n        {\n            rehash(_VSTD::max<size_type>(2 * __bc + !__is_hash_power2(__bc),\n                           size_type(ceil(float(size() + 1) / max_load_factor()))));\n            __bc = bucket_count();\n        }\n        size_t __chash = __constrain_hash(__cp->__hash_, __bc);\n        __next_pointer __pp = __bucket_list_[__chash];\n        while (__pp->__next_ != __np)\n            __pp = __pp->__next_;\n        __cp->__next_ = __np;\n        __pp->__next_ = static_cast<__next_pointer>(__cp);\n        ++size();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return iterator(static_cast<__next_pointer>(__cp), this);\n#else\n        return iterator(static_cast<__next_pointer>(__cp));\n#endif\n    }\n    return __node_insert_multi(__cp);\n}\n\n\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key, class ..._Args>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args)\n#else\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key, class _Args>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_key_args(_Key const& __k, _Args& __args)\n#endif\n{\n\n    size_t __hash = hash_function()(__k);\n    size_type __bc = bucket_count();\n    bool __inserted = false;\n    __next_pointer __nd;\n    size_t __chash;\n    if (__bc != 0)\n    {\n        __chash = __constrain_hash(__hash, __bc);\n        __nd = __bucket_list_[__chash];\n        if (__nd != nullptr)\n        {\n            for (__nd = __nd->__next_; __nd != nullptr &&\n                (__nd->__hash() == __hash || __constrain_hash(__nd->__hash(), __bc) == __chash);\n                                                           __nd = __nd->__next_)\n            {\n                if (key_eq()(__nd->__upcast()->__value_, __k))\n                    goto __done;\n            }\n        }\n    }\n    {\n#ifndef _LIBCPP_CXX03_LANG\n        __node_holder __h = __construct_node_hash(__hash, _VSTD::forward<_Args>(__args)...);\n#else\n        __node_holder __h = __construct_node_hash(__hash, __args);\n#endif\n        if (size()+1 > __bc * max_load_factor() || __bc == 0)\n        {\n            rehash(_VSTD::max<size_type>(2 * __bc + !__is_hash_power2(__bc),\n                           size_type(ceil(float(size() + 1) / max_load_factor()))));\n            __bc = bucket_count();\n            __chash = __constrain_hash(__hash, __bc);\n        }\n        // insert_after __bucket_list_[__chash], or __first_node if bucket is null\n        __next_pointer __pn = __bucket_list_[__chash];\n        if (__pn == nullptr)\n        {\n            __pn = __p1_.first().__ptr();\n            __h->__next_ = __pn->__next_;\n            __pn->__next_ = __h.get()->__ptr();\n            // fix up __bucket_list_\n            __bucket_list_[__chash] = __pn;\n            if (__h->__next_ != nullptr)\n                __bucket_list_[__constrain_hash(__h->__next_->__hash(), __bc)]\n                    = __h.get()->__ptr();\n        }\n        else\n        {\n            __h->__next_ = __pn->__next_;\n            __pn->__next_ = static_cast<__next_pointer>(__h.get());\n        }\n        __nd = static_cast<__next_pointer>(__h.release());\n        // increment size\n        ++size();\n        __inserted = true;\n    }\n__done:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return pair<iterator, bool>(iterator(__nd, this), __inserted);\n#else\n    return pair<iterator, bool>(iterator(__nd), __inserted);\n#endif\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class... _Args>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_impl(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    pair<iterator, bool> __r = __node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class... _Args>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_multi(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class... _Args>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_hint_multi(\n        const_iterator __p, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container::emplace_hint(const_iterator, args...) called with an iterator not\"\n        \" referring to this unordered container\");\n#endif\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __node_insert_multi(__p, __h.get());\n    __h.release();\n    return __r;\n}\n\n#else // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_multi(const __container_value_type& __x)\n{\n    __node_holder __h = __construct_node(__x);\n    iterator __r = __node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_multi(const_iterator __p,\n                                                         const __container_value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container::insert(const_iterator, lvalue) called with an iterator not\"\n        \" referring to this unordered container\");\n#endif\n    __node_holder __h = __construct_node(__x);\n    iterator __r = __node_insert_multi(__p, __h.get());\n    __h.release();\n    return __r;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _NodeHandle, class _InsertReturnType>\n_LIBCPP_INLINE_VISIBILITY\n_InsertReturnType\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_insert_unique(\n    _NodeHandle&& __nh)\n{\n    if (__nh.empty())\n        return _InsertReturnType{end(), false, _NodeHandle()};\n    pair<iterator, bool> __result = __node_insert_unique(__nh.__ptr_);\n    if (__result.second)\n        __nh.__release();\n    return _InsertReturnType{__result.first, __result.second, _VSTD::move(__nh)};\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _NodeHandle>\n_LIBCPP_INLINE_VISIBILITY\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_insert_unique(\n    const_iterator, _NodeHandle&& __nh)\n{\n    if (__nh.empty())\n        return end();\n    pair<iterator, bool> __result = __node_insert_unique(__nh.__ptr_);\n    if (__result.second)\n        __nh.__release();\n    return __result.first;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _NodeHandle>\n_LIBCPP_INLINE_VISIBILITY\n_NodeHandle\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_extract(\n    key_type const& __key)\n{\n    iterator __i = find(__key);\n    if (__i == end())\n        return _NodeHandle();\n    return __node_handle_extract<_NodeHandle>(__i);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _NodeHandle>\n_LIBCPP_INLINE_VISIBILITY\n_NodeHandle\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_extract(\n    const_iterator __p)\n{\n    allocator_type __alloc(__node_alloc());\n    return _NodeHandle(remove(__p).release(), __alloc);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Table>\n_LIBCPP_INLINE_VISIBILITY\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_merge_unique(\n    _Table& __source)\n{\n    static_assert(is_same<__node, typename _Table::__node>::value, \"\");\n\n    for (typename _Table::iterator __it = __source.begin();\n         __it != __source.end();)\n    {\n        __node_pointer __src_ptr = __it.__node_->__upcast();\n        size_t __hash = hash_function()(__src_ptr->__value_);\n        __next_pointer __existing_node =\n            __node_insert_unique_prepare(__hash, __src_ptr->__value_);\n        auto __prev_iter = __it++;\n        if (__existing_node == nullptr)\n        {\n            (void)__source.remove(__prev_iter).release();\n            __src_ptr->__hash_ = __hash;\n            __node_insert_unique_perform(__src_ptr);\n        }\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _NodeHandle>\n_LIBCPP_INLINE_VISIBILITY\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_insert_multi(\n    _NodeHandle&& __nh)\n{\n    if (__nh.empty())\n        return end();\n    iterator __result = __node_insert_multi(__nh.__ptr_);\n    __nh.__release();\n    return __result;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _NodeHandle>\n_LIBCPP_INLINE_VISIBILITY\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_insert_multi(\n    const_iterator __hint, _NodeHandle&& __nh)\n{\n    if (__nh.empty())\n        return end();\n    iterator __result = __node_insert_multi(__hint, __nh.__ptr_);\n    __nh.__release();\n    return __result;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Table>\n_LIBCPP_INLINE_VISIBILITY\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_merge_multi(\n    _Table& __source)\n{\n    static_assert(is_same<typename _Table::__node, __node>::value, \"\");\n\n    for (typename _Table::iterator __it = __source.begin();\n         __it != __source.end();)\n    {\n        __node_pointer __src_ptr = __it.__node_->__upcast();\n        size_t __src_hash = hash_function()(__src_ptr->__value_);\n        __next_pointer __pn =\n            __node_insert_multi_prepare(__src_hash, __src_ptr->__value_);\n        (void)__source.remove(__it++).release();\n        __src_ptr->__hash_ = __src_hash;\n        __node_insert_multi_perform(__src_ptr, __pn);\n    }\n}\n#endif  // _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::rehash(size_type __n)\n{\n    if (__n == 1)\n        __n = 2;\n    else if (__n & (__n - 1))\n        __n = __next_prime(__n);\n    size_type __bc = bucket_count();\n    if (__n > __bc)\n        __rehash(__n);\n    else if (__n < __bc)\n    {\n        __n = _VSTD::max<size_type>\n              (\n                  __n,\n                  __is_hash_power2(__bc) ? __next_hash_pow2(size_t(ceil(float(size()) / max_load_factor()))) :\n                                           __next_prime(size_t(ceil(float(size()) / max_load_factor())))\n              );\n        if (__n < __bc)\n            __rehash(__n);\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__rehash(size_type __nbc)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    __pointer_allocator& __npa = __bucket_list_.get_deleter().__alloc();\n    __bucket_list_.reset(__nbc > 0 ?\n                      __pointer_alloc_traits::allocate(__npa, __nbc) : nullptr);\n    __bucket_list_.get_deleter().size() = __nbc;\n    if (__nbc > 0)\n    {\n        for (size_type __i = 0; __i < __nbc; ++__i)\n            __bucket_list_[__i] = nullptr;\n        __next_pointer __pp = __p1_.first().__ptr();\n        __next_pointer __cp = __pp->__next_;\n        if (__cp != nullptr)\n        {\n            size_type __chash = __constrain_hash(__cp->__hash(), __nbc);\n            __bucket_list_[__chash] = __pp;\n            size_type __phash = __chash;\n            for (__pp = __cp, __cp = __cp->__next_; __cp != nullptr;\n                                                           __cp = __pp->__next_)\n            {\n                __chash = __constrain_hash(__cp->__hash(), __nbc);\n                if (__chash == __phash)\n                    __pp = __cp;\n                else\n                {\n                    if (__bucket_list_[__chash] == nullptr)\n                    {\n                        __bucket_list_[__chash] = __pp;\n                        __pp = __cp;\n                        __phash = __chash;\n                    }\n                    else\n                    {\n                        __next_pointer __np = __cp;\n                        for (; __np->__next_ != nullptr &&\n                               key_eq()(__cp->__upcast()->__value_,\n                                        __np->__next_->__upcast()->__value_);\n                                                           __np = __np->__next_)\n                            ;\n                        __pp->__next_ = __np->__next_;\n                        __np->__next_ = __bucket_list_[__chash]->__next_;\n                        __bucket_list_[__chash]->__next_ = __cp;\n\n                    }\n                }\n            }\n        }\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k)\n{\n    size_t __hash = hash_function()(__k);\n    size_type __bc = bucket_count();\n    if (__bc != 0)\n    {\n        size_t __chash = __constrain_hash(__hash, __bc);\n        __next_pointer __nd = __bucket_list_[__chash];\n        if (__nd != nullptr)\n        {\n            for (__nd = __nd->__next_; __nd != nullptr &&\n                (__nd->__hash() == __hash\n                  || __constrain_hash(__nd->__hash(), __bc) == __chash);\n                                                           __nd = __nd->__next_)\n            {\n                if ((__nd->__hash() == __hash)\n                    && key_eq()(__nd->__upcast()->__value_, __k))\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                    return iterator(__nd, this);\n#else\n                    return iterator(__nd);\n#endif\n            }\n        }\n    }\n    return end();\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k) const\n{\n    size_t __hash = hash_function()(__k);\n    size_type __bc = bucket_count();\n    if (__bc != 0)\n    {\n        size_t __chash = __constrain_hash(__hash, __bc);\n        __next_pointer __nd = __bucket_list_[__chash];\n        if (__nd != nullptr)\n        {\n            for (__nd = __nd->__next_; __nd != nullptr &&\n                (__hash == __nd->__hash()\n                    || __constrain_hash(__nd->__hash(), __bc) == __chash);\n                                                           __nd = __nd->__next_)\n            {\n                if ((__nd->__hash() == __hash)\n                    && key_eq()(__nd->__upcast()->__value_, __k))\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                    return const_iterator(__nd, this);\n#else\n                    return const_iterator(__nd);\n#endif\n            }\n        }\n\n    }\n    return end();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class ..._Args>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(_Args&& ...__args)\n{\n    static_assert(!__is_hash_value_type<_Args...>::value,\n                  \"Construct cannot be called with a hash value type\");\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = hash_function()(__h->__value_);\n    __h->__next_ = nullptr;\n    return __h;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _First, class ..._Rest>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node_hash(\n    size_t __hash, _First&& __f, _Rest&& ...__rest)\n{\n    static_assert(!__is_hash_value_type<_First, _Rest...>::value,\n                  \"Construct cannot be called with a hash value type\");\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_),\n                             _VSTD::forward<_First>(__f),\n                             _VSTD::forward<_Rest>(__rest)...);\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = __hash;\n    __h->__next_ = nullptr;\n    return __h;\n}\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(const __container_value_type& __v)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = hash_function()(__h->__value_);\n    __h->__next_ = nullptr;\n    return _LIBCPP_EXPLICIT_MOVE(__h);  // explicitly moved for C++03\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node_hash(size_t __hash,\n                                                                const __container_value_type& __v)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = __hash;\n    __h->__next_ = nullptr;\n    return _LIBCPP_EXPLICIT_MOVE(__h);  // explicitly moved for C++03\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __p)\n{\n    __next_pointer __np = __p.__node_;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container erase(iterator) called with an iterator not\"\n        \" referring to this container\");\n    _LIBCPP_ASSERT(__p != end(),\n        \"unordered container erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __r(__np, this);\n#else\n    iterator __r(__np);\n#endif\n    ++__r;\n    remove(__p);\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __first,\n                                                const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"unodered container::erase(iterator, iterator) called with an iterator not\"\n        \" referring to this unodered container\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__last) == this,\n        \"unodered container::erase(iterator, iterator) called with an iterator not\"\n        \" referring to this unodered container\");\n#endif\n    for (const_iterator __p = __first; __first != __last; __p = __first)\n    {\n        ++__first;\n        erase(__p);\n    }\n    __next_pointer __np = __last.__node_;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator (__np, this);\n#else\n    return iterator (__np);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_unique(const _Key& __k)\n{\n    iterator __i = find(__k);\n    if (__i == end())\n        return 0;\n    erase(__i);\n    return 1;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_multi(const _Key& __k)\n{\n    size_type __r = 0;\n    iterator __i = find(__k);\n    if (__i != end())\n    {\n        iterator __e = end();\n        do\n        {\n            erase(__i++);\n            ++__r;\n        } while (__i != __e && key_eq()(*__i, __k));\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::remove(const_iterator __p) _NOEXCEPT\n{\n    // current node\n    __next_pointer __cn = __p.__node_;\n    size_type __bc = bucket_count();\n    size_t __chash = __constrain_hash(__cn->__hash(), __bc);\n    // find previous node\n    __next_pointer __pn = __bucket_list_[__chash];\n    for (; __pn->__next_ != __cn; __pn = __pn->__next_)\n        ;\n    // Fix up __bucket_list_\n        // if __pn is not in same bucket (before begin is not in same bucket) &&\n        //    if __cn->__next_ is not in same bucket (nullptr is not in same bucket)\n    if (__pn == __p1_.first().__ptr()\n            || __constrain_hash(__pn->__hash(), __bc) != __chash)\n    {\n        if (__cn->__next_ == nullptr\n            || __constrain_hash(__cn->__next_->__hash(), __bc) != __chash)\n            __bucket_list_[__chash] = nullptr;\n    }\n        // if __cn->__next_ is not in same bucket (nullptr is in same bucket)\n    if (__cn->__next_ != nullptr)\n    {\n        size_t __nhash = __constrain_hash(__cn->__next_->__hash(), __bc);\n        if (__nhash != __chash)\n            __bucket_list_[__nhash] = __pn;\n    }\n    // remove __cn\n    __pn->__next_ = __cn->__next_;\n    __cn->__next_ = nullptr;\n    --size();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __dp = __c->end_; __dp != __c->beg_; )\n    {\n        --__dp;\n        iterator* __i = static_cast<iterator*>((*__dp)->__i_);\n        if (__i->__node_ == __cn)\n        {\n            (*__dp)->__c_ = nullptr;\n            if (--__c->end_ != __dp)\n                memmove(__dp, __dp+1, (__c->end_ - __dp)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    return __node_holder(__cn->__upcast(), _Dp(__node_alloc(), true));\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ninline\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_unique(const _Key& __k) const\n{\n    return static_cast<size_type>(find(__k) != end());\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_multi(const _Key& __k) const\n{\n    size_type __r = 0;\n    const_iterator __i = find(__k);\n    if (__i != end())\n    {\n        const_iterator __e = end();\n        do\n        {\n            ++__i;\n            ++__r;\n        } while (__i != __e && key_eq()(*__i, __k));\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(\n        const _Key& __k)\n{\n    iterator __i = find(__k);\n    iterator __j = __i;\n    if (__i != end())\n        ++__j;\n    return pair<iterator, iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(\n        const _Key& __k) const\n{\n    const_iterator __i = find(__k);\n    const_iterator __j = __i;\n    if (__i != end())\n        ++__j;\n    return pair<const_iterator, const_iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(\n        const _Key& __k)\n{\n    iterator __i = find(__k);\n    iterator __j = __i;\n    if (__i != end())\n    {\n        iterator __e = end();\n        do\n        {\n            ++__j;\n        } while (__j != __e && key_eq()(*__j, __k));\n    }\n    return pair<iterator, iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(\n        const _Key& __k) const\n{\n    const_iterator __i = find(__k);\n    const_iterator __j = __i;\n    if (__i != end())\n    {\n        const_iterator __e = end();\n        do\n        {\n            ++__j;\n        } while (__j != __e && key_eq()(*__j, __k));\n    }\n    return pair<const_iterator, const_iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::swap(__hash_table& __u)\n#if _LIBCPP_STD_VER <= 11\n    _NOEXCEPT_DEBUG_(\n        __is_nothrow_swappable<hasher>::value && __is_nothrow_swappable<key_equal>::value\n        && (!allocator_traits<__pointer_allocator>::propagate_on_container_swap::value\n              || __is_nothrow_swappable<__pointer_allocator>::value)\n        && (!__node_traits::propagate_on_container_swap::value\n              || __is_nothrow_swappable<__node_allocator>::value)\n            )\n#else\n  _NOEXCEPT_DEBUG_(__is_nothrow_swappable<hasher>::value && __is_nothrow_swappable<key_equal>::value)\n#endif\n{\n    _LIBCPP_ASSERT(__node_traits::propagate_on_container_swap::value ||\n                   this->__node_alloc() == __u.__node_alloc(),\n                   \"list::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    {\n    __node_pointer_pointer __npp = __bucket_list_.release();\n    __bucket_list_.reset(__u.__bucket_list_.release());\n    __u.__bucket_list_.reset(__npp);\n    }\n    _VSTD::swap(__bucket_list_.get_deleter().size(), __u.__bucket_list_.get_deleter().size());\n    __swap_allocator(__bucket_list_.get_deleter().__alloc(),\n             __u.__bucket_list_.get_deleter().__alloc());\n    __swap_allocator(__node_alloc(), __u.__node_alloc());\n    _VSTD::swap(__p1_.first().__next_, __u.__p1_.first().__next_);\n    __p2_.swap(__u.__p2_);\n    __p3_.swap(__u.__p3_);\n    if (size() > 0)\n        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =\n            __p1_.first().__ptr();\n    if (__u.size() > 0)\n        __u.__bucket_list_[__constrain_hash(__u.__p1_.first().__next_->__hash(), __u.bucket_count())] =\n            __u.__p1_.first().__ptr();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::bucket_size(size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < bucket_count(),\n        \"unordered container::bucket_size(n) called with n >= bucket_count()\");\n    __next_pointer __np = __bucket_list_[__n];\n    size_type __bc = bucket_count();\n    size_type __r = 0;\n    if (__np != nullptr)\n    {\n        for (__np = __np->__next_; __np != nullptr &&\n                                   __constrain_hash(__np->__hash(), __bc) == __n;\n                                                    __np = __np->__next_, ++__r)\n            ;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__hash_table<_Tp, _Hash, _Equal, _Alloc>& __x,\n     __hash_table<_Tp, _Hash, _Equal, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__dereferenceable(const const_iterator* __i) const\n{\n    return __i->__node_ != nullptr;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__decrementable(const const_iterator*) const\n{\n    return false;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__addable(const const_iterator*, ptrdiff_t) const\n{\n    return false;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__subscriptable(const const_iterator*, ptrdiff_t) const\n{\n    return false;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP__HASH_TABLE\n","// -*- C++ -*-\n//===---------------------------- math.h ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MATH_H\n#define _LIBCPP_MATH_H\n\n/*\n    math.h synopsis\n\nMacros:\n\n    HUGE_VAL\n    HUGE_VALF               // C99\n    HUGE_VALL               // C99\n    INFINITY                // C99\n    NAN                     // C99\n    FP_INFINITE             // C99\n    FP_NAN                  // C99\n    FP_NORMAL               // C99\n    FP_SUBNORMAL            // C99\n    FP_ZERO                 // C99\n    FP_FAST_FMA             // C99\n    FP_FAST_FMAF            // C99\n    FP_FAST_FMAL            // C99\n    FP_ILOGB0               // C99\n    FP_ILOGBNAN             // C99\n    MATH_ERRNO              // C99\n    MATH_ERREXCEPT          // C99\n    math_errhandling        // C99\n\nTypes:\n\n    float_t                 // C99\n    double_t                // C99\n\n// C90\n\nfloating_point abs(floating_point x);\n\nfloating_point acos (arithmetic x);\nfloat          acosf(float x);\nlong double    acosl(long double x);\n\nfloating_point asin (arithmetic x);\nfloat          asinf(float x);\nlong double    asinl(long double x);\n\nfloating_point atan (arithmetic x);\nfloat          atanf(float x);\nlong double    atanl(long double x);\n\nfloating_point atan2 (arithmetic y, arithmetic x);\nfloat          atan2f(float y, float x);\nlong double    atan2l(long double y, long double x);\n\nfloating_point ceil (arithmetic x);\nfloat          ceilf(float x);\nlong double    ceill(long double x);\n\nfloating_point cos (arithmetic x);\nfloat          cosf(float x);\nlong double    cosl(long double x);\n\nfloating_point cosh (arithmetic x);\nfloat          coshf(float x);\nlong double    coshl(long double x);\n\nfloating_point exp (arithmetic x);\nfloat          expf(float x);\nlong double    expl(long double x);\n\nfloating_point fabs (arithmetic x);\nfloat          fabsf(float x);\nlong double    fabsl(long double x);\n\nfloating_point floor (arithmetic x);\nfloat          floorf(float x);\nlong double    floorl(long double x);\n\nfloating_point fmod (arithmetic x, arithmetic y);\nfloat          fmodf(float x, float y);\nlong double    fmodl(long double x, long double y);\n\nfloating_point frexp (arithmetic value, int* exp);\nfloat          frexpf(float value, int* exp);\nlong double    frexpl(long double value, int* exp);\n\nfloating_point ldexp (arithmetic value, int exp);\nfloat          ldexpf(float value, int exp);\nlong double    ldexpl(long double value, int exp);\n\nfloating_point log (arithmetic x);\nfloat          logf(float x);\nlong double    logl(long double x);\n\nfloating_point log10 (arithmetic x);\nfloat          log10f(float x);\nlong double    log10l(long double x);\n\nfloating_point modf (floating_point value, floating_point* iptr);\nfloat          modff(float value, float* iptr);\nlong double    modfl(long double value, long double* iptr);\n\nfloating_point pow (arithmetic x, arithmetic y);\nfloat          powf(float x, float y);\nlong double    powl(long double x, long double y);\n\nfloating_point sin (arithmetic x);\nfloat          sinf(float x);\nlong double    sinl(long double x);\n\nfloating_point sinh (arithmetic x);\nfloat          sinhf(float x);\nlong double    sinhl(long double x);\n\nfloating_point sqrt (arithmetic x);\nfloat          sqrtf(float x);\nlong double    sqrtl(long double x);\n\nfloating_point tan (arithmetic x);\nfloat          tanf(float x);\nlong double    tanl(long double x);\n\nfloating_point tanh (arithmetic x);\nfloat          tanhf(float x);\nlong double    tanhl(long double x);\n\n//  C99\n\nbool signbit(arithmetic x);\n\nint fpclassify(arithmetic x);\n\nbool isfinite(arithmetic x);\nbool isinf(arithmetic x);\nbool isnan(arithmetic x);\nbool isnormal(arithmetic x);\n\nbool isgreater(arithmetic x, arithmetic y);\nbool isgreaterequal(arithmetic x, arithmetic y);\nbool isless(arithmetic x, arithmetic y);\nbool islessequal(arithmetic x, arithmetic y);\nbool islessgreater(arithmetic x, arithmetic y);\nbool isunordered(arithmetic x, arithmetic y);\n\nfloating_point acosh (arithmetic x);\nfloat          acoshf(float x);\nlong double    acoshl(long double x);\n\nfloating_point asinh (arithmetic x);\nfloat          asinhf(float x);\nlong double    asinhl(long double x);\n\nfloating_point atanh (arithmetic x);\nfloat          atanhf(float x);\nlong double    atanhl(long double x);\n\nfloating_point cbrt (arithmetic x);\nfloat          cbrtf(float x);\nlong double    cbrtl(long double x);\n\nfloating_point copysign (arithmetic x, arithmetic y);\nfloat          copysignf(float x, float y);\nlong double    copysignl(long double x, long double y);\n\nfloating_point erf (arithmetic x);\nfloat          erff(float x);\nlong double    erfl(long double x);\n\nfloating_point erfc (arithmetic x);\nfloat          erfcf(float x);\nlong double    erfcl(long double x);\n\nfloating_point exp2 (arithmetic x);\nfloat          exp2f(float x);\nlong double    exp2l(long double x);\n\nfloating_point expm1 (arithmetic x);\nfloat          expm1f(float x);\nlong double    expm1l(long double x);\n\nfloating_point fdim (arithmetic x, arithmetic y);\nfloat          fdimf(float x, float y);\nlong double    fdiml(long double x, long double y);\n\nfloating_point fma (arithmetic x, arithmetic y, arithmetic z);\nfloat          fmaf(float x, float y, float z);\nlong double    fmal(long double x, long double y, long double z);\n\nfloating_point fmax (arithmetic x, arithmetic y);\nfloat          fmaxf(float x, float y);\nlong double    fmaxl(long double x, long double y);\n\nfloating_point fmin (arithmetic x, arithmetic y);\nfloat          fminf(float x, float y);\nlong double    fminl(long double x, long double y);\n\nfloating_point hypot (arithmetic x, arithmetic y);\nfloat          hypotf(float x, float y);\nlong double    hypotl(long double x, long double y);\n\nint ilogb (arithmetic x);\nint ilogbf(float x);\nint ilogbl(long double x);\n\nfloating_point lgamma (arithmetic x);\nfloat          lgammaf(float x);\nlong double    lgammal(long double x);\n\nlong long llrint (arithmetic x);\nlong long llrintf(float x);\nlong long llrintl(long double x);\n\nlong long llround (arithmetic x);\nlong long llroundf(float x);\nlong long llroundl(long double x);\n\nfloating_point log1p (arithmetic x);\nfloat          log1pf(float x);\nlong double    log1pl(long double x);\n\nfloating_point log2 (arithmetic x);\nfloat          log2f(float x);\nlong double    log2l(long double x);\n\nfloating_point logb (arithmetic x);\nfloat          logbf(float x);\nlong double    logbl(long double x);\n\nlong lrint (arithmetic x);\nlong lrintf(float x);\nlong lrintl(long double x);\n\nlong lround (arithmetic x);\nlong lroundf(float x);\nlong lroundl(long double x);\n\ndouble      nan (const char* str);\nfloat       nanf(const char* str);\nlong double nanl(const char* str);\n\nfloating_point nearbyint (arithmetic x);\nfloat          nearbyintf(float x);\nlong double    nearbyintl(long double x);\n\nfloating_point nextafter (arithmetic x, arithmetic y);\nfloat          nextafterf(float x, float y);\nlong double    nextafterl(long double x, long double y);\n\nfloating_point nexttoward (arithmetic x, long double y);\nfloat          nexttowardf(float x, long double y);\nlong double    nexttowardl(long double x, long double y);\n\nfloating_point remainder (arithmetic x, arithmetic y);\nfloat          remainderf(float x, float y);\nlong double    remainderl(long double x, long double y);\n\nfloating_point remquo (arithmetic x, arithmetic y, int* pquo);\nfloat          remquof(float x, float y, int* pquo);\nlong double    remquol(long double x, long double y, int* pquo);\n\nfloating_point rint (arithmetic x);\nfloat          rintf(float x);\nlong double    rintl(long double x);\n\nfloating_point round (arithmetic x);\nfloat          roundf(float x);\nlong double    roundl(long double x);\n\nfloating_point scalbln (arithmetic x, long ex);\nfloat          scalblnf(float x, long ex);\nlong double    scalblnl(long double x, long ex);\n\nfloating_point scalbn (arithmetic x, int ex);\nfloat          scalbnf(float x, int ex);\nlong double    scalbnl(long double x, int ex);\n\nfloating_point tgamma (arithmetic x);\nfloat          tgammaf(float x);\nlong double    tgammal(long double x);\n\nfloating_point trunc (arithmetic x);\nfloat          truncf(float x);\nlong double    truncl(long double x);\n\n*/\n\n#include <__config>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#include_next <math.h>\n\n#ifdef __cplusplus\n\n// We support including .h headers inside 'extern \"C\"' contexts, so switch\n// back to C++ linkage before including these C++ headers.\nextern \"C++\" {\n\n#include <type_traits>\n#include <limits>\n\n// signbit\n\n#ifdef signbit\n\ntemplate <class _A1>\n_LIBCPP_INLINE_VISIBILITY\nbool\n__libcpp_signbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return signbit(__lcpp_x);\n}\n\n#undef signbit\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_floating_point<_A1>::value, bool>::type\nsignbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<\n    std::is_integral<_A1>::value && std::is_signed<_A1>::value, bool>::type\nsignbit(_A1 __lcpp_x) _NOEXCEPT\n{ return __lcpp_x < 0; }\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<\n    std::is_integral<_A1>::value && !std::is_signed<_A1>::value, bool>::type\nsignbit(_A1) _NOEXCEPT\n{ return false; }\n\n#elif defined(_LIBCPP_MSVCRT)\n\ntemplate <typename _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_floating_point<_A1>::value, bool>::type\nsignbit(_A1 __lcpp_x) _NOEXCEPT\n{\n  return ::signbit(static_cast<typename std::__promote<_A1>::type>(__lcpp_x));\n}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<\n    std::is_integral<_A1>::value && std::is_signed<_A1>::value, bool>::type\nsignbit(_A1 __lcpp_x) _NOEXCEPT\n{ return __lcpp_x < 0; }\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<\n    std::is_integral<_A1>::value && !std::is_signed<_A1>::value, bool>::type\nsignbit(_A1) _NOEXCEPT\n{ return false; }\n\n#endif  // signbit\n\n// fpclassify\n\n#ifdef fpclassify\n\ntemplate <class _A1>\n_LIBCPP_INLINE_VISIBILITY\nint\n__libcpp_fpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return fpclassify(__lcpp_x);\n}\n\n#undef fpclassify\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_floating_point<_A1>::value, int>::type\nfpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, int>::type\nfpclassify(_A1 __lcpp_x) _NOEXCEPT\n{ return __lcpp_x == 0 ? FP_ZERO : FP_NORMAL; }\n\n#elif defined(_LIBCPP_MSVCRT)\n\ntemplate <typename _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_floating_point<_A1>::value, bool>::type\nfpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n  return ::fpclassify(static_cast<typename std::__promote<_A1>::type>(__lcpp_x));\n}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, int>::type\nfpclassify(_A1 __lcpp_x) _NOEXCEPT\n{ return __lcpp_x == 0 ? FP_ZERO : FP_NORMAL; }\n\n#endif  // fpclassify\n\n// isfinite\n\n#ifdef isfinite\n\ntemplate <class _A1>\n_LIBCPP_INLINE_VISIBILITY\nbool\n__libcpp_isfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isfinite(__lcpp_x);\n}\n\n#undef isfinite\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<\n    std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity,\n    bool>::type\nisfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<\n    std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity,\n    bool>::type\nisfinite(_A1) _NOEXCEPT\n{ return true; }\n\n#endif  // isfinite\n\n// isinf\n\n#ifdef isinf\n\ntemplate <class _A1>\n_LIBCPP_INLINE_VISIBILITY\nbool\n__libcpp_isinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isinf(__lcpp_x);\n}\n\n#undef isinf\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<\n    std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity,\n    bool>::type\nisinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<\n    std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity,\n    bool>::type\nisinf(_A1) _NOEXCEPT\n{ return false; }\n\n#ifdef _LIBCPP_PREFERRED_OVERLOAD\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisinf(float __lcpp_x) _NOEXCEPT { return __libcpp_isinf(__lcpp_x); }\n\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nbool\nisinf(double __lcpp_x) _NOEXCEPT { return __libcpp_isinf(__lcpp_x); }\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisinf(long double __lcpp_x) _NOEXCEPT { return __libcpp_isinf(__lcpp_x); }\n#endif\n\n#endif  // isinf\n\n// isnan\n\n#ifdef isnan\n\ntemplate <class _A1>\n_LIBCPP_INLINE_VISIBILITY\nbool\n__libcpp_isnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnan(__lcpp_x);\n}\n\n#undef isnan\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_floating_point<_A1>::value, bool>::type\nisnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, bool>::type\nisnan(_A1) _NOEXCEPT\n{ return false; }\n\n#ifdef _LIBCPP_PREFERRED_OVERLOAD\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisnan(float __lcpp_x) _NOEXCEPT { return __libcpp_isnan(__lcpp_x); }\n\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nbool\nisnan(double __lcpp_x) _NOEXCEPT { return __libcpp_isnan(__lcpp_x); }\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisnan(long double __lcpp_x) _NOEXCEPT { return __libcpp_isnan(__lcpp_x); }\n#endif\n\n#endif  // isnan\n\n// isnormal\n\n#ifdef isnormal\n\ntemplate <class _A1>\n_LIBCPP_INLINE_VISIBILITY\nbool\n__libcpp_isnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnormal(__lcpp_x);\n}\n\n#undef isnormal\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_floating_point<_A1>::value, bool>::type\nisnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, bool>::type\nisnormal(_A1 __lcpp_x) _NOEXCEPT\n{ return __lcpp_x != 0; }\n\n#endif  // isnormal\n\n// isgreater\n\n#ifdef isgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_INLINE_VISIBILITY\nbool\n__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreater\n\n// isgreaterequal\n\n#ifdef isgreaterequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_INLINE_VISIBILITY\nbool\n__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreaterequal(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreaterequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreaterequal\n\n// isless\n\n#ifdef isless\n\ntemplate <class _A1, class _A2>\n_LIBCPP_INLINE_VISIBILITY\nbool\n__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isless(__lcpp_x, __lcpp_y);\n}\n\n#undef isless\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isless\n\n// islessequal\n\n#ifdef islessequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_INLINE_VISIBILITY\nbool\n__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessequal(__lcpp_x, __lcpp_y);\n}\n\n#undef islessequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessequal\n\n// islessgreater\n\n#ifdef islessgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_INLINE_VISIBILITY\nbool\n__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef islessgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessgreater\n\n// isunordered\n\n#ifdef isunordered\n\ntemplate <class _A1, class _A2>\n_LIBCPP_INLINE_VISIBILITY\nbool\n__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isunordered(__lcpp_x, __lcpp_y);\n}\n\n#undef isunordered\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isunordered\n\n// abs\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY\nfloat\nabs(float __lcpp_x) _NOEXCEPT {return ::fabsf(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\ndouble\nabs(double __lcpp_x) _NOEXCEPT {return ::fabs(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong double\nabs(long double __lcpp_x) _NOEXCEPT {return ::fabsl(__lcpp_x);}\n#endif // !(defined(_AIX) || defined(__sun__))\n\n// acos\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       acos(float __lcpp_x) _NOEXCEPT       {return ::acosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acos(long double __lcpp_x) _NOEXCEPT {return ::acosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nacos(_A1 __lcpp_x) _NOEXCEPT {return ::acos((double)__lcpp_x);}\n\n// asin\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       asin(float __lcpp_x) _NOEXCEPT       {return ::asinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asin(long double __lcpp_x) _NOEXCEPT {return ::asinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nasin(_A1 __lcpp_x) _NOEXCEPT {return ::asin((double)__lcpp_x);}\n\n// atan\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       atan(float __lcpp_x) _NOEXCEPT       {return ::atanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan(long double __lcpp_x) _NOEXCEPT {return ::atanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\natan(_A1 __lcpp_x) _NOEXCEPT {return ::atan((double)__lcpp_x);}\n\n// atan2\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       atan2(float __lcpp_y, float __lcpp_x) _NOEXCEPT             {return ::atan2f(__lcpp_y, __lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan2(long double __lcpp_y, long double __lcpp_x) _NOEXCEPT {return ::atan2l(__lcpp_y, __lcpp_x);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\natan2(_A1 __lcpp_y, _A2 __lcpp_x) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);\n}\n\n// ceil\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       ceil(float __lcpp_x) _NOEXCEPT       {return ::ceilf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double ceil(long double __lcpp_x) _NOEXCEPT {return ::ceill(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nceil(_A1 __lcpp_x) _NOEXCEPT {return ::ceil((double)__lcpp_x);}\n\n// cos\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       cos(float __lcpp_x) _NOEXCEPT       {return ::cosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cos(long double __lcpp_x) _NOEXCEPT {return ::cosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncos(_A1 __lcpp_x) _NOEXCEPT {return ::cos((double)__lcpp_x);}\n\n// cosh\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       cosh(float __lcpp_x) _NOEXCEPT       {return ::coshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cosh(long double __lcpp_x) _NOEXCEPT {return ::coshl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncosh(_A1 __lcpp_x) _NOEXCEPT {return ::cosh((double)__lcpp_x);}\n\n// exp\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       exp(float __lcpp_x) _NOEXCEPT       {return ::expf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp(long double __lcpp_x) _NOEXCEPT {return ::expl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexp(_A1 __lcpp_x) _NOEXCEPT {return ::exp((double)__lcpp_x);}\n\n// fabs\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       fabs(float __lcpp_x) _NOEXCEPT       {return ::fabsf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double fabs(long double __lcpp_x) _NOEXCEPT {return ::fabsl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfabs(_A1 __lcpp_x) _NOEXCEPT {return ::fabs((double)__lcpp_x);}\n\n// floor\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       floor(float __lcpp_x) _NOEXCEPT       {return ::floorf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double floor(long double __lcpp_x) _NOEXCEPT {return ::floorl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfloor(_A1 __lcpp_x) _NOEXCEPT {return ::floor((double)__lcpp_x);}\n\n// fmod\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       fmod(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::fmodf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmod(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::fmodl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmod(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// frexp\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       frexp(float __lcpp_x, int* __lcpp_e) _NOEXCEPT       {return ::frexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double frexp(long double __lcpp_x, int* __lcpp_e) _NOEXCEPT {return ::frexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfrexp(_A1 __lcpp_x, int* __lcpp_e) _NOEXCEPT {return ::frexp((double)__lcpp_x, __lcpp_e);}\n\n// ldexp\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       ldexp(float __lcpp_x, int __lcpp_e) _NOEXCEPT       {return ::ldexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double ldexp(long double __lcpp_x, int __lcpp_e) _NOEXCEPT {return ::ldexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nldexp(_A1 __lcpp_x, int __lcpp_e) _NOEXCEPT {return ::ldexp((double)__lcpp_x, __lcpp_e);}\n\n// log\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       log(float __lcpp_x) _NOEXCEPT       {return ::logf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log(long double __lcpp_x) _NOEXCEPT {return ::logl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog(_A1 __lcpp_x) _NOEXCEPT {return ::log((double)__lcpp_x);}\n\n// log10\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       log10(float __lcpp_x) _NOEXCEPT       {return ::log10f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log10(long double __lcpp_x) _NOEXCEPT {return ::log10l(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog10(_A1 __lcpp_x) _NOEXCEPT {return ::log10((double)__lcpp_x);}\n\n// modf\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       modf(float __lcpp_x, float* __lcpp_y) _NOEXCEPT             {return ::modff(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double modf(long double __lcpp_x, long double* __lcpp_y) _NOEXCEPT {return ::modfl(__lcpp_x, __lcpp_y);}\n#endif\n\n// pow\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       pow(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::powf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double pow(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::powl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\npow(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// sin\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sin(float __lcpp_x) _NOEXCEPT       {return ::sinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sin(long double __lcpp_x) _NOEXCEPT {return ::sinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsin(_A1 __lcpp_x) _NOEXCEPT {return ::sin((double)__lcpp_x);}\n\n// sinh\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sinh(float __lcpp_x) _NOEXCEPT       {return ::sinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sinh(long double __lcpp_x) _NOEXCEPT {return ::sinhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsinh(_A1 __lcpp_x) _NOEXCEPT {return ::sinh((double)__lcpp_x);}\n\n// sqrt\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sqrt(float __lcpp_x) _NOEXCEPT       {return ::sqrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sqrt(long double __lcpp_x) _NOEXCEPT {return ::sqrtl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsqrt(_A1 __lcpp_x) _NOEXCEPT {return ::sqrt((double)__lcpp_x);}\n\n// tan\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       tan(float __lcpp_x) _NOEXCEPT       {return ::tanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tan(long double __lcpp_x) _NOEXCEPT {return ::tanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntan(_A1 __lcpp_x) _NOEXCEPT {return ::tan((double)__lcpp_x);}\n\n// tanh\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       tanh(float __lcpp_x) _NOEXCEPT       {return ::tanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tanh(long double __lcpp_x) _NOEXCEPT {return ::tanhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntanh(_A1 __lcpp_x) _NOEXCEPT {return ::tanh((double)__lcpp_x);}\n\n// acosh\n\ninline _LIBCPP_INLINE_VISIBILITY float       acosh(float __lcpp_x) _NOEXCEPT       {return ::acoshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acosh(long double __lcpp_x) _NOEXCEPT {return ::acoshl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nacosh(_A1 __lcpp_x) _NOEXCEPT {return ::acosh((double)__lcpp_x);}\n\n// asinh\n\ninline _LIBCPP_INLINE_VISIBILITY float       asinh(float __lcpp_x) _NOEXCEPT       {return ::asinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asinh(long double __lcpp_x) _NOEXCEPT {return ::asinhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nasinh(_A1 __lcpp_x) _NOEXCEPT {return ::asinh((double)__lcpp_x);}\n\n// atanh\n\ninline _LIBCPP_INLINE_VISIBILITY float       atanh(float __lcpp_x) _NOEXCEPT       {return ::atanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atanh(long double __lcpp_x) _NOEXCEPT {return ::atanhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\natanh(_A1 __lcpp_x) _NOEXCEPT {return ::atanh((double)__lcpp_x);}\n\n// cbrt\n\ninline _LIBCPP_INLINE_VISIBILITY float       cbrt(float __lcpp_x) _NOEXCEPT       {return ::cbrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cbrt(long double __lcpp_x) _NOEXCEPT {return ::cbrtl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncbrt(_A1 __lcpp_x) _NOEXCEPT {return ::cbrt((double)__lcpp_x);}\n\n// copysign\n\ninline _LIBCPP_INLINE_VISIBILITY float copysign(float __lcpp_x,\n                                                float __lcpp_y) _NOEXCEPT {\n  return ::copysignf(__lcpp_x, __lcpp_y);\n}\ninline _LIBCPP_INLINE_VISIBILITY long double\ncopysign(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {\n  return ::copysignl(__lcpp_x, __lcpp_y);\n}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\ncopysign(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// erf\n\ninline _LIBCPP_INLINE_VISIBILITY float       erf(float __lcpp_x) _NOEXCEPT       {return ::erff(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erf(long double __lcpp_x) _NOEXCEPT {return ::erfl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nerf(_A1 __lcpp_x) _NOEXCEPT {return ::erf((double)__lcpp_x);}\n\n// erfc\n\ninline _LIBCPP_INLINE_VISIBILITY float       erfc(float __lcpp_x) _NOEXCEPT       {return ::erfcf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erfc(long double __lcpp_x) _NOEXCEPT {return ::erfcl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nerfc(_A1 __lcpp_x) _NOEXCEPT {return ::erfc((double)__lcpp_x);}\n\n// exp2\n\ninline _LIBCPP_INLINE_VISIBILITY float       exp2(float __lcpp_x) _NOEXCEPT       {return ::exp2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp2(long double __lcpp_x) _NOEXCEPT {return ::exp2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexp2(_A1 __lcpp_x) _NOEXCEPT {return ::exp2((double)__lcpp_x);}\n\n// expm1\n\ninline _LIBCPP_INLINE_VISIBILITY float       expm1(float __lcpp_x) _NOEXCEPT       {return ::expm1f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double expm1(long double __lcpp_x) _NOEXCEPT {return ::expm1l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexpm1(_A1 __lcpp_x) _NOEXCEPT {return ::expm1((double)__lcpp_x);}\n\n// fdim\n\ninline _LIBCPP_INLINE_VISIBILITY float       fdim(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::fdimf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fdim(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::fdiml(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfdim(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fma\n\ninline _LIBCPP_INLINE_VISIBILITY float       fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) _NOEXCEPT                   {return ::fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) _NOEXCEPT {return ::fmal(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2, class _A3>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value &&\n    std::is_arithmetic<_A3>::value,\n    std::__promote<_A1, _A2, _A3>\n>::type\nfma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value &&\n                     std::is_same<_A3, __result_type>::value)), \"\");\n    return ::fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);\n}\n\n// fmax\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmax(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::fmaxf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmax(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::fmaxl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmax(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fmin\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmin(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::fminf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmin(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::fminl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmin(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// hypot\n\ninline _LIBCPP_INLINE_VISIBILITY float       hypot(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::hypotf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double hypot(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::hypotl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nhypot(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// ilogb\n\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(float __lcpp_x) _NOEXCEPT       {return ::ilogbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(long double __lcpp_x) _NOEXCEPT {return ::ilogbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, int>::type\nilogb(_A1 __lcpp_x) _NOEXCEPT {return ::ilogb((double)__lcpp_x);}\n\n// lgamma\n\ninline _LIBCPP_INLINE_VISIBILITY float       lgamma(float __lcpp_x) _NOEXCEPT       {return ::lgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double lgamma(long double __lcpp_x) _NOEXCEPT {return ::lgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlgamma(_A1 __lcpp_x) _NOEXCEPT {return ::lgamma((double)__lcpp_x);}\n\n// llrint\n\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(float __lcpp_x) _NOEXCEPT       {return ::llrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(long double __lcpp_x) _NOEXCEPT {return ::llrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type\nllrint(_A1 __lcpp_x) _NOEXCEPT {return ::llrint((double)__lcpp_x);}\n\n// llround\n\ninline _LIBCPP_INLINE_VISIBILITY long long llround(float __lcpp_x) _NOEXCEPT       {return ::llroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llround(long double __lcpp_x) _NOEXCEPT {return ::llroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type\nllround(_A1 __lcpp_x) _NOEXCEPT {return ::llround((double)__lcpp_x);}\n\n// log1p\n\ninline _LIBCPP_INLINE_VISIBILITY float       log1p(float __lcpp_x) _NOEXCEPT       {return ::log1pf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log1p(long double __lcpp_x) _NOEXCEPT {return ::log1pl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog1p(_A1 __lcpp_x) _NOEXCEPT {return ::log1p((double)__lcpp_x);}\n\n// log2\n\ninline _LIBCPP_INLINE_VISIBILITY float       log2(float __lcpp_x) _NOEXCEPT       {return ::log2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log2(long double __lcpp_x) _NOEXCEPT {return ::log2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog2(_A1 __lcpp_x) _NOEXCEPT {return ::log2((double)__lcpp_x);}\n\n// logb\n\ninline _LIBCPP_INLINE_VISIBILITY float       logb(float __lcpp_x) _NOEXCEPT       {return ::logbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double logb(long double __lcpp_x) _NOEXCEPT {return ::logbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlogb(_A1 __lcpp_x) _NOEXCEPT {return ::logb((double)__lcpp_x);}\n\n// lrint\n\ninline _LIBCPP_INLINE_VISIBILITY long lrint(float __lcpp_x) _NOEXCEPT       {return ::lrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lrint(long double __lcpp_x) _NOEXCEPT {return ::lrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long>::type\nlrint(_A1 __lcpp_x) _NOEXCEPT {return ::lrint((double)__lcpp_x);}\n\n// lround\n\ninline _LIBCPP_INLINE_VISIBILITY long lround(float __lcpp_x) _NOEXCEPT       {return ::lroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lround(long double __lcpp_x) _NOEXCEPT {return ::lroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long>::type\nlround(_A1 __lcpp_x) _NOEXCEPT {return ::lround((double)__lcpp_x);}\n\n// nan\n\n// nearbyint\n\ninline _LIBCPP_INLINE_VISIBILITY float       nearbyint(float __lcpp_x) _NOEXCEPT       {return ::nearbyintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double nearbyint(long double __lcpp_x) _NOEXCEPT {return ::nearbyintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nnearbyint(_A1 __lcpp_x) _NOEXCEPT {return ::nearbyint((double)__lcpp_x);}\n\n// nextafter\n\ninline _LIBCPP_INLINE_VISIBILITY float       nextafter(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::nextafterf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nextafter(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::nextafterl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nnextafter(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// nexttoward\n\ninline _LIBCPP_INLINE_VISIBILITY float       nexttoward(float __lcpp_x, long double __lcpp_y) _NOEXCEPT       {return ::nexttowardf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nexttoward(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::nexttowardl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nnexttoward(_A1 __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::nexttoward((double)__lcpp_x, __lcpp_y);}\n\n// remainder\n\ninline _LIBCPP_INLINE_VISIBILITY float       remainder(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::remainderf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double remainder(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::remainderl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nremainder(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// remquo\n\ninline _LIBCPP_INLINE_VISIBILITY float       remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) _NOEXCEPT             {return ::remquof(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) _NOEXCEPT {return ::remquol(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nremquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);\n}\n\n// rint\n\ninline _LIBCPP_INLINE_VISIBILITY float       rint(float __lcpp_x) _NOEXCEPT       {return ::rintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double rint(long double __lcpp_x) _NOEXCEPT {return ::rintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nrint(_A1 __lcpp_x) _NOEXCEPT {return ::rint((double)__lcpp_x);}\n\n// round\n\ninline _LIBCPP_INLINE_VISIBILITY float       round(float __lcpp_x) _NOEXCEPT       {return ::roundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double round(long double __lcpp_x) _NOEXCEPT {return ::roundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nround(_A1 __lcpp_x) _NOEXCEPT {return ::round((double)__lcpp_x);}\n\n// scalbln\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbln(float __lcpp_x, long __lcpp_y) _NOEXCEPT       {return ::scalblnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbln(long double __lcpp_x, long __lcpp_y) _NOEXCEPT {return ::scalblnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nscalbln(_A1 __lcpp_x, long __lcpp_y) _NOEXCEPT {return ::scalbln((double)__lcpp_x, __lcpp_y);}\n\n// scalbn\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbn(float __lcpp_x, int __lcpp_y) _NOEXCEPT       {return ::scalbnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbn(long double __lcpp_x, int __lcpp_y) _NOEXCEPT {return ::scalbnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nscalbn(_A1 __lcpp_x, int __lcpp_y) _NOEXCEPT {return ::scalbn((double)__lcpp_x, __lcpp_y);}\n\n// tgamma\n\ninline _LIBCPP_INLINE_VISIBILITY float       tgamma(float __lcpp_x) _NOEXCEPT       {return ::tgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tgamma(long double __lcpp_x) _NOEXCEPT {return ::tgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntgamma(_A1 __lcpp_x) _NOEXCEPT {return ::tgamma((double)__lcpp_x);}\n\n// trunc\n\ninline _LIBCPP_INLINE_VISIBILITY float       trunc(float __lcpp_x) _NOEXCEPT       {return ::truncf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double trunc(long double __lcpp_x) _NOEXCEPT {return ::truncl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntrunc(_A1 __lcpp_x) _NOEXCEPT {return ::trunc((double)__lcpp_x);}\n\n} // extern \"C++\"\n\n#endif // __cplusplus\n\n#else // _LIBCPP_MATH_H\n\n// This include lives outside the header guard in order to support an MSVC\n// extension which allows users to do:\n//\n// #define _USE_MATH_DEFINES\n// #include <math.h>\n//\n// and receive the definitions of mathematical constants, even if <math.h>\n// has previously been included.\n#if defined(_LIBCPP_MSVCRT) && defined(_USE_MATH_DEFINES)\n#include_next <math.h>\n#endif\n\n#endif  // _LIBCPP_MATH_H\n","// -*- C++ -*-\n//===-------------------------- algorithm ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ALGORITHM\n#define _LIBCPP_ALGORITHM\n\n/*\n    algorithm synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class InputIterator, class Predicate>\n    constexpr bool     // constexpr in C++20\n    all_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    constexpr bool     // constexpr in C++20\n    any_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    constexpr bool     // constexpr in C++20\n    none_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Function>\n    constexpr Function          // constexpr in C++20\n    for_each(InputIterator first, InputIterator last, Function f);\n\ntemplate<class InputIterator, class Size, class Function>\n    constexpr InputIterator     // constexpr in C++20\n    for_each_n(InputIterator first, Size n, Function f); // C++17\n\ntemplate <class InputIterator, class T>\n    constexpr InputIterator     // constexpr in C++20\n    find(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    constexpr InputIterator     // constexpr in C++20\n    find_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate<class InputIterator, class Predicate>\n    InputIterator               // constexpr in C++20\n    find_if_not(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1            // constexpr in C++20\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1            // constexpr in C++20\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    constexpr ForwardIterator1  // constexpr in C++20\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    constexpr ForwardIterator1  // constexpr in C++20\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator>\n    constexpr ForwardIterator   // constexpr in C++20\n    adjacent_find(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    constexpr ForwardIterator   // constexpr in C++20\n    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class T>\n    constexpr typename iterator_traits<InputIterator>::difference_type  // constexpr in C++20\n    count(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    constexpr typename iterator_traits<InputIterator>::difference_type // constexpr in C++20\n    count_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator1, class InputIterator2>\n    constexpr pair<InputIterator1, InputIterator2>   // constexpr in C++20\n    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    constexpr pair<InputIterator1, InputIterator2>   // constexpr in C++20\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    constexpr pair<InputIterator1, InputIterator2>   // constexpr in C++20\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    constexpr pair<InputIterator1, InputIterator2>   // constexpr in C++20\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2,\n             BinaryPredicate pred); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2>\n    constexpr bool      // constexpr in C++20\n    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    constexpr bool      // constexpr in C++20\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    constexpr bool      // constexpr in C++20\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    constexpr bool      // constexpr in C++20\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2,\n          BinaryPredicate pred); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    constexpr bool      // constexpr in C++20\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2);\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    constexpr bool      // constexpr in C++20\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    constexpr bool      // constexpr in C++20\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, BinaryPredicate pred);\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    constexpr bool      // constexpr in C++20\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2,\n                   BinaryPredicate pred);  // **C++14**\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    constexpr ForwardIterator1      // constexpr in C++20\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    constexpr ForwardIterator1      // constexpr in C++20\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator, class Size, class T>\n    constexpr ForwardIterator       // constexpr in C++20\n    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);\n\ntemplate <class ForwardIterator, class Size, class T, class BinaryPredicate>\n    constexpr ForwardIterator       // constexpr in C++20\n    search_n(ForwardIterator first, ForwardIterator last,\n             Size count, const T& value, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate<class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    copy_if(InputIterator first, InputIterator last,\n            OutputIterator result, Predicate pred);\n\ntemplate<class InputIterator, class Size, class OutputIterator>\n    OutputIterator\n    copy_n(InputIterator first, Size n, OutputIterator result);\n\ntemplate <class BidirectionalIterator1, class BidirectionalIterator2>\n    BidirectionalIterator2\n    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,\n                  BidirectionalIterator2 result);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator2\n    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    void\n    iter_swap(ForwardIterator1 a, ForwardIterator2 b);\n\ntemplate <class InputIterator, class OutputIterator, class UnaryOperation>\n    constexpr OutputIterator      // constexpr in C++20\n    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>\n    constexpr OutputIterator      // constexpr in C++20\n    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,\n              OutputIterator result, BinaryOperation binary_op);\n\ntemplate <class ForwardIterator, class T>\n    constexpr void      // constexpr in C++20\n    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);\n\ntemplate <class ForwardIterator, class Predicate, class T>\n    constexpr void      // constexpr in C++20\n    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    constexpr OutputIterator      // constexpr in C++20\n    replace_copy(InputIterator first, InputIterator last, OutputIterator result,\n                 const T& old_value, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate, class T>\n    constexpr OutputIterator      // constexpr in C++20\n    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);\n\ntemplate <class ForwardIterator, class T>\n    constexpr void      // constexpr in C++20\n    fill(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class OutputIterator, class Size, class T>\n    constexpr OutputIterator      // constexpr in C++20\n    fill_n(OutputIterator first, Size n, const T& value);\n\ntemplate <class ForwardIterator, class Generator>\n    constexpr void      // constexpr in C++20\n    generate(ForwardIterator first, ForwardIterator last, Generator gen);\n\ntemplate <class OutputIterator, class Size, class Generator>\n    constexpr OutputIterator      // constexpr in C++20\n    generate_n(OutputIterator first, Size n, Generator gen);\n\ntemplate <class ForwardIterator, class T>\n    constexpr ForwardIterator     // constexpr in C++20\n    remove(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class Predicate>\n    constexpr ForwardIterator     // constexpr in C++20\n    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    constexpr OutputIterator     // constexpr in C++20\n    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate>\n    constexpr OutputIterator     // constexpr in C++20\n    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate <class InputIterator, class OutputIterator, class BinaryPredicate>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);\n\ntemplate <class BidirectionalIterator>\n    void\n    reverse(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class OutputIterator>\n    constexpr OutputIterator       // constexpr in C++20\n    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);\n\ntemplate <class ForwardIterator, class OutputIterator>\n    OutputIterator\n    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);\n\ntemplate <class RandomAccessIterator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last); // deprecated in C++14, removed in C++17\n\ntemplate <class RandomAccessIterator, class RandomNumberGenerator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                   RandomNumberGenerator& rand);  // deprecated in C++14, removed in C++17\n\ntemplate<class PopulationIterator, class SampleIterator,\n         class Distance, class UniformRandomBitGenerator>\n    SampleIterator sample(PopulationIterator first, PopulationIterator last,\n                          SampleIterator out, Distance n,\n                          UniformRandomBitGenerator&& g); // C++17\n\ntemplate<class RandomAccessIterator, class UniformRandomNumberGenerator>\n    void shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                 UniformRandomNumberGenerator&& g);\n\ntemplate <class InputIterator, class Predicate>\n    constexpr bool  // constexpr in C++20\n    is_partitioned(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator1,\n          class OutputIterator2, class Predicate>\n    constexpr pair<OutputIterator1, OutputIterator2>   // constexpr in C++20\n    partition_copy(InputIterator first, InputIterator last,\n                   OutputIterator1 out_true, OutputIterator2 out_false,\n                   Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate<class ForwardIterator, class Predicate>\n    constexpr ForwardIterator  // constexpr in C++20\n    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class ForwardIterator>\n    constexpr bool  // constexpr in C++20\n    is_sorted(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class ForwardIterator>\n    constexpr ForwardIterator    // constexpr in C++20\n    is_sorted_until(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    constexpr ForwardIterator    // constexpr in C++20\n    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);\n\ntemplate <class InputIterator, class RandomAccessIterator>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last);\n\ntemplate <class InputIterator, class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    constexpr ForwardIterator                         // constexpr in C++20\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    constexpr ForwardIterator                         // constexpr in C++20\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    constexpr ForwardIterator                         // constexpr in C++20\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    constexpr ForwardIterator                         // constexpr in C++20\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    constexpr pair<ForwardIterator, ForwardIterator>  // constexpr in C++20\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    constexpr pair<ForwardIterator, ForwardIterator>  // constexpr in C++20\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    constexpr bool                                    // constexpr in C++20\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    constexpr bool                                    // constexpr in C++20\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    constexpr bool                                    // constexpr in C++20\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    constexpr bool                                    // constexpr in C++20\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    constexpr OutputIterator                         // constexpr in C++20\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    constexpr OutputIterator                         // constexpr in C++20\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    constexpr bool   // constexpr in C++20\n    is_heap(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    constexpr bool   // constexpr in C++20\n    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    constexpr RandomAccessIterator   // constexpr in C++20\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    constexpr RandomAccessIterator   // constexpr in C++20\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    min(const T& a, const T& b);  // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    min(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    min(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    min(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi );               // C++17\n\ntemplate<class T, class Compare>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi, Compare comp ); // C++17\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    max(const T& a, const T& b); // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    max(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    max(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    max(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class ForwardIterator>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last);   // constexpr in C++14\n\ntemplate<class ForwardIterator, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);   // constexpr in C++14\n\ntemplate<class T>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    pair<T, T>\n    minmax(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<T, T>\n    minmax(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate <class InputIterator1, class InputIterator2>\n    constexpr bool     // constexpr in C++20\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    constexpr bool     // constexpr in C++20\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n                            InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <initializer_list>\n#include <type_traits>\n#include <cstring>\n#include <utility> // needed to provide swap_ranges.\n#include <memory>\n#include <functional>\n#include <iterator>\n#include <cstddef>\n#include <bit>\n#include <version>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// I'd like to replace these with _VSTD::equal_to<void>, but can't because:\n//   * That only works with C++14 and later, and\n//   * We haven't included <functional> here.\ntemplate <class _T1, class _T2 = _T1>\nstruct __equal_to\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __less\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _Predicate>\nclass __invert // invert the sense of a comparison\n{\nprivate:\n    _Predicate __p_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __invert() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __invert(_Predicate __p) : __p_(__p) {}\n\n    template <class _T1>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x) {return !__p_(__x);}\n\n    template <class _T1, class _T2>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x, const _T2& __y) {return __p_(__y, __x);}\n};\n\n// Perform division by two quickly for positive integers (llvm.org/PR39129)\n\ntemplate <typename _Integral>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    is_integral<_Integral>::value,\n    _Integral\n>::type\n__half_positive(_Integral __value)\n{\n    return static_cast<_Integral>(static_cast<typename make_unsigned<_Integral>::type>(__value) / 2);\n}\n\ntemplate <typename _Tp>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    !is_integral<_Tp>::value,\n    _Tp\n>::type\n__half_positive(_Tp __value)\n{\n    return __value / 2;\n}\n\n#ifdef _LIBCPP_DEBUG\n\ntemplate <class _Compare>\nstruct __debug_less\n{\n    _Compare __comp_;\n    __debug_less(_Compare& __c) : __comp_(__c) {}\n\n    template <class _Tp, class _Up>\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        bool __r = __comp_(__x, __y);\n        if (__r)\n            __do_compare_assert(0, __y, __x);\n        return __r;\n    }\n\n    template <class _LHS, class _RHS>\n    inline _LIBCPP_INLINE_VISIBILITY\n    decltype((void)_VSTD::declval<_Compare&>()(\n        _VSTD::declval<_LHS const&>(), _VSTD::declval<_RHS const&>()))\n    __do_compare_assert(int, _LHS const& __l, _RHS const& __r) {\n        _LIBCPP_ASSERT(!__comp_(__l, __r),\n            \"Comparator does not induce a strict weak ordering\");\n    }\n\n    template <class _LHS, class _RHS>\n    inline _LIBCPP_INLINE_VISIBILITY\n    void __do_compare_assert(long, _LHS const&, _RHS const&) {}\n};\n\n#endif  // _LIBCPP_DEBUG\n\n// all_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nall_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            return false;\n    return true;\n}\n\n// any_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nany_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return true;\n    return false;\n}\n\n// none_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nnone_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// for_each\n\ntemplate <class _InputIterator, class _Function>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_Function\nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)\n{\n    for (; __first != __last; ++__first)\n        __f(*__first);\n    return __f;\n}\n\n#if _LIBCPP_STD_VER > 14\n// for_each_n\n\ntemplate <class _InputIterator, class _Size, class _Function>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_InputIterator\nfor_each_n(_InputIterator __first, _Size __orig_n, _Function __f)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    while (__n > 0)\n    {\n         __f(*__first);\n         ++__first;\n         --__n;\n    }\n    return __first;\n}\n#endif\n\n// find\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_InputIterator\nfind(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            break;\n    return __first;\n}\n\n// find_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_InputIterator\nfind_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_if_not\n\ntemplate<class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_InputIterator\nfind_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_end\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 _ForwardIterator1\n__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n           forward_iterator_tag, forward_iterator_tag)\n{\n    // modeled after search algorithm\n    _ForwardIterator1 __r = __last1;  // __last1 is the \"default\" answer\n    if (__first2 == __last2)\n        return __r;\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __last1)         // if source exhausted return last correct answer\n                return __r;                  //    (or __last1 if never found)\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)\n            {                         // Pattern exhaused, record answer and search for another one\n                __r = __first1;\n                ++__first1;\n                break;\n            }\n            if (++__m1 == __last1)     // Source exhausted, return last answer\n                return __r;\n            if (!__pred(*__m1, *__m2))  // mismatch, restart with a new __first\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 _BidirectionalIterator1\n__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,\n           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,\n           bidirectional_iterator_tag, bidirectional_iterator_tag)\n{\n    // modeled after search algorithm (in reverse)\n    if (__first2 == __last2)\n        return __last1;  // Everything matches an empty sequence\n    _BidirectionalIterator1 __l1 = __last1;\n    _BidirectionalIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __l1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        // *__l1 matches *__l2, now match elements before here\n        _BidirectionalIterator1 __m1 = __l1;\n        _BidirectionalIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)  // If pattern exhausted, __m1 is the answer (works for 1 element pattern)\n                return __m1;\n            if (__m1 == __first1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*--__m1, *--__m2))  // if there is a mismatch, restart with a new __l1\n            {\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1\n__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __last1;\n    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);  // End of pattern match can't go before here\n    _RandomAccessIterator1 __l1 = __last1;\n    _RandomAccessIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        while (true)\n        {\n            if (__s == __l1)\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        _RandomAccessIterator1 __m1 = __l1;\n        _RandomAccessIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)\n                return __m1;\n                                 // no need to check range on __m1 because __s guarantees we have enough source\n            if (!__pred(*--__m1, *--__m2))\n            {\n                break;\n            }\n        }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// find_first_of\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator1\n__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1)\n        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n            if (__pred(*__first1, *__j))\n                return __first1;\n    return __last1;\n}\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY  _LIBCPP_CONSTEXPR_AFTER_CXX17\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY  _LIBCPP_CONSTEXPR_AFTER_CXX17\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// adjacent_find\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__first, *__i))\n                return __first;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::adjacent_find(__first, __last, __equal_to<__v>());\n}\n\n// count\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\ntypename iterator_traits<_InputIterator>::difference_type\ncount(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            ++__r;\n    return __r;\n}\n\n// count_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\ntypename iterator_traits<_InputIterator>::difference_type\ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            ++__r;\n    return __r;\n}\n\n// mismatch\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2,\n         _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n#endif\n\n// equal\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\n__equal(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,\n        input_iterator_tag, input_iterator_tag )\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return __first1 == __last1 && __first2 == __last2;\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\n__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n      random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::equal<_RandomAccessIterator1, _RandomAccessIterator2,\n                        typename add_lvalue_reference<_BinaryPredicate>::type>\n                       (__first1, __last1, __first2, __pred );\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )\n{\n    return _VSTD::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n#endif\n\n// is_permutation\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 bool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _BinaryPredicate __pred)\n{\n//  shorten sequences as much as possible by lopping of any equal prefix\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    if (__first1 == __last1)\n        return true;\n\n//  __first1 != __last1 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n    if (__l1 == _D1(1))\n        return false;\n    _ForwardIterator2 __last2 = _VSTD::next(__first2, __l1);\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n    //  Have we already counted the number of *__i in [f1, l1)?\n        _ForwardIterator1 __match = __first1;\n        for (; __match != __i; ++__match)\n            if (__pred(*__match, *__i))\n                break;\n        if (__match == __i) {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n    }\n    return true;\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 bool\n__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                 _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n                 _BinaryPredicate __pred,\n                 forward_iterator_tag, forward_iterator_tag )\n{\n//  shorten sequences as much as possible by lopping of any equal prefix\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    if (__first1 == __last1)\n        return __first2 == __last2;\n    else if (__first2 == __last2)\n        return false;\n\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n\n    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;\n    _D2 __l2 = _VSTD::distance(__first2, __last2);\n    if (__l1 != __l2)\n        return false;\n\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n    //  Have we already counted the number of *__i in [f1, l1)?\n        _ForwardIterator1 __match = __first1;\n        for (; __match != __i; ++__match)\n            if (__pred(*__match, *__i))\n                break;\n        if (__match == __i) {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n    }\n    return true;\n}\n\ntemplate<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 bool\n__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,\n               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2,\n               _BinaryPredicate __pred,\n               random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,\n                                 typename add_lvalue_reference<_BinaryPredicate>::type>\n                                (__first1, __last1, __first2, __pred );\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n               _BinaryPredicate __pred )\n{\n    return _VSTD::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__is_permutation(__first1, __last1, __first2, __last2,\n        __equal_to<__v1, __v2>(),\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n#endif\n\n// search\n// __search is in <functional>\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__search<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category())\n            .first;\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _ForwardIterator, class _Searcher>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_ForwardIterator search(_ForwardIterator __f, _ForwardIterator __l, const _Searcher &__s)\n{ return __s(__f, __l).first; }\n#endif\n\n// search_n\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 _ForwardIterator\n__search_n(_ForwardIterator __first, _ForwardIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first == __last)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _ForwardIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n            if (++__m == __last)  // Otherwise if source exhaused, pattern not found\n                return __last;\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 _RandomAccessIterator\n__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    _Size __len = static_cast<_Size>(__last - __first);\n    if (__len < __count)\n        return __last;\n    const _RandomAccessIterator __s = __last - (__count - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first >= __s)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _RandomAccessIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n             ++__m;          // no need to check range on __m because __s guarantees we have enough source\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last,\n         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)\n{\n    return _VSTD::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>\n           (__first, __last, __convert_to_integral(__count), __value_, __pred,\n           typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::search_n(__first, __last, __convert_to_integral(__count),\n                           __value_, __equal_to<__v, _Tp>());\n}\n\n// copy\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n_Iter\n__unwrap_iter(_Iter __i)\n{\n    return __i;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(move_iterator<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    __wrap_iter<_Tp*>\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = *__first;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_backward\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = *--__last;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\ncopy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__copy_backward(__unwrap_iter(__first),\n                                  __unwrap_iter(__last),\n                                  __unwrap_iter(__result));\n}\n\n// copy_if\n\ntemplate<class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy_if(_InputIterator __first, _InputIterator __last,\n        _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// copy_n\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    if (__n > 0)\n    {\n        *__result = *__first;\n        ++__result;\n        for (--__n; __n > 0; --__n)\n        {\n            ++__first;\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    return _VSTD::copy(__first, __first + __n, __result);\n}\n\n// move\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = _VSTD::move(*__first);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmove(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// move_backward\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = _VSTD::move(*--__last);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\nmove_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// iter_swap\n\n// moved to <type_traits> for better swap / noexcept support\n\n// transform\n\ntemplate <class _InputIterator, class _OutputIterator, class _UnaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_OutputIterator\ntransform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = __op(*__first);\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_OutputIterator\ntransform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,\n          _OutputIterator __result, _BinaryOperation __binary_op)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)\n        *__result = __binary_op(*__first1, *__first2);\n    return __result;\n}\n\n// replace\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nvoid\nreplace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __old_value)\n            *__first = __new_value;\n}\n\n// replace_if\n\ntemplate <class _ForwardIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nvoid\nreplace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            *__first = __new_value;\n}\n\n// replace_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_OutputIterator\nreplace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n             const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (*__first == __old_value)\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// replace_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_OutputIterator\nreplace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n                _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (__pred(*__first))\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// fill_n\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_OutputIterator\n__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __value_;\n    return __first;\n}\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_OutputIterator\nfill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n   return _VSTD::__fill_n(__first, __convert_to_integral(__n), __value_);\n}\n\n// fill\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nvoid\n__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)\n{\n    for (; __first != __last; ++__first)\n        *__first = __value_;\n}\n\ntemplate <class _RandomAccessIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nvoid\n__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)\n{\n    _VSTD::fill_n(__first, __last - __first, __value_);\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nvoid\nfill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    _VSTD::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// generate\n\ntemplate <class _ForwardIterator, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nvoid\ngenerate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)\n{\n    for (; __first != __last; ++__first)\n        *__first = __gen();\n}\n\n// generate_n\n\ntemplate <class _OutputIterator, class _Size, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY  _LIBCPP_CONSTEXPR_AFTER_CXX17\n_OutputIterator\ngenerate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __gen();\n    return __first;\n}\n\n// remove\n\ntemplate <class _ForwardIterator, class _Tp>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 _ForwardIterator\nremove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    __first = _VSTD::find(__first, __last, __value_);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!(*__i == __value_))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_if\n\ntemplate <class _ForwardIterator, class _Predicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 _ForwardIterator\nremove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    __first = _VSTD::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>\n                           (__first, __last, __pred);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_OutputIterator\nremove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!(*__first == __value_))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// remove_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_OutputIterator\nremove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// unique\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 _ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    __first = _VSTD::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>\n                                 (__first, __last, __pred);\n    if (__first != __last)\n    {\n        // ...  a  a  ?  ...\n        //      f     i\n        _ForwardIterator __i = __first;\n        for (++__i; ++__i != __last;)\n            if (!__pred(*__first, *__i))\n                *++__first = _VSTD::move(*__i);\n        ++__first;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::unique(__first, __last, __equal_to<__v>());\n}\n\n// unique_copy\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _OutputIterator>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 _OutputIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t(*__first);\n        *__result = __t;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(__t, *__first))\n            {\n                __t = *__first;\n                *__result = __t;\n                ++__result;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 _OutputIterator\n__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              forward_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        *__result = *__i;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(*__i, *__first))\n            {\n                *__result = *__first;\n                ++__result;\n                __i = __first;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 _ForwardIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, forward_iterator_tag)\n{\n    if (__first != __last)\n    {\n        *__result = *__first;\n        while (++__first != __last)\n            if (!__pred(*__result, *__first))\n                *++__result = *__first;\n        ++__result;\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)\n{\n    return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>\n                              (__first, __last, __result, __pred,\n                               typename iterator_traits<_InputIterator>::iterator_category(),\n                               typename iterator_traits<_OutputIterator>::iterator_category());\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type __v;\n    return _VSTD::unique_copy(__first, __last, __result, __equal_to<__v>());\n}\n\n// reverse\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)\n{\n    while (__first != __last)\n    {\n        if (__first == --__last)\n            break;\n        _VSTD::iter_swap(__first, __last);\n        ++__first;\n    }\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)\n{\n    if (__first != __last)\n        for (; __first < --__last; ++__first)\n            _VSTD::iter_swap(__first, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    _VSTD::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());\n}\n\n// reverse_copy\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_OutputIterator\nreverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__result)\n        *__result = *--__last;\n    return __result;\n}\n\n// rotate\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_left(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    value_type __tmp = _VSTD::move(*__first);\n    _ForwardIterator __lm1 = _VSTD::move(_VSTD::next(__first), __last, __first);\n    *__lm1 = _VSTD::move(__tmp);\n    return __lm1;\n}\n\ntemplate <class _BidirectionalIterator>\n_BidirectionalIterator\n__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    _BidirectionalIterator __lm1 = _VSTD::prev(__last);\n    value_type __tmp = _VSTD::move(*__lm1);\n    _BidirectionalIterator __fp1 = _VSTD::move_backward(__first, __lm1, __last);\n    *__first = _VSTD::move(__tmp);\n    return __fp1;\n}\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    _ForwardIterator __i = __middle;\n    while (true)\n    {\n        swap(*__first, *__i);\n        ++__first;\n        if (++__i == __last)\n            break;\n        if (__first == __middle)\n            __middle = __i;\n    }\n    _ForwardIterator __r = __first;\n    if (__first != __middle)\n    {\n        __i = __middle;\n        while (true)\n        {\n            swap(*__first, *__i);\n            ++__first;\n            if (++__i == __last)\n            {\n                if (__first == __middle)\n                    break;\n                __i = __middle;\n            }\n            else if (__first == __middle)\n                __middle = __i;\n        }\n    }\n    return __r;\n}\n\ntemplate<typename _Integral>\ninline _LIBCPP_INLINE_VISIBILITY\n_Integral\n__algo_gcd(_Integral __x, _Integral __y)\n{\n    do\n    {\n        _Integral __t = __x % __y;\n        __x = __y;\n        __y = __t;\n    } while (__y);\n    return __x;\n}\n\ntemplate<typename _RandomAccessIterator>\n_RandomAccessIterator\n__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n\n    const difference_type __m1 = __middle - __first;\n    const difference_type __m2 = __last - __middle;\n    if (__m1 == __m2)\n    {\n        _VSTD::swap_ranges(__first, __middle, __middle);\n        return __middle;\n    }\n    const difference_type __g = _VSTD::__algo_gcd(__m1, __m2);\n    for (_RandomAccessIterator __p = __first + __g; __p != __first;)\n    {\n        value_type __t(_VSTD::move(*--__p));\n        _RandomAccessIterator __p1 = __p;\n        _RandomAccessIterator __p2 = __p1 + __m1;\n        do\n        {\n            *__p1 = _VSTD::move(*__p2);\n            __p1 = __p2;\n            const difference_type __d = __last - __p2;\n            if (__m1 < __d)\n                __p2 += __m1;\n            else\n                __p2 = __first + (__m1 - __d);\n        } while (__p2 != __p);\n        *__p1 = _VSTD::move(__t);\n    }\n    return __first + __m2;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\n__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n         _VSTD::forward_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_ForwardIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator\n__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n         _VSTD::bidirectional_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_BidirectionalIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\n__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n         _VSTD::random_access_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n        return _VSTD::__rotate_gcd(__first, __middle, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nrotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    if (__first == __middle)\n        return __last;\n    if (__middle == __last)\n        return __first;\n    return _VSTD::__rotate(__first, __middle, __last,\n                           typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// rotate_copy\n\ntemplate <class _ForwardIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nrotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __middle, _VSTD::copy(__middle, __last, __result));\n}\n\n// min_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    static_assert(__is_forward_iterator<_ForwardIterator>::value,\n        \"std::min_element requires a ForwardIterator\");\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__i, *__first))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::min_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// min\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::min(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n// max_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    static_assert(__is_forward_iterator<_ForwardIterator>::value,\n        \"std::max_element requires a ForwardIterator\");\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__first, *__i))\n                __first = __i;\n    }\n    return __first;\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::max_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// max\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__a, __b) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::max(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 14\n// clamp\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi, _Compare __comp)\n{\n    _LIBCPP_ASSERT(!__comp(__hi, __lo), \"Bad bounds passed to std::clamp\");\n    return __comp(__v, __lo) ? __lo : __comp(__hi, __v) ? __hi : __v;\n\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi)\n{\n    return _VSTD::clamp(__v, __lo, __hi, __less<_Tp>());\n}\n#endif\n\n// minmax_element\n\ntemplate <class _ForwardIterator, class _Compare>\n_LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n  static_assert(__is_forward_iterator<_ForwardIterator>::value,\n        \"std::minmax_element requires a ForwardIterator\");\n  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);\n  if (__first != __last)\n  {\n      if (++__first != __last)\n      {\n          if (__comp(*__first, *__result.first))\n              __result.first = __first;\n          else\n              __result.second = __first;\n          while (++__first != __last)\n          {\n              _ForwardIterator __i = __first;\n              if (++__first == __last)\n              {\n                  if (__comp(*__i, *__result.first))\n                      __result.first = __i;\n                  else if (!__comp(*__i, *__result.second))\n                      __result.second = __i;\n                  break;\n              }\n              else\n              {\n                  if (__comp(*__first, *__i))\n                  {\n                      if (__comp(*__first, *__result.first))\n                          __result.first = __first;\n                      if (!__comp(*__i, *__result.second))\n                          __result.second = __i;\n                  }\n                  else\n                  {\n                      if (__comp(*__i, *__result.first))\n                          __result.first = __i;\n                      if (!__comp(*__first, *__result.second))\n                          __result.second = __first;\n                  }\n              }\n          }\n      }\n  }\n  return __result;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::minmax_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// minmax\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :\n                              pair<const _Tp&, const _Tp&>(__a, __b);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::minmax(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    typedef typename initializer_list<_Tp>::const_iterator _Iter;\n    _Iter __first = __t.begin();\n    _Iter __last  = __t.end();\n    std::pair<_Tp, _Tp> __result(*__first, *__first);\n\n    ++__first;\n    if (__t.size() % 2 == 0)\n    {\n        if (__comp(*__first,  __result.first))\n            __result.first  = *__first;\n        else\n            __result.second = *__first;\n        ++__first;\n    }\n\n    while (__first != __last)\n    {\n        _Tp __prev = *__first++;\n        if (__comp(*__first, __prev)) {\n            if ( __comp(*__first, __result.first)) __result.first  = *__first;\n            if (!__comp(__prev, __result.second))  __result.second = __prev;\n            }\n        else {\n            if ( __comp(__prev, __result.first))    __result.first  = __prev;\n            if (!__comp(*__first, __result.second)) __result.second = *__first;\n            }\n\n        __first++;\n    }\n    return __result;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t)\n{\n    return _VSTD::minmax(__t, __less<_Tp>());\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n// random_shuffle\n\n// __independent_bits_engine\n\ntemplate <unsigned long long _Xp, size_t _Rp>\nstruct __log2_imp\n{\n    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp\n                                           : __log2_imp<_Xp, _Rp - 1>::value;\n};\n\ntemplate <unsigned long long _Xp>\nstruct __log2_imp<_Xp, 0>\n{\n    static const size_t value = 0;\n};\n\ntemplate <size_t _Rp>\nstruct __log2_imp<0, _Rp>\n{\n    static const size_t value = _Rp + 1;\n};\n\ntemplate <class _UIntType, _UIntType _Xp>\nstruct __log2\n{\n    static const size_t value = __log2_imp<_Xp,\n                                         sizeof(_UIntType) * __CHAR_BIT__ - 1>::value;\n};\n\ntemplate<class _Engine, class _UIntType>\nclass __independent_bits_engine\n{\npublic:\n    // types\n    typedef _UIntType result_type;\n\nprivate:\n    typedef typename _Engine::result_type _Engine_result_type;\n    typedef typename conditional\n        <\n            sizeof(_Engine_result_type) <= sizeof(result_type),\n                result_type,\n                _Engine_result_type\n        >::type _Working_result_type;\n\n    _Engine& __e_;\n    size_t __w_;\n    size_t __w0_;\n    size_t __n_;\n    size_t __n0_;\n    _Working_result_type __y0_;\n    _Working_result_type __y1_;\n    _Engine_result_type __mask0_;\n    _Engine_result_type __mask1_;\n\n#ifdef _LIBCPP_CXX03_LANG\n    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min\n                                          + _Working_result_type(1);\n#else\n    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()\n                                                      + _Working_result_type(1);\n#endif\n    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;\n    static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;\n    static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;\n\npublic:\n    // constructors and seeding functions\n    __independent_bits_engine(_Engine& __e, size_t __w);\n\n    // generating functions\n    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}\n\nprivate:\n    result_type __eval(false_type);\n    result_type __eval(true_type);\n};\n\ntemplate<class _Engine, class _UIntType>\n__independent_bits_engine<_Engine, _UIntType>\n    ::__independent_bits_engine(_Engine& __e, size_t __w)\n        : __e_(__e),\n          __w_(__w)\n{\n    __n_ = __w_ / __m + (__w_ % __m != 0);\n    __w0_ = __w_ / __n_;\n    if (_Rp == 0)\n        __y0_ = _Rp;\n    else if (__w0_ < _WDt)\n        __y0_ = (_Rp >> __w0_) << __w0_;\n    else\n        __y0_ = 0;\n    if (_Rp - __y0_ > __y0_ / __n_)\n    {\n        ++__n_;\n        __w0_ = __w_ / __n_;\n        if (__w0_ < _WDt)\n            __y0_ = (_Rp >> __w0_) << __w0_;\n        else\n            __y0_ = 0;\n    }\n    __n0_ = __n_ - __w_ % __n_;\n    if (__w0_ < _WDt - 1)\n        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);\n    else\n        __y1_ = 0;\n    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :\n                          _Engine_result_type(0);\n    __mask1_ = __w0_ < _EDt - 1 ?\n                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :\n                               _Engine_result_type(~0);\n}\n\ntemplate<class _Engine, class _UIntType>\ninline\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)\n{\n    return static_cast<result_type>(__e_() & __mask0_);\n}\n\ntemplate<class _Engine, class _UIntType>\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)\n{\n    const size_t _WRt = numeric_limits<result_type>::digits;\n    result_type _Sp = 0;\n    for (size_t __k = 0; __k < __n0_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y0_);\n        if (__w0_ < _WRt)\n            _Sp <<= __w0_;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask0_;\n    }\n    for (size_t __k = __n0_; __k < __n_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y1_);\n        if (__w0_ < _WRt - 1)\n            _Sp <<= __w0_ + 1;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask1_;\n    }\n    return _Sp;\n}\n\n// uniform_int_distribution\n\ntemplate<class _IntType = int>\nclass uniform_int_distribution\n{\npublic:\n    // types\n    typedef _IntType result_type;\n\n    class param_type\n    {\n        result_type __a_;\n        result_type __b_;\n    public:\n        typedef uniform_int_distribution distribution_type;\n\n        explicit param_type(result_type __a = 0,\n                            result_type __b = numeric_limits<result_type>::max())\n            : __a_(__a), __b_(__b) {}\n\n        result_type a() const {return __a_;}\n        result_type b() const {return __b_;}\n\n        friend bool operator==(const param_type& __x, const param_type& __y)\n            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}\n        friend bool operator!=(const param_type& __x, const param_type& __y)\n            {return !(__x == __y);}\n    };\n\nprivate:\n    param_type __p_;\n\npublic:\n    // constructors and reset functions\n    explicit uniform_int_distribution(result_type __a = 0,\n                                      result_type __b = numeric_limits<result_type>::max())\n        : __p_(param_type(__a, __b)) {}\n    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}\n    void reset() {}\n\n    // generating functions\n    template<class _URNG> result_type operator()(_URNG& __g)\n        {return (*this)(__g, __p_);}\n    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);\n\n    // property functions\n    result_type a() const {return __p_.a();}\n    result_type b() const {return __p_.b();}\n\n    param_type param() const {return __p_;}\n    void param(const param_type& __p) {__p_ = __p;}\n\n    result_type min() const {return a();}\n    result_type max() const {return b();}\n\n    friend bool operator==(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n        {return __x.__p_ == __y.__p_;}\n    friend bool operator!=(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n            {return !(__x == __y);}\n};\n\ntemplate<class _IntType>\ntemplate<class _URNG>\ntypename uniform_int_distribution<_IntType>::result_type\nuniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)\n_LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK\n{\n    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),\n                                            uint32_t, uint64_t>::type _UIntType;\n    const _UIntType _Rp = _UIntType(__p.b()) - _UIntType(__p.a()) + _UIntType(1);\n    if (_Rp == 1)\n        return __p.a();\n    const size_t _Dt = numeric_limits<_UIntType>::digits;\n    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;\n    if (_Rp == 0)\n        return static_cast<result_type>(_Eng(__g, _Dt)());\n    size_t __w = _Dt - __clz(_Rp) - 1;\n    if ((_Rp & (std::numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)\n        ++__w;\n    _Eng __e(__g, __w);\n    _UIntType __u;\n    do\n    {\n        __u = __e();\n    } while (__u >= _Rp);\n    return static_cast<result_type>(__u + __p.a());\n}\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_RANDOM_SHUFFLE) \\\n  || defined(_LIBCPP_BUILDING_LIBRARY)\nclass _LIBCPP_TYPE_VIS __rs_default;\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\nclass _LIBCPP_TYPE_VIS __rs_default\n{\n    static unsigned __c_;\n\n    __rs_default();\npublic:\n    typedef uint_fast32_t result_type;\n\n    static const result_type _Min = 0;\n    static const result_type _Max = 0xFFFFFFFF;\n\n    __rs_default(const __rs_default&);\n    ~__rs_default();\n\n    result_type operator()();\n\n    static _LIBCPP_CONSTEXPR result_type min() {return _Min;}\n    static _LIBCPP_CONSTEXPR result_type max() {return _Max;}\n\n    friend _LIBCPP_FUNC_VIS __rs_default __rs_get();\n};\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\ntemplate <class _RandomAccessIterator>\n_LIBCPP_DEPRECATED_IN_CXX14 void\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        __rs_default __g = __rs_get();\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _RandomNumberGenerator>\n_LIBCPP_DEPRECATED_IN_CXX14 void\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_CXX03_LANG\n               _RandomNumberGenerator&& __rand)\n#else\n               _RandomNumberGenerator& __rand)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        for (--__last; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __rand(__d);\n            if (__i != difference_type(0))\n              swap(*__first, *(__first + __i));\n        }\n    }\n}\n#endif\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output_iter,\n                         _Distance __n,\n                         _UniformRandomNumberGenerator & __g,\n                         input_iterator_tag) {\n\n  _Distance __k = 0;\n  for (; __first != __last && __k < __n; ++__first, (void)++__k)\n    __output_iter[__k] = *__first;\n  _Distance __sz = __k;\n  for (; __first != __last; ++__first, (void)++__k) {\n    _Distance __r = _VSTD::uniform_int_distribution<_Distance>(0, __k)(__g);\n    if (__r < __sz)\n      __output_iter[__r] = *__first;\n  }\n  return __output_iter + _VSTD::min(__n, __k);\n}\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output_iter,\n                         _Distance __n,\n                         _UniformRandomNumberGenerator& __g,\n                         forward_iterator_tag) {\n  _Distance __unsampled_sz = _VSTD::distance(__first, __last);\n  for (__n = _VSTD::min(__n, __unsampled_sz); __n != 0; ++__first) {\n    _Distance __r =\n        _VSTD::uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);\n    if (__r < __n) {\n      *__output_iter++ = *__first;\n      --__n;\n    }\n  }\n  return __output_iter;\n}\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output_iter,\n                         _Distance __n, _UniformRandomNumberGenerator& __g) {\n  typedef typename iterator_traits<_PopulationIterator>::iterator_category\n        _PopCategory;\n  typedef typename iterator_traits<_PopulationIterator>::difference_type\n        _Difference;\n  static_assert(__is_forward_iterator<_PopulationIterator>::value ||\n                __is_random_access_iterator<_SampleIterator>::value,\n                \"SampleIterator must meet the requirements of RandomAccessIterator\");\n  typedef typename common_type<_Distance, _Difference>::type _CommonType;\n  _LIBCPP_ASSERT(__n >= 0, \"N must be a positive number.\");\n  return _VSTD::__sample(\n      __first, __last, __output_iter, _CommonType(__n),\n      __g, _PopCategory());\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\ninline _LIBCPP_INLINE_VISIBILITY\n_SampleIterator sample(_PopulationIterator __first,\n                       _PopulationIterator __last, _SampleIterator __output_iter,\n                       _Distance __n, _UniformRandomNumberGenerator&& __g) {\n    return _VSTD::__sample(__first, __last, __output_iter, __n, __g);\n}\n#endif // _LIBCPP_STD_VER > 14\n\ntemplate<class _RandomAccessIterator, class _UniformRandomNumberGenerator>\n    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_CXX03_LANG\n                 _UniformRandomNumberGenerator&& __g)\n#else\n                 _UniformRandomNumberGenerator& __g)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _InputIterator, class _Predicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 bool\nis_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    if ( __first == __last )\n        return true;\n    ++__first;\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// partition\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)\n{\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    for (_ForwardIterator __p = __first; ++__p != __last;)\n    {\n        if (__pred(*__p))\n        {\n            swap(*__first, *__p);\n            ++__first;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n            bidirectional_iterator_tag)\n{\n    while (true)\n    {\n        while (true)\n        {\n            if (__first == __last)\n                return __first;\n            if (!__pred(*__first))\n                break;\n            ++__first;\n        }\n        do\n        {\n            if (__first == --__last)\n                return __first;\n        } while (!__pred(*__last));\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\npartition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return _VSTD::__partition<typename add_lvalue_reference<_Predicate>::type>\n                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// partition_copy\n\ntemplate <class _InputIterator, class _OutputIterator1,\n          class _OutputIterator2, class _Predicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 pair<_OutputIterator1, _OutputIterator2>\npartition_copy(_InputIterator __first, _InputIterator __last,\n               _OutputIterator1 __out_true, _OutputIterator2 __out_false,\n               _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__out_true = *__first;\n            ++__out_true;\n        }\n        else\n        {\n            *__out_false = *__first;\n            ++__out_false;\n        }\n    }\n    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);\n}\n\n// partition_point\n\ntemplate<class _ForwardIterator, class _Predicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 _ForwardIterator\npartition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = _VSTD::__half_positive(__len);\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__pred(*__m))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\n// stable_partition\n\ntemplate <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, forward_iterator_tag __fit)\n{\n    // *__first is known to be false\n    // __len >= 1\n    if (__len == 1)\n        return __first;\n    if (__len == 2)\n    {\n        _ForwardIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            return __m;\n        }\n        return __first;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        __i = __first;\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 3\n    _ForwardIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m), *__first know to be false\n    // F?????????????????\n    // f       m         l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);\n    // TTTFFFFF??????????\n    // f  ff   m         l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    _ForwardIterator __m1 = __m;\n    _ForwardIterator __second_false = __last;\n    _Distance __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF??????\n    // f  ff   m  m1     l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf   l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\nstruct __return_temporary_buffer\n{\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) const {_VSTD::return_temporary_buffer(__p);}\n};\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   forward_iterator_tag)\n{\n    const unsigned __alloc_limit = 3;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // We now have a reduced range [__first, __last)\n    // *__first is known to be false\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, forward_iterator_tag());\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)\n{\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    if (__len == 2)\n    {\n        swap(*__first, *__last);\n        return __last;\n    }\n    if (__len == 3)\n    {\n        _BidirectionalIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            swap(*__m, *__last);\n            return __last;\n        }\n        swap(*__m, *__last);\n        swap(*__first, *__m);\n        return __m;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _BidirectionalIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // move *__last, known to be true\n        *__first = _VSTD::move(*__i);\n        __i = ++__first;\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 4\n    _BidirectionalIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false\n    // F????????????????T\n    // f       m        l\n    _BidirectionalIterator __m1 = __m;\n    _BidirectionalIterator __first_false = __first;\n    _Distance __len_half = __len2;\n    while (!__pred(*--__m1))\n    {\n        if (__m1 == __first)\n            goto __first_half_done;\n        --__len_half;\n    }\n    // F???TFFF?????????T\n    // f   m1  m        l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);\n__first_half_done:\n    // TTTFFFFF?????????T\n    // f  ff   m        l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    __m1 = __m;\n    _BidirectionalIterator __second_false = __last;\n    ++__second_false;\n    __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF?????T\n    // f  ff   m  m1    l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf  l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   bidirectional_iterator_tag)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    const difference_type __alloc_limit = 4;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // __first points to first false, everything prior to __first is already set.\n    // Either prove [__first, __last) is all false and return __first, or point __last to last true\n    do\n    {\n        if (__first == --__last)\n            return __first;\n    } while (!__pred(*__last));\n    // We now have a reduced range [__first, __last]\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    difference_type __len = _VSTD::distance(__first, __last) + 1;\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nstable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// is_sorted_until\n\ntemplate <class _ForwardIterator, class _Compare>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 _ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__comp(*__i, *__first))\n                return __i;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// is_sorted\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return _VSTD::is_sorted_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// sort\n\n// stable, 2-3 compares, 0-2 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)\n{\n    unsigned __r = 0;\n    if (!__c(*__y, *__x))          // if x <= y\n    {\n        if (!__c(*__z, *__y))      // if y <= z\n            return __r;            // x <= y && y <= z\n                                   // x <= y && y > z\n        swap(*__y, *__z);          // x <= z && y < z\n        __r = 1;\n        if (__c(*__y, *__x))       // if x > y\n        {\n            swap(*__x, *__y);      // x < y && y <= z\n            __r = 2;\n        }\n        return __r;                // x <= y && y < z\n    }\n    if (__c(*__z, *__y))           // x > y, if y > z\n    {\n        swap(*__x, *__z);          // x < y && y < z\n        __r = 1;\n        return __r;\n    }\n    swap(*__x, *__y);              // x > y && y <= z\n    __r = 1;                       // x < y && x <= z\n    if (__c(*__z, *__y))           // if y > z\n    {\n        swap(*__y, *__z);          // x <= y && y < z\n        __r = 2;\n    }\n    return __r;\n}                                  // x <= y && y <= z\n\n// stable, 3-6 compares, 0-5 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _Compare __c)\n{\n    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);\n    if (__c(*__x4, *__x3))\n    {\n        swap(*__x3, *__x4);\n        ++__r;\n        if (__c(*__x3, *__x2))\n        {\n            swap(*__x2, *__x3);\n            ++__r;\n            if (__c(*__x2, *__x1))\n            {\n                swap(*__x1, *__x2);\n                ++__r;\n            }\n        }\n    }\n    return __r;\n}\n\n// stable, 4-10 compares, 0-9 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\n_LIBCPP_HIDDEN\nunsigned\n__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)\n{\n    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);\n    if (__c(*__x5, *__x4))\n    {\n        swap(*__x4, *__x5);\n        ++__r;\n        if (__c(*__x4, *__x3))\n        {\n            swap(*__x3, *__x4);\n            ++__r;\n            if (__c(*__x3, *__x2))\n            {\n                swap(*__x2, *__x3);\n                ++__r;\n                if (__c(*__x2, *__x1))\n                {\n                    swap(*__x1, *__x2);\n                    ++__r;\n                }\n            }\n        }\n    }\n    return __r;\n}\n\n// Assumes size > 0\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    _BirdirectionalIterator __lm1 = __last;\n    for (--__lm1; __first != __lm1; ++__first)\n    {\n        _BirdirectionalIterator __i = _VSTD::min_element<_BirdirectionalIterator,\n                                                        typename add_lvalue_reference<_Compare>::type>\n                                                       (__first, __last, __comp);\n        if (__i != __first)\n            swap(*__first, *__i);\n    }\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first != __last)\n    {\n        _BirdirectionalIterator __i = __first;\n        for (++__i; __i != __last; ++__i)\n        {\n            _BirdirectionalIterator __j = __i;\n            value_type __t(_VSTD::move(*__j));\n            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t,  *--__k); --__j)\n                *__j = _VSTD::move(*__k);\n            *__j = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n        }\n        __j = __i;\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nbool\n__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    switch (__last - __first)\n    {\n    case 0:\n    case 1:\n        return true;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return true;\n    case 3:\n        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n        return true;\n    case 4:\n        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n        return true;\n    case 5:\n        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n        return true;\n    }\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    const unsigned __limit = 8;\n    unsigned __count = 0;\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n            if (++__count == __limit)\n                return ++__i == __last;\n        }\n        __j = __i;\n    }\n    return true;\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,\n                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first1 != __last1)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);\n        value_type* __last2 = __first2;\n        ::new(__last2) value_type(_VSTD::move(*__first1));\n        __d.__incr((value_type*)0);\n        for (++__last2; ++__first1 != __last1; ++__last2)\n        {\n            value_type* __j2 = __last2;\n            value_type* __i2 = __j2;\n            if (__comp(*__first1, *--__i2))\n            {\n                ::new(__j2) value_type(_VSTD::move(*__i2));\n                __d.__incr((value_type*)0);\n                for (--__j2; __i2 != __first2 && __comp(*__first1,  *--__i2); --__j2)\n                    *__j2 = _VSTD::move(*__i2);\n                *__j2 = _VSTD::move(*__first1);\n            }\n            else\n            {\n                ::new(__j2) value_type(_VSTD::move(*__first1));\n                __d.__incr((value_type*)0);\n            }\n        }\n        __h.release();\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&\n                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;\n    while (true)\n    {\n    __restart:\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n            return;\n        case 4:\n            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n            return;\n        case 5:\n            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n            return;\n        }\n        if (__len <= __limit)\n        {\n            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > 5\n        _RandomAccessIterator __m = __first;\n        _RandomAccessIterator __lm1 = __last;\n        --__lm1;\n        unsigned __n_swaps;\n        {\n        difference_type __delta;\n        if (__len >= 1000)\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __delta /= 2;\n            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);\n        }\n        else\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);\n        }\n        }\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted, sort the secod part\n                    // _VSTD::__sort<_Compare>(__i, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        // It is known that *__i < *__m\n        ++__i;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            // known that __i <= __m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i > __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        // If we were given a perfect partition, see if insertion sort is quick...\n        if (__n_swaps == 0)\n        {\n            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);\n            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))\n            {\n                if (__fs)\n                    return;\n                __last = __i;\n                continue;\n            }\n            else\n            {\n                if (__fs)\n                {\n                    __first = ++__i;\n                    continue;\n                }\n            }\n        }\n        // sort smaller range with recursive call and larger with tail recursion elimination\n        if (__i - __first < __last - __i)\n        {\n            _VSTD::__sort<_Compare>(__first, __i, __comp);\n            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            __first = ++__i;\n        }\n        else\n        {\n            _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            // _VSTD::__sort<_Compare>(__first, __i, __comp);\n            __last = __i;\n        }\n    }\n}\n\n// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_Tp** __first, _Tp** __last)\n{\n    _VSTD::sort((size_t*)__first, (size_t*)__last, __less<size_t>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)\n{\n    _VSTD::sort(__first.base(), __last.base());\n}\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)\n{\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);\n}\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))\n\n// lower_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 _ForwardIterator\n__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = _VSTD::__half_positive(__len);\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::lower_bound(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// upper_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 _ForwardIterator\n__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = _VSTD::__half_positive(__len);\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(__value_, *__m))\n            __len = __l2;\n        else\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::upper_bound(__first, __last, __value_,\n                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// equal_range\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 pair<_ForwardIterator, _ForwardIterator>\n__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = _VSTD::__half_positive(__len);\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else if (__comp(__value_, *__m))\n        {\n            __last = __m;\n            __len = __l2;\n        }\n        else\n        {\n            _ForwardIterator __mp1 = __m;\n            return pair<_ForwardIterator, _ForwardIterator>\n                   (\n                      __lower_bound<_Compare>(__first, __m, __value_, __comp),\n                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)\n                   );\n        }\n    }\n    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::equal_range(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// binary_search\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\n__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);\n    return __first != __last && !__comp(__value_, *__first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::binary_search(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__merge(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());\n}\n\n// inplace_merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2,\n          class _OutputIterator>\nvoid __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2,\n                          _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            _VSTD::move(__first1, __last1, __result);\n            return;\n        }\n\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    // __first2 through __last2 are already in the right spot.\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n    if (__len1 <= __len2)\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        __half_inplace_merge(__buff, __p, __middle, __last, __first, __comp);\n    }\n    else\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        typedef reverse_iterator<_BidirectionalIterator> _RBi;\n        typedef reverse_iterator<value_type*> _Rv;\n        __half_inplace_merge(_Rv(__p), _Rv(__buff),\n                             _RBi(__middle), _RBi(__first),\n                             _RBi(__last), __invert<_Compare>(__comp));\n    }\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    while (true)\n    {\n        // if __middle == __last, we're done\n        if (__len2 == 0)\n            return;\n        if (__len1 <= __buff_size || __len2 <= __buff_size)\n            return __buffered_inplace_merge<_Compare>\n                   (__first, __middle, __last, __comp, __len1, __len2, __buff);\n        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0\n        for (; true; ++__first, (void) --__len1)\n        {\n            if (__len1 == 0)\n                return;\n            if (__comp(*__middle, *__first))\n                break;\n        }\n        // __first < __middle < __last\n        // *__first > *__middle\n        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that\n        //     all elements in:\n        //         [__first, __m1)  <= [__middle, __m2)\n        //         [__middle, __m2) <  [__m1, __middle)\n        //         [__m1, __middle) <= [__m2, __last)\n        //     and __m1 or __m2 is in the middle of its range\n        _BidirectionalIterator __m1;  // \"median\" of [__first, __middle)\n        _BidirectionalIterator __m2;  // \"median\" of [__middle, __last)\n        difference_type __len11;      // distance(__first, __m1)\n        difference_type __len21;      // distance(__middle, __m2)\n        // binary search smaller range\n        if (__len1 < __len2)\n        {   // __len >= 1, __len2 >= 2\n            __len21 = __len2 / 2;\n            __m2 = __middle;\n            _VSTD::advance(__m2, __len21);\n            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);\n            __len11 = _VSTD::distance(__first, __m1);\n        }\n        else\n        {\n            if (__len1 == 1)\n            {   // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1\n                // It is known *__first > *__middle\n                swap(*__first, *__middle);\n                return;\n            }\n            // __len1 >= 2, __len2 >= 1\n            __len11 = __len1 / 2;\n            __m1 = __first;\n            _VSTD::advance(__m1, __len11);\n            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);\n            __len21 = _VSTD::distance(__middle, __m2);\n        }\n        difference_type __len12 = __len1 - __len11;  // distance(__m1, __middle)\n        difference_type __len22 = __len2 - __len21;  // distance(__m2, __last)\n        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)\n        // swap middle two partitions\n        __middle = _VSTD::rotate(__m1, __middle, __m2);\n        // __len12 and __len21 now have swapped meanings\n        // merge smaller range with recurisve call and larger with tail recursion elimination\n        if (__len11 + __len21 < __len12 + __len22)\n        {\n            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n            __first = __middle;\n            __middle = __m2;\n            __len1 = __len12;\n            __len2 = __len22;\n        }\n        else\n        {\n            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n            __last = __middle;\n            __middle = __m1;\n            __len1 = __len11;\n            __len2 = __len21;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n              _Compare __comp)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    difference_type __len1 = _VSTD::distance(__first, __middle);\n    difference_type __len2 = _VSTD::distance(__middle, __last);\n    difference_type __buf_size = _VSTD::min(__len1, __len2);\n    pair<value_type*, ptrdiff_t> __buf = _VSTD::get_temporary_buffer<value_type>(__buf_size);\n    unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);\n\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __c, __len1, __len2,\n                                            __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,\n                                            __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)\n{\n    _VSTD::inplace_merge(__first, __middle, __last,\n                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// stable_sort\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nvoid\n__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h(__result, __d);\n    for (; true; ++__result)\n    {\n        if (__first1 == __last1)\n        {\n            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first2));\n            __h.release();\n            return;\n        }\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first1));\n            __h.release();\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            ::new (__result) value_type(_VSTD::move(*__first2));\n            __d.__incr((value_type*)0);\n            ++__first2;\n        }\n        else\n        {\n            ::new (__result) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first1;\n        }\n    }\n}\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\nvoid\n__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result)\n                *__result = _VSTD::move(*__first1);\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    for (; __first2 != __last2; ++__first2, ++__result)\n        *__result = _VSTD::move(*__first2);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,\n                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    switch (__len)\n    {\n    case 0:\n        return;\n    case 1:\n        ::new(__first2) value_type(_VSTD::move(*__first1));\n        return;\n    case 2:\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);\n        if (__comp(*--__last1, *__first1))\n        {\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n        }\n        else\n        {\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n        }\n        __h2.release();\n        return;\n    }\n    if (__len <= 8)\n    {\n        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first1 + __l2;\n    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);\n    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);\n    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);\n}\n\ntemplate <class _Tp>\nstruct __stable_sort_switch\n{\n    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    switch (__len)\n    {\n    case 0:\n    case 1:\n        return;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return;\n    }\n    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __insertion_sort<_Compare>(__first, __last, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first + __l2;\n    if (__len <= __buff_size)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);\n        __d.__set(__l2, (value_type*)0);\n        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);\n        __d.__set(__len, (value_type*)0);\n        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);\n//         __merge<_Compare>(move_iterator<value_type*>(__buff),\n//                           move_iterator<value_type*>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __len),\n//                           __first, __comp);\n        return;\n    }\n    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);\n    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);\n    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __stable_sort<_Comp_ref>(__first, __last, __c, __len, __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap_until\n\ntemplate <class _RandomAccessIterator, class _Compare>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 _RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    difference_type __p = 0;\n    difference_type __c = 1;\n    _RandomAccessIterator __pp = __first;\n    while (__c < __len)\n    {\n        _RandomAccessIterator __cp = __first + __c;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__c;\n        ++__cp;\n        if (__c == __len)\n            return __last;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__p;\n        ++__pp;\n        __c = 2 * __p + 1;\n    }\n    return __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    return _VSTD::is_heap_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// push_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n          typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        __len = (__len - 2) / 2;\n        _RandomAccessIterator __ptr = __first + __len;\n        if (__comp(*__ptr, *--__last))\n        {\n            value_type __t(_VSTD::move(*__last));\n            do\n            {\n                *__last = _VSTD::move(*__ptr);\n                __last = __ptr;\n                if (__len == 0)\n                    break;\n                __len = (__len - 1) / 2;\n                __ptr = __first + __len;\n            } while (__comp(*__ptr, __t));\n            *__last = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sift_up<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// pop_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_down(_RandomAccessIterator __first, _RandomAccessIterator /*__last*/,\n            _Compare __comp,\n            typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n            _RandomAccessIterator __start)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    // left-child of __start is at 2 * __start + 1\n    // right-child of __start is at 2 * __start + 2\n    difference_type __child = __start - __first;\n\n    if (__len < 2 || (__len - 2) / 2 < __child)\n        return;\n\n    __child = 2 * __child + 1;\n    _RandomAccessIterator __child_i = __first + __child;\n\n    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n        // right-child exists and is greater than left-child\n        ++__child_i;\n        ++__child;\n    }\n\n    // check if we are in heap-order\n    if (__comp(*__child_i, *__start))\n        // we are, __start is larger than it's largest child\n        return;\n\n    value_type __top(_VSTD::move(*__start));\n    do\n    {\n        // we are not in heap-order, swap the parent with it's largest child\n        *__start = _VSTD::move(*__child_i);\n        __start = __child_i;\n\n        if ((__len - 2) / 2 < __child)\n            break;\n\n        // recompute the child based off of the updated parent\n        __child = 2 * __child + 1;\n        __child_i = __first + __child;\n\n        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n            // right-child exists and is greater than left-child\n            ++__child_i;\n            ++__child;\n        }\n\n        // check if we are in heap-order\n    } while (!__comp(*__child_i, __top));\n    *__start = _VSTD::move(__top);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n           typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    if (__len > 1)\n    {\n        swap(*__first, *--__last);\n        __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __pop_heap<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// make_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __n = __last - __first;\n    if (__n > 1)\n    {\n        // start from the first parent, there is no need to consider children\n        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)\n        {\n            __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __make_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __make_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// sort_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)\n        __pop_heap<_Compare>(__first, __last, __comp, __n);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n    __make_heap<_Compare>(__first, __middle, __comp);\n    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;\n    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__first))\n        {\n            swap(*__i, *__first);\n            __sift_down<_Compare>(__first, __middle, __comp, __len, __first);\n        }\n    }\n    __sort_heap<_Compare>(__first, __middle, __comp);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    _VSTD::partial_sort(__first, __middle, __last,\n                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort_copy\n\ntemplate <class _Compare, class _InputIterator, class _RandomAccessIterator>\n_RandomAccessIterator\n__partial_sort_copy(_InputIterator __first, _InputIterator __last,\n                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n    _RandomAccessIterator __r = __result_first;\n    if (__r != __result_last)\n    {\n        for (; __first != __last && __r != __result_last; (void) ++__first, ++__r)\n            *__r = *__first;\n        __make_heap<_Compare>(__result_first, __r, __comp);\n        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;\n        for (; __first != __last; ++__first)\n            if (__comp(*__first, *__result_first))\n            {\n                *__result_first = *__first;\n                __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);\n            }\n        __sort_heap<_Compare>(__result_first, __r, __comp);\n    }\n    return __r;\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)\n{\n    return _VSTD::partial_sort_copy(__first, __last, __result_first, __result_last,\n                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// nth_element\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    const difference_type __limit = 7;\n    while (true)\n    {\n    __restart:\n        if (__nth == __last)\n            return;\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            {\n            _RandomAccessIterator __m = __first;\n            _VSTD::__sort3<_Compare>(__first, ++__m, --__last, __comp);\n            return;\n            }\n        }\n        if (__len <= __limit)\n        {\n            __selection_sort<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > __limit >= 3\n        _RandomAccessIterator __m = __first + __len/2;\n        _RandomAccessIterator __lm1 = __last;\n        unsigned __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, --__lm1, __comp);\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted,\n                    if (__nth < __i)\n                        return;\n                    // __nth_element the secod part\n                    // __nth_element<_Compare>(__i, __nth, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        ++__i;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i >= __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        if (__nth == __i)\n            return;\n        if (__n_swaps == 0)\n        {\n            // We were given a perfectly partitioned sequence.  Coincidence?\n            if (__nth < __i)\n            {\n                // Check for [__first, __i) already sorted\n                __j = __m = __first;\n                while (++__j != __i)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__first, __i) sorted\n                return;\n            }\n            else\n            {\n                // Check for [__i, __last) already sorted\n                __j = __m = __i;\n                while (++__j != __last)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__i, __last) sorted\n                return;\n            }\n        }\nnot_sorted:\n        // __nth_element on range containing __nth\n        if (__nth < __i)\n        {\n            // __nth_element<_Compare>(__first, __nth, __i, __comp);\n            __last = __i;\n        }\n        else\n        {\n            // __nth_element<_Compare>(__i+1, __nth, __last, __comp);\n            __first = ++__i;\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __nth_element<_Comp_ref>(__first, __nth, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)\n{\n    _VSTD::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// includes\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 bool\n__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n           _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1)\n    {\n        if (__first1 == __last1 || __comp(*__first2, *__first1))\n            return false;\n        if (!__comp(*__first1, *__first2))\n            ++__first2;\n    }\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n         _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::includes(__first1, __last1, __first2, __last2,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_union\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            if (!__comp(*__first1, *__first2))\n                ++__first2;\n            *__result = *__first1;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_union(__first1, __last1, __first2, __last2, __result,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_intersection\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 _OutputIterator\n__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1 && __first2 != __last2)\n    {\n        if (__comp(*__first1, *__first2))\n            ++__first1;\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n            {\n                *__result = *__first1;\n                ++__result;\n                ++__first1;\n            }\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,\n                                  __less<typename iterator_traits<_InputIterator1>::value_type,\n                                         typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_difference(__first1, __last1, __first2, __last2, __result,\n                                __less<typename iterator_traits<_InputIterator1>::value_type,\n                                       typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_symmetric_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (__comp(*__first2, *__first1))\n            {\n                *__result = *__first2;\n                ++__result;\n            }\n            else\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,\n                                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// lexicographical_compare\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 bool\n__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1, (void) ++__first2)\n    {\n        if (__first1 == __last1 || __comp(*__first1, *__first2))\n            return true;\n        if (__comp(*__first2, *__first1))\n            return false;\n    }\n    return false;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::lexicographical_compare(__first1, __last1, __first2, __last2,\n                                         __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// next_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*--__i, *__ip1))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*__i, *--__j))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __next_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __next_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::next_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// prev_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*__ip1, *--__i))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*--__j, *__i))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __prev_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __prev_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::prev_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_ALGORITHM\n","// -*- C++ -*-\n//===----------------------------- new ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_NEW\n#define _LIBCPP_NEW\n\n/*\n    new synopsis\n\nnamespace std\n{\n\nclass bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() noexcept;\n    bad_alloc(const bad_alloc&) noexcept;\n    bad_alloc& operator=(const bad_alloc&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_array_new_length : public bad_alloc // C++14\n{\npublic:\n    bad_array_new_length() noexcept;\n};\n\nenum class align_val_t : size_t {}; // C++17\nstruct nothrow_t {};\nextern const nothrow_t nothrow;\ntypedef void (*new_handler)();\nnew_handler set_new_handler(new_handler new_p) noexcept;\nnew_handler get_new_handler() noexcept;\n\n// 21.6.4, pointer optimization barrier\ntemplate <class T> constexpr T* launder(T* p) noexcept; // C++17\n}  // std\n\nvoid* operator new(std::size_t size);                                   // replaceable, nodiscard in C++2a\nvoid* operator new(std::size_t size, std::align_val_t alignment);       // replaceable, C++17, nodiscard in C++2a\nvoid* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable, nodiscard in C++2a\nvoid* operator new(std::size_t size, std::align_val_t alignment,\n                   const std::nothrow_t&) noexcept;                     // replaceable, C++17, nodiscard in C++2a\nvoid  operator delete(void* ptr) noexcept;                              // replaceable\nvoid  operator delete(void* ptr, std::size_t size) noexcept;            // replaceable, C++14\nvoid  operator delete(void* ptr, std::align_val_t alignment) noexcept;  // replaceable, C++17\nvoid  operator delete(void* ptr, std::size_t size,\n                      std::align_val_t alignment) noexcept;             // replaceable, C++17\nvoid  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable\nvoid  operator delete(void* ptr, std:align_val_t alignment,\n                      const std::nothrow_t&) noexcept;                  // replaceable, C++17\n\nvoid* operator new[](std::size_t size);                                 // replaceable, nodiscard in C++2a\nvoid* operator new[](std::size_t size,\n                     std::align_val_t alignment) noexcept;              // replaceable, C++17, nodiscard in C++2a\nvoid* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable, nodiscard in C++2a\nvoid* operator new[](std::size_t size, std::align_val_t alignment,\n                     const std::nothrow_t&) noexcept;                   // replaceable, C++17, nodiscard in C++2a\nvoid  operator delete[](void* ptr) noexcept;                            // replaceable\nvoid  operator delete[](void* ptr, std::size_t size) noexcept;          // replaceable, C++14\nvoid  operator delete[](void* ptr,\n                        std::align_val_t alignment) noexcept;           // replaceable, C++17\nvoid  operator delete[](void* ptr, std::size_t size,\n                        std::align_val_t alignment) noexcept;           // replaceable, C++17\nvoid  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable\nvoid  operator delete[](void* ptr, std::align_val_t alignment,\n                        const std::nothrow_t&) noexcept;                // replaceable, C++17\n\nvoid* operator new  (std::size_t size, void* ptr) noexcept;             // nodiscard in C++2a\nvoid* operator new[](std::size_t size, void* ptr) noexcept;             // nodiscard in C++2a\nvoid  operator delete  (void* ptr, void*) noexcept;\nvoid  operator delete[](void* ptr, void*) noexcept;\n\n*/\n\n#include <__config>\n#include <exception>\n#include <type_traits>\n#include <cstddef>\n#include <version>\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if defined(_LIBCPP_ABI_MICROSOFT) && !defined(_LIBCPP_NO_VCRUNTIME)\n#include <new.h>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#if !defined(__cpp_sized_deallocation) || __cpp_sized_deallocation  < 201309L\n#define _LIBCPP_HAS_NO_LANGUAGE_SIZED_DEALLOCATION\n#endif\n\n#if !defined(_LIBCPP_BUILDING_LIBRARY) && _LIBCPP_STD_VER < 14 && \\\n    defined(_LIBCPP_HAS_NO_LANGUAGE_SIZED_DEALLOCATION)\n# define _LIBCPP_HAS_NO_LIBRARY_SIZED_DEALLOCATION\n#endif\n\n#if defined(_LIBCPP_HAS_NO_LIBRARY_SIZED_DEALLOCATION) || \\\n    defined(_LIBCPP_HAS_NO_LANGUAGE_SIZED_DEALLOCATION)\n# define _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n#endif\n\n#if !__has_builtin(__builtin_operator_new) || \\\n   __has_builtin(__builtin_operator_new) < 201802L\n#define _LIBCPP_HAS_NO_BUILTIN_OVERLOADED_OPERATOR_NEW_DELETE\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\n#if !defined(_LIBCPP_ABI_MICROSOFT) || defined(_LIBCPP_NO_VCRUNTIME)\nstruct _LIBCPP_TYPE_VIS nothrow_t {};\nextern _LIBCPP_FUNC_VIS const nothrow_t nothrow;\n\nclass _LIBCPP_EXCEPTION_ABI bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() _NOEXCEPT;\n    virtual ~bad_alloc() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_new_length\n    : public bad_alloc\n{\npublic:\n    bad_array_new_length() _NOEXCEPT;\n    virtual ~bad_array_new_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\ntypedef void (*new_handler)();\n_LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;\n\n#endif // !_LIBCPP_ABI_MICROSOFT || _LIBCPP_NO_VCRUNTIME\n\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_bad_alloc();  // not in C++ spec\n\n#if !defined(_LIBCPP_HAS_NO_LIBRARY_ALIGNED_ALLOCATION) && \\\n    !defined(_LIBCPP_DEFER_NEW_TO_VCRUNTIME)\n#ifndef _LIBCPP_CXX03_LANG\nenum class _LIBCPP_ENUM_VIS align_val_t : size_t { };\n#else\nenum align_val_t { __zero = 0, __max = (size_t)-1 };\n#endif\n#endif\n\n}  // std\n\n#if defined(_LIBCPP_CXX03_LANG)\n#define _THROW_BAD_ALLOC throw(std::bad_alloc)\n#else\n#define _THROW_BAD_ALLOC\n#endif\n\n#if !defined(_LIBCPP_DEFER_NEW_TO_VCRUNTIME)\n\n_LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz) _THROW_BAD_ALLOC;\n_LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_LIBRARY_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE void  operator delete(void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n_LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz) _THROW_BAD_ALLOC;\n_LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_LIBRARY_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE void  operator delete[](void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_LIBRARY_ALIGNED_ALLOCATION\n_LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;\n_LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_LIBRARY_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE void  operator delete(void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;\n#endif\n\n_LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;\n_LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_LIBRARY_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE void  operator delete[](void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;\n#endif\n#endif\n\n_LIBCPP_NODISCARD_AFTER_CXX17 inline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {return __p;}\n_LIBCPP_NODISCARD_AFTER_CXX17 inline _LIBCPP_INLINE_VISIBILITY void* operator new[](std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete  (void*, void*) _NOEXCEPT {}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete[](void*, void*) _NOEXCEPT {}\n\n#endif // !_LIBCPP_DEFER_NEW_TO_VCRUNTIME\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n_LIBCPP_CONSTEXPR inline _LIBCPP_INLINE_VISIBILITY bool __is_overaligned_for_new(size_t __align) _NOEXCEPT {\n#ifdef __STDCPP_DEFAULT_NEW_ALIGNMENT__\n  return __align > __STDCPP_DEFAULT_NEW_ALIGNMENT__;\n#else\n  return __align > alignment_of<max_align_t>::value;\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void *__libcpp_allocate(size_t __size, size_t __align) {\n#ifndef _LIBCPP_HAS_NO_ALIGNED_ALLOCATION\n  if (__is_overaligned_for_new(__align)) {\n    const align_val_t __align_val = static_cast<align_val_t>(__align);\n# ifdef _LIBCPP_HAS_NO_BUILTIN_OVERLOADED_OPERATOR_NEW_DELETE\n    return ::operator new(__size, __align_val);\n# else\n    return __builtin_operator_new(__size, __align_val);\n# endif\n  }\n#else\n  ((void)__align);\n#endif\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  return ::operator new(__size);\n#else\n  return __builtin_operator_new(__size);\n#endif\n}\n\nstruct _DeallocateCaller {\n  static inline _LIBCPP_INLINE_VISIBILITY\n  void __do_deallocate_handle_size_align(void *__ptr, size_t __size, size_t __align) {\n#if defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION)\n    ((void)__align);\n    return __do_deallocate_handle_size(__ptr, __size);\n#else\n    if (__is_overaligned_for_new(__align)) {\n      const align_val_t __align_val = static_cast<align_val_t>(__align);\n      return __do_deallocate_handle_size(__ptr, __size, __align_val);\n    } else {\n      return __do_deallocate_handle_size(__ptr, __size);\n    }\n#endif\n  }\n\n  static inline _LIBCPP_INLINE_VISIBILITY\n  void __do_deallocate_handle_align(void *__ptr, size_t __align) {\n#if defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION)\n    ((void)__align);\n    return __do_call(__ptr);\n#else\n    if (__is_overaligned_for_new(__align)) {\n      const align_val_t __align_val = static_cast<align_val_t>(__align);\n      return __do_call(__ptr, __align_val);\n    } else {\n      return __do_call(__ptr);\n    }\n#endif\n  }\n\n private:\n  static inline void __do_deallocate_handle_size(void *__ptr, size_t __size) {\n#ifdef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n    ((void)__size);\n    return __do_call(__ptr);\n#else\n    return __do_call(__ptr, __size);\n#endif\n  }\n\n#ifndef _LIBCPP_HAS_NO_ALIGNED_ALLOCATION\n  static inline void __do_deallocate_handle_size(void *__ptr, size_t __size, align_val_t __align) {\n#ifdef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n    ((void)__size);\n    return __do_call(__ptr, __align);\n#else\n    return __do_call(__ptr, __size, __align);\n#endif\n  }\n#endif\n\nprivate:\n  template <class _A1, class _A2>\n  static inline void __do_call(void *__ptr, _A1 __a1, _A2 __a2) {\n#if defined(_LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE) || \\\n    defined(_LIBCPP_HAS_NO_BUILTIN_OVERLOADED_OPERATOR_NEW_DELETE)\n    return ::operator delete(__ptr, __a1, __a2);\n#else\n    return __builtin_operator_delete(__ptr, __a1, __a2);\n#endif\n  }\n\n  template <class _A1>\n  static inline void __do_call(void *__ptr, _A1 __a1) {\n#if defined(_LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE) || \\\n    defined(_LIBCPP_HAS_NO_BUILTIN_OVERLOADED_OPERATOR_NEW_DELETE)\n    return ::operator delete(__ptr, __a1);\n#else\n    return __builtin_operator_delete(__ptr, __a1);\n#endif\n  }\n\n  static inline void __do_call(void *__ptr) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n    return ::operator delete(__ptr);\n#else\n    return __builtin_operator_delete(__ptr);\n#endif\n  }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY void __libcpp_deallocate(void* __ptr, size_t __size, size_t __align) {\n  _DeallocateCaller::__do_deallocate_handle_size_align(__ptr, __size, __align);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void __libcpp_deallocate_unsized(void* __ptr, size_t __align) {\n  _DeallocateCaller::__do_deallocate_handle_align(__ptr, __align);\n}\n\ntemplate <class _Tp>\n_LIBCPP_NODISCARD_AFTER_CXX17 inline\n_LIBCPP_CONSTEXPR _Tp* __launder(_Tp* __p) _NOEXCEPT\n{\n    static_assert (!(is_function<_Tp>::value), \"can't launder functions\" );\n    static_assert (!(is_same<void, typename remove_cv<_Tp>::type>::value), \"can't launder cv-void\" );\n#ifdef _LIBCPP_COMPILER_HAS_BUILTIN_LAUNDER\n    return __builtin_launder(__p);\n#else\n    return __p;\n#endif\n}\n\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp>\n_LIBCPP_NODISCARD_AFTER_CXX17 inline _LIBCPP_INLINE_VISIBILITY\nconstexpr _Tp* launder(_Tp* __p) noexcept\n{\n    return _VSTD::__launder(__p);\n}\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_NEW\n","// -*- C++ -*-\n//===--------------------------- stdexcept --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STDEXCEPT\n#define _LIBCPP_STDEXCEPT\n\n/*\n    stdexcept synopsis\n\nnamespace std\n{\n\nclass logic_error;\n    class domain_error;\n    class invalid_argument;\n    class length_error;\n    class out_of_range;\nclass runtime_error;\n    class range_error;\n    class overflow_error;\n    class underflow_error;\n\nfor each class xxx_error:\n\nclass xxx_error : public exception // at least indirectly\n{\npublic:\n    explicit xxx_error(const string& what_arg);\n    explicit xxx_error(const char*   what_arg);\n\n    virtual const char* what() const noexcept // returns what_arg\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <iosfwd>  // for string forward decl\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_HIDDEN __libcpp_refstring\n{\n    const char* __imp_;\n\n    bool __uses_refcount() const;\npublic:\n    explicit __libcpp_refstring(const char* __msg);\n    __libcpp_refstring(const __libcpp_refstring& __s) _NOEXCEPT;\n    __libcpp_refstring& operator=(const __libcpp_refstring& __s) _NOEXCEPT;\n    ~__libcpp_refstring();\n\n    const char* c_str() const _NOEXCEPT {return __imp_;}\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI logic_error\n    : public exception\n{\nprivate:\n    _VSTD::__libcpp_refstring __imp_;\npublic:\n    explicit logic_error(const string&);\n    explicit logic_error(const char*);\n\n    logic_error(const logic_error&) _NOEXCEPT;\n    logic_error& operator=(const logic_error&) _NOEXCEPT;\n\n    virtual ~logic_error() _NOEXCEPT;\n\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI runtime_error\n    : public exception\n{\nprivate:\n    _VSTD::__libcpp_refstring __imp_;\npublic:\n    explicit runtime_error(const string&);\n    explicit runtime_error(const char*);\n\n    runtime_error(const runtime_error&) _NOEXCEPT;\n    runtime_error& operator=(const runtime_error&) _NOEXCEPT;\n\n    virtual ~runtime_error() _NOEXCEPT;\n\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI domain_error\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const char* __s)   : logic_error(__s) {}\n\n    virtual ~domain_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI invalid_argument\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const char* __s)   : logic_error(__s) {}\n\n    virtual ~invalid_argument() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI length_error\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit length_error(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit length_error(const char* __s)   : logic_error(__s) {}\n\n    virtual ~length_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI out_of_range\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const char* __s)   : logic_error(__s) {}\n\n    virtual ~out_of_range() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI range_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit range_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit range_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~range_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI overflow_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~overflow_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI underflow_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~underflow_error() _NOEXCEPT;\n};\n\n}  // std\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// in the dylib\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\n_LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY\nvoid __throw_logic_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw logic_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY\nvoid __throw_domain_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw domain_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY\nvoid __throw_invalid_argument(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw invalid_argument(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY\nvoid __throw_length_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY\nvoid __throw_out_of_range(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY\nvoid __throw_range_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw range_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY\nvoid __throw_overflow_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw overflow_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY\nvoid __throw_underflow_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw underflow_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STDEXCEPT\n","// -*- C++ -*-\n//===------------------------------ vector --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_VECTOR\n#define _LIBCPP_VECTOR\n\n/*\n    vector synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Allocator = allocator<T> >\nclass vector\n{\npublic:\n    typedef T                                        value_type;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n);\n    explicit vector(size_type n, const allocator_type&); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value); // C++17\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    value_type*       data() noexcept;\n    const value_type* data() const noexcept;\n\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        reference emplace_back(Args&&... args); // reference in C++17\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(vector&)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator = allocator<T> >\nclass vector<bool, Allocator>\n{\npublic:\n    typedef bool                                     value_type;\n    typedef Allocator                                allocator_type;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef iterator                                 pointer;\n    typedef const_iterator                           const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class reference\n    {\n    public:\n        reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        reference& operator=(const bool x) noexcept;\n        reference& operator=(const reference& x) noexcept;\n        iterator operator&() const noexcept;\n        void flip() noexcept;\n    };\n\n    class const_reference\n    {\n    public:\n        const_reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        const_iterator operator&() const noexcept;\n    };\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n, const allocator_type& a = allocator_type()); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value); // C++17\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    void push_back(const value_type& x);\n    template <class... Args> reference emplace_back(Args&&... args);  // C++14; reference in C++17\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);  // C++14\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, value_type x);\n\n    void swap(vector&)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n    void flip() noexcept;\n\n    bool __invariants() const;\n};\n\ntemplate <class InputIterator, class Allocator = allocator<typename iterator_traits<InputIterator>::value_type>>\n   vector(InputIterator, InputIterator, Allocator = Allocator())\n   -> vector<typename iterator_traits<InputIterator>::value_type, Allocator>;\n\ntemplate <class Allocator> struct hash<std::vector<bool, Allocator>>;\n\ntemplate <class T, class Allocator> bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\n\ntemplate <class T, class Allocator>\nvoid swap(vector<T,Allocator>& x, vector<T,Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class T, class Allocator, class U>\n    void erase(vector<T, Allocator>& c, const U& value);       // C++20\ntemplate <class T, class Allocator, class Predicate>\n    void erase_if(vector<T, Allocator>& c, Predicate pred);    // C++20\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd> // for forward declaration of vector\n#include <__bit_reference>\n#include <type_traits>\n#include <climits>\n#include <limits>\n#include <initializer_list>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n#include <cstring>\n#include <version>\n#include <__split_buffer>\n#include <__functional_base>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __vector_base_common\n{\nprotected:\n    _LIBCPP_INLINE_VISIBILITY __vector_base_common() {}\n    _LIBCPP_NORETURN void __throw_length_error() const;\n    _LIBCPP_NORETURN void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_length_error() const\n{\n    _VSTD::__throw_length_error(\"vector\");\n}\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_out_of_range() const\n{\n    _VSTD::__throw_out_of_range(\"vector\");\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __vector_base_common<true>)\n\ntemplate <class _Tp, class _Allocator>\nclass __vector_base\n    : protected __vector_base_common<true>\n{\npublic:\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::size_type       size_type;\nprotected:\n    typedef _Tp                                      value_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer& __end_cap() _NOEXCEPT\n        {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const pointer& __end_cap() const _NOEXCEPT\n        {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY __vector_base(const allocator_type& __a);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY __vector_base(allocator_type&& __a) _NOEXCEPT;\n#endif\n    ~__vector_base();\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return static_cast<size_type>(__end_cap() - __begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n            {\n                clear();\n                __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n                __begin_ = __end_ = __end_cap() = nullptr;\n            }\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base&, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base&, false_type)\n        _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) _NOEXCEPT\n{\n    pointer __soon_to_be_end = __end_;\n    while (__new_last != __soon_to_be_end)\n        __alloc_traits::destroy(__alloc(), _VSTD::__to_raw_pointer(--__soon_to_be_end));\n    __end_ = __new_last;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr, __a)\n{\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base(allocator_type&& __a) _NOEXCEPT\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr, std::move(__a)) {}\n#endif\n\ntemplate <class _Tp, class _Allocator>\n__vector_base<_Tp, _Allocator>::~__vector_base()\n{\n    if (__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n    }\n}\n\ntemplate <class _Tp, class _Allocator /* = allocator<_Tp> */>\nclass _LIBCPP_TEMPLATE_VIS vector\n    : private __vector_base<_Tp, _Allocator>\n{\nprivate:\n    typedef __vector_base<_Tp, _Allocator>           __base;\n    typedef allocator<_Tp>                           __default_allocator_type;\npublic:\n    typedef vector                                   __self;\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef typename __base::__alloc_traits          __alloc_traits;\n    typedef typename __base::reference               reference;\n    typedef typename __base::const_reference         const_reference;\n    typedef typename __base::size_type               size_type;\n    typedef typename __base::difference_type         difference_type;\n    typedef typename __base::pointer                 pointer;\n    typedef typename __base::const_pointer           const_pointer;\n    typedef __wrap_iter<pointer>                     iterator;\n    typedef __wrap_iter<const_pointer>               const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n        : __base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const value_type& __x);\n    vector(size_type __n, const value_type& __x, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value,\n                                 _InputIterator>::type __last);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value,\n                                 _ForwardIterator>::type __last);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~vector()\n    {\n        __annotate_delete();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__erase_c(this);\n#endif\n    }\n\n    vector(const vector& __x);\n    vector(const vector& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(const vector& __x);\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il);\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __x)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const_reference __u);\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return this->__alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY iterator               begin() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         begin()   const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY iterator               end() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         end()     const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return static_cast<size_type>(this->__end_ - this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __base::capacity();}\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return this->__begin_ == this->__end_;}\n    size_type max_size() const _NOEXCEPT;\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n);\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const;\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY reference       back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    value_type*       data() _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n\n#ifdef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    void __emplace_back(const value_type& __x) { push_back(__x); }\n#else\n    template <class _Arg>\n    _LIBCPP_INLINE_VISIBILITY\n    void __emplace_back(_Arg&& __arg) {\n      emplace_back(_VSTD::forward<_Arg>(__arg));\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_STD_VER > 14\n        reference emplace_back(_Args&&... __args);\n#else\n        void      emplace_back(_Args&&... __args);\n#endif\n#endif // !_LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n\n    iterator insert(const_iterator __position, const_reference __x);\n\n#ifndef _LIBCPP_CXX03_LANG\n    iterator insert(const_iterator __position, value_type&& __x);\n    template <class... _Args>\n        iterator emplace(const_iterator __position, _Args&&... __args);\n#endif  // !_LIBCPP_CXX03_LANG\n\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n    {\n        size_type __old_size = size();\n        __base::clear();\n        __annotate_shrink(__old_size);\n        __invalidate_all_iterators();\n    }\n\n    void resize(size_type __sz);\n    void resize(size_type __sz, const_reference __x);\n\n    void swap(vector&)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG;\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(pointer __new_last);\n    void __vallocate(size_type __n);\n    void __vdeallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type __recommend(size_type __new_size) const;\n    void __construct_at_end(size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n);\n    void __append(size_type __n);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       __make_iter(pointer __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(const_pointer __p) const _NOEXCEPT;\n    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);\n    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);\n    void __move_range(pointer __from_s, pointer __from_e, pointer __to);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    void __move_assign(vector& __c, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n    {\n        __invalidate_iterators_past(__new_last);\n        size_type __old_size = size();\n        __base::__destruct_at_end(__new_last);\n        __annotate_shrink(__old_size);\n    }\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> void __push_back_slow_path(_Up&& __x);\n\n    template <class... _Args>\n    void __emplace_back_slow_path(_Args&&... __args);\n#else\n    template <class _Up> void __push_back_slow_path(_Up& __x);\n#endif\n\n    // The following functions are no-ops outside of AddressSanitizer mode.\n    // We call annotatations only for the default Allocator because other allocators\n    // may not meet the AddressSanitizer alignment constraints.\n    // See the documentation for __sanitizer_annotate_contiguous_container for more details.\n#ifndef _LIBCPP_HAS_NO_ASAN\n    void __annotate_contiguous_container(const void *__beg, const void *__end,\n                                         const void *__old_mid,\n                                         const void *__new_mid) const\n    {\n\n      if (__beg && is_same<allocator_type, __default_allocator_type>::value)\n        __sanitizer_annotate_contiguous_container(__beg, __end, __old_mid, __new_mid);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_contiguous_container(const void*, const void*, const void*,\n                                         const void*) const {}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_new(size_type __current_size) const {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + capacity(), data() + __current_size);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_delete() const {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + capacity());\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_increase(size_type __n) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + size() + __n);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_shrink(size_type __old_size) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + __old_size, data() + size());\n    }\n#ifndef _LIBCPP_HAS_NO_ASAN\n    // The annotation for size increase should happen before the actual increase,\n    // but if an exception is thrown after that the annotation has to be undone.\n    struct __RAII_IncreaseAnnotator {\n      __RAII_IncreaseAnnotator(const vector &__v, size_type __n = 1)\n        : __commit(false), __v(__v), __old_size(__v.size() + __n) {\n        __v.__annotate_increase(__n);\n      }\n      void __done() { __commit = true; }\n      ~__RAII_IncreaseAnnotator() {\n        if (__commit) return;\n        __v.__annotate_shrink(__old_size);\n      }\n      bool __commit;\n      const vector &__v;\n      size_type __old_size;\n    };\n#else\n    struct __RAII_IncreaseAnnotator {\n      _LIBCPP_INLINE_VISIBILITY\n      __RAII_IncreaseAnnotator(const vector &, size_type = 1) {}\n      _LIBCPP_INLINE_VISIBILITY void __done() {}\n    };\n#endif\n\n};\n\n#ifndef _LIBCPP_HAS_NO_DEDUCTION_GUIDES\ntemplate<class _InputIterator,\n         class _Alloc = typename std::allocator<typename iterator_traits<_InputIterator>::value_type>,\n         class = typename enable_if<__is_allocator<_Alloc>::value, void>::type\n         >\nvector(_InputIterator, _InputIterator)\n  -> vector<typename iterator_traits<_InputIterator>::value_type, _Alloc>;\n\ntemplate<class _InputIterator,\n         class _Alloc,\n         class = typename enable_if<__is_allocator<_Alloc>::value, void>::type\n         >\nvector(_InputIterator, _InputIterator, _Alloc)\n  -> vector<typename iterator_traits<_InputIterator>::value_type, _Alloc>;\n#endif\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)\n{\n    __annotate_delete();\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::pointer\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)\n{\n    __annotate_delete();\n    pointer __r = __v.__begin_;\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, __p, __v.__begin_);\n    __alloc_traits::__construct_forward(this->__alloc(), __p, this->__end_, __v.__end_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n    return __r;\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __end_cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__vallocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);\n    this->__end_cap() = this->__begin_ + __n;\n    __annotate_new(0);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__vdeallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());\n        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::max_size() const _NOEXCEPT\n{\n    return _VSTD::min<size_type>(__alloc_traits::max_size(this->__alloc()),\n                                 numeric_limits<difference_type>::max());\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max<size_type>(2*__cap, __new_size);\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    __RAII_IncreaseAnnotator __annotator(*this, __n);\n    __alloc_traits::__construct_range_forward(__a, __first, __last, this->__end_);\n    __annotator.__done();\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n, __x);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n, __x);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        __vallocate(__n);\n        __construct_at_end(__n);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        __vallocate(__n);\n        __construct_at_end(__n);\n    }\n}\n#endif\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        __vallocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        __vallocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value,\n                          _InputIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        __emplace_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        __emplace_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value,\n                                                   _ForwardIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        __vallocate(__n);\n        __construct_at_end(__first, __last, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        __vallocate(__n);\n        __construct_at_end(__first, __last, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x)\n    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        __vallocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        __vallocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_, __n);\n    }\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#endif\n    : __base(_VSTD::move(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__x);\n#endif\n    this->__begin_ = __x.__begin_;\n    this->__end_ = __x.__end_;\n    this->__end_cap() = __x.__end_cap();\n    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __x.__alloc())\n    {\n        this->__begin_ = __x.__begin_;\n        this->__end_ = __x.__end_;\n        this->__end_cap() = __x.__end_cap();\n        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->swap(this, &__x);\n#endif\n    }\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__x.begin()), _Ip(__x.end()));\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        __vallocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end(), __il.size());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        __vallocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end(), __il.size());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(vector&& __x)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__x, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__base::__alloc() != __c.__alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    __vdeallocate();\n    __base::__move_assign_alloc(__c); // this can throw\n    this->__begin_ = __c.__begin_;\n    this->__end_ = __c.__end_;\n    this->__end_cap() = __c.__end_cap();\n    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__c);\n#endif\n}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(const vector& __x)\n{\n    if (this != &__x)\n    {\n        __base::__copy_assign_alloc(__x);\n        assign(__x.__begin_, __x.__end_);\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        __emplace_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __new_size = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__new_size <= capacity())\n    {\n        _ForwardIterator __mid = __last;\n        bool __growing = false;\n        if (__new_size > size())\n        {\n            __growing = true;\n            __mid =  __first;\n            _VSTD::advance(__mid, size());\n        }\n        pointer __m = _VSTD::copy(__first, __mid, this->__begin_);\n        if (__growing)\n            __construct_at_end(__mid, __last, __new_size - size());\n        else\n            this->__destruct_at_end(__m);\n    }\n    else\n    {\n        __vdeallocate();\n        __vallocate(__recommend(__new_size));\n        __construct_at_end(__first, __last, __new_size);\n    }\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)\n{\n    if (__n <= capacity())\n    {\n        size_type __s = size();\n        _VSTD::fill_n(this->__begin_, _VSTD::min(__n, __s), __u);\n        if (__n > __s)\n            __construct_at_end(__n - __s, __u);\n        else\n            this->__destruct_at_end(this->__begin_ + __n);\n    }\n    else\n    {\n        __vdeallocate();\n        __vallocate(__recommend(static_cast<size_type>(__n)));\n        __construct_at_end(__n, __u);\n    }\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::__make_iter(pointer __p) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p);\n#else\n    return iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::__make_iter(const_pointer __p) const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(this, __p);\n#else\n    return const_iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::begin() _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::begin() const _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::end() _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::end() const _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::operator[](size_type __n)\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::operator[](size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);\n            __swap_out_circular_buffer(__v);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _Up>\nvoid\n#ifndef _LIBCPP_CXX03_LANG\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)\n#else\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up& __x)\n#endif\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n    // __v.push_back(_VSTD::forward<_Up>(__x));\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Up>(__x));\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (this->__end_ != this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_), __x);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(__x);\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(__x));\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(_VSTD::move(__x));\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\nvector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n//    __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Args>(__args)...);\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ninline\n#if _LIBCPP_STD_VER > 14\ntypename vector<_Tp, _Allocator>::reference\n#else\nvoid\n#endif\nvector<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::forward<_Args>(__args)...);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __emplace_back_slow_path(_VSTD::forward<_Args>(__args)...);\n#if _LIBCPP_STD_VER > 14\n    return this->back();\n#endif\n}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\nvector<_Tp, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"vector::pop_back called for empty vector\");\n    this->__destruct_at_end(this->__end_ - 1);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __position)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::erase(iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__position != end(),\n        \"vector::erase(iterator) called with a non-dereferenceable iterator\");\n    difference_type __ps = __position - cbegin();\n    pointer __p = this->__begin_ + __ps;\n    this->__destruct_at_end(_VSTD::move(__p + 1, this->__end_, __p));\n    this->__invalidate_iterators_past(__p-1);\n    iterator __r = __make_iter(__p);\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__last) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"vector::erase(first, last) called with invalid range\");\n    pointer __p = this->__begin_ + (__first - begin());\n    if (__first != __last) {\n        this->__destruct_at_end(_VSTD::move(__p + (__last - __first), this->__end_, __p));\n        this->__invalidate_iterators_past(__p - 1);\n    }\n    iterator __r = __make_iter(__p);\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)\n{\n    pointer __old_last = this->__end_;\n    difference_type __n = __old_last - __to;\n    for (pointer __i = __from_s + __n; __i < __from_e; ++__i, ++this->__end_)\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(*__i));\n    _VSTD::move_backward(__from_s, __from_s + __n, __old_last);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_), __x);\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n            if (__p <= __xr && __xr < this->__end_)\n                ++__xr;\n            *__p = *__xr;\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(__x);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::move(__x));\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__x);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(_VSTD::move(__x));\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::emplace(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::forward<_Args>(__args)...);\n            ++this->__end_;\n        }\n        else\n        {\n            __temp_value<value_type, _Allocator> __tmp(this->__alloc(), _VSTD::forward<_Args>(__args)...);\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__tmp.get());\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (__n > 0)\n    {\n        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            if (__n > static_cast<size_type>(this->__end_ - __p))\n            {\n                size_type __cx = __n - (this->__end_ - __p);\n                __construct_at_end(__cx, __x);\n                __n -= __cx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n                if (__p <= __xr && __xr < this->__end_)\n                    __xr += __old_n;\n                _VSTD::fill_n(__p, __n, *__xr);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__n, __x);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    difference_type __off = __position - begin();\n    pointer __p = this->__begin_ + __off;\n    allocator_type& __a = this->__alloc();\n    pointer __old_last = this->__end_;\n    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_),\n                                  *__first);\n        ++this->__end_;\n        __annotator.__done();\n    }\n    __split_buffer<value_type, allocator_type&> __v(__a);\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.__construct_at_end(__first, __last);\n            difference_type __old_size = __old_last - this->__begin_;\n            difference_type __old_p = __p - this->__begin_;\n            reserve(__recommend(size() + __v.size()));\n            __p = this->__begin_ + __old_p;\n            __old_last = this->__begin_ + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__make_iter(__old_last), end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_last, this->__end_);\n    insert(__make_iter(__p), make_move_iterator(__v.begin()),\n                                    make_move_iterator(__v.end()));\n    return begin() + __off;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n > 0)\n    {\n        if (__n <= this->__end_cap() - this->__end_)\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            _ForwardIterator __m = __last;\n            difference_type __dx = this->__end_ - __p;\n            if (__n > __dx)\n            {\n                __m = __first;\n                difference_type __diff = this->__end_ - __p;\n                _VSTD::advance(__m, __diff);\n                __construct_at_end(__m, __last, __n - __diff);\n                __n = __dx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                _VSTD::copy(__first, __m, __p);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__first, __last);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs, __x);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::swap(vector& __x)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT_DEBUG\n#else\n    _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__alloc() == __x.__alloc(),\n                   \"vector::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__end_, __x.__end_);\n    _VSTD::swap(this->__end_cap(), __x.__end_cap());\n    __swap_allocator(this->__alloc(), __x.__alloc(),\n        integral_constant<bool,__alloc_traits::propagate_on_container_swap::value>());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__x);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__end_ != nullptr || this->__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (this->__begin_ > this->__end_)\n            return false;\n        if (this->__begin_ == this->__end_cap())\n            return false;\n        if (this->__end_ > this->__end_cap())\n            return false;\n    }\n    return true;\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->__begin_ <= __i->base() && __i->base() < this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->__begin_ < __i->base() && __i->base() <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p < this->__end_;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_iterators_past(pointer __new_last) {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n  __c_node* __c = __get_db()->__find_c_and_lock(this);\n  for (__i_node** __p = __c->end_; __p != __c->beg_; ) {\n    --__p;\n    const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n    if (__i->base() > __new_last) {\n      (*__p)->__c_ = nullptr;\n      if (--__c->end_ != __p)\n        memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n    }\n  }\n  __get_db()->unlock();\n#else\n  ((void)__new_last);\n#endif\n}\n\n// vector<bool>\n\ntemplate <class _Allocator> class vector<bool, _Allocator>;\n\ntemplate <class _Allocator> struct hash<vector<bool, _Allocator> >;\n\ntemplate <class _Allocator>\nstruct __has_storage_type<vector<bool, _Allocator> >\n{\n    static const bool value = true;\n};\n\ntemplate <class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS vector<bool, _Allocator>\n    : private __vector_base_common<true>\n{\npublic:\n    typedef vector                                   __self;\n    typedef bool                                     value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef size_type __storage_type;\n    typedef __bit_iterator<vector, false>            pointer;\n    typedef __bit_iterator<vector, true>             const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\nprivate:\n    typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type __storage_allocator;\n    typedef allocator_traits<__storage_allocator>    __storage_traits;\n    typedef typename __storage_traits::pointer       __storage_pointer;\n    typedef typename __storage_traits::const_pointer __const_storage_pointer;\n\n    __storage_pointer                                      __begin_;\n    size_type                                              __size_;\n    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;\npublic:\n    typedef __bit_reference<vector>                  reference;\n    typedef __bit_const_reference<vector>            const_reference;\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& __cap() _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __cap() const _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    __storage_allocator& __alloc() _NOEXCEPT\n        {return __cap_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __storage_allocator& __alloc() const _NOEXCEPT\n        {return __cap_alloc_.second();}\n\n    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __internal_cap_to_external(size_type __n) _NOEXCEPT\n        {return __n * __bits_per_word;}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __external_cap_to_internal(size_type __n) _NOEXCEPT\n        {return (__n - 1) / __bits_per_word + 1;}\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n    ~vector();\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const value_type& __v);\n    vector(size_type __n, const value_type& __v, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n\n    vector(const vector& __v);\n    vector(const vector& __v, const allocator_type& __a);\n    vector& operator=(const vector& __v);\n\n#ifndef _LIBCPP_CXX03_LANG\n    vector(initializer_list<value_type> __il);\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __v)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#endif\n    vector(vector&& __v, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __v)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value &&\n           !__is_forward_iterator<_InputIterator>::value,\n           void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n           void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const value_type& __x);\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(this->__alloc());}\n\n    size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __internal_cap_to_external(__cap());}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return __size_;}\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return __size_ == 0;}\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT\n        {return __make_iter(__size_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n)       {return __make_ref(__n);}\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const {return __make_ref(__n);}\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()       {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY reference       back()        {return __make_ref(__size_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const {return __make_ref(__size_ - 1);}\n\n    void push_back(const value_type& __x);\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY reference emplace_back(_Args&&... __args)\n#else\n    _LIBCPP_INLINE_VISIBILITY void      emplace_back(_Args&&... __args)\n#endif\n    {\n        push_back ( value_type ( _VSTD::forward<_Args>(__args)... ));\n#if _LIBCPP_STD_VER > 14\n        return this->back();\n#endif\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {--__size_;}\n\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n   _LIBCPP_INLINE_VISIBILITY iterator emplace(const_iterator position, _Args&&... __args)\n        { return insert ( position, value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    iterator insert(const_iterator __position, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__size_ = 0;}\n\n    void swap(vector&)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n    static void swap(reference __x, reference __y) _NOEXCEPT { _VSTD::swap(__x, __y); }\n\n    void resize(size_type __sz, value_type __x = false);\n    void flip() _NOEXCEPT;\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void __vallocate(size_type __n);\n    void __vdeallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __align_it(size_type __new_size) _NOEXCEPT\n        {return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);}\n    _LIBCPP_INLINE_VISIBILITY  size_type __recommend(size_type __new_size) const;\n    _LIBCPP_INLINE_VISIBILITY void __construct_at_end(size_type __n, bool __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    reference __make_ref(size_type __pos) _NOEXCEPT\n        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference __make_ref(size_type __pos) const _NOEXCEPT\n        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __make_iter(size_type __pos) _NOEXCEPT\n        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(size_type __pos) const _NOEXCEPT\n        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __const_iterator_cast(const_iterator __p) _NOEXCEPT\n        {return begin() + (__p - cbegin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __v)\n        {__copy_assign_alloc(__v, integral_constant<bool,\n                      __storage_traits::propagate_on_container_copy_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n                __vdeallocate();\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector&, false_type)\n        {}\n\n    void __move_assign(vector& __c, false_type);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __storage_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector&, false_type)\n        _NOEXCEPT\n        {}\n\n    size_t __hash_code() const _NOEXCEPT;\n\n    friend class __bit_reference<vector>;\n    friend class __bit_const_reference<vector>;\n    friend class __bit_iterator<vector, false>;\n    friend class __bit_iterator<vector, true>;\n    friend struct __bit_array<vector>;\n    friend struct _LIBCPP_TEMPLATE_VIS hash<vector>;\n};\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__invalidate_all_iterators()\n{\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__vallocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    __n = __external_cap_to_internal(__n);\n    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);\n    this->__size_ = 0;\n    this->__cap() = __n;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__vdeallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());\n        __invalidate_all_iterators();\n        this->__begin_ = nullptr;\n        this->__size_ = this->__cap() = 0;\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __amax = __storage_traits::max_size(__alloc());\n    size_type __nmax = numeric_limits<size_type>::max() / 2;  // end() >= begin(), always\n    if (__nmax / __bits_per_word <= __amax)\n        return __nmax;\n    return __internal_cap_to_external(__amax);\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max(2*__cap, __align_it(__new_size));\n}\n\n//  Default constructs __n objects starting at __end_\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += __n;\n    if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) != ((this->__size_ - 1) / __bits_per_word))\n    {\n        if (this->__size_ <= __bits_per_word)\n            this->__begin_[0] = __storage_type(0);\n        else\n            this->__begin_[(this->__size_ - 1) / __bits_per_word] = __storage_type(0);\n    }\n    _VSTD::fill_n(__make_iter(__old_size), __n, __x);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += _VSTD::distance(__first, __last);\n    if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) != ((this->__size_ - 1) / __bits_per_word))\n    {\n        if (this->__size_ <= __bits_per_word)\n            this->__begin_[0] = __storage_type(0);\n        else\n            this->__begin_[(this->__size_ - 1) / __bits_per_word] = __storage_type(0);\n    }\n    _VSTD::copy(__first, __last, __make_iter(__old_size));\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        __vallocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        __vallocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n#endif\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        __vallocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        __vallocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        __vallocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        __vallocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        __vallocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        __vallocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::~vector()\n{\n    if (__begin_ != nullptr)\n        __storage_traits::deallocate(__alloc(), __begin_, __cap());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))\n{\n    if (__v.size() > 0)\n    {\n        __vallocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__v.size() > 0)\n    {\n        __vallocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(const vector& __v)\n{\n    if (this != &__v)\n    {\n        __copy_assign_alloc(__v);\n        if (__v.__size_)\n        {\n            if (__v.__size_ > capacity())\n            {\n                __vdeallocate();\n                __vallocate(__v.__size_);\n            }\n            _VSTD::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);\n        }\n        __size_ = __v.__size_;\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY vector<bool, _Allocator>::vector(vector&& __v)\n#if _LIBCPP_STD_VER > 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#endif\n    : __begin_(__v.__begin_),\n      __size_(__v.__size_),\n      __cap_alloc_(std::move(__v.__cap_alloc_)) {\n    __v.__begin_ = nullptr;\n    __v.__size_ = 0;\n    __v.__cap() = 0;\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__a == allocator_type(__v.__alloc()))\n    {\n        this->__begin_ = __v.__begin_;\n        this->__size_ = __v.__size_;\n        this->__cap() = __v.__cap();\n        __v.__begin_ = nullptr;\n        __v.__cap() = __v.__size_ = 0;\n    }\n    else if (__v.size() > 0)\n    {\n        __vallocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(vector&& __v)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__v, integral_constant<bool,\n          __storage_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__alloc() != __c.__alloc())\n        assign(__c.begin(), __c.end());\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    __vdeallocate();\n    __move_assign_alloc(__c);\n    this->__begin_ = __c.__begin_;\n    this->__size_ = __c.__size_;\n    this->__cap() = __c.__cap();\n    __c.__begin_ = nullptr;\n    __c.__cap() = __c.__size_ = 0;\n}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::assign(size_type __n, const value_type& __x)\n{\n    __size_ = 0;\n    if (__n > 0)\n    {\n        size_type __c = capacity();\n        if (__n <= __c)\n            __size_ = __n;\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__n));\n            __v.__size_ = __n;\n            swap(__v);\n        }\n        _VSTD::fill_n(begin(), __n, __x);\n    }\n  __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_forward_iterator<_InputIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    clear();\n    difference_type __ns = _VSTD::distance(__first, __last);\n    _LIBCPP_ASSERT(__ns >= 0, \"invalid range specified\");\n    const size_t __n = static_cast<size_type>(__ns);\n    if (__n)\n    {\n        if (__n > capacity())\n        {\n            __vdeallocate();\n            __vallocate(__n);\n        }\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        vector __v(this->__alloc());\n        __v.__vallocate(__n);\n        __v.__construct_at_end(this->begin(), this->end());\n        swap(__v);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (__external_cap_to_internal(size()) > __cap())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            vector(*this, allocator_type(__alloc())).swap(*this);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::reference\nvector<bool, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::const_reference\nvector<bool, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::push_back(const value_type& __x)\n{\n    if (this->__size_ == this->capacity())\n        reserve(__recommend(this->__size_ + 1));\n    ++this->__size_;\n    back() = __x;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)\n{\n    iterator __r;\n    if (size() < capacity())\n    {\n        const_iterator __old_end = end();\n        ++__size_;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + 1));\n        __v.__size_ = __size_ + 1;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    *__r = __x;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)\n{\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::fill_n(__r, __n, __x);\n    return __r;\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n    difference_type __off = __position - begin();\n    iterator __p = __const_iterator_cast(__position);\n    iterator __old_end = end();\n    for (; size() != capacity() && __first != __last; ++__first)\n    {\n        ++this->__size_;\n        back() = *__first;\n    }\n    vector __v(__alloc());\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.assign(__first, __last);\n            difference_type __old_size = static_cast<difference_type>(__old_end - begin());\n            difference_type __old_p = __p - begin();\n            reserve(__recommend(size() + __v.size()));\n            __p = begin() + __old_p;\n            __old_end = begin() + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__old_end, end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_end, end());\n    insert(__p, __v.begin(), __v.end());\n    return begin() + __off;\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n    const difference_type __n_signed = _VSTD::distance(__first, __last);\n    _LIBCPP_ASSERT(__n_signed >= 0, \"invalid range specified\");\n    const size_type __n = static_cast<size_type>(__n_signed);\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::copy(__first, __last, __r);\n    return __r;\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __position)\n{\n    iterator __r = __const_iterator_cast(__position);\n    _VSTD::copy(__position + 1, this->cend(), __r);\n    --__size_;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n    iterator __r = __const_iterator_cast(__first);\n    difference_type __d = __last - __first;\n    _VSTD::copy(__last, this->cend(), __r);\n    __size_ -= __d;\n    return __r;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::swap(vector& __x)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__size_, __x.__size_);\n    _VSTD::swap(this->__cap(), __x.__cap());\n    __swap_allocator(this->__alloc(), __x.__alloc(),\n        integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::resize(size_type __sz, value_type __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n    {\n        iterator __r;\n        size_type __c = capacity();\n        size_type __n = __sz - __cs;\n        if (__n <= __c && __cs <= __c - __n)\n        {\n            __r = end();\n            __size_ += __n;\n        }\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__size_ + __n));\n            __v.__size_ = __size_ + __n;\n            __r = _VSTD::copy(cbegin(), cend(), __v.begin());\n            swap(__v);\n        }\n        _VSTD::fill_n(__r, __n, __x);\n    }\n    else\n        __size_ = __sz;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::flip() _NOEXCEPT\n{\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        *__p = ~*__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __storage_type __b = *__p & __m;\n        *__p &= ~__m;\n        *__p |= ~__b & __m;\n    }\n}\n\ntemplate <class _Allocator>\nbool\nvector<bool, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__size_ != 0 || this->__cap() != 0)\n            return false;\n    }\n    else\n    {\n        if (this->__cap() == 0)\n            return false;\n        if (this->__size_ > this->capacity())\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Allocator>\nsize_t\nvector<bool, _Allocator>::__hash_code() const _NOEXCEPT\n{\n    size_t __h = 0;\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        __h ^= *__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __h ^= *__p & __m;\n    }\n    return __h;\n}\n\ntemplate <class _Allocator>\nstruct _LIBCPP_TEMPLATE_VIS hash<vector<bool, _Allocator> >\n    : public unary_function<vector<bool, _Allocator>, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const vector<bool, _Allocator>& __vec) const _NOEXCEPT\n        {return __vec.__hash_code();}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();\n    return __sz == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n#if _LIBCPP_STD_VER > 17\ntemplate <class _Tp, class _Allocator, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid erase(vector<_Tp, _Allocator>& __c, const _Up& __v)\n{ __c.erase(_VSTD::remove(__c.begin(), __c.end(), __v), __c.end()); }\n\ntemplate <class _Tp, class _Allocator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid erase_if(vector<_Tp, _Allocator>& __c, _Predicate __pred)\n{ __c.erase(_VSTD::remove_if(__c.begin(), __c.end(), __pred), __c.end()); }\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_VECTOR\n","// -*- C++ -*-\n#ifndef _LIBCPP_SPLIT_BUFFER\n#define _LIBCPP_SPLIT_BUFFER\n\n#include <__config>\n#include <type_traits>\n#include <algorithm>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __split_buffer_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nstruct __split_buffer\n    : private __split_buffer_common<true>\n{\nprivate:\n    __split_buffer(const __split_buffer&);\n    __split_buffer& operator=(const __split_buffer&);\npublic:\n    typedef _Tp                                             value_type;\n    typedef _Allocator                                      allocator_type;\n    typedef typename remove_reference<allocator_type>::type __alloc_rr;\n    typedef allocator_traits<__alloc_rr>                    __alloc_traits;\n    typedef value_type&                                     reference;\n    typedef const value_type&                               const_reference;\n    typedef typename __alloc_traits::size_type              size_type;\n    typedef typename __alloc_traits::difference_type        difference_type;\n    typedef typename __alloc_traits::pointer                pointer;\n    typedef typename __alloc_traits::const_pointer          const_pointer;\n    typedef pointer                                         iterator;\n    typedef const_pointer                                   const_iterator;\n\n    pointer                                         __first_;\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;\n\n    _LIBCPP_INLINE_VISIBILITY __alloc_rr&           __alloc() _NOEXCEPT         {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY const __alloc_rr&     __alloc() const _NOEXCEPT   {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY pointer&              __end_cap() _NOEXCEPT       {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY const pointer&        __end_cap() const _NOEXCEPT {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __split_buffer()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __split_buffer(__alloc_rr& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __split_buffer(const __alloc_rr& __a);\n    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);\n    ~__split_buffer();\n\n#ifndef _LIBCPP_CXX03_LANG\n    __split_buffer(__split_buffer&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);\n    __split_buffer& operator=(__split_buffer&& __c)\n        _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value);\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY       iterator begin() _NOEXCEPT       {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator begin() const _NOEXCEPT {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY       iterator end() _NOEXCEPT         {return __end_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator end() const _NOEXCEPT   {return __end_;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n        {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY size_type size() const {return static_cast<size_type>(__end_ - __begin_);}\n    _LIBCPP_INLINE_VISIBILITY bool empty()     const {return __end_ == __begin_;}\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}\n\n    _LIBCPP_INLINE_VISIBILITY       reference front()       {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY       reference back()        {return *(__end_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const  {return *(__end_ - 1);}\n\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n    void push_front(const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#ifndef _LIBCPP_CXX03_LANG\n    void push_front(value_type&& __x);\n    void push_back(value_type&& __x);\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\n    _LIBCPP_INLINE_VISIBILITY void pop_front() {__destruct_at_begin(__begin_+1);}\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {__destruct_at_end(__end_-1);}\n\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _InputIter>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIter>::value &&\n           !__is_forward_iterator<_InputIter>::value,\n            void\n        >::type\n        __construct_at_end(_InputIter __first, _InputIter __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY void __destruct_at_begin(pointer __new_begin)\n        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}\n        _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_begin(pointer __new_begin, false_type);\n        _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_begin(pointer __new_begin, true_type);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n        {__destruct_at_end(__new_last, false_type());}\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, false_type) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, true_type) _NOEXCEPT;\n\n    void swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value);\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer&, false_type) _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\nbool\n__split_buffer<_Tp, _Allocator>::__invariants() const\n{\n    if (__first_ == nullptr)\n    {\n        if (__begin_ != nullptr)\n            return false;\n        if (__end_ != nullptr)\n            return false;\n        if (__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (__begin_ < __first_)\n            return false;\n        if (__end_ < __begin_)\n            return false;\n        if (__end_cap() < __end_)\n            return false;\n    }\n    return true;\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ntypename enable_if\n<\n     __is_input_iterator<_InputIter>::value &&\n    !__is_forward_iterator<_InputIter>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        if (__end_ == __end_cap())\n        {\n            size_type __old_cap = __end_cap() - __first_;\n            size_type __new_cap = _VSTD::max<size_type>(2 * __old_cap, 8);\n            __split_buffer __buf(__new_cap, 0, __a);\n            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)\n                __alloc_traits::construct(__buf.__alloc(),\n                        _VSTD::__to_raw_pointer(__buf.__end_), _VSTD::move(*__p));\n            swap(__buf);\n        }\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)\n{\n    while (__begin_ != __new_begin)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(__begin_++));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)\n{\n    __begin_ = __new_begin;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) _NOEXCEPT\n{\n    __end_ = __new_last;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)\n    : __end_cap_(nullptr, __a)\n{\n    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;\n    __begin_ = __end_ = __first_ + __start;\n    __end_cap() = __first_ + __cap;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::~__split_buffer()\n{\n    clear();\n    if (__first_)\n        __alloc_traits::deallocate(__alloc(), __first_, capacity());\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __first_(_VSTD::move(__c.__first_)),\n      __begin_(_VSTD::move(__c.__begin_)),\n      __end_(_VSTD::move(__c.__end_)),\n      __end_cap_(_VSTD::move(__c.__end_cap_))\n{\n    __c.__first_ = nullptr;\n    __c.__begin_ = nullptr;\n    __c.__end_ = nullptr;\n    __c.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)\n    : __end_cap_(__second_tag(), __a)\n{\n    if (__a == __c.__alloc())\n    {\n        __first_ = __c.__first_;\n        __begin_ = __c.__begin_;\n        __end_ = __c.__end_;\n        __end_cap() = __c.__end_cap();\n        __c.__first_ = nullptr;\n        __c.__begin_ = nullptr;\n        __c.__end_ = nullptr;\n        __c.__end_cap() = nullptr;\n    }\n    else\n    {\n        size_type __cap = __c.size();\n        __first_ = __alloc_traits::allocate(__alloc(), __cap);\n        __begin_ = __end_ = __first_;\n        __end_cap() = __first_ + __cap;\n        typedef move_iterator<iterator> _Ip;\n        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>&\n__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)\n    _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value)\n{\n    clear();\n    shrink_to_fit();\n    __first_ = __c.__first_;\n    __begin_ = __c.__begin_;\n    __end_ = __c.__end_;\n    __end_cap() = __c.__end_cap();\n    __move_assign_alloc(__c,\n        integral_constant<bool,\n                          __alloc_traits::propagate_on_container_move_assignment::value>());\n    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n{\n    _VSTD::swap(__first_, __x.__first_);\n    _VSTD::swap(__begin_, __x.__begin_);\n    _VSTD::swap(__end_, __x.__end_);\n    _VSTD::swap(__end_cap(), __x.__end_cap());\n    __swap_allocator(__alloc(), __x.__alloc());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n < capacity())\n    {\n        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());\n        __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                               move_iterator<pointer>(__end_));\n        _VSTD::swap(__first_, __t.__first_);\n        _VSTD::swap(__begin_, __t.__begin_);\n        _VSTD::swap(__end_, __t.__end_);\n        _VSTD::swap(__end_cap(), __t.__end_cap());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            __t.__end_ = __t.__begin_ + (__end_ - __begin_);\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1), __x);\n    --__begin_;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1),\n            _VSTD::move(__x));\n    --__begin_;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_), __x);\n    ++__end_;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n            _VSTD::move(__x));\n    ++__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\n__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n                              _VSTD::forward<_Args>(__args)...);\n    ++__end_;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)\n        _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_SPLIT_BUFFER\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2018\n *\n *  @file js_utils.hpp\n *  @brief Tools for passing data between C++ and Javascript.\n */\n\n#ifndef EMP_WEB_JS_UTILS_HPP_INCLUDE\n#define EMP_WEB_JS_UTILS_HPP_INCLUDE\n\n#include <map>\n#include <string>\n#include <typeinfo>\n\n#include \"../base/array.hpp\"\n#include \"../base/assert.hpp\"\n#include \"../base/map.hpp\"\n#include \"../base/vector.hpp\"\n\n#include \"init.hpp\"\n\n\nnamespace emp {\n\n  /// This function returns a std::map mapping typeid names to the appropriate\n  /// strings to describe those types in Javscript. This is useful when using\n  /// getValue() from within MAIN_THREAD_EM_ASM macros.\n  ///\n  ///  For example, say we have a templated function that takes a pointer to type\n  /// T. We find out the appropriate string for type T:\n  /// std::map<const char*, std::string> type_map = GetTypeToStringMap();\n  /// std::string type_string = type_map[typeid(T).name()];\n  ///\n  /// Now we can pass type_string.c_str() into MAIN_THREAD_EM_ASM:\n  /// `MAIN_THREAD_EM_ASM({\n  ///    var value = getValue($0, $1);\n  /// }, pointer, type_string.c_str();`\n\n  std::map<std::string, std::string> get_type_to_string_map() {\n    // Using typeid().name() could create problems because it varies by\n    // implementation. All that matters is consistency, but obscure could\n    // technically be given the same name. So far it seems to not be an issue\n    // with Emscripten, which is most critical for this code.\n    std::map<std::string, std::string> map_type_names;\n    map_type_names[typeid(int8_t).name()] = \"i8\";\n    map_type_names[typeid(int16_t).name()] = \"i16\";\n    map_type_names[typeid(int32_t).name()] = \"i32\";\n    map_type_names[typeid(int64_t).name()] = \"i64\";\n    map_type_names[typeid(float).name()] = \"float\";\n    map_type_names[typeid(double).name()] = \"double\";\n    map_type_names[typeid(int8_t*).name()] = \"i8*\";\n    map_type_names[typeid(int16_t*).name()] = \"i16*\";\n    map_type_names[typeid(int32_t*).name()] = \"i32*\";\n    map_type_names[typeid(int64_t*).name()] = \"i64*\";\n    map_type_names[typeid(float*).name()] = \"float*\";\n    map_type_names[typeid(double*).name()] = \"double*\";\n    map_type_names[typeid(void*).name()] = \"*\";\n    map_type_names[typeid(std::string).name()] = \"string\";\n\n    return map_type_names;\n  }\n\n  /// This function can be called to pass an array, vector, or other container with contiguously\n  /// stored data into Javascript.\n  /// The array will be stored in emp.__incoming_array. Currently supports\n  /// arrays containing all of the types defined in get_type_to_string_map, which\n  /// are also all of the types that emscripten supports getting via pointer.\n  /// This function also supports nested arrays, and arrays of objects created with\n  /// introspective tuple structs.\n\n  /// @cond TEMPLATES\n\n  // This code now works for all containers, as long as they store data contiguously\n\n  template<typename C, class = typename C::value_type>\n  typename std::enable_if<std::is_pod<typename C::value_type>::value, void>::type\n  pass_array_to_javascript(C values, emp::vector<int> recursive_el)\n  {\n    using T = typename C::value_type;\n    //Figure out what string to use for the type we've been given\n    std::map<std::string, std::string> map_type_names = get_type_to_string_map();\n    emp_assert((map_type_names.find(typeid(T).name()) != map_type_names.end()));\n    int type_size = sizeof(T);\n    (void) type_size;\n    std::string type_string = map_type_names[typeid(T).name()];\n\n    // Clear array, if this isn't a recursive call\n    if (recursive_el.size() == 0) {\n      MAIN_THREAD_EM_ASM({emp_i.__incoming_array = [];});\n    }\n\n    MAIN_THREAD_EM_ASM({\n      var curr_array = emp_i.__incoming_array;\n      var depth = 0;\n\n      // Make sure that we're at the right depth, in case of recursive call.\n      while (curr_array.length > 0) {\n        var next_index = getValue($4+(depth*4), \"i32\");\n        depth += 1;\n        curr_array = curr_array[next_index];\n      }\n\n      // Iterate over array, get values, and add them to incoming array.\n      for (i=0; i<$1; i++) {\n        curr_array.push(getValue($0+(i*$2), UTF8ToString($3)));\n      }\n    }, &values[0], values.size(), type_size, type_string.c_str(), recursive_el.data());\n  }\n\n  // Specialization for strings\n  template<typename C, class = typename C::value_type>\n  typename std::enable_if<std::is_same<typename C::value_type, std::string>::value, void>::type\n  pass_array_to_javascript(C values, emp::vector<int> recursive_el)\n  {\n    // Clear array, if this isn't a recursive call\n    if (recursive_el.size() == 0) {\n      MAIN_THREAD_EM_ASM({emp_i.__incoming_array = [];});\n    };\n\n    MAIN_THREAD_EM_ASM({\n      emp_i.__curr_array = emp_i.__incoming_array;\n      var depth = 0;\n\n      // Make sure that we are at the right depth, in case of recursive call.\n      while (emp_i.__curr_array.length > 0) {\n        var next_index = getValue($0+(depth*4), \"i32\");\n        depth += 1;\n        emp_i.__curr_array = emp_i.__curr_array[next_index];\n      };\n    }, recursive_el.data());\n\n    // Iterate over array, get values, and add them to incoming array.\n    for (auto val : values) {\n      (void) val;\n      MAIN_THREAD_EM_ASM({\n        emp_i.__curr_array.push(UTF8ToString($0));\n      }, val.c_str());\n    };\n\n    MAIN_THREAD_EM_ASM({delete emp_i.__curr_array;});\n  }\n\n  // Handle user-defined JSON_TYPE\n  template<typename C, class = typename C::value_type>\n  typename std::enable_if<C::value_type::n_fields != -1, void>::type\n  pass_array_to_javascript(C values, emp::vector<int> recursive_el) {\n\n    std::map<std::string, std::string> map_type_names = get_type_to_string_map();\n    // Initialize array in Javascript\n    if (recursive_el.size() == 0) {\n      MAIN_THREAD_EM_ASM({emp_i.__incoming_array = [];});\n    }\n\n    // Initialize objects in Javascript\n    MAIN_THREAD_EM_ASM({\n      var curr_array = emp_i.__incoming_array;\n      var depth = 0;\n\n      // Make sure that we're at the right depth, in case of recursive call.\n      while (curr_array.length > 0) {\n        var next_index = getValue($1+(depth*4), \"i32\");\n        depth += 1;\n        curr_array = curr_array[next_index];\n      }\n\n      // Append empty objects\n      for (i=0; i<$0; i++) {\n        var new_obj = {};\n        curr_array.push(new_obj);\n      }\n    }, values.size(), recursive_el.data());\n\n    for (std::size_t j = 0; j<values.size(); j++) { // Iterate over array\n      for (std::size_t i = 0; i<values[j].var_names.size(); i++) { // Iterate over object members\n\n        // Get variable name and type for this member variable\n        std::string var_name = values[j].var_names[i];\n        std::string type_string = map_type_names[values[j].var_types[i].name()];\n        // Make sure member variable is an allowed type\n        emp_assert((map_type_names.find(values[j].var_types[i].name())\n              != map_type_names.end()), values[j].var_types[i].name());\n\n        // Load data into array of objects\n        MAIN_THREAD_EM_ASM({\n          var curr_array = emp_i.__incoming_array;\n          var depth = 0;\n\n          // Make sure we are at the right depth, in case of recursive call.\n          while (curr_array[0].length > 0) {\n            var next_index = getValue($4+(depth*4), \"i32\");\n            depth += 1;\n            curr_array = curr_array[next_index];\n          }\n\n          if (UTF8ToString($1) == \"string\") {\n            curr_array[$3][UTF8ToString($2)] = UTF8ToString($0);\n          } else {\n            curr_array[$3][UTF8ToString($2)] = getValue($0, UTF8ToString($1));\n          }\n        }, values[j].pointers[i], type_string.c_str(), var_name.c_str(),\n        j, recursive_el.data());\n      }\n    }\n  }\n\n  /// @endcond\n\n  // This version of the function handles non-nested containers\n  template<typename C, class = typename C::value_type>\n  void pass_array_to_javascript(C values) {\n    pass_array_to_javascript(values, emp::vector<int>(0));\n  }\n\n  /// @cond TEMPLATES\n\n  // This version of the function handles nested arrays with recursive calls\n  // until a non-array type is found.\n  template<std::size_t SIZE1, std::size_t SIZE2, typename T>\n  void pass_array_to_javascript(emp::array<emp::array<T, SIZE1>, SIZE2> values,\n        emp::vector<int> recursive_el = emp::vector<int>()) {\n\n    // Initialize if this is the first call to this function\n    if (recursive_el.size() == 0) {\n      MAIN_THREAD_EM_ASM({emp_i.__incoming_array = [];});\n    }\n\n    // Append empty arrays to array that we are currently handling in recursion\n    MAIN_THREAD_EM_ASM({\n      var curr_array = emp_i.__incoming_array;\n      var depth = 0;\n      while (curr_array.length > 0) {\n        var next_index = getValue($0+(depth*4), \"i32\");\n        depth += 1;\n        curr_array = curr_array[next_index];\n      }\n      for (i=0; i<$1; i++) {\n        curr_array.push([]);\n      }\n    }, recursive_el.data(), values.size());\n\n    // Make recursive calls - recursive_els specifies coordinates of array we're\n    // currently operating on\n    for (std::size_t i = 0; i<values.size(); i++) {\n      emp::vector<int> new_recursive_el (recursive_el);\n      new_recursive_el.push_back((int) i);\n      pass_array_to_javascript(values[i], new_recursive_el);\n    }\n  }\n\n  // This version of the function handles nested vectors with recursive calls\n  // until a non-array type is found.\n  template<typename T>\n  void pass_array_to_javascript(emp::vector<emp::vector<T> > values,\n        emp::vector<int> recursive_el = emp::vector<int>()) {\n\n    // Initialize if this is the first call to this function\n    if (recursive_el.size() == 0) {\n      MAIN_THREAD_EM_ASM({emp_i.__incoming_array = [];});\n    }\n\n    // Append empty arrays to array that we are currently handling in recursion\n    MAIN_THREAD_EM_ASM({\n      var curr_array = emp_i.__incoming_array;\n      var depth = 0;\n      while (curr_array.length > 0) {\n        var next_index = getValue($0+(depth*4), \"i32\");\n        depth += 1;\n        curr_array = curr_array[next_index];\n      }\n      for (i=0; i<$1; i++) {\n        curr_array.push([]);\n      }\n    }, recursive_el.data(), values.size());\n\n    // Make recursive calls - recursive_els specifies coordinates of array we are\n    // currently operating on\n    for (std::size_t i = 0; i<values.size(); i++) {\n      emp::vector<int> new_recursive_el (recursive_el);\n      new_recursive_el.push_back((int) i);\n      pass_array_to_javascript(values[i], new_recursive_el);\n    }\n  }\n\n  /// @endcond\n\n  /// This function lets you pass an array from javascript to C++!\n  /// It takes a reference to the array as an argument and populates it\n  /// with the contents of emp.__outgoing_array.\n  ///\n  /// Currently accepts arrays of ints, floats, doubles, chars, and std::strings\n  /// The size of the passed array must be equal to the size of the array stored\n  /// in emp.__outgoing_array\n  //\n  // Don't worry about the recurse argument - it's for handling nested arrays\n  // internally\n  #ifdef __EMSCRIPTEN__\n  template <std::size_t SIZE, typename T>\n  void pass_array_to_cpp(emp::array<T, SIZE> & arr, bool recurse = false) {\n\n    //Figure out type stuff\n    std::map<std::string, std::string> map_type_names = get_type_to_string_map();\n    emp_assert((map_type_names.find(typeid(T).name()) != map_type_names.end()), typeid(T).name());\n    int type_size = sizeof(T);\n    (void) type_size;\n    std::string type_string = map_type_names[typeid(T).name()];\n\n    //Make sure arrays have the same length\n    emp_assert(arr.size() == MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length}),\n               arr.size(), MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length}));\n\n    //Write emp.__outgoing_array contents to a buffer\n    T * buffer = (T*) MAIN_THREAD_EM_ASM_INT({\n      var buffer = Module._malloc(emp_i.__outgoing_array.length*$0);\n\n      for (i=0; i<emp_i.__outgoing_array.length; i++) {\n        setValue(buffer+(i*$0), emp_i.__outgoing_array[i], UTF8ToString($1));\n      }\n\n      return buffer;\n    }, type_size, type_string.c_str());\n\n    // Populate array from buffer\n    for (std::size_t i=0; i<arr.size(); i++) {\n      arr[i] = *(buffer + i);\n    }\n\n    // Free the memory we allocated in Javascript\n    free(buffer);\n  }\n\n  #else\n\n  template <std::size_t SIZE, typename T>\n  void pass_array_to_cpp(emp::array<T, SIZE> & arr, bool recurse = false) {;}\n  #endif\n\n  /// Same as pass_array_to_cpp, but lets you store values in a vector instead\n  #ifdef __EMSCRIPTEN__\n  template <typename T>\n  void pass_vector_to_cpp(emp::vector<T> & arr, bool recurse = false) {\n\n    // Figure out type stuff\n    std::map<std::string, std::string> map_type_names = get_type_to_string_map();\n    emp_assert((map_type_names.find(typeid(T).name()) != map_type_names.end()), typeid(T).name());\n    int type_size = sizeof(T);\n    (void) type_size;\n    std::string type_string = map_type_names[typeid(T).name()];\n\n    // Write emp.__outgoing_array contents to a buffer\n    T * buffer = (T*) MAIN_THREAD_EM_ASM_INT({\n      var buffer = Module._malloc(emp_i.__outgoing_array.length*$0);\n\n      for (i=0; i<emp_i.__outgoing_array.length; i++) {\n        setValue(buffer+(i*$0), emp_i.__outgoing_array[i], UTF8ToString($1));\n      }\n\n      return buffer;\n    }, type_size, type_string.c_str());\n\n    // Populate array from buffer\n    for (int i=0; i < MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length}); i++) {\n      arr.push_back(*(buffer + i));\n    }\n\n    //Free the memory we allocated in Javascript\n    free(buffer);\n  }\n\n  #else\n  template <typename T>\n  void pass_vector_to_cpp(emp::vector<T> & arr, bool recurse = false) {;}\n  #endif\n\n  /// @cond TEMPLATES\n\n\n  // template <typename T>\n  // typename std::enable_if<C::value_type::n_fields != -1, void>::type\n  // pass_vector_to_cpp(emp::vector<T> & arr, bool recurse = false) {\n  //\n  //   // Figure out type stuff\n  //   std::map<std::string, std::string> map_type_names = get_type_to_string_map();\n  //   emp_assert((map_type_names.find(typeid(T).name()) != map_type_names.end()), typeid(T).name());\n  //   int type_size = sizeof(T);\n  //   (void) type_size;\n  //   std::string type_string = map_type_names[typeid(T).name()];\n  //\n  //   // Write emp.__outgoing_array contents to a buffer\n  //   T * buffer = (T*) MAIN_THREAD_EM_ASM_INT({\n  //       var buffer = Module._malloc(emp_i.__outgoing_array.length*$0);\n  //\n  //       for (i=0; i<emp_i.__outgoing_array.length; i++) {\n  //         setValue(buffer+(i*$0), emp_i.__outgoing_array[i], UTF8ToString($1));\n  //       }\n  //\n  //       return buffer;\n  //   }, type_size, type_string.c_str());\n  //\n  //   // Populate array from buffer\n  //   for (int i=0; i < MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length}); i++) {\n  //     arr.push_back(*(buffer + i));\n  //   }\n  //\n  //   //Free the memory we allocated in Javascript\n  //   free(buffer);\n  // }\n\n  // Chars aren't one of the types supported by setValue, but by treating them\n  // as strings in Javascript we can pass them out to a C++ array\n  #ifdef __EMSCRIPTEN__\n  template <std::size_t SIZE>\n  void pass_array_to_cpp(emp::array<char, SIZE> & arr, bool recurse = false) {\n\n    emp_assert(arr.size() == MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length}));\n\n    char * buffer = (char *) MAIN_THREAD_EM_ASM_INT({\n      // Since we're treating each char as it's own string, each one\n      // will be null-termianted. So we malloc length*2 addresses.\n      var new_length = emp_i.__outgoing_array.length*2;\n      var buffer = Module._malloc(new_length);\n\n      for (i=0; i<emp_i.__outgoing_array.length; i++) {\n        stringToUTF8(emp_i.__outgoing_array[i], buffer+(i*2),2);\n      }\n\n      return buffer;\n    });\n\n    for (size_t i=0; i<arr.size(); i++) {\n      arr[i] = *(buffer + i*2);\n    }\n\n    free(buffer);\n  }\n  #else\n  template <std::size_t SIZE>\n  void pass_array_to_cpp(emp::array<char, SIZE> & arr, bool recurse = false) {;}\n  #endif\n\n  // Chars aren't one of the types supported by setValue, but by treating them\n  // as strings in Javascript we can pass them out to a C++ array\n  #ifdef __EMSCRIPTEN__\n  void pass_vector_to_cpp(emp::vector<char> & arr, bool recurse = false) {\n\n    char * buffer = (char *) MAIN_THREAD_EM_ASM_INT({\n      // Since we're treating each char as it's own string, each one\n      // will be null-termianted. So we malloc length*2 addresses.\n      var buffer = Module._malloc(emp_i.__outgoing_array.length*2);\n\n      for (i=0; i<emp_i.__outgoing_array.length; i++) {\n        stringToUTF8(emp_i.__outgoing_array[i], buffer+(i*2),2);\n      }\n\n      return buffer;\n    });\n\n    for (int i=0; i<MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length}); i++) {\n      arr.push_back(*(buffer + i*2));\n    }\n\n    free(buffer);\n  }\n  #else\n  void pass_vector_to_cpp(emp::vector<char> & arr, bool recurse = false) {;}\n  #endif\n\n  // We can handle strings in a similar way\n  #ifdef __EMSCRIPTEN__\n  template <std::size_t SIZE>\n  void pass_array_to_cpp(emp::array<std::string, SIZE> & arr, bool recurse = false) {\n\n    emp_assert(arr.size() == MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length}));\n\n    char * buffer = (char *) MAIN_THREAD_EM_ASM_INT({\n      // Figure how much memory to allocate\n      var arr_size = 0;\n      for (i=0; i<emp_i.__outgoing_array.length; i++) {\n        arr_size += emp_i.__outgoing_array[i].length + 1;\n      }\n\n      var buffer = Module._malloc(arr_size);\n\n      // Track place in memory to write too\n      var cumulative_size = 0;\n      var cur_length = 0;\n      for (i=0; i<emp_i.__outgoing_array.length; i++) {\n        cur_length = emp_i.__outgoing_array[i].length + 1;\n        stringToUTF8(emp_i.__outgoing_array[i], buffer + (cumulative_size), cur_length);\n        cumulative_size += cur_length;\n      }\n\n      return buffer;\n    });\n\n    // Track place in memory to read from\n    int cumulative_size = 0;\n    for (size_t i=0; i<arr.size(); i++) {\n      // Since std::string constructor reads to null terminator, this just works.\n      arr[i] = std::string(buffer + cumulative_size);\n      cumulative_size += arr[i].size() + 1;\n    }\n\n    free(buffer);\n  }\n  #else\n  template <std::size_t SIZE>\n  void pass_array_to_cpp(emp::array<std::string, SIZE> & arr, bool recurse = false) {;}\n  #endif\n\n  // We can handle strings in a similar way\n  #ifdef __EMSCRIPTEN__\n  void pass_vector_to_cpp(emp::vector<std::string> & arr, bool recurse = false) {\n\n    char * buffer = (char *) MAIN_THREAD_EM_ASM_INT({\n      // Figure how much memory to allocate\n      var arr_size = 0;\n      for (i=0; i<emp_i.__outgoing_array.length; i++) {\n        arr_size += emp_i.__outgoing_array[i].length + 1;\n      }\n\n      var buffer = Module._malloc(arr_size);\n\n      // Track place in memory to write too\n      var cumulative_size = 0;\n      var cur_length = 0;\n      for (i=0; i<emp_i.__outgoing_array.length; i++) {\n        cur_length = emp_i.__outgoing_array[i].length + 1;\n        stringToUTF8(emp_i.__outgoing_array[i], buffer + (cumulative_size), cur_length);\n        cumulative_size += cur_length;\n      }\n\n      return buffer;\n    });\n\n    // Track place in memory to read from\n    int cumulative_size = 0;\n    for (int i=0; i<MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length}); i++) {\n      // Since std::string constructor reads to null terminator, this just works.\n      arr.push_back(std::string(buffer + cumulative_size));\n      cumulative_size += arr[(size_t)i].size() + 1;\n    }\n\n    free(buffer);\n  }\n  #else\n  void pass_vector_to_cpp(emp::vector<std::string> & arr, bool recurse = false) {;}\n  #endif\n\n  // We can handle nested arrays through recursive calls on chunks of them\n  #ifdef __EMSCRIPTEN__\n  template <std::size_t SIZE, std::size_t SIZE2, typename T>\n  void pass_array_to_cpp(emp::array<emp::array<T, SIZE2>, SIZE> & arr, bool recurse = false) {\n\n    emp_assert(arr.size() == MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length}));\n\n    // Create temp array to hold whole array while pieces are passed in\n    if (recurse == 0) {\n      MAIN_THREAD_EM_ASM({emp_i.__temp_array = [emp_i.__outgoing_array];});\n    } else {\n      // This is a little wasteful of space, but the alternatives are\n      // surprisingly ugly\n      MAIN_THREAD_EM_ASM({emp_i.__temp_array.push(emp_i.__outgoing_array);});\n    }\n\n    for (size_t i = 0; i < arr.size(); i++) {\n      MAIN_THREAD_EM_ASM({\n        emp_i.__outgoing_array = emp_i.__temp_array[emp_i.__temp_array.length - 1][$0];\n      }, i);\n      pass_array_to_cpp(arr[i], true);\n    }\n\n    // Clear temp array\n    if (recurse == 0) { MAIN_THREAD_EM_ASM({emp_i.__temp_array = [];}); }\n    else { MAIN_THREAD_EM_ASM({emp_i.__temp_array.pop();}); }\n  }\n  #else\n  template <std::size_t SIZE, std::size_t SIZE2, typename T>\n  void pass_array_to_cpp(emp::array<emp::array<T, SIZE2>, SIZE> & arr, bool recurse = false) {;}\n  #endif\n\n  /// We can handle nested arrays through recursive calls on chunks of them\n  #ifdef __EMSCRIPTEN__\n  template <typename T>\n  void pass_vector_to_cpp(emp::vector<emp::vector<T> > & arr, bool recurse = false) {\n\n    // Create temp array to hold whole array while pieces are passed in\n    int size = MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length});\n\n    if (recurse == 0) {\n      MAIN_THREAD_EM_ASM({\n        emp_i.__temp_array = [emp_i.__outgoing_array];\n      });\n    } else {\n      // This is a little wasteful of space, but the alternatives are\n      // surprisingly ugly\n      MAIN_THREAD_EM_ASM({emp_i.__temp_array.push(emp_i.__outgoing_array);});\n    }\n\n    for (int i = 0; i < size; i++) {\n      MAIN_THREAD_EM_ASM({\n        emp_i.__outgoing_array = emp_i.__temp_array[emp_i.__temp_array.length - 1][$0];\n      }, i);\n      while ((int)arr.size() <= i) {\n        arr.push_back(emp::vector<T>());\n      }\n      pass_vector_to_cpp(arr[i], true);\n    }\n\n    // Clear temp array\n    if (recurse == 0) {\n      MAIN_THREAD_EM_ASM({emp_i.__temp_array = [];});\n    } else {\n      MAIN_THREAD_EM_ASM({emp_i.__temp_array.pop();});\n    }\n  }\n  #else\n  template <typename T>\n  void pass_vector_to_cpp(emp::vector<emp::vector<T> > & arr, bool recurse = false) {;}\n  #endif\n\n  /// @endcond\n\n  /// This function can be called to pass a map into JavaScript.\n  /// The resulting JavaScript object will be stored in emp.__incoming_map.\n  /// @param dict the map being passed into JavaScript\n  template <typename KEY_T, typename VAL_T>\n  void pass_map_to_javascript(const emp::map<KEY_T, VAL_T> & dict) {\n\n    emp::vector<KEY_T> keys;\n    emp::vector<VAL_T> values;\n\n    // extract keys and values from dict\n    for (typename std::map<KEY_T, VAL_T>::const_iterator it = dict.begin(); it != dict.end(); ++it) {\n      keys.push_back(it->first);\n      values.push_back(it->second);\n    }\n\n    // pass in extracted keys vector to JS\n    emp::pass_array_to_javascript(keys);\n    MAIN_THREAD_EM_ASM({\n      emp_i.__incoming_map_keys = emp_i.__incoming_array;\n    });\n\n    // check to make sure each key is not an object or a function\n    #ifdef __EMSCRIPTEN__\n    emp_assert(\n        MAIN_THREAD_EM_ASM_INT({\n          emp_i.__incoming_map_keys.forEach(function(key) {\n            if (typeof key === \"object\" || typeof key === \"function\") { return 0; }\n          });\n          return 1;\n        }), \"Keys cannot be an object or a function\");\n    #endif\n\n    // pass in extracted values vector to JS\n    emp::pass_array_to_javascript(values);\n    MAIN_THREAD_EM_ASM({\n      emp_i.__incoming_map_values = emp_i.__incoming_array;\n\n      // create dictionary\n      emp_i.__incoming_map = ( {} );\n      emp_i.__incoming_map_keys.forEach(function(key, val) {\n        emp_i.__incoming_map[key] = emp_i.__incoming_map_values[val]\n      });\n\n      // clean up unneeded vars\n      delete emp_i.__incoming_map_keys;\n      delete emp_i.__incoming_map_values;\n    });\n  }\n\n\n  /// This function can be called to pass two arrays of the same length into JavaScript (where a map is then created)\n  /// One array should hold keys, and the other should hold values\n  /// (note that the key-value pairs must line up across the arrays)\n  /// The resulting JavaScript object will be stored in emp.__incoming_map.\n  /// @param keys an array holding the keys to the map\n  /// @param values an array holding the values to the map\n  template <typename KEY_T, typename VAL_T, size_t SIZE>\n  void pass_map_to_javascript(const emp::array<KEY_T, SIZE> & keys, const emp::array<VAL_T, SIZE> & values) {\n\n    // pass in keys vector to JS\n    emp::pass_array_to_javascript(keys);\n    MAIN_THREAD_EM_ASM({\n      emp_i.__incoming_map_keys = emp_i.__incoming_array;\n    });\n\n    // check to make sure each key is not an object or a function\n    #ifdef __EMSCRIPTEN__\n    emp_assert(\n        MAIN_THREAD_EM_ASM_INT({\n          emp_i.__incoming_map_keys.forEach(function(key) {\n            if (typeof key === \"object\" || typeof key === \"function\") { return 0; }\n          });\n          return 1;\n        }), \"Keys cannot be an object or a function\");\n    #endif\n\n    // pass in values vector to JS\n    emp::pass_array_to_javascript(values);\n    MAIN_THREAD_EM_ASM({\n      emp_i.__incoming_map_values = emp_i.__incoming_array;\n\n      // create dictionary\n      emp_i.__incoming_map = ( {} );\n      emp_i.__incoming_map_keys.forEach(function(key, val) {\n        emp_i.__incoming_map[key] = emp_i.__incoming_map_values[val]\n      });\n\n      // clean up unneeded vars\n      delete emp_i.__incoming_map_keys;\n      delete emp_i.__incoming_map_values;\n    });\n  }\n\n  /// Helper function that returns DOM view port size in pixels.\n  int GetViewPortSize() {\n    return MAIN_THREAD_EM_ASM_INT({\n      return Math.min(\n        Math.max(\n          document.documentElement.clientWidth,\n          $(window).width(),\n          window.innerWidth || 0\n        ),\n        Math.max(\n          document.documentElement.clientHeight,\n          $(window).height(),\n          window.innerHeight || 0\n        )\n       );\n    });\n  }\n\n}\n\n\n#endif // #ifndef EMP_WEB_JS_UTILS_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2016-2021.\n *\n *  @file array.hpp\n *  @brief A drop-in wrapper for std::array; adds on bounds checking in debug mode.\n *  @note Status: RELEASE\n *\n *  If EMP_NDEBUG is set, emp::array is just an alias for std::array.\n *  Otherwise, every time an array is accessed, tests are done to make sure that the\n *  access is legal.\n *\n *  @todo Add tests in array::front and array::back to ensure not empty.\n *  @todo Add tests for get.\n */\n\n#ifndef EMP_BASE_ARRAY_HPP_INCLUDE\n#define EMP_BASE_ARRAY_HPP_INCLUDE\n\n#include <array>\n#include <initializer_list>\n#include <vector>\n\n#include \"assert.hpp\"\n\n#ifdef EMP_NDEBUG\n\nnamespace emp {\n  /// In release mode, emp::array is simply an alias for std::array.\n  template <typename T, size_t N> using array = std::array<T,N>;\n}\n\n#else\n\nnamespace emp {\n\n  /// We are in debug mode, so emp::array has the same interface as std::array, but with extra\n  /// bounds checking.  Using vector as our base since it has the right pieces and is dynamic.\n  template <typename T, size_t N>\n  class array : public std::vector<T> {\n  private:\n    using this_t = emp::array<T,N>;\n    using base_t = std::vector<T>;\n\n  public:\n    bool valid;\n\n    /// Setup an iterator wrapper to make sure that they're valid.\n    template<typename ITERATOR_T>\n    struct iterator_wrapper : public ITERATOR_T {\n      using this_t = iterator_wrapper<ITERATOR_T>;\n      using wrapped_t = ITERATOR_T;\n      using vec_t = emp::array<T,N>;\n\n      /// What vector was this iterator created from?\n      const vec_t * v_ptr{ nullptr };\n\n      iterator_wrapper() { ; }\n\n      iterator_wrapper(const ITERATOR_T & _in, const vec_t * _v) : ITERATOR_T(_in), v_ptr(_v) { ; }\n      iterator_wrapper(const this_t &) = default;\n      iterator_wrapper(this_t &&) = default;\n      ~iterator_wrapper() { ; }\n\n      // Debug tools to make sure this iterator is okay.\n      bool OK(bool begin_ok=true, bool end_ok=true) const {\n        if (v_ptr == nullptr) return false;                // Invalid vector\n        if (!v_ptr->valid) return false;                   // Vector has been deleted!\n        size_t pos = (size_t) (*this - v_ptr->begin());\n        if (pos > v_ptr->size()) return false;             // Iterator out of range.\n        if (!begin_ok && pos == 0) return false;           // Iterator not allowed at beginning.\n        if (!end_ok && pos == v_ptr->size()) return false; // Iterator not allowed at end.\n        return true;\n      }\n\n      this_t & operator=(const this_t &) = default;\n      this_t & operator=(this_t &&) = default;\n\n      operator ITERATOR_T() { return *this; }\n      operator const ITERATOR_T() const { return *this; }\n\n      auto & operator*() {\n        emp_assert(OK(true, false));  // Ensure array is being pointed to properly.\n        return wrapped_t::operator*();\n      }\n      const auto & operator*() const {\n        emp_assert(OK(true, false));  // Ensure array is being pointed to properly.\n        return wrapped_t::operator*();\n      }\n\n      auto operator->() {\n        emp_assert(OK(true, false));  // Ensure array is being pointed to properly.\n        return wrapped_t::operator->();\n      }\n      auto operator->() const {\n        emp_assert(OK(true, false));  // Ensure array is being pointed to properly.\n        return wrapped_t::operator->();\n      }\n\n      this_t & operator++() { emp_assert(OK(true,false)); wrapped_t::operator++(); return *this; }\n      this_t operator++(int x) { emp_assert(OK(true,false)); return this_t(wrapped_t::operator++(x), v_ptr); }\n      this_t & operator--() { emp_assert(OK(false,true)); wrapped_t::operator--(); return *this; }\n      this_t operator--(int x) { emp_assert(OK(false,true)); return this_t(wrapped_t::operator--(x), v_ptr); }\n\n      auto operator+(int in) { emp_assert(OK()); return this_t(wrapped_t::operator+(in), v_ptr); }\n      auto operator-(int in) { emp_assert(OK()); return this_t(wrapped_t::operator-(in), v_ptr); }\n      auto operator-(const this_t & in) { emp_assert(OK()); return ((wrapped_t) *this) - (wrapped_t) in; }\n\n      this_t & operator+=(int in) { emp_assert(OK()); wrapped_t::operator+=(in); return *this; }\n      this_t & operator-=(int in) { emp_assert(OK()); wrapped_t::operator-=(in); return *this; }\n      auto & operator[](int offset) { emp_assert(OK()); return wrapped_t::operator[](offset); }\n    };\n\n    using iterator = iterator_wrapper< typename base_t::iterator >;\n    using const_iterator = iterator_wrapper< typename base_t::const_iterator >;\n    using reverse_iterator = iterator_wrapper< typename base_t::reverse_iterator >;\n    using const_reverse_iterator = iterator_wrapper< typename base_t::const_reverse_iterator >;\n    using value_type = T;\n    using size_type = typename base_t::size_type;\n    using reference = typename base_t::reference;\n    using const_reference = typename base_t::const_reference;\n\n    array() : base_t(N), valid(true) {};\n    array(const this_t & _in) : base_t(_in), valid(true) { emp_assert(_in.size() == N); };\n    array(std::initializer_list<T> in_list) : base_t(in_list), valid(true) { emp_assert(size() == N); }\n    template <typename InputIt>\n    array(InputIt first, InputIt last) : base_t(first, last), valid(true) { emp_assert(size() == N); }\n    ~array() { valid=false; } // No longer valid when array is deleted.\n\n    operator std::array<T,N>() {\n      std::array<T,N> ar;\n      for (size_t i = 0; i < N; i++) ar[i] = base_t::operator[](i);\n      return ar;\n    }\n\n    constexpr size_t size() const { return N; }\n\n    iterator begin() noexcept { return iterator(base_t::begin(), this); }\n    const_iterator begin() const noexcept { return const_iterator(base_t::begin(), this); }\n    iterator end() noexcept { return iterator(base_t::end(), this); }\n    const_iterator end() const noexcept { return const_iterator(base_t::end(), this); }\n\n    this_t & operator=(const this_t &) = default;\n\n    T & operator[](size_t pos) {\n      emp_assert(pos < N, pos, N);\n      return base_t::operator[](pos);\n    }\n\n    const T & operator[](size_t pos) const {\n      emp_assert(pos < N, pos, N);\n      return base_t::operator[](pos);\n    }\n\n    T & back() { emp_assert(N > 0); return base_t::back(); }\n    const T & back() const { emp_assert(N > 0); return base_t::back(); }\n    T & front() { emp_assert(N > 0); return base_t::front(); }\n    const T & front() const { emp_assert(N > 0); return base_t::front(); }\n\n    void fill(const T & val) { this->assign(N, val); }\n\n    // Functions to make sure to throw an error on:\n\n    void resize(size_t /* new_size */) { emp_assert(false, \"invalid operation for array!\"); }\n    void resize(size_t /* new_size */, const T & /* val */) { emp_assert(false, \"invalid operation for array!\"); }\n\n    template <typename... PB_Ts>\n    void push_back(PB_Ts &&... /* args */) { emp_assert(false, \"invalid operation for array!\"); }\n    void pop_back() { emp_assert(false, \"invalid operation for array!\"); }\n\n    template <typename... ARGS>\n    iterator insert(ARGS &&... args) {\n      emp_assert(false, \"invalid operation for array!\");\n      return iterator( base_t::insert(std::forward<ARGS>(args)...), this );\n    }\n\n    template <typename... ARGS>\n    iterator erase(ARGS &&... args) {\n      emp_assert(false, \"invalid operation for array!\");\n      return iterator( base_t::erase(std::forward<ARGS>(args)...), this );\n    }\n\n    template <typename... ARGS>\n    iterator emplace(ARGS &&... args) {\n      emp_assert(false, \"invalid operation for array!\");\n      return iterator( base_t::emplace(std::forward<ARGS>(args)...), this );\n    }\n\n    template <typename... ARGS>\n    void emplace_back(ARGS &&... /* args */) {\n      emp_assert(false, \"invalid operation for array!\");\n    }\n  };\n\n\n}\n\n// specialization for std::tuple_size\ntemplate <class T, size_t N>\nstruct std::tuple_size<emp::array<T, N>> : public integral_constant<size_t, N> {\n};\n\n#endif // NDEBUG off\n\n\nnamespace std {\n  // A crude, generic printing function for arrays.\n  template <typename T, size_t N>\n  inline std::ostream & operator<<(std::ostream & out, const emp::array<T,N> & v) {\n    for (const T & x : v) out << x << \" \";\n    return out;\n  }\n\n  template <typename T, size_t N>\n  std::istream & operator>>(std::istream & is, emp::array<T,N> & v) {\n    for (T & x : v) is >> x;\n    return is;\n  }\n\n}\n\n#endif // #ifndef EMP_BASE_ARRAY_HPP_INCLUDE\n","// -*- C++ -*-\n//===-------------------------- typeinfo ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __LIBCPP_TYPEINFO\n#define __LIBCPP_TYPEINFO\n\n/*\n\n    typeinfo synopsis\n\nnamespace std {\n\nclass type_info\n{\npublic:\n    virtual ~type_info();\n\n    bool operator==(const type_info& rhs) const noexcept;\n    bool operator!=(const type_info& rhs) const noexcept;\n\n    bool before(const type_info& rhs) const noexcept;\n    size_t hash_code() const noexcept;\n    const char* name() const noexcept;\n\n    type_info(const type_info& rhs) = delete;\n    type_info& operator=(const type_info& rhs) = delete;\n};\n\nclass bad_cast\n    : public exception\n{\npublic:\n    bad_cast() noexcept;\n    bad_cast(const bad_cast&) noexcept;\n    bad_cast& operator=(const bad_cast&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() noexcept;\n    bad_typeid(const bad_typeid&) noexcept;\n    bad_typeid& operator=(const bad_typeid&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#include <cstdint>\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#if defined(_LIBCPP_ABI_MICROSOFT) && !defined(_LIBCPP_NO_VCRUNTIME)\n#include <vcruntime_typeinfo.h>\n#else\n\n#if defined(_LIBCPP_NONUNIQUE_RTTI_BIT) && !defined(_LIBCPP_ABI_MICROSOFT)\n#   define _LIBCPP_HAS_NONUNIQUE_TYPEINFO\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI type_info\n{\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\n\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    _LIBCPP_INLINE_VISIBILITY\n    int __compare_nonunique_names(const type_info &__arg) const _NOEXCEPT\n    { return __builtin_strcmp(name(), __arg.name()); }\n#endif\n\n#if defined(_LIBCPP_ABI_MICROSOFT)\n    mutable struct {\n      const char *__undecorated_name;\n      const char __decorated_name[1];\n    } __data;\n\n    int __compare(const type_info &__rhs) const _NOEXCEPT;\n#endif // _LIBCPP_ABI_MICROSOFT\n\nprotected:\n#if !defined(_LIBCPP_ABI_MICROSOFT)\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    // A const char* with the non-unique RTTI bit possibly set.\n    uintptr_t __type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n)\n      : __type_name(reinterpret_cast<uintptr_t>(__n)) {}\n#else\n    const char *__type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n) : __type_name(__n) {}\n#endif\n#endif // ! _LIBCPP_ABI_MICROSOFT\n\npublic:\n    _LIBCPP_AVAILABILITY_TYPEINFO_VTABLE\n    virtual ~type_info();\n\n#if defined(_LIBCPP_ABI_MICROSOFT)\n    const char *name() const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT {\n      return __compare(__arg) < 0;\n    }\n\n    size_t hash_code() const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT {\n      return __compare(__arg) == 0;\n    }\n#else\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n    {\n      return reinterpret_cast<const char*>(__type_name &\n                                           ~_LIBCPP_NONUNIQUE_RTTI_BIT);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n    {\n      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return __type_name < __arg.__type_name;\n      return __compare_nonunique_names(__arg) < 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n    {\n      if (!(__type_name & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return __type_name;\n\n      const char* __ptr = name();\n      size_t __hash = 5381;\n      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))\n        __hash = (__hash * 33) ^ __c;\n      return __hash;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n    {\n      if (__type_name == __arg.__type_name)\n        return true;\n\n      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return false;\n      return __compare_nonunique_names(__arg) == 0;\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n    { return __type_name; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n    { return __type_name < __arg.__type_name; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n    { return reinterpret_cast<size_t>(__type_name); }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n    { return __type_name == __arg.__type_name; }\n#endif\n#endif // _LIBCPP_ABI_MICROSOFT\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const type_info& __arg) const _NOEXCEPT\n    { return !operator==(__arg); }\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_cast\n    : public exception\n{\npublic:\n    bad_cast() _NOEXCEPT;\n    virtual ~bad_cast() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() _NOEXCEPT;\n    virtual ~bad_typeid() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n}  // std\n\n#endif // defined(_LIBCPP_ABI_MICROSOFT) && !defined(_LIBCPP_NO_VCRUNTIME)\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n_LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY\nvoid __throw_bad_cast()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_cast();\n#else\n    _VSTD::abort();\n#endif\n}\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // __LIBCPP_TYPEINFO\n","// -*- C++ -*-\n//===----------------------------- map ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MAP\n#define _LIBCPP_MAP\n\n/*\n\n    map synopsis\n\nnamespace std\n{\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass map\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n    typedef unspecified                              node_type;              // C++17\n    typedef INSERT_RETURN_TYPE<iterator, node_type>  insert_return_type;     // C++17\n\n    class value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    map()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit map(const key_compare& comp);\n    map(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp = key_compare());\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp, const allocator_type& a);\n    map(const map& m);\n    map(map&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit map(const allocator_type& a);\n    map(const map& m, const allocator_type& a);\n    map(map&& m, const allocator_type& a);\n    map(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    map(initializer_list<value_type> il, const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last, const allocator_type& a)\n            : map(first, last, Compare(), a) {}  // C++14\n    map(initializer_list<value_type> il, const allocator_type& a)\n        : map(il, Compare(), a) {}  // C++14\n   ~map();\n\n    map& operator=(const map& m);\n    map& operator=(map&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    map& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // element access:\n    mapped_type& operator[](const key_type& k);\n    mapped_type& operator[](key_type&& k);\n\n          mapped_type& at(const key_type& k);\n    const mapped_type& at(const key_type& k) const;\n\n    // modifiers:\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator, bool> insert(const value_type& v);\n    pair<iterator, bool> insert(      value_type&& v);                                // C++17\n    template <class P>\n        pair<iterator, bool> insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position,       value_type&& v);                   // C++17\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    node_type extract(const_iterator position);                                       // C++17\n    node_type extract(const key_type& x);                                             // C++17\n    insert_return_type insert(node_type&& nh);                                        // C++17\n    iterator insert(const_iterator hint, node_type&& nh);                             // C++17\n\n    template <class... Args>\n        pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);          // C++17\n    template <class... Args>\n        pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);               // C++17\n    template <class... Args>\n        iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args); // C++17\n    template <class... Args>\n        iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);      // C++17\n    template <class M>\n        pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);            // C++17\n    template <class M>\n        pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);                 // C++17\n    template <class M>\n        iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);   // C++17\n    template <class M>\n        iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);        // C++17\n\n    iterator  erase(const_iterator position);\n    iterator  erase(iterator position); // C++14\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    template<class C2>\n      void merge(map<Key, T, C2, Allocator>& source);         // C++17\n    template<class C2>\n      void merge(map<Key, T, C2, Allocator>&& source);        // C++17\n    template<class C2>\n      void merge(multimap<Key, T, C2, Allocator>& source);    // C++17\n    template<class C2>\n      void merge(multimap<Key, T, C2, Allocator>&& source);   // C++17\n\n    void swap(map& m)\n        noexcept(allocator_traits<allocator_type>::is_always_equal::value &&\n            is_nothrow_swappable<key_compare>::value); // C++17\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(map<Key, T, Compare, Allocator>& x, map<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Compare, class Allocator, class Predicate>\n  void erase_if(map<Key, T, Compare, Allocator>& c, Predicate pred);  // C++20\n\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass multimap\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type,mapped_type>         value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n    typedef unspecified                              node_type;              // C++17\n\n    class value_compare\n        : public binary_function<value_type,value_type,bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    multimap()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit multimap(const key_compare& comp);\n    multimap(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp,\n                 const allocator_type& a);\n    multimap(const multimap& m);\n    multimap(multimap&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit multimap(const allocator_type& a);\n    multimap(const multimap& m, const allocator_type& a);\n    multimap(multimap&& m, const allocator_type& a);\n    multimap(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    multimap(initializer_list<value_type> il, const key_compare& comp,\n             const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const allocator_type& a)\n            : multimap(first, last, Compare(), a) {} // C++14\n    multimap(initializer_list<value_type> il, const allocator_type& a)\n        : multimap(il, Compare(), a) {} // C++14\n    ~multimap();\n\n    multimap& operator=(const multimap& m);\n    multimap& operator=(multimap&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    multimap& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& v);\n    iterator insert(      value_type&& v);                                            // C++17\n    template <class P>\n        iterator insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position,       value_type&& v);                   // C++17\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    node_type extract(const_iterator position);                                       // C++17\n    node_type extract(const key_type& x);                                             // C++17\n    iterator insert(node_type&& nh);                                                  // C++17\n    iterator insert(const_iterator hint, node_type&& nh);                             // C++17\n\n    iterator  erase(const_iterator position);\n    iterator  erase(iterator position); // C++14\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    template<class C2>\n      void merge(multimap<Key, T, C2, Allocator>& source);    // C++17\n    template<class C2>\n      void merge(multimap<Key, T, C2, Allocator>&& source);   // C++17\n    template<class C2>\n      void merge(map<Key, T, C2, Allocator>& source);         // C++17\n    template<class C2>\n      void merge(map<Key, T, C2, Allocator>&& source);        // C++17\n\n    void swap(multimap& m)\n        noexcept(allocator_traits<allocator_type>::is_always_equal::value &&\n            is_nothrow_swappable<key_compare>::value); // C++17\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(multimap<Key, T, Compare, Allocator>& x,\n     multimap<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Compare, class Allocator, class Predicate>\n  void erase_if(multimap<Key, T, Compare, Allocator>& c, Predicate pred);  // C++20\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tree>\n#include <__node_handle>\n#include <iterator>\n#include <memory>\n#include <utility>\n#include <functional>\n#include <initializer_list>\n#include <type_traits>\n#include <version>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _CP, class _Compare,\n          bool = is_empty<_Compare>::value && !__libcpp_is_final<_Compare>::value>\nclass __map_value_compare\n    : private _Compare\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : _Compare() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : _Compare(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__get_value().first, __y.__get_value().first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__get_value().first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x, __y.__get_value().first);}\n    void swap(__map_value_compare&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Compare>::value)\n    {\n      using _VSTD::swap;\n      swap(static_cast<_Compare&>(*this), static_cast<_Compare&>(__y));\n    }\n\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return static_cast<const _Compare&>(*this) (__x, __y.__get_value().first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return static_cast<const _Compare&>(*this) (__x.__get_value().first, __y);}\n#endif\n};\n\ntemplate <class _Key, class _CP, class _Compare>\nclass __map_value_compare<_Key, _CP, _Compare, false>\n{\n    _Compare comp;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : comp() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : comp(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return comp;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return comp(__x.__get_value().first, __y.__get_value().first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return comp(__x.__get_value().first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return comp(__x, __y.__get_value().first);}\n    void swap(__map_value_compare&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Compare>::value)\n    {\n        using _VSTD::swap;\n        swap(comp, __y.comp);\n    }\n\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return comp (__x, __y.__get_value().first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return comp (__x.__get_value().first, __y);}\n#endif\n};\n\ntemplate <class _Key, class _CP, class _Compare, bool __b>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__map_value_compare<_Key, _CP, _Compare, __b>& __x,\n     __map_value_compare<_Key, _CP, _Compare, __b>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Allocator>\nclass __map_node_destructor\n{\n    typedef _Allocator                          allocator_type;\n    typedef allocator_traits<allocator_type>    __alloc_traits;\n\npublic:\n    typedef typename __alloc_traits::pointer    pointer;\n\nprivate:\n    allocator_type& __na_;\n\n    __map_node_destructor& operator=(const __map_node_destructor&);\n\npublic:\n    bool __first_constructed;\n    bool __second_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __map_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __first_constructed(false),\n          __second_constructed(false)\n        {}\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    __map_node_destructor(__tree_node_destructor<allocator_type>&& __x) _NOEXCEPT\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            __x.__value_constructed = false;\n        }\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__second_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__get_value().second));\n        if (__first_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__get_value().first));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n};\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class map;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class multimap;\ntemplate <class _TreeIterator> class __map_const_iterator;\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp>\nstruct __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type&, mapped_type&>            __nc_ref_pair_type;\n    typedef pair<key_type&&, mapped_type&&>          __nc_rref_pair_type;\n\nprivate:\n    value_type __cc;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    value_type& __get_value()\n    {\n#if _LIBCPP_STD_VER > 14\n        return *_VSTD::launder(_VSTD::addressof(__cc));\n#else\n        return __cc;\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type& __get_value() const\n    {\n#if _LIBCPP_STD_VER > 14\n        return *_VSTD::launder(_VSTD::addressof(__cc));\n#else\n        return __cc;\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __nc_ref_pair_type __ref()\n    {\n        value_type& __v = __get_value();\n        return __nc_ref_pair_type(const_cast<key_type&>(__v.first), __v.second);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __nc_rref_pair_type __move()\n    {\n        value_type& __v = __get_value();\n        return __nc_rref_pair_type(\n            _VSTD::move(const_cast<key_type&>(__v.first)),\n            _VSTD::move(__v.second));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(const __value_type& __v)\n    {\n        __ref() = __v.__get_value();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(__value_type&& __v)\n    {\n        __ref() = __v.__move();\n        return *this;\n    }\n\n    template <class _ValueTp,\n              class = typename enable_if<\n                    __is_same_uncvref<_ValueTp, value_type>::value\n                 >::type\n             >\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(_ValueTp&& __v)\n    {\n        __ref() = _VSTD::forward<_ValueTp>(__v);\n        return *this;\n    }\n\nprivate:\n    __value_type() _LIBCPP_EQUAL_DELETE;\n    ~__value_type() _LIBCPP_EQUAL_DELETE;\n    __value_type(const __value_type& __v) _LIBCPP_EQUAL_DELETE;\n    __value_type(__value_type&& __v) _LIBCPP_EQUAL_DELETE;\n};\n\n#else\n\ntemplate <class _Key, class _Tp>\nstruct __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n\nprivate:\n    value_type __cc;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    value_type& __get_value() { return __cc; }\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type& __get_value() const { return __cc; }\n\nprivate:\n   __value_type();\n   __value_type(__value_type const&);\n   __value_type& operator=(__value_type const&);\n   ~__value_type();\n};\n\n#endif // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp>\nstruct __extract_key_value_types;\n\ntemplate <class _Key, class _Tp>\nstruct __extract_key_value_types<__value_type<_Key, _Tp> >\n{\n  typedef _Key const __key_type;\n  typedef _Tp        __mapped_type;\n};\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TEMPLATE_VIS __map_iterator\n{\n    typedef typename _TreeIterator::_NodeTypes                   _NodeTypes;\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n\n    _TreeIterator __i_;\n\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef typename _NodeTypes::__map_value_type                value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef value_type&                                          reference;\n    typedef typename _NodeTypes::__map_value_type_pointer        pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__get_value();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__get_value());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator++(int)\n    {\n        __map_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator--(int)\n    {\n        __map_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS multimap;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __map_const_iterator;\n};\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TEMPLATE_VIS __map_const_iterator\n{\n    typedef typename _TreeIterator::_NodeTypes                   _NodeTypes;\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n\n    _TreeIterator __i_;\n\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef typename _NodeTypes::__map_value_type                value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename _NodeTypes::__const_map_value_type_pointer  pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(__map_iterator<\n        typename _TreeIterator::__non_const_iterator> __i) _NOEXCEPT\n        : __i_(__i.__i_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__get_value();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__get_value());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator++(int)\n    {\n        __map_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator--(int)\n    {\n        __map_const_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS multimap;\n    template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS __tree_const_iterator;\n};\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TEMPLATE_VIS map\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), \"\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    class _LIBCPP_TEMPLATE_VIS value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,\n                                                 __value_type>::type __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>   __base;\n    typedef typename __base::__node_traits                 __node_traits;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>             iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n#if _LIBCPP_STD_VER > 14\n    typedef __map_node_handle<typename __base::__node, allocator_type> node_type;\n    typedef __insert_return_type<iterator, node_type> insert_return_type;\n#endif\n\n    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>\n        friend class _LIBCPP_TEMPLATE_VIS map;\n    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>\n        friend class _LIBCPP_TEMPLATE_VIS multimap;\n\n    _LIBCPP_INLINE_VISIBILITY\n    map()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(key_compare())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), typename __base::allocator_type(__a))\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n    map(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : map(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m)\n        : __tree_(__m.__tree_)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(const map& __m)\n        {\n#ifndef _LIBCPP_CXX03_LANG\n            __tree_ = __m.__tree_;\n#else\n            if (this != &__m) {\n                __tree_.clear();\n                __tree_.value_comp() = __m.__tree_.value_comp();\n                __tree_.__copy_assign_alloc(__m.__tree_);\n                insert(__m.begin(), __m.end());\n            }\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    map(map&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), typename __base::allocator_type(__a))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const allocator_type& __a)\n        : map(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_unique(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const allocator_type& __a)\n        : __tree_(typename __base::allocator_type(__a))\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    mapped_type& operator[](const key_type& __k);\n#ifndef _LIBCPP_CXX03_LANG\n    mapped_type& operator[](key_type&& __k);\n#endif\n\n          mapped_type& at(const key_type& __k);\n    const mapped_type& at(const key_type& __k) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return allocator_type(__tree_.__alloc());}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> emplace(_Args&& ...__args) {\n        return __tree_.__emplace_unique(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {\n        return __tree_.__emplace_hint_unique(__p.__i_, _VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert(_Pp&& __p)\n            {return __tree_.__insert_unique(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_unique(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n        insert(const value_type& __v) {return __tree_.__insert_unique(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n        insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_unique(__p.__i_, __v);}\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    insert(value_type&& __v) {return __tree_.__insert_unique(_VSTD::move(__v));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p,  value_type&& __v)\n    {return __tree_.__insert_unique(__p.__i_, _VSTD::move(__v));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                insert(__e.__i_, *__f);\n        }\n\n#if _LIBCPP_STD_VER > 14\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> try_emplace(const key_type& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_unique_key_args(__k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(__k),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> try_emplace(key_type&& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_unique_key_args(__k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(_VSTD::move(__k)),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator try_emplace(const_iterator __h, const key_type& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_hint_unique_key_args(__h.__i_, __k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(__k),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator try_emplace(const_iterator __h, key_type&& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_hint_unique_key_args(__h.__i_, __k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(_VSTD::move(__k)),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert_or_assign(const key_type& __k, _Vp&& __v)\n    {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return _VSTD::make_pair(__p, false);\n        }\n        return _VSTD::make_pair(emplace_hint(__p, __k, _VSTD::forward<_Vp>(__v)), true);\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert_or_assign(key_type&& __k, _Vp&& __v)\n    {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return _VSTD::make_pair(__p, false);\n        }\n        return _VSTD::make_pair(emplace_hint(__p, _VSTD::move(__k), _VSTD::forward<_Vp>(__v)), true);\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert_or_assign(const_iterator __h, const key_type& __k, _Vp&& __v)\n     {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return __p;\n        }\n        return emplace_hint(__h, __k, _VSTD::forward<_Vp>(__v));\n     }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert_or_assign(const_iterator __h, key_type&& __k, _Vp&& __v)\n     {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return __p;\n        }\n        return emplace_hint(__h, _VSTD::move(__k), _VSTD::forward<_Vp>(__v));\n     }\n\n#endif // _LIBCPP_STD_VER > 14\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(iterator __p)       {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k)\n        {return __tree_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    insert_return_type insert(node_type&& __nh)\n    {\n        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),\n            \"node_type with incompatible allocator passed to map::insert()\");\n        return __tree_.template __node_handle_insert_unique<\n            node_type, insert_return_type>(_VSTD::move(__nh));\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __hint, node_type&& __nh)\n    {\n        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),\n            \"node_type with incompatible allocator passed to map::insert()\");\n        return __tree_.template __node_handle_insert_unique<node_type>(\n            __hint.__i_, _VSTD::move(__nh));\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    node_type extract(key_type const& __key)\n    {\n        return __tree_.template __node_handle_extract<node_type>(__key);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    node_type extract(const_iterator __it)\n    {\n        return __tree_.template __node_handle_extract<node_type>(__it.__i_);\n    }\n    template <class _Compare2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(map<key_type, mapped_type, _Compare2, allocator_type>& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        __tree_.__node_handle_merge_unique(__source.__tree_);\n    }\n    template <class _Compare2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(map<key_type, mapped_type, _Compare2, allocator_type>&& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        __tree_.__node_handle_merge_unique(__source.__tree_);\n    }\n    template <class _Compare2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        __tree_.__node_handle_merge_unique(__source.__tree_);\n    }\n    template <class _Compare2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>&& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        __tree_.__node_handle_merge_unique(__source.__tree_);\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(map& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k) const {return __tree_.__count_multi(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n        {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n        {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n        {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator> equal_range(const key_type& __k)\n        {return __tree_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n        {return __tree_.__equal_range_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_multi(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n    typedef typename __base::__node_base_pointer       __node_base_pointer;\n    typedef typename __base::__parent_pointer          __parent_pointer;\n\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n#ifdef _LIBCPP_CXX03_LANG\n    __node_holder __construct_node_with_key(const key_type& __k);\n#endif\n};\n\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmap<_Key, _Tp, _Compare, _Allocator>::map(map&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), typename __base::allocator_type(__a))\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_unique(__e.__i_,\n                    __m.__tree_.remove(__m.begin().__i_)->__value_.__move());\n    }\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)\n{\n    return __tree_.__emplace_unique_key_args(__k,\n        _VSTD::piecewise_construct,\n        _VSTD::forward_as_tuple(__k),\n        _VSTD::forward_as_tuple()).first->__get_value().second;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](key_type&& __k)\n{\n    return __tree_.__emplace_unique_key_args(__k,\n        _VSTD::piecewise_construct,\n        _VSTD::forward_as_tuple(_VSTD::move(__k)),\n        _VSTD::forward_as_tuple()).first->__get_value().second;\n}\n\n#else // _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(const key_type& __k)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__get_value().first), __k);\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__get_value().second));\n    __h.get_deleter().__second_constructed = true;\n    return _LIBCPP_EXPLICIT_MOVE(__h);  // explicitly moved for C++03\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __tree_.__find_equal(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node_with_key(__k);\n        __tree_.__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return __r->__value_.__get_value().second;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __tree_.__find_equal(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_pointer>(__child)->__value_.__get_value().second;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nconst _Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const\n{\n    __parent_pointer __parent;\n    __node_base_pointer __child = __tree_.__find_equal(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_pointer>(__child)->__value_.__get_value().second;\n}\n\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(map<_Key, _Tp, _Compare, _Allocator>& __x,\n     map<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n#if _LIBCPP_STD_VER > 17\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid erase_if(map<_Key, _Tp, _Compare, _Allocator>& __c, _Predicate __pred)\n{ __libcpp_erase_if_container(__c, __pred); }\n#endif\n\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TEMPLATE_VIS multimap\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), \"\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    class _LIBCPP_TEMPLATE_VIS value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY\n        value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,\n                                                 __value_type>::type __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>            __base;\n    typedef typename __base::__node_traits                          __node_traits;\n    typedef allocator_traits<allocator_type>                        __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>      iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n#if _LIBCPP_STD_VER > 14\n    typedef __map_node_handle<typename __base::__node, allocator_type> node_type;\n#endif\n\n    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>\n        friend class _LIBCPP_TEMPLATE_VIS map;\n    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>\n        friend class _LIBCPP_TEMPLATE_VIS multimap;\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(key_compare())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), typename __base::allocator_type(__a))\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : multimap(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m)\n        : __tree_(__m.__tree_.value_comp(),\n          __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(const multimap& __m)\n        {\n#ifndef _LIBCPP_CXX03_LANG\n            __tree_ = __m.__tree_;\n#else\n            if (this != &__m) {\n                __tree_.clear();\n                __tree_.value_comp() = __m.__tree_.value_comp();\n                __tree_.__copy_assign_alloc(__m.__tree_);\n                insert(__m.begin(), __m.end());\n            }\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    multimap(multimap&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), typename __base::allocator_type(__a))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const allocator_type& __a)\n        : multimap(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_multi(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const allocator_type& __a)\n        : __tree_(typename __base::allocator_type(__a))\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return allocator_type(__tree_.__alloc());}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp() const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp() const\n        {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_CXX03_LANG\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator emplace(_Args&& ...__args) {\n        return __tree_.__emplace_multi(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {\n        return __tree_.__emplace_hint_multi(__p.__i_, _VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(_Pp&& __p)\n            {return __tree_.__insert_multi(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_multi(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(value_type&& __v)\n        {return __tree_.__insert_multi(_VSTD::move(__v));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __v)\n        {return __tree_.__insert_multi(__p.__i_, _VSTD::move(__v));}\n\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __v) {return __tree_.__insert_multi(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_multi(__p.__i_, __v);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_multi(__e.__i_, *__f);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(iterator __p)       {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(node_type&& __nh)\n    {\n        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),\n            \"node_type with incompatible allocator passed to multimap::insert()\");\n        return __tree_.template __node_handle_insert_multi<node_type>(\n            _VSTD::move(__nh));\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __hint, node_type&& __nh)\n    {\n        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),\n            \"node_type with incompatible allocator passed to multimap::insert()\");\n        return __tree_.template __node_handle_insert_multi<node_type>(\n            __hint.__i_, _VSTD::move(__nh));\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    node_type extract(key_type const& __key)\n    {\n        return __tree_.template __node_handle_extract<node_type>(__key);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    node_type extract(const_iterator __it)\n    {\n        return __tree_.template __node_handle_extract<node_type>(\n            __it.__i_);\n    }\n    template <class _Compare2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        return __tree_.__node_handle_merge_multi(__source.__tree_);\n    }\n    template <class _Compare2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>&& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        return __tree_.__node_handle_merge_multi(__source.__tree_);\n    }\n    template <class _Compare2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(map<key_type, mapped_type, _Compare2, allocator_type>& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        return __tree_.__node_handle_merge_multi(__source.__tree_);\n    }\n    template <class _Compare2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(map<key_type, mapped_type, _Compare2, allocator_type>&& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        return __tree_.__node_handle_merge_multi(__source.__tree_);\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(multimap& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k) const {return __tree_.__count_multi(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n            {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n            {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n            {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator>             equal_range(const key_type& __k)\n            {return __tree_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n            {return __tree_.__equal_range_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_multi(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n};\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmultimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), typename __base::allocator_type(__a))\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_multi(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__move()));\n    }\n}\n#endif\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n     multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n#if _LIBCPP_STD_VER > 17\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid erase_if(multimap<_Key, _Tp, _Compare, _Allocator>& __c, _Predicate __pred)\n{ __libcpp_erase_if_container(__c, __pred); }\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MAP\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___TREE\n#define _LIBCPP___TREE\n\n#include <__config>\n#include <iterator>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _Compare, class _Allocator> class __tree;\ntemplate <class _Tp, class _NodePtr, class _DiffType>\n    class _LIBCPP_TEMPLATE_VIS __tree_iterator;\ntemplate <class _Tp, class _ConstNodePtr, class _DiffType>\n    class _LIBCPP_TEMPLATE_VIS __tree_const_iterator;\n\ntemplate <class _Pointer> class __tree_end_node;\ntemplate <class _VoidPtr> class __tree_node_base;\ntemplate <class _Tp, class _VoidPtr> class __tree_node;\n\ntemplate <class _Key, class _Value>\nstruct __value_type;\n\ntemplate <class _Allocator> class __map_node_destructor;\ntemplate <class _TreeIterator> class _LIBCPP_TEMPLATE_VIS __map_iterator;\ntemplate <class _TreeIterator> class _LIBCPP_TEMPLATE_VIS __map_const_iterator;\n\n/*\n\n_NodePtr algorithms\n\nThe algorithms taking _NodePtr are red black tree algorithms.  Those\nalgorithms taking a parameter named __root should assume that __root\npoints to a proper red black tree (unless otherwise specified).\n\nEach algorithm herein assumes that __root->__parent_ points to a non-null\nstructure which has a member __left_ which points back to __root.  No other\nmember is read or written to at __root->__parent_.\n\n__root->__parent_ will be referred to below (in comments only) as end_node.\nend_node->__left_ is an externably accessible lvalue for __root, and can be\nchanged by node insertion and removal (without explicit reference to end_node).\n\nAll nodes (with the exception of end_node), even the node referred to as\n__root, have a non-null __parent_ field.\n\n*/\n\n// Returns:  true if __x is a left child of its parent, else false\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__tree_is_left_child(_NodePtr __x) _NOEXCEPT\n{\n    return __x == __x->__parent_->__left_;\n}\n\n// Determines if the subtree rooted at __x is a proper red black subtree.  If\n//    __x is a proper subtree, returns the black height (null counts as 1).  If\n//    __x is an improper subtree, returns 0.\ntemplate <class _NodePtr>\nunsigned\n__tree_sub_invariant(_NodePtr __x)\n{\n    if (__x == nullptr)\n        return 1;\n    // parent consistency checked by caller\n    // check __x->__left_ consistency\n    if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)\n        return 0;\n    // check __x->__right_ consistency\n    if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)\n        return 0;\n    // check __x->__left_ != __x->__right_ unless both are nullptr\n    if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)\n        return 0;\n    // If this is red, neither child can be red\n    if (!__x->__is_black_)\n    {\n        if (__x->__left_ && !__x->__left_->__is_black_)\n            return 0;\n        if (__x->__right_ && !__x->__right_->__is_black_)\n            return 0;\n    }\n    unsigned __h = __tree_sub_invariant(__x->__left_);\n    if (__h == 0)\n        return 0;  // invalid left subtree\n    if (__h != __tree_sub_invariant(__x->__right_))\n        return 0;  // invalid or different height right subtree\n    return __h + __x->__is_black_;  // return black height of this node\n}\n\n// Determines if the red black tree rooted at __root is a proper red black tree.\n//    __root == nullptr is a proper tree.  Returns true is __root is a proper\n//    red black tree, else returns false.\ntemplate <class _NodePtr>\nbool\n__tree_invariant(_NodePtr __root)\n{\n    if (__root == nullptr)\n        return true;\n    // check __x->__parent_ consistency\n    if (__root->__parent_ == nullptr)\n        return false;\n    if (!__tree_is_left_child(__root))\n        return false;\n    // root must be black\n    if (!__root->__is_black_)\n        return false;\n    // do normal node checks\n    return __tree_sub_invariant(__root) != 0;\n}\n\n// Returns:  pointer to the left-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_min(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__left_ != nullptr)\n        __x = __x->__left_;\n    return __x;\n}\n\n// Returns:  pointer to the right-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_max(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__right_ != nullptr)\n        __x = __x->__right_;\n    return __x;\n}\n\n// Returns:  pointer to the next in-order node after __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_next(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__right_ != nullptr)\n        return __tree_min(__x->__right_);\n    while (!__tree_is_left_child(__x))\n        __x = __x->__parent_unsafe();\n    return __x->__parent_unsafe();\n}\n\ntemplate <class _EndNodePtr, class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_EndNodePtr\n__tree_next_iter(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__right_ != nullptr)\n        return static_cast<_EndNodePtr>(__tree_min(__x->__right_));\n    while (!__tree_is_left_child(__x))\n        __x = __x->__parent_unsafe();\n    return static_cast<_EndNodePtr>(__x->__parent_);\n}\n\n// Returns:  pointer to the previous in-order node before __x.\n// Precondition:  __x != nullptr.\n// Note: __x may be the end node.\ntemplate <class _NodePtr, class _EndNodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_prev_iter(_EndNodePtr __x) _NOEXCEPT\n{\n    if (__x->__left_ != nullptr)\n        return __tree_max(__x->__left_);\n    _NodePtr __xx = static_cast<_NodePtr>(__x);\n    while (__tree_is_left_child(__xx))\n        __xx = __xx->__parent_unsafe();\n    return __xx->__parent_unsafe();\n}\n\n// Returns:  pointer to a node which has no children\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_leaf(_NodePtr __x) _NOEXCEPT\n{\n    while (true)\n    {\n        if (__x->__left_ != nullptr)\n        {\n            __x = __x->__left_;\n            continue;\n        }\n        if (__x->__right_ != nullptr)\n        {\n            __x = __x->__right_;\n            continue;\n        }\n        break;\n    }\n    return __x;\n}\n\n// Effects:  Makes __x->__right_ the subtree root with __x as its left child\n//           while preserving in-order order.\n// Precondition:  __x->__right_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_left_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__right_;\n    __x->__right_ = __y->__left_;\n    if (__x->__right_ != nullptr)\n        __x->__right_->__set_parent(__x);\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_unsafe()->__right_ = __y;\n    __y->__left_ = __x;\n    __x->__set_parent(__y);\n}\n\n// Effects:  Makes __x->__left_ the subtree root with __x as its right child\n//           while preserving in-order order.\n// Precondition:  __x->__left_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_right_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__left_;\n    __x->__left_ = __y->__right_;\n    if (__x->__left_ != nullptr)\n        __x->__left_->__set_parent(__x);\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_unsafe()->__right_ = __y;\n    __y->__right_ = __x;\n    __x->__set_parent(__y);\n}\n\n// Effects:  Rebalances __root after attaching __x to a leaf.\n// Precondition:  __root != nulptr && __x != nullptr.\n//                __x has no children.\n//                __x == __root or == a direct or indirect child of __root.\n//                If __x were to be unlinked from __root (setting __root to\n//                  nullptr if __root == __x), __tree_invariant(__root) == true.\n// Postcondition: __tree_invariant(end_node->__left_) == true.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_balance_after_insert(_NodePtr __root, _NodePtr __x) _NOEXCEPT\n{\n    __x->__is_black_ = __x == __root;\n    while (__x != __root && !__x->__parent_unsafe()->__is_black_)\n    {\n        // __x->__parent_ != __root because __x->__parent_->__is_black == false\n        if (__tree_is_left_child(__x->__parent_unsafe()))\n        {\n            _NodePtr __y = __x->__parent_unsafe()->__parent_unsafe()->__right_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = true;\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (!__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_unsafe();\n                    __tree_left_rotate(__x);\n                }\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = true;\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = false;\n                __tree_right_rotate(__x);\n                break;\n            }\n        }\n        else\n        {\n            _NodePtr __y = __x->__parent_unsafe()->__parent_->__left_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = true;\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_unsafe();\n                    __tree_right_rotate(__x);\n                }\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = true;\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = false;\n                __tree_left_rotate(__x);\n                break;\n            }\n        }\n    }\n}\n\n// Precondition:  __root != nullptr && __z != nullptr.\n//                __tree_invariant(__root) == true.\n//                __z == __root or == a direct or indirect child of __root.\n// Effects:  unlinks __z from the tree rooted at __root, rebalancing as needed.\n// Postcondition: __tree_invariant(end_node->__left_) == true && end_node->__left_\n//                nor any of its children refer to __z.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_remove(_NodePtr __root, _NodePtr __z) _NOEXCEPT\n{\n    // __z will be removed from the tree.  Client still needs to destruct/deallocate it\n    // __y is either __z, or if __z has two children, __tree_next(__z).\n    // __y will have at most one child.\n    // __y will be the initial hole in the tree (make the hole at a leaf)\n    _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr) ?\n                    __z : __tree_next(__z);\n    // __x is __y's possibly null single child\n    _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;\n    // __w is __x's possibly null uncle (will become __x's sibling)\n    _NodePtr __w = nullptr;\n    // link __x to __y's parent, and find __w\n    if (__x != nullptr)\n        __x->__parent_ = __y->__parent_;\n    if (__tree_is_left_child(__y))\n    {\n        __y->__parent_->__left_ = __x;\n        if (__y != __root)\n            __w = __y->__parent_unsafe()->__right_;\n        else\n            __root = __x;  // __w == nullptr\n    }\n    else\n    {\n        __y->__parent_unsafe()->__right_ = __x;\n        // __y can't be root if it is a right child\n        __w = __y->__parent_->__left_;\n    }\n    bool __removed_black = __y->__is_black_;\n    // If we didn't remove __z, do so now by splicing in __y for __z,\n    //    but copy __z's color.  This does not impact __x or __w.\n    if (__y != __z)\n    {\n        // __z->__left_ != nulptr but __z->__right_ might == __x == nullptr\n        __y->__parent_ = __z->__parent_;\n        if (__tree_is_left_child(__z))\n            __y->__parent_->__left_ = __y;\n        else\n            __y->__parent_unsafe()->__right_ = __y;\n        __y->__left_ = __z->__left_;\n        __y->__left_->__set_parent(__y);\n        __y->__right_ = __z->__right_;\n        if (__y->__right_ != nullptr)\n            __y->__right_->__set_parent(__y);\n        __y->__is_black_ = __z->__is_black_;\n        if (__root == __z)\n            __root = __y;\n    }\n    // There is no need to rebalance if we removed a red, or if we removed\n    //     the last node.\n    if (__removed_black && __root != nullptr)\n    {\n        // Rebalance:\n        // __x has an implicit black color (transferred from the removed __y)\n        //    associated with it, no matter what its color is.\n        // If __x is __root (in which case it can't be null), it is supposed\n        //    to be black anyway, and if it is doubly black, then the double\n        //    can just be ignored.\n        // If __x is red (in which case it can't be null), then it can absorb\n        //    the implicit black just by setting its color to black.\n        // Since __y was black and only had one child (which __x points to), __x\n        //   is either red with no children, else null, otherwise __y would have\n        //   different black heights under left and right pointers.\n        // if (__x == __root || __x != nullptr && !__x->__is_black_)\n        if (__x != nullptr)\n            __x->__is_black_ = true;\n        else\n        {\n            //  Else __x isn't root, and is \"doubly black\", even though it may\n            //     be null.  __w can not be null here, else the parent would\n            //     see a black height >= 2 on the __x side and a black height\n            //     of 1 on the __w side (__w must be a non-null black or a red\n            //     with a non-null black child).\n            while (true)\n            {\n                if (!__tree_is_left_child(__w))  // if x is left child\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_unsafe()->__is_black_ = false;\n                        __tree_left_rotate(__w->__parent_unsafe());\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__left_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__left_->__right_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_unsafe();\n                        // __x can no longer be null\n                        if (__x == __root || !__x->__is_black_)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_unsafe()->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__right_ == nullptr || __w->__right_->__is_black_)\n                        {\n                            // __w left child is non-null and red\n                            __w->__left_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_right_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_unsafe();\n                        }\n                        // __w has a right red child, left child may be null\n                        __w->__is_black_ = __w->__parent_unsafe()->__is_black_;\n                        __w->__parent_unsafe()->__is_black_ = true;\n                        __w->__right_->__is_black_ = true;\n                        __tree_left_rotate(__w->__parent_unsafe());\n                        break;\n                    }\n                }\n                else\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_unsafe()->__is_black_ = false;\n                        __tree_right_rotate(__w->__parent_unsafe());\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__right_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__right_->__left_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_unsafe();\n                        // __x can no longer be null\n                        if (!__x->__is_black_ || __x == __root)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_unsafe()->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__left_ == nullptr || __w->__left_->__is_black_)\n                        {\n                            // __w right child is non-null and red\n                            __w->__right_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_left_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_unsafe();\n                        }\n                        // __w has a left red child, right child may be null\n                        __w->__is_black_ = __w->__parent_unsafe()->__is_black_;\n                        __w->__parent_unsafe()->__is_black_ = true;\n                        __w->__left_->__is_black_ = true;\n                        __tree_right_rotate(__w->__parent_unsafe());\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\n// node traits\n\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp>\nstruct __is_tree_value_type_imp : false_type {};\n\ntemplate <class _Key, class _Value>\nstruct __is_tree_value_type_imp<__value_type<_Key, _Value>> : true_type {};\n\ntemplate <class ..._Args>\nstruct __is_tree_value_type : false_type {};\n\ntemplate <class _One>\nstruct __is_tree_value_type<_One> : __is_tree_value_type_imp<typename __uncvref<_One>::type> {};\n#endif\n\ntemplate <class _Tp>\nstruct __tree_key_value_types {\n  typedef _Tp key_type;\n  typedef _Tp __node_value_type;\n  typedef _Tp __container_value_type;\n  static const bool __is_map = false;\n\n  _LIBCPP_INLINE_VISIBILITY\n  static key_type const& __get_key(_Tp const& __v) {\n    return __v;\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type const& __get_value(__node_value_type const& __v) {\n    return __v;\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type* __get_ptr(__node_value_type& __n) {\n    return _VSTD::addressof(__n);\n  }\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type&& __move(__node_value_type& __v) {\n    return _VSTD::move(__v);\n  }\n#endif\n};\n\ntemplate <class _Key, class _Tp>\nstruct __tree_key_value_types<__value_type<_Key, _Tp> > {\n  typedef _Key                                         key_type;\n  typedef _Tp                                          mapped_type;\n  typedef __value_type<_Key, _Tp>                      __node_value_type;\n  typedef pair<const _Key, _Tp>                        __container_value_type;\n  typedef __container_value_type                       __map_value_type;\n  static const bool __is_map = true;\n\n  _LIBCPP_INLINE_VISIBILITY\n  static key_type const&\n  __get_key(__node_value_type const& __t) {\n    return __t.__get_value().first;\n  }\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,\n      key_type const&>::type\n  __get_key(_Up& __t) {\n    return __t.first;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type const&\n  __get_value(__node_value_type const& __t) {\n    return __t.__get_value();\n  }\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,\n      __container_value_type const&>::type\n  __get_value(_Up& __t) {\n    return __t;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type* __get_ptr(__node_value_type& __n) {\n    return _VSTD::addressof(__n.__get_value());\n  }\n\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY\n  static pair<key_type&&, mapped_type&&> __move(__node_value_type& __v) {\n    return __v.__move();\n  }\n#endif\n};\n\ntemplate <class _VoidPtr>\nstruct __tree_node_base_types {\n  typedef _VoidPtr                                               __void_pointer;\n\n  typedef __tree_node_base<__void_pointer>                      __node_base_type;\n  typedef typename __rebind_pointer<_VoidPtr, __node_base_type>::type\n                                                             __node_base_pointer;\n\n  typedef __tree_end_node<__node_base_pointer>                  __end_node_type;\n  typedef typename __rebind_pointer<_VoidPtr, __end_node_type>::type\n                                                             __end_node_pointer;\n#if defined(_LIBCPP_ABI_TREE_REMOVE_NODE_POINTER_UB)\n  typedef __end_node_pointer __parent_pointer;\n#else\n  typedef typename conditional<\n      is_pointer<__end_node_pointer>::value,\n        __end_node_pointer,\n        __node_base_pointer>::type __parent_pointer;\n#endif\n\nprivate:\n  static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),\n                  \"_VoidPtr does not point to unqualified void type\");\n};\n\ntemplate <class _Tp, class _AllocPtr, class _KVTypes = __tree_key_value_types<_Tp>,\n         bool = _KVTypes::__is_map>\nstruct __tree_map_pointer_types {};\n\ntemplate <class _Tp, class _AllocPtr, class _KVTypes>\nstruct __tree_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {\n  typedef typename _KVTypes::__map_value_type   _Mv;\n  typedef typename __rebind_pointer<_AllocPtr, _Mv>::type\n                                                       __map_value_type_pointer;\n  typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type\n                                                 __const_map_value_type_pointer;\n};\n\ntemplate <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>\nstruct __tree_node_types;\n\ntemplate <class _NodePtr, class _Tp, class _VoidPtr>\nstruct __tree_node_types<_NodePtr, __tree_node<_Tp, _VoidPtr> >\n    : public __tree_node_base_types<_VoidPtr>,\n             __tree_key_value_types<_Tp>,\n             __tree_map_pointer_types<_Tp, _VoidPtr>\n{\n  typedef __tree_node_base_types<_VoidPtr> __base;\n  typedef __tree_key_value_types<_Tp>      __key_base;\n  typedef __tree_map_pointer_types<_Tp, _VoidPtr> __map_pointer_base;\npublic:\n\n  typedef typename pointer_traits<_NodePtr>::element_type       __node_type;\n  typedef _NodePtr                                              __node_pointer;\n\n  typedef _Tp                                                 __node_value_type;\n  typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type\n                                                      __node_value_type_pointer;\n  typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type\n                                                __const_node_value_type_pointer;\n#if defined(_LIBCPP_ABI_TREE_REMOVE_NODE_POINTER_UB)\n  typedef typename __base::__end_node_pointer __iter_pointer;\n#else\n  typedef typename conditional<\n      is_pointer<__node_pointer>::value,\n        typename __base::__end_node_pointer,\n        __node_pointer>::type __iter_pointer;\n#endif\nprivate:\n    static_assert(!is_const<__node_type>::value,\n                \"_NodePtr should never be a pointer to const\");\n    static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,\n                          _NodePtr>::value), \"_VoidPtr does not rebind to _NodePtr.\");\n};\n\ntemplate <class _ValueTp, class _VoidPtr>\nstruct __make_tree_node_types {\n  typedef typename __rebind_pointer<_VoidPtr, __tree_node<_ValueTp, _VoidPtr> >::type\n                                                                        _NodePtr;\n  typedef __tree_node_types<_NodePtr> type;\n};\n\n// node\n\ntemplate <class _Pointer>\nclass __tree_end_node\n{\npublic:\n    typedef _Pointer pointer;\n    pointer __left_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_end_node() _NOEXCEPT : __left_() {}\n};\n\ntemplate <class _VoidPtr>\nclass __tree_node_base\n    : public __tree_node_base_types<_VoidPtr>::__end_node_type\n{\n    typedef __tree_node_base_types<_VoidPtr> _NodeBaseTypes;\n\npublic:\n    typedef typename _NodeBaseTypes::__node_base_pointer pointer;\n    typedef typename _NodeBaseTypes::__parent_pointer __parent_pointer;\n\n    pointer          __right_;\n    __parent_pointer __parent_;\n    bool __is_black_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __parent_unsafe() const { return static_cast<pointer>(__parent_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_parent(pointer __p) {\n        __parent_ = static_cast<__parent_pointer>(__p);\n    }\n\nprivate:\n  ~__tree_node_base() _LIBCPP_EQUAL_DELETE;\n  __tree_node_base(__tree_node_base const&) _LIBCPP_EQUAL_DELETE;\n  __tree_node_base& operator=(__tree_node_base const&) _LIBCPP_EQUAL_DELETE;\n};\n\ntemplate <class _Tp, class _VoidPtr>\nclass __tree_node\n    : public __tree_node_base<_VoidPtr>\n{\npublic:\n    typedef _Tp __node_value_type;\n\n    __node_value_type __value_;\n\nprivate:\n  ~__tree_node() _LIBCPP_EQUAL_DELETE;\n  __tree_node(__tree_node const&) _LIBCPP_EQUAL_DELETE;\n  __tree_node& operator=(__tree_node const&) _LIBCPP_EQUAL_DELETE;\n};\n\n\ntemplate <class _Allocator>\nclass __tree_node_destructor\n{\n    typedef _Allocator                                      allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n\npublic:\n    typedef typename __alloc_traits::pointer                pointer;\nprivate:\n    typedef __tree_node_types<pointer> _NodeTypes;\n    allocator_type& __na_;\n\n    __tree_node_destructor& operator=(const __tree_node_destructor&);\n\npublic:\n    bool __value_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_node_destructor(allocator_type& __na, bool __val = false) _NOEXCEPT\n        : __na_(__na),\n          __value_constructed(__val)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__value_constructed)\n            __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n\n    template <class> friend class __map_node_destructor;\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _NodeType, class _Alloc>\nstruct __generic_container_node_destructor;\ntemplate <class _Tp, class _VoidPtr, class _Alloc>\nstruct __generic_container_node_destructor<__tree_node<_Tp, _VoidPtr>, _Alloc>\n    : __tree_node_destructor<_Alloc>\n{\n    using __tree_node_destructor<_Alloc>::__tree_node_destructor;\n};\n#endif\n\ntemplate <class _Tp, class _NodePtr, class _DiffType>\nclass _LIBCPP_TEMPLATE_VIS __tree_iterator\n{\n    typedef __tree_node_types<_NodePtr>                     _NodeTypes;\n    typedef _NodePtr                                        __node_pointer;\n    typedef typename _NodeTypes::__node_base_pointer        __node_base_pointer;\n    typedef typename _NodeTypes::__end_node_pointer         __end_node_pointer;\n    typedef typename _NodeTypes::__iter_pointer             __iter_pointer;\n    typedef pointer_traits<__node_pointer> __pointer_traits;\n\n    __iter_pointer __ptr_;\n\npublic:\n    typedef bidirectional_iterator_tag                     iterator_category;\n    typedef _Tp                                            value_type;\n    typedef _DiffType                                      difference_type;\n    typedef value_type&                                    reference;\n    typedef typename _NodeTypes::__node_value_type_pointer pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const\n        {return __get_np()->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__get_np()->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator++() {\n      __ptr_ = static_cast<__iter_pointer>(\n          __tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));\n      return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator++(int)\n        {__tree_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator--() {\n      __ptr_ = static_cast<__iter_pointer>(__tree_prev_iter<__node_base_pointer>(\n          static_cast<__end_node_pointer>(__ptr_)));\n      return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator--(int)\n        {__tree_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_iterator(__end_node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }\n    template <class, class, class> friend class __tree;\n    template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS __tree_const_iterator;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __map_iterator;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS multimap;\n    template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS set;\n    template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS multiset;\n};\n\ntemplate <class _Tp, class _NodePtr, class _DiffType>\nclass _LIBCPP_TEMPLATE_VIS __tree_const_iterator\n{\n    typedef __tree_node_types<_NodePtr>                     _NodeTypes;\n    typedef typename _NodeTypes::__node_pointer             __node_pointer;\n    typedef typename _NodeTypes::__node_base_pointer        __node_base_pointer;\n    typedef typename _NodeTypes::__end_node_pointer         __end_node_pointer;\n    typedef typename _NodeTypes::__iter_pointer             __iter_pointer;\n    typedef pointer_traits<__node_pointer> __pointer_traits;\n\n    __iter_pointer __ptr_;\n\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef _Tp                                                  value_type;\n    typedef _DiffType                                            difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_const_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\nprivate:\n    typedef __tree_iterator<value_type, __node_pointer, difference_type>\n                                                           __non_const_iterator;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator(__non_const_iterator __p) _NOEXCEPT\n        : __ptr_(__p.__ptr_) {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const\n        {return __get_np()->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__get_np()->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator++() {\n      __ptr_ = static_cast<__iter_pointer>(\n          __tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));\n      return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator++(int)\n        {__tree_const_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator--() {\n      __ptr_ = static_cast<__iter_pointer>(__tree_prev_iter<__node_base_pointer>(\n          static_cast<__end_node_pointer>(__ptr_)));\n      return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator--(int)\n        {__tree_const_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_const_iterator(__node_pointer __p) _NOEXCEPT\n        : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_const_iterator(__end_node_pointer __p) _NOEXCEPT\n        : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }\n\n    template <class, class, class> friend class __tree;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS multimap;\n    template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS set;\n    template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS multiset;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __map_const_iterator;\n\n};\n\ntemplate<class _Tp, class _Compare>\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_DIAGNOSE_WARNING(!std::__invokable<_Compare const&, _Tp const&, _Tp const&>::value,\n        \"the specified comparator type does not provide a const call operator\")\n#endif\nint __diagnose_non_const_comparator();\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nclass __tree\n{\npublic:\n    typedef _Tp                                      value_type;\n    typedef _Compare                                 value_compare;\n    typedef _Allocator                               allocator_type;\n\nprivate:\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __make_tree_node_types<value_type,\n        typename __alloc_traits::void_pointer>::type\n                                                    _NodeTypes;\n    typedef typename _NodeTypes::key_type           key_type;\npublic:\n    typedef typename _NodeTypes::__node_value_type      __node_value_type;\n    typedef typename _NodeTypes::__container_value_type __container_value_type;\n\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n\npublic:\n    typedef typename _NodeTypes::__void_pointer        __void_pointer;\n\n    typedef typename _NodeTypes::__node_type           __node;\n    typedef typename _NodeTypes::__node_pointer        __node_pointer;\n\n    typedef typename _NodeTypes::__node_base_type      __node_base;\n    typedef typename _NodeTypes::__node_base_pointer   __node_base_pointer;\n\n    typedef typename _NodeTypes::__end_node_type       __end_node_t;\n    typedef typename _NodeTypes::__end_node_pointer    __end_node_ptr;\n\n    typedef typename _NodeTypes::__parent_pointer      __parent_pointer;\n    typedef typename _NodeTypes::__iter_pointer        __iter_pointer;\n\n    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;\n    typedef allocator_traits<__node_allocator>         __node_traits;\n\nprivate:\n    // check for sane allocator pointer rebinding semantics. Rebinding the\n    // allocator for a new pointer type should be exactly the same as rebinding\n    // the pointer using 'pointer_traits'.\n    static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),\n                  \"Allocator does not rebind pointers in a sane manner.\");\n    typedef typename __rebind_alloc_helper<__node_traits, __node_base>::type\n        __node_base_allocator;\n    typedef allocator_traits<__node_base_allocator> __node_base_traits;\n    static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),\n                 \"Allocator does not rebind pointers in a sane manner.\");\n\nprivate:\n    __iter_pointer                                     __begin_node_;\n    __compressed_pair<__end_node_t, __node_allocator>  __pair1_;\n    __compressed_pair<size_type, value_compare>        __pair3_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __iter_pointer __end_node() _NOEXCEPT\n    {\n        return static_cast<__iter_pointer>(\n                pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first())\n        );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __iter_pointer __end_node() const _NOEXCEPT\n    {\n        return static_cast<__iter_pointer>(\n            pointer_traits<__end_node_ptr>::pointer_to(\n                const_cast<__end_node_t&>(__pair1_.first())\n            )\n        );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n          __node_allocator& __node_alloc() _NOEXCEPT {return __pair1_.second();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __pair1_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n          __iter_pointer& __begin_node() _NOEXCEPT {return __begin_node_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const __iter_pointer& __begin_node() const _NOEXCEPT {return __begin_node_;}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type __alloc() const _NOEXCEPT\n        {return allocator_type(__node_alloc());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n          size_type& size() _NOEXCEPT {return __pair3_.first();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& size() const _NOEXCEPT {return __pair3_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n          value_compare& value_comp() _NOEXCEPT {return __pair3_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_compare& value_comp() const _NOEXCEPT\n        {return __pair3_.second();}\npublic:\n\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __root() const _NOEXCEPT\n        {return static_cast<__node_pointer>(__end_node()->__left_);}\n\n    __node_base_pointer* __root_ptr() const _NOEXCEPT {\n        return _VSTD::addressof(__end_node()->__left_);\n    }\n\n    typedef __tree_iterator<value_type, __node_pointer, difference_type>             iterator;\n    typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;\n\n    explicit __tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value);\n    explicit __tree(const allocator_type& __a);\n    __tree(const value_compare& __comp, const allocator_type& __a);\n    __tree(const __tree& __t);\n    __tree& operator=(const __tree& __t);\n    template <class _InputIterator>\n        void __assign_unique(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        void __assign_multi(_InputIterator __first, _InputIterator __last);\n#ifndef _LIBCPP_CXX03_LANG\n    __tree(__tree&& __t)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__node_allocator>::value &&\n            is_nothrow_move_constructible<value_compare>::value);\n    __tree(__tree&& __t, const allocator_type& __a);\n    __tree& operator=(__tree&& __t)\n        _NOEXCEPT_(\n            __node_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<value_compare>::value &&\n            is_nothrow_move_assignable<__node_allocator>::value);\n#endif // _LIBCPP_CXX03_LANG\n\n    ~__tree();\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin()  _NOEXCEPT {return       iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return const_iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return       iterator(__end_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return const_iterator(__end_node());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n        {return std::min<size_type>(\n                __node_traits::max_size(__node_alloc()),\n                numeric_limits<difference_type >::max());}\n\n    void clear() _NOEXCEPT;\n\n    void swap(__tree& __t)\n#if _LIBCPP_STD_VER <= 11\n        _NOEXCEPT_(\n            __is_nothrow_swappable<value_compare>::value\n            && (!__node_traits::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<__node_allocator>::value)\n            );\n#else\n        _NOEXCEPT_(__is_nothrow_swappable<value_compare>::value);\n#endif\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Key, class ..._Args>\n    pair<iterator, bool>\n    __emplace_unique_key_args(_Key const&, _Args&&... __args);\n    template <class _Key, class ..._Args>\n    iterator\n    __emplace_hint_unique_key_args(const_iterator, _Key const&, _Args&&...);\n\n    template <class... _Args>\n    pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);\n\n    template <class... _Args>\n    iterator __emplace_hint_unique_impl(const_iterator __p, _Args&&... __args);\n\n    template <class... _Args>\n    iterator __emplace_multi(_Args&&... __args);\n\n    template <class... _Args>\n    iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique(_Pp&& __x) {\n        return __emplace_unique_extract_key(_VSTD::forward<_Pp>(__x),\n                                            __can_extract_key<_Pp, key_type>());\n    }\n\n    template <class _First, class _Second>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        __can_extract_map_key<_First, key_type, __container_value_type>::value,\n        pair<iterator, bool>\n    >::type __emplace_unique(_First&& __f, _Second&& __s) {\n        return __emplace_unique_key_args(__f, _VSTD::forward<_First>(__f),\n                                              _VSTD::forward<_Second>(__s));\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique(_Args&&... __args) {\n        return __emplace_unique_impl(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {\n      return __emplace_unique_impl(_VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {\n      return __emplace_unique_key_args(__x, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {\n      return __emplace_unique_key_args(__x.first, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_hint_unique(const_iterator __p, _Pp&& __x) {\n        return __emplace_hint_unique_extract_key(__p, _VSTD::forward<_Pp>(__x),\n                                            __can_extract_key<_Pp, key_type>());\n    }\n\n    template <class _First, class _Second>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        __can_extract_map_key<_First, key_type, __container_value_type>::value,\n        iterator\n    >::type __emplace_hint_unique(const_iterator __p, _First&& __f, _Second&& __s) {\n        return __emplace_hint_unique_key_args(__p, __f,\n                                              _VSTD::forward<_First>(__f),\n                                              _VSTD::forward<_Second>(__s));\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_hint_unique(const_iterator __p, _Args&&... __args) {\n        return __emplace_hint_unique_impl(__p, _VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_fail_tag) {\n      return __emplace_hint_unique_impl(__p, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_self_tag) {\n      return __emplace_hint_unique_key_args(__p, __x, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_first_tag) {\n      return __emplace_hint_unique_key_args(__p, __x.first, _VSTD::forward<_Pp>(__x));\n    }\n\n#else\n    template <class _Key, class _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique_key_args(_Key const&, _Args& __args);\n    template <class _Key, class _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_hint_unique_key_args(const_iterator, _Key const&, _Args&);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(const __container_value_type& __v) {\n        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_unique(const_iterator __p, const __container_value_type& __v) {\n        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), __v);\n    }\n\n#ifdef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const __container_value_type& __v);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const_iterator __p, const __container_value_type& __v);\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(__container_value_type&& __v) {\n        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), _VSTD::move(__v));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_unique(const_iterator __p, __container_value_type&& __v) {\n        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), _VSTD::move(__v));\n    }\n\n    template <class _Vp, class = typename enable_if<\n            !is_same<typename __unconstref<_Vp>::type,\n                     __container_value_type\n            >::value\n        >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(_Vp&& __v) {\n        return __emplace_unique(_VSTD::forward<_Vp>(__v));\n    }\n\n    template <class _Vp, class = typename enable_if<\n            !is_same<typename __unconstref<_Vp>::type,\n                     __container_value_type\n            >::value\n        >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_unique(const_iterator __p, _Vp&& __v) {\n        return __emplace_hint_unique(__p, _VSTD::forward<_Vp>(__v));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(__container_value_type&& __v) {\n        return __emplace_multi(_VSTD::move(__v));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const_iterator __p, __container_value_type&& __v) {\n        return __emplace_hint_multi(__p, _VSTD::move(__v));\n    }\n\n    template <class _Vp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(_Vp&& __v) {\n        return __emplace_multi(_VSTD::forward<_Vp>(__v));\n    }\n\n    template <class _Vp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const_iterator __p, _Vp&& __v) {\n        return __emplace_hint_multi(__p, _VSTD::forward<_Vp>(__v));\n    }\n\n#endif // !_LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator             __node_insert_unique(const_iterator __p,\n                                              __node_pointer __nd);\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __node_insert_multi(__node_pointer __nd);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);\n\n\n    _LIBCPP_INLINE_VISIBILITY iterator\n    __remove_node_pointer(__node_pointer) _NOEXCEPT;\n\n#if _LIBCPP_STD_VER > 14\n    template <class _NodeHandle, class _InsertReturnType>\n    _LIBCPP_INLINE_VISIBILITY\n    _InsertReturnType __node_handle_insert_unique(_NodeHandle&&);\n    template <class _NodeHandle>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __node_handle_insert_unique(const_iterator, _NodeHandle&&);\n    template <class _Tree>\n    _LIBCPP_INLINE_VISIBILITY\n    void __node_handle_merge_unique(_Tree& __source);\n\n    template <class _NodeHandle>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __node_handle_insert_multi(_NodeHandle&&);\n    template <class _NodeHandle>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __node_handle_insert_multi(const_iterator, _NodeHandle&&);\n    template <class _Tree>\n    _LIBCPP_INLINE_VISIBILITY\n    void __node_handle_merge_multi(_Tree& __source);\n\n\n    template <class _NodeHandle>\n    _LIBCPP_INLINE_VISIBILITY\n    _NodeHandle __node_handle_extract(key_type const&);\n    template <class _NodeHandle>\n    _LIBCPP_INLINE_VISIBILITY\n    _NodeHandle __node_handle_extract(const_iterator);\n#endif\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __f, const_iterator __l);\n    template <class _Key>\n        size_type __erase_unique(const _Key& __k);\n    template <class _Key>\n        size_type __erase_multi(const _Key& __k);\n\n    void __insert_node_at(__parent_pointer     __parent,\n                          __node_base_pointer& __child,\n                          __node_base_pointer __new_node) _NOEXCEPT;\n\n    template <class _Key>\n        iterator find(const _Key& __v);\n    template <class _Key>\n        const_iterator find(const _Key& __v) const;\n\n    template <class _Key>\n        size_type __count_unique(const _Key& __k) const;\n    template <class _Key>\n        size_type __count_multi(const _Key& __k) const;\n\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator lower_bound(const _Key& __v)\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __lower_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __iter_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator lower_bound(const _Key& __v) const\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __lower_bound(const _Key& __v,\n                                     __node_pointer __root,\n                                     __iter_pointer __result) const;\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator upper_bound(const _Key& __v)\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __upper_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __iter_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator upper_bound(const _Key& __v) const\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __upper_bound(const _Key& __v,\n                                     __node_pointer __root,\n                                     __iter_pointer __result) const;\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_unique(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_unique(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_multi(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_multi(const _Key& __k) const;\n\n    typedef __tree_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n    __node_holder remove(const_iterator __p) _NOEXCEPT;\nprivate:\n    __node_base_pointer&\n        __find_leaf_low(__parent_pointer& __parent, const key_type& __v);\n    __node_base_pointer&\n        __find_leaf_high(__parent_pointer& __parent, const key_type& __v);\n    __node_base_pointer&\n        __find_leaf(const_iterator __hint,\n                    __parent_pointer& __parent, const key_type& __v);\n    // FIXME: Make this function const qualified. Unfortunetly doing so\n    // breaks existing code which uses non-const callable comparators.\n    template <class _Key>\n    __node_base_pointer&\n        __find_equal(__parent_pointer& __parent, const _Key& __v);\n    template <class _Key>\n    _LIBCPP_INLINE_VISIBILITY __node_base_pointer&\n    __find_equal(__parent_pointer& __parent, const _Key& __v) const {\n      return const_cast<__tree*>(this)->__find_equal(__parent, __v);\n    }\n    template <class _Key>\n    __node_base_pointer&\n        __find_equal(const_iterator __hint, __parent_pointer& __parent,\n                     __node_base_pointer& __dummy,\n                     const _Key& __v);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class ..._Args>\n    __node_holder __construct_node(_Args&& ...__args);\n#else\n    __node_holder __construct_node(const __container_value_type& __v);\n#endif\n\n    void destroy(__node_pointer __nd) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t)\n        {__copy_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t, true_type)\n        {\n        if (__node_alloc() != __t.__node_alloc())\n            clear();\n        __node_alloc() = __t.__node_alloc();\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree&, false_type) {}\n\n    void __move_assign(__tree& __t, false_type);\n    void __move_assign(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n                   is_nothrow_move_assignable<__node_allocator>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<__node_allocator>::value)\n        {__move_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n        {__node_alloc() = _VSTD::move(__t.__node_alloc());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree&, false_type) _NOEXCEPT {}\n\n    __node_pointer __detach();\n    static __node_pointer __detach(__node_pointer);\n\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS multimap;\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value)\n    : __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)\n    : __begin_node_(__iter_pointer()),\n      __pair1_(__second_tag(), __node_allocator(__a)),\n      __pair3_(0)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp,\n                                           const allocator_type& __a)\n    : __begin_node_(__iter_pointer()),\n      __pair1_(__second_tag(), __node_allocator(__a)),\n      __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\n// Precondition:  size() != 0\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach()\n{\n    __node_pointer __cache = static_cast<__node_pointer>(__begin_node());\n    __begin_node() = __end_node();\n    __end_node()->__left_->__parent_ = nullptr;\n    __end_node()->__left_ = nullptr;\n    size() = 0;\n    // __cache->__left_ == nullptr\n    if (__cache->__right_ != nullptr)\n        __cache = static_cast<__node_pointer>(__cache->__right_);\n    // __cache->__left_ == nullptr\n    // __cache->__right_ == nullptr\n    return __cache;\n}\n\n// Precondition:  __cache != nullptr\n//    __cache->left_ == nullptr\n//    __cache->right_ == nullptr\n//    This is no longer a red-black tree\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach(__node_pointer __cache)\n{\n    if (__cache->__parent_ == nullptr)\n        return nullptr;\n    if (__tree_is_left_child(static_cast<__node_base_pointer>(__cache)))\n    {\n        __cache->__parent_->__left_ = nullptr;\n        __cache = static_cast<__node_pointer>(__cache->__parent_);\n        if (__cache->__right_ == nullptr)\n            return __cache;\n        return static_cast<__node_pointer>(__tree_leaf(__cache->__right_));\n    }\n    // __cache is right child\n    __cache->__parent_unsafe()->__right_ = nullptr;\n    __cache = static_cast<__node_pointer>(__cache->__parent_);\n    if (__cache->__left_ == nullptr)\n        return __cache;\n    return static_cast<__node_pointer>(__tree_leaf(__cache->__left_));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t)\n{\n    if (this != &__t)\n    {\n        value_comp() = __t.value_comp();\n        __copy_assign_alloc(__t);\n        __assign_multi(__t.begin(), __t.end());\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_unique(_InputIterator __first, _InputIterator __last)\n{\n    typedef iterator_traits<_InputIterator> _ITraits;\n    typedef typename _ITraits::value_type _ItValueType;\n    static_assert((is_same<_ItValueType, __container_value_type>::value),\n                  \"__assign_unique may only be called with the containers value type\");\n\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_unique(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_unique(*__first);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last)\n{\n    typedef iterator_traits<_InputIterator> _ITraits;\n    typedef typename _ITraits::value_type _ItValueType;\n    static_assert((is_same<_ItValueType, __container_value_type>::value ||\n                  is_same<_ItValueType, __node_value_type>::value),\n                  \"__assign_multi may only be called with the containers value type\"\n                  \" or the nodes value type\");\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_multi(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_multi(_NodeTypes::__get_value(*__first));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)\n    : __begin_node_(__iter_pointer()),\n      __pair1_(__second_tag(), __node_traits::select_on_container_copy_construction(__t.__node_alloc())),\n      __pair3_(0, __t.value_comp())\n{\n    __begin_node() = __end_node();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t)\n    _NOEXCEPT_(\n        is_nothrow_move_constructible<__node_allocator>::value &&\n        is_nothrow_move_constructible<value_compare>::value)\n    : __begin_node_(_VSTD::move(__t.__begin_node_)),\n      __pair1_(_VSTD::move(__t.__pair1_)),\n      __pair3_(_VSTD::move(__t.__pair3_))\n{\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t, const allocator_type& __a)\n    : __pair1_(__second_tag(), __node_allocator(__a)),\n      __pair3_(0, _VSTD::move(__t.value_comp()))\n{\n    if (__a == __t.__alloc())\n    {\n        if (__t.size() == 0)\n            __begin_node() = __end_node();\n        else\n        {\n            __begin_node() = __t.__begin_node();\n            __end_node()->__left_ = __t.__end_node()->__left_;\n            __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());\n            size() = __t.size();\n            __t.__begin_node() = __t.__end_node();\n            __t.__end_node()->__left_ = nullptr;\n            __t.size() = 0;\n        }\n    }\n    else\n    {\n        __begin_node() = __end_node();\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n               is_nothrow_move_assignable<__node_allocator>::value)\n{\n    destroy(static_cast<__node_pointer>(__end_node()->__left_));\n    __begin_node_ = __t.__begin_node_;\n    __pair1_.first() = __t.__pair1_.first();\n    __move_assign_alloc(__t);\n    __pair3_ = _VSTD::move(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, false_type)\n{\n    if (__node_alloc() == __t.__node_alloc())\n        __move_assign(__t, true_type());\n    else\n    {\n        value_comp() = _VSTD::move(__t.value_comp());\n        const_iterator __e = end();\n        if (size() != 0)\n        {\n            __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                while (__cache != nullptr && __t.size() != 0)\n                {\n                    __cache->__value_ = _VSTD::move(__t.remove(__t.begin())->__value_);\n                    __node_pointer __next = __detach(__cache);\n                    __node_insert_multi(__cache);\n                    __cache = __next;\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n                throw;\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__cache != nullptr)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n            }\n        }\n        while (__t.size() != 0)\n            __insert_multi(__e, _NodeTypes::__move(__t.remove(__t.begin())->__value_));\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(__tree&& __t)\n    _NOEXCEPT_(\n        __node_traits::propagate_on_container_move_assignment::value &&\n        is_nothrow_move_assignable<value_compare>::value &&\n        is_nothrow_move_assignable<__node_allocator>::value)\n\n{\n    __move_assign(__t, integral_constant<bool,\n                  __node_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::~__tree()\n{\n    static_assert((is_copy_constructible<value_compare>::value),\n                 \"Comparator must be copy-constructible.\");\n  destroy(__root());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) _NOEXCEPT\n{\n    if (__nd != nullptr)\n    {\n        destroy(static_cast<__node_pointer>(__nd->__left_));\n        destroy(static_cast<__node_pointer>(__nd->__right_));\n        __node_allocator& __na = __node_alloc();\n        __node_traits::destroy(__na, _NodeTypes::__get_ptr(__nd->__value_));\n        __node_traits::deallocate(__na, __nd, 1);\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)\n#if _LIBCPP_STD_VER <= 11\n        _NOEXCEPT_(\n            __is_nothrow_swappable<value_compare>::value\n            && (!__node_traits::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<__node_allocator>::value)\n            )\n#else\n        _NOEXCEPT_(__is_nothrow_swappable<value_compare>::value)\n#endif\n{\n    using _VSTD::swap;\n    swap(__begin_node_, __t.__begin_node_);\n    swap(__pair1_.first(), __t.__pair1_.first());\n    __swap_allocator(__node_alloc(), __t.__node_alloc());\n    __pair3_.swap(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());\n    if (__t.size() == 0)\n        __t.__begin_node() = __t.__end_node();\n    else\n        __t.__end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__t.__end_node());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::clear() _NOEXCEPT\n{\n    destroy(__root());\n    size() = 0;\n    __begin_node() = __end_node();\n    __end_node()->__left_ = nullptr;\n}\n\n// Find lower_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(__parent_pointer& __parent,\n                                                   const key_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__parent_pointer>(__nd);\n                    return __nd->__right_;\n                }\n            }\n            else\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__parent_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__parent_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find upper_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(__parent_pointer& __parent,\n                                                    const key_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__parent_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__parent_pointer>(__nd);\n                    return __nd->__right_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__parent_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find leaf place to insert closest to __hint\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,\n                                               __parent_pointer& __parent,\n                                               const key_type& __v)\n{\n    if (__hint == end() || !value_comp()(*__hint, __v))  // check before\n    {\n        // __v <= *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || !value_comp()(__v, *--__prior))\n        {\n            // *prev(__hint) <= __v <= *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__parent_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__parent_pointer>(__prior.__ptr_);\n                return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;\n            }\n        }\n        // __v < *prev(__hint)\n        return __find_leaf_high(__parent, __v);\n    }\n    // else __v > *__hint\n    return __find_leaf_low(__parent, __v);\n}\n\n// Find place to insert if __v doesn't exist\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(__parent_pointer& __parent,\n                                                const _Key& __v)\n{\n    __node_pointer __nd = __root();\n    __node_base_pointer* __nd_ptr = __root_ptr();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr) {\n                    __nd_ptr = _VSTD::addressof(__nd->__left_);\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                } else {\n                    __parent = static_cast<__parent_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr) {\n                    __nd_ptr = _VSTD::addressof(__nd->__right_);\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                } else {\n                    __parent = static_cast<__parent_pointer>(__nd);\n                    return __nd->__right_;\n                }\n            }\n            else\n            {\n                __parent = static_cast<__parent_pointer>(__nd);\n                return *__nd_ptr;\n            }\n        }\n    }\n    __parent = static_cast<__parent_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find place to insert if __v doesn't exist\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,\n                                                __parent_pointer& __parent,\n                                                __node_base_pointer& __dummy,\n                                                const _Key& __v)\n{\n    if (__hint == end() || value_comp()(__v, *__hint))  // check before\n    {\n        // __v < *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || value_comp()(*--__prior, __v))\n        {\n            // *prev(__hint) < __v < *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__parent_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__parent_pointer>(__prior.__ptr_);\n                return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;\n            }\n        }\n        // __v <= *prev(__hint)\n        return __find_equal(__parent, __v);\n    }\n    else if (value_comp()(*__hint, __v))  // check after\n    {\n        // *__hint < __v\n        const_iterator __next = _VSTD::next(__hint);\n        if (__next == end() || value_comp()(__v, *__next))\n        {\n            // *__hint < __v < *_VSTD::next(__hint)\n            if (__hint.__get_np()->__right_ == nullptr)\n            {\n                __parent = static_cast<__parent_pointer>(__hint.__ptr_);\n                return static_cast<__node_base_pointer>(__hint.__ptr_)->__right_;\n            }\n            else\n            {\n                __parent = static_cast<__parent_pointer>(__next.__ptr_);\n                return __parent->__left_;\n            }\n        }\n        // *next(__hint) <= __v\n        return __find_equal(__parent, __v);\n    }\n    // else __v == *__hint\n    __parent = static_cast<__parent_pointer>(__hint.__ptr_);\n    __dummy = static_cast<__node_base_pointer>(__hint.__ptr_);\n    return __dummy;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid __tree<_Tp, _Compare, _Allocator>::__insert_node_at(\n    __parent_pointer __parent, __node_base_pointer& __child,\n    __node_base_pointer __new_node) _NOEXCEPT\n{\n    __new_node->__left_   = nullptr;\n    __new_node->__right_  = nullptr;\n    __new_node->__parent_ = __parent;\n    // __new_node->__is_black_ is initialized in __tree_balance_after_insert\n    __child = __new_node;\n    if (__begin_node()->__left_ != nullptr)\n        __begin_node() = static_cast<__iter_pointer>(__begin_node()->__left_);\n    __tree_balance_after_insert(__end_node()->__left_, __child);\n    ++size();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class... _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args)\n#else\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const& __k, _Args& __args)\n#endif\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n#ifndef _LIBCPP_CXX03_LANG\n        __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n#else\n        __node_holder __h = __construct_node(__args);\n#endif\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(\n    const_iterator __p, _Key const& __k, _Args&&... __args)\n#else\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(\n    const_iterator __p, _Key const& __k, _Args& __args)\n#endif\n{\n    __parent_pointer __parent;\n    __node_base_pointer __dummy;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n#ifndef _LIBCPP_CXX03_LANG\n        __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n#else\n        __node_holder __h = __construct_node(__args);\n#endif\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args&& ...__args)\n{\n    static_assert(!__is_tree_value_type<_Args...>::value,\n                  \"Cannot construct from __value_type\");\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__value_constructed = true;\n    return __h;\n}\n\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique_impl(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_impl(const_iterator __p, _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __parent_pointer __parent;\n    __node_base_pointer __dummy;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__h->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p,\n                                                        _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__h->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(const __container_value_type& __v)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    return _LIBCPP_EXPLICIT_MOVE(__h);  // explicitly moved for C++03\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#ifdef _LIBCPP_CXX03_LANG\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const __container_value_type& __v)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__v));\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const_iterator __p, const __container_value_type& __v)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__v));\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n#endif\n\ntemplate <class _Tp, class _Compare, class _Allocator>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(__node_pointer __nd)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(const_iterator __p,\n                                                        __node_pointer __nd)\n{\n    __parent_pointer __parent;\n    __node_base_pointer __dummy;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__nd->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,\n                                                       __node_pointer __nd)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__nd->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__remove_node_pointer(__node_pointer __ptr) _NOEXCEPT\n{\n    iterator __r(__ptr);\n    ++__r;\n    if (__begin_node() == __ptr)\n        __begin_node() = __r.__ptr_;\n    --size();\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__ptr));\n    return __r;\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _NodeHandle, class _InsertReturnType>\n_LIBCPP_INLINE_VISIBILITY\n_InsertReturnType\n__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_unique(\n    _NodeHandle&& __nh)\n{\n    if (__nh.empty())\n        return _InsertReturnType{end(), false, _NodeHandle()};\n\n    __node_pointer __ptr = __nh.__ptr_;\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent,\n                                                __ptr->__value_);\n    if (__child != nullptr)\n        return _InsertReturnType{\n            iterator(static_cast<__node_pointer>(__child)),\n            false, _VSTD::move(__nh)};\n\n    __insert_node_at(__parent, __child,\n                     static_cast<__node_base_pointer>(__ptr));\n    __nh.__release();\n    return _InsertReturnType{iterator(__ptr), true, _NodeHandle()};\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _NodeHandle>\n_LIBCPP_INLINE_VISIBILITY\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_unique(\n    const_iterator __hint, _NodeHandle&& __nh)\n{\n    if (__nh.empty())\n        return end();\n\n    __node_pointer __ptr = __nh.__ptr_;\n    __parent_pointer __parent;\n    __node_base_pointer __dummy;\n    __node_base_pointer& __child = __find_equal(__hint, __parent, __dummy,\n                                                __ptr->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child,\n                         static_cast<__node_base_pointer>(__ptr));\n        __r = __ptr;\n        __nh.__release();\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _NodeHandle>\n_LIBCPP_INLINE_VISIBILITY\n_NodeHandle\n__tree<_Tp, _Compare, _Allocator>::__node_handle_extract(key_type const& __key)\n{\n    iterator __it = find(__key);\n    if (__it == end())\n        return _NodeHandle();\n    return __node_handle_extract<_NodeHandle>(__it);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _NodeHandle>\n_LIBCPP_INLINE_VISIBILITY\n_NodeHandle\n__tree<_Tp, _Compare, _Allocator>::__node_handle_extract(const_iterator __p)\n{\n    __node_pointer __np = __p.__get_np();\n    __remove_node_pointer(__np);\n    return _NodeHandle(__np, __alloc());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Tree>\n_LIBCPP_INLINE_VISIBILITY\nvoid\n__tree<_Tp, _Compare, _Allocator>::__node_handle_merge_unique(_Tree& __source)\n{\n    static_assert(is_same<typename _Tree::__node_pointer, __node_pointer>::value, \"\");\n\n    for (typename _Tree::iterator __i = __source.begin();\n         __i != __source.end();)\n    {\n        __node_pointer __src_ptr = __i.__get_np();\n        __parent_pointer __parent;\n        __node_base_pointer& __child =\n            __find_equal(__parent, _NodeTypes::__get_key(__src_ptr->__value_));\n        ++__i;\n        if (__child != nullptr)\n            continue;\n        __source.__remove_node_pointer(__src_ptr);\n        __insert_node_at(__parent, __child,\n                         static_cast<__node_base_pointer>(__src_ptr));\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _NodeHandle>\n_LIBCPP_INLINE_VISIBILITY\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_multi(_NodeHandle&& __nh)\n{\n    if (__nh.empty())\n        return end();\n    __node_pointer __ptr = __nh.__ptr_;\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(\n        __parent, _NodeTypes::__get_key(__ptr->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__ptr));\n    __nh.__release();\n    return iterator(__ptr);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _NodeHandle>\n_LIBCPP_INLINE_VISIBILITY\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_multi(\n    const_iterator __hint, _NodeHandle&& __nh)\n{\n    if (__nh.empty())\n        return end();\n\n    __node_pointer __ptr = __nh.__ptr_;\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__hint, __parent,\n                                               _NodeTypes::__get_key(__ptr->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__ptr));\n    __nh.__release();\n    return iterator(__ptr);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Tree>\n_LIBCPP_INLINE_VISIBILITY\nvoid\n__tree<_Tp, _Compare, _Allocator>::__node_handle_merge_multi(_Tree& __source)\n{\n    static_assert(is_same<typename _Tree::__node_pointer, __node_pointer>::value, \"\");\n\n    for (typename _Tree::iterator __i = __source.begin();\n         __i != __source.end();)\n    {\n        __node_pointer __src_ptr = __i.__get_np();\n        __parent_pointer __parent;\n        __node_base_pointer& __child = __find_leaf_high(\n            __parent, _NodeTypes::__get_key(__src_ptr->__value_));\n        ++__i;\n        __source.__remove_node_pointer(__src_ptr);\n        __insert_node_at(__parent, __child,\n                         static_cast<__node_base_pointer>(__src_ptr));\n    }\n}\n\n#endif  // _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p)\n{\n    __node_pointer __np = __p.__get_np();\n    iterator __r = __remove_node_pointer(__np);\n    __node_allocator& __na = __node_alloc();\n    __node_traits::destroy(__na, _NodeTypes::__get_ptr(\n        const_cast<__node_value_type&>(*__p)));\n    __node_traits::deallocate(__na, __np, 1);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l)\n{\n    while (__f != __l)\n        __f = erase(__f);\n    return iterator(__l.__ptr_);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key& __k)\n{\n    iterator __i = find(__k);\n    if (__i == end())\n        return 0;\n    erase(__i);\n    return 1;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key& __k)\n{\n    pair<iterator, iterator> __p = __equal_range_multi(__k);\n    size_type __r = 0;\n    for (; __p.first != __p.second; ++__r)\n        __p.first = erase(__p.first);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v)\n{\n    iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const\n{\n    const_iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const\n{\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const\n{\n    __iter_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__rt);\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _VSTD::distance(\n                __lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),\n                __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result)\n            );\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __iter_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = static_cast<__iter_pointer>(__root);\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __iter_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = static_cast<__iter_pointer>(__root);\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __iter_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__root);\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __iter_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__root);\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __iter_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__rt);\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(iterator(__rt),\n                      iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__iter_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __iter_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__rt);\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(const_iterator(__rt),\n                      const_iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__iter_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __iter_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__rt);\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),\n                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __iter_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__rt);\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),\n                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) _NOEXCEPT\n{\n    __node_pointer __np = __p.__get_np();\n    if (__begin_node() == __p.__ptr_)\n    {\n        if (__np->__right_ != nullptr)\n            __begin_node() = static_cast<__iter_pointer>(__np->__right_);\n        else\n            __begin_node() = static_cast<__iter_pointer>(__np->__parent_);\n    }\n    --size();\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    return __node_holder(__np, _Dp(__node_alloc(), true));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__tree<_Tp, _Compare, _Allocator>& __x,\n     __tree<_Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP___TREE\n","// -*- C++ -*-\n//===------------------------ string_view ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING_VIEW\n#define _LIBCPP_STRING_VIEW\n\n/*\nstring_view synopsis\n\nnamespace std {\n\n    // 7.2, Class template basic_string_view\n    template<class charT, class traits = char_traits<charT>>\n        class basic_string_view;\n\n    // 7.9, basic_string_view non-member comparison functions\n    template<class charT, class traits>\n    constexpr bool operator==(basic_string_view<charT, traits> x,\n                              basic_string_view<charT, traits> y) noexcept;\n    template<class charT, class traits>\n    constexpr bool operator!=(basic_string_view<charT, traits> x,\n                              basic_string_view<charT, traits> y) noexcept;\n    template<class charT, class traits>\n    constexpr bool operator< (basic_string_view<charT, traits> x,\n                                 basic_string_view<charT, traits> y) noexcept;\n    template<class charT, class traits>\n    constexpr bool operator> (basic_string_view<charT, traits> x,\n                              basic_string_view<charT, traits> y) noexcept;\n    template<class charT, class traits>\n    constexpr bool operator<=(basic_string_view<charT, traits> x,\n                                 basic_string_view<charT, traits> y) noexcept;\n    template<class charT, class traits>\n    constexpr bool operator>=(basic_string_view<charT, traits> x,\n                              basic_string_view<charT, traits> y) noexcept;\n    // see below, sufficient additional overloads of comparison functions\n\n    // 7.10, Inserters and extractors\n    template<class charT, class traits>\n      basic_ostream<charT, traits>&\n        operator<<(basic_ostream<charT, traits>& os,\n                   basic_string_view<charT, traits> str);\n\n    // basic_string_view typedef names\n    typedef basic_string_view<char> string_view;\n    typedef basic_string_view<char16_t> u16string_view;\n    typedef basic_string_view<char32_t> u32string_view;\n    typedef basic_string_view<wchar_t> wstring_view;\n\n    template<class charT, class traits = char_traits<charT>>\n    class basic_string_view {\n      public:\n      // types\n      typedef traits traits_type;\n      typedef charT value_type;\n      typedef charT* pointer;\n      typedef const charT* const_pointer;\n      typedef charT& reference;\n      typedef const charT& const_reference;\n      typedef implementation-defined const_iterator;\n      typedef const_iterator iterator;\n      typedef reverse_iterator<const_iterator> const_reverse_iterator;\n      typedef const_reverse_iterator reverse_iterator;\n      typedef size_t size_type;\n      typedef ptrdiff_t difference_type;\n      static constexpr size_type npos = size_type(-1);\n\n      // 7.3, basic_string_view constructors and assignment operators\n      constexpr basic_string_view() noexcept;\n      constexpr basic_string_view(const basic_string_view&) noexcept = default;\n      basic_string_view& operator=(const basic_string_view&) noexcept = default;\n      template<class Allocator>\n      constexpr basic_string_view(const charT* str);\n      constexpr basic_string_view(const charT* str, size_type len);\n\n      // 7.4, basic_string_view iterator support\n      constexpr const_iterator begin() const noexcept;\n      constexpr const_iterator end() const noexcept;\n      constexpr const_iterator cbegin() const noexcept;\n      constexpr const_iterator cend() const noexcept;\n      const_reverse_iterator rbegin() const noexcept;\n      const_reverse_iterator rend() const noexcept;\n      const_reverse_iterator crbegin() const noexcept;\n      const_reverse_iterator crend() const noexcept;\n\n      // 7.5, basic_string_view capacity\n      constexpr size_type size() const noexcept;\n      constexpr size_type length() const noexcept;\n      constexpr size_type max_size() const noexcept;\n      constexpr bool empty() const noexcept;\n\n      // 7.6, basic_string_view element access\n      constexpr const_reference operator[](size_type pos) const;\n      constexpr const_reference at(size_type pos) const;\n      constexpr const_reference front() const;\n      constexpr const_reference back() const;\n      constexpr const_pointer data() const noexcept;\n\n      // 7.7, basic_string_view modifiers\n      constexpr void remove_prefix(size_type n);\n      constexpr void remove_suffix(size_type n);\n      constexpr void swap(basic_string_view& s) noexcept;\n\n      size_type copy(charT* s, size_type n, size_type pos = 0) const;\n\n      constexpr basic_string_view substr(size_type pos = 0, size_type n = npos) const;\n      constexpr int compare(basic_string_view s) const noexcept;\n      constexpr int compare(size_type pos1, size_type n1, basic_string_view s) const;\n      constexpr int compare(size_type pos1, size_type n1,\n                            basic_string_view s, size_type pos2, size_type n2) const;\n      constexpr int compare(const charT* s) const;\n      constexpr int compare(size_type pos1, size_type n1, const charT* s) const;\n      constexpr int compare(size_type pos1, size_type n1,\n                            const charT* s, size_type n2) const;\n      constexpr size_type find(basic_string_view s, size_type pos = 0) const noexcept;\n      constexpr size_type find(charT c, size_type pos = 0) const noexcept;\n      constexpr size_type find(const charT* s, size_type pos, size_type n) const;\n      constexpr size_type find(const charT* s, size_type pos = 0) const;\n      constexpr size_type rfind(basic_string_view s, size_type pos = npos) const noexcept;\n      constexpr size_type rfind(charT c, size_type pos = npos) const noexcept;\n      constexpr size_type rfind(const charT* s, size_type pos, size_type n) const;\n      constexpr size_type rfind(const charT* s, size_type pos = npos) const;\n      constexpr size_type find_first_of(basic_string_view s, size_type pos = 0) const noexcept;\n      constexpr size_type find_first_of(charT c, size_type pos = 0) const noexcept;\n      constexpr size_type find_first_of(const charT* s, size_type pos, size_type n) const;\n      constexpr size_type find_first_of(const charT* s, size_type pos = 0) const;\n      constexpr size_type find_last_of(basic_string_view s, size_type pos = npos) const noexcept;\n      constexpr size_type find_last_of(charT c, size_type pos = npos) const noexcept;\n      constexpr size_type find_last_of(const charT* s, size_type pos, size_type n) const;\n      constexpr size_type find_last_of(const charT* s, size_type pos = npos) const;\n      constexpr size_type find_first_not_of(basic_string_view s, size_type pos = 0) const noexcept;\n      constexpr size_type find_first_not_of(charT c, size_type pos = 0) const noexcept;\n      constexpr size_type find_first_not_of(const charT* s, size_type pos, size_type n) const;\n      constexpr size_type find_first_not_of(const charT* s, size_type pos = 0) const;\n      constexpr size_type find_last_not_of(basic_string_view s, size_type pos = npos) const noexcept;\n      constexpr size_type find_last_not_of(charT c, size_type pos = npos) const noexcept;\n      constexpr size_type find_last_not_of(const charT* s, size_type pos, size_type n) const;\n      constexpr size_type find_last_not_of(const charT* s, size_type pos = npos) const;\n\n      constexpr bool starts_with(basic_string_view s) const noexcept; // C++2a\n      constexpr bool starts_with(charT c) const noexcept;             // C++2a\n      constexpr bool starts_with(const charT* s) const;               // C++2a\n      constexpr bool ends_with(basic_string_view s) const noexcept;   // C++2a\n      constexpr bool ends_with(charT c) const noexcept;               // C++2a\n      constexpr bool ends_with(const charT* s) const;                 // C++2a\n\n     private:\n      const_pointer data_;  // exposition only\n      size_type     size_;  // exposition only\n    };\n\n  // 7.11, Hash support\n  template <class T> struct hash;\n  template <> struct hash<string_view>;\n  template <> struct hash<u16string_view>;\n  template <> struct hash<u32string_view>;\n  template <> struct hash<wstring_view>;\n\n  constexpr basic_string_view<char>     operator \"\" sv( const char *str,     size_t len ) noexcept;\n  constexpr basic_string_view<wchar_t>  operator \"\" sv( const wchar_t *str,  size_t len ) noexcept;\n  constexpr basic_string_view<char16_t> operator \"\" sv( const char16_t *str, size_t len ) noexcept;\n  constexpr basic_string_view<char32_t> operator \"\" sv( const char32_t *str, size_t len ) noexcept;\n\n}  // namespace std\n\n\n*/\n\n#include <__config>\n#include <__string>\n#include <algorithm>\n#include <iterator>\n#include <limits>\n#include <stdexcept>\n#include <version>\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate<class _CharT, class _Traits = char_traits<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS basic_string_view {\npublic:\n    // types\n    typedef _Traits                                    traits_type;\n    typedef _CharT                                     value_type;\n    typedef _CharT*                                    pointer;\n    typedef const _CharT*                              const_pointer;\n    typedef _CharT&                                    reference;\n    typedef const _CharT&                              const_reference;\n    typedef const_pointer                              const_iterator; // See [string.view.iterators]\n    typedef const_iterator                             iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>    const_reverse_iterator;\n    typedef const_reverse_iterator                     reverse_iterator;\n    typedef size_t                                     size_type;\n    typedef ptrdiff_t                                  difference_type;\n    static _LIBCPP_CONSTEXPR const size_type npos = -1; // size_type(-1);\n\n    static_assert((!is_array<value_type>::value), \"Character type of basic_string_view must not be an array\");\n    static_assert(( is_standard_layout<value_type>::value), \"Character type of basic_string_view must be standard-layout\");\n    static_assert(( is_trivial<value_type>::value), \"Character type of basic_string_view must be trivial\");\n    static_assert((is_same<_CharT, typename traits_type::char_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n\n    // [string.view.cons], construct/copy\n    _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n    basic_string_view() _NOEXCEPT : __data (nullptr), __size(0) {}\n\n    _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n    basic_string_view(const basic_string_view&) _NOEXCEPT = default;\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    basic_string_view& operator=(const basic_string_view&) _NOEXCEPT = default;\n\n    _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n    basic_string_view(const _CharT* __s, size_type __len) _NOEXCEPT\n        : __data(__s), __size(__len)\n    {\n// #if _LIBCPP_STD_VER > 11\n//         _LIBCPP_ASSERT(__len == 0 || __s != nullptr, \"string_view::string_view(_CharT *, size_t): received nullptr\");\n// #endif\n    }\n\n    _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n    basic_string_view(const _CharT* __s)\n        : __data(__s), __size(_Traits::length(__s)) {}\n\n    // [string.view.iterators], iterators\n    _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT { return cbegin(); }\n\n    _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT { return cend(); }\n\n    _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT { return __data; }\n\n    _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT { return __data + __size; }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX14 _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()   const _NOEXCEPT { return const_reverse_iterator(cend()); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX14 _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()     const _NOEXCEPT { return const_reverse_iterator(cbegin()); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX14 _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin()  const _NOEXCEPT { return const_reverse_iterator(cend()); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX14 _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()    const _NOEXCEPT { return const_reverse_iterator(cbegin()); }\n\n    // [string.view.capacity], capacity\n    _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n    size_type size()     const _NOEXCEPT { return __size; }\n\n    _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n    size_type length()   const _NOEXCEPT { return __size; }\n\n    _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT { return numeric_limits<size_type>::max(); }\n\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    bool empty()         const _NOEXCEPT { return __size == 0; }\n\n    // [string.view.access], element access\n    _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n    const_reference operator[](size_type __pos) const _NOEXCEPT { return __data[__pos]; }\n\n    _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n    const_reference at(size_type __pos) const\n    {\n        return __pos >= size()\n            ? (__throw_out_of_range(\"string_view::at\"), __data[0])\n            : __data[__pos];\n    }\n\n    _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n    const_reference front() const\n    {\n        return _LIBCPP_ASSERT(!empty(), \"string_view::front(): string is empty\"), __data[0];\n    }\n\n    _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n    const_reference back() const\n    {\n        return _LIBCPP_ASSERT(!empty(), \"string_view::back(): string is empty\"), __data[__size-1];\n    }\n\n    _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n    const_pointer data() const _NOEXCEPT { return __data; }\n\n    // [string.view.modifiers], modifiers:\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    void remove_prefix(size_type __n) _NOEXCEPT\n    {\n        _LIBCPP_ASSERT(__n <= size(), \"remove_prefix() can't remove more than size()\");\n        __data += __n;\n        __size -= __n;\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    void remove_suffix(size_type __n) _NOEXCEPT\n    {\n        _LIBCPP_ASSERT(__n <= size(), \"remove_suffix() can't remove more than size()\");\n        __size -= __n;\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string_view& __other) _NOEXCEPT\n    {\n        const value_type *__p = __data;\n        __data = __other.__data;\n        __other.__data = __p;\n\n        size_type __sz = __size;\n        __size = __other.__size;\n        __other.__size = __sz;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type copy(_CharT* __s, size_type __n, size_type __pos = 0) const\n    {\n        if (__pos > size())\n            __throw_out_of_range(\"string_view::copy\");\n        size_type __rlen = _VSTD::min(__n, size() - __pos);\n        _Traits::copy(__s, data() + __pos, __rlen);\n        return __rlen;\n    }\n\n    _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n    basic_string_view substr(size_type __pos = 0, size_type __n = npos) const\n    {\n        return __pos > size()\n            ? (__throw_out_of_range(\"string_view::substr\"), basic_string_view())\n            : basic_string_view(data() + __pos, _VSTD::min(__n, size() - __pos));\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 int compare(basic_string_view __sv) const _NOEXCEPT\n    {\n        size_type __rlen = _VSTD::min( size(), __sv.size());\n        int __retval = _Traits::compare(data(), __sv.data(), __rlen);\n        if ( __retval == 0 ) // first __rlen chars matched\n            __retval = size() == __sv.size() ? 0 : ( size() < __sv.size() ? -1 : 1 );\n        return __retval;\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, basic_string_view __sv) const\n    {\n        return substr(__pos1, __n1).compare(__sv);\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    int compare(                       size_type __pos1, size_type __n1, \n                basic_string_view __sv, size_type __pos2, size_type __n2) const\n    {\n        return substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    int compare(const _CharT* __s) const _NOEXCEPT\n    {\n        return compare(basic_string_view(__s));\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const _CharT* __s) const\n    {\n        return substr(__pos1, __n1).compare(basic_string_view(__s));\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const _CharT* __s, size_type __n2) const\n    {\n        return substr(__pos1, __n1).compare(basic_string_view(__s, __n2));\n    }\n\n    // find\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find(basic_string_view __s, size_type __pos = 0) const _NOEXCEPT\n    {\n        _LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, \"string_view::find(): received nullptr\");\n        return __str_find<value_type, size_type, traits_type, npos>\n            (data(), size(), __s.data(), __pos, __s.size());\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find(_CharT __c, size_type __pos = 0) const _NOEXCEPT\n    {\n        return __str_find<value_type, size_type, traits_type, npos>\n            (data(), size(), __c, __pos);\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find(const _CharT* __s, size_type __pos, size_type __n) const\n    {\n        _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string_view::find(): received nullptr\");\n        return __str_find<value_type, size_type, traits_type, npos>\n            (data(), size(), __s, __pos, __n);\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find(const _CharT* __s, size_type __pos = 0) const\n    {\n        _LIBCPP_ASSERT(__s != nullptr, \"string_view::find(): received nullptr\");\n        return __str_find<value_type, size_type, traits_type, npos>\n            (data(), size(), __s, __pos, traits_type::length(__s));\n    }\n\n    // rfind\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(basic_string_view __s, size_type __pos = npos) const _NOEXCEPT\n    {\n        _LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, \"string_view::find(): received nullptr\");\n        return __str_rfind<value_type, size_type, traits_type, npos>\n            (data(), size(), __s.data(), __pos, __s.size());\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(_CharT __c, size_type __pos = npos) const _NOEXCEPT\n    {\n        return __str_rfind<value_type, size_type, traits_type, npos>\n            (data(), size(), __c, __pos);\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const _CharT* __s, size_type __pos, size_type __n) const\n    {\n        _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string_view::rfind(): received nullptr\");\n        return __str_rfind<value_type, size_type, traits_type, npos>\n            (data(), size(), __s, __pos, __n);\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const _CharT* __s, size_type __pos=npos) const\n    {\n        _LIBCPP_ASSERT(__s != nullptr, \"string_view::rfind(): received nullptr\");\n        return __str_rfind<value_type, size_type, traits_type, npos>\n            (data(), size(), __s, __pos, traits_type::length(__s));\n    }\n\n    // find_first_of\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(basic_string_view __s, size_type __pos = 0) const _NOEXCEPT\n    {\n        _LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, \"string_view::find_first_of(): received nullptr\");\n        return __str_find_first_of<value_type, size_type, traits_type, npos>\n            (data(), size(), __s.data(), __pos, __s.size());\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(_CharT __c, size_type __pos = 0) const _NOEXCEPT\n    { return find(__c, __pos); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const _CharT* __s, size_type __pos, size_type __n) const\n    {\n        _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string_view::find_first_of(): received nullptr\");\n        return __str_find_first_of<value_type, size_type, traits_type, npos>\n            (data(), size(), __s, __pos, __n);\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const _CharT* __s, size_type __pos=0) const\n    {\n        _LIBCPP_ASSERT(__s != nullptr, \"string_view::find_first_of(): received nullptr\");\n        return __str_find_first_of<value_type, size_type, traits_type, npos>\n            (data(), size(), __s, __pos, traits_type::length(__s));\n    }\n\n    // find_last_of\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(basic_string_view __s, size_type __pos=npos) const _NOEXCEPT\n    {\n        _LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, \"string_view::find_last_of(): received nullptr\");\n        return __str_find_last_of<value_type, size_type, traits_type, npos>\n            (data(), size(), __s.data(), __pos, __s.size());\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(_CharT __c, size_type __pos = npos) const _NOEXCEPT\n    { return rfind(__c, __pos); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const _CharT* __s, size_type __pos, size_type __n) const\n    {\n        _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string_view::find_last_of(): received nullptr\");\n        return __str_find_last_of<value_type, size_type, traits_type, npos>\n            (data(), size(), __s, __pos, __n);\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const _CharT* __s, size_type __pos=npos) const\n    {\n        _LIBCPP_ASSERT(__s != nullptr, \"string_view::find_last_of(): received nullptr\");\n        return __str_find_last_of<value_type, size_type, traits_type, npos>\n            (data(), size(), __s, __pos, traits_type::length(__s));\n    }\n\n    // find_first_not_of\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(basic_string_view __s, size_type __pos=0) const _NOEXCEPT\n    {\n        _LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, \"string_view::find_first_not_of(): received nullptr\");\n        return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n            (data(), size(), __s.data(), __pos, __s.size());\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(_CharT __c, size_type __pos=0) const _NOEXCEPT\n    {\n        return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n            (data(), size(), __c, __pos);\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const\n    {\n        _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string_view::find_first_not_of(): received nullptr\");\n        return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n            (data(), size(), __s, __pos, __n);\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const _CharT* __s, size_type __pos=0) const\n    {\n        _LIBCPP_ASSERT(__s != nullptr, \"string_view::find_first_not_of(): received nullptr\");\n        return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n            (data(), size(), __s, __pos, traits_type::length(__s));\n    }\n\n    // find_last_not_of\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(basic_string_view __s, size_type __pos=npos) const _NOEXCEPT\n    {\n        _LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, \"string_view::find_last_not_of(): received nullptr\");\n        return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n            (data(), size(), __s.data(), __pos, __s.size());\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(_CharT __c, size_type __pos=npos) const _NOEXCEPT\n    {\n        return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n            (data(), size(), __c, __pos);\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const\n    {\n        _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string_view::find_last_not_of(): received nullptr\");\n        return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n            (data(), size(), __s, __pos, __n);\n    }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const _CharT* __s, size_type __pos=npos) const\n    {\n        _LIBCPP_ASSERT(__s != nullptr, \"string_view::find_last_not_of(): received nullptr\");\n        return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n            (data(), size(), __s, __pos, traits_type::length(__s));\n    }\n\n#if _LIBCPP_STD_VER > 17\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool starts_with(basic_string_view __s) const _NOEXCEPT\n    { return size() >= __s.size() && compare(0, __s.size(), __s) == 0; }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool starts_with(value_type __c) const _NOEXCEPT\n    { return !empty() && _Traits::eq(front(), __c); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool starts_with(const value_type* __s) const _NOEXCEPT\n    { return starts_with(basic_string_view(__s)); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool ends_with(basic_string_view __s) const _NOEXCEPT\n    { return size() >= __s.size() && compare(size() - __s.size(), npos, __s) == 0; }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool ends_with(value_type __c) const _NOEXCEPT\n    { return !empty() && _Traits::eq(back(), __c); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool ends_with(const value_type* __s) const _NOEXCEPT\n    { return ends_with(basic_string_view(__s)); }\n#endif\n\nprivate:\n    const   value_type* __data;\n    size_type           __size;\n};\n\n\n// [string.view.comparison]\n// operator ==\ntemplate<class _CharT, class _Traits>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbool operator==(basic_string_view<_CharT, _Traits> __lhs,\n                basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT\n{\n    if ( __lhs.size() != __rhs.size()) return false;\n    return __lhs.compare(__rhs) == 0;\n}\n\ntemplate<class _CharT, class _Traits>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbool operator==(basic_string_view<_CharT, _Traits> __lhs,\n                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) _NOEXCEPT\n{\n    if ( __lhs.size() != __rhs.size()) return false;\n    return __lhs.compare(__rhs) == 0;\n}\n\ntemplate<class _CharT, class _Traits>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbool operator==(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs, \n                basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT\n{\n    if ( __lhs.size() != __rhs.size()) return false;\n    return __lhs.compare(__rhs) == 0;\n}\n\n\n// operator !=\ntemplate<class _CharT, class _Traits>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbool operator!=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT\n{\n    if ( __lhs.size() != __rhs.size())\n        return true;\n    return __lhs.compare(__rhs) != 0;\n}\n\ntemplate<class _CharT, class _Traits>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbool operator!=(basic_string_view<_CharT, _Traits> __lhs,\n                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) _NOEXCEPT\n{\n    if ( __lhs.size() != __rhs.size())\n        return true;\n    return __lhs.compare(__rhs) != 0;\n}\n\ntemplate<class _CharT, class _Traits>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbool operator!=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs, \n                basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT\n{\n    if ( __lhs.size() != __rhs.size())\n        return true;\n    return __lhs.compare(__rhs) != 0;\n}\n\n\n// operator <\ntemplate<class _CharT, class _Traits>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbool operator<(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbool operator<(basic_string_view<_CharT, _Traits> __lhs,\n                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbool operator<(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs, \n                basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\n\n// operator >\ntemplate<class _CharT, class _Traits>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbool operator> (basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) > 0;\n}\n\ntemplate<class _CharT, class _Traits>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbool operator>(basic_string_view<_CharT, _Traits> __lhs,\n                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) > 0;\n}\n\ntemplate<class _CharT, class _Traits>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbool operator>(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs, \n                basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) > 0;\n}\n\n\n// operator <=\ntemplate<class _CharT, class _Traits>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbool operator<=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) <= 0;\n}\n\ntemplate<class _CharT, class _Traits>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbool operator<=(basic_string_view<_CharT, _Traits> __lhs,\n                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) <= 0;\n}\n\ntemplate<class _CharT, class _Traits>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbool operator<=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs, \n                basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) <= 0;\n}\n\n\n// operator >=\ntemplate<class _CharT, class _Traits>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbool operator>=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) >= 0;\n}\n\n\ntemplate<class _CharT, class _Traits>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbool operator>=(basic_string_view<_CharT, _Traits> __lhs,\n                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) >= 0;\n}\n\ntemplate<class _CharT, class _Traits>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbool operator>=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs, \n                basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) >= 0;\n}\n\ntypedef basic_string_view<char>     string_view;\n#ifndef _LIBCPP_NO_HAS_CHAR8_T\ntypedef basic_string_view<char8_t>  u8string_view;\n#endif\ntypedef basic_string_view<char16_t> u16string_view;\ntypedef basic_string_view<char32_t> u32string_view;\ntypedef basic_string_view<wchar_t>  wstring_view;\n\n// [string.view.hash]\ntemplate<class _CharT, class _Traits>\nstruct _LIBCPP_TEMPLATE_VIS hash<basic_string_view<_CharT, _Traits> >\n    : public unary_function<basic_string_view<_CharT, _Traits>, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const basic_string_view<_CharT, _Traits> __val) const _NOEXCEPT {\n        return __do_string_hash(__val.data(), __val.data() + __val.size());\n    }\n};\n\n\n#if _LIBCPP_STD_VER > 11 \ninline namespace literals\n{\n  inline namespace string_view_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    basic_string_view<char> operator \"\" sv(const char *__str, size_t __len) _NOEXCEPT\n    {\n        return basic_string_view<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    basic_string_view<wchar_t> operator \"\" sv(const wchar_t *__str, size_t __len) _NOEXCEPT\n    {\n        return basic_string_view<wchar_t> (__str, __len);\n    }\n\n#ifndef _LIBCPP_NO_HAS_CHAR8_T\n    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    basic_string_view<char8_t> operator \"\" sv(const char8_t *__str, size_t __len) _NOEXCEPT\n    {\n        return basic_string_view<char8_t> (__str, __len);\n    }\n#endif\n\n    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    basic_string_view<char16_t> operator \"\" sv(const char16_t *__str, size_t __len) _NOEXCEPT\n    {\n        return basic_string_view<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    basic_string_view<char32_t> operator \"\" sv(const char32_t *__str, size_t __len) _NOEXCEPT\n    {\n        return basic_string_view<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif // _LIBCPP_STRING_VIEW\n","// -*- C++ -*-\n//===-------------------------- ostream -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_OSTREAM\n#define _LIBCPP_OSTREAM\n\n/*\n    ostream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ostream\n    : virtual public basic_ios<charT,traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    explicit basic_ostream(basic_streambuf<char_type,traits>* sb);\n    basic_ostream(basic_ostream&& rhs);\n    virtual ~basic_ostream();\n\n    // 27.7.2.3 Assign/swap\n    basic_ostream& operator=(const basic_ostream& rhs) = delete; // C++14\n    basic_ostream& operator=(basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n\n    // 27.7.2.4 Prefix/suffix:\n    class sentry;\n\n    // 27.7.2.6 Formatted output:\n    basic_ostream& operator<<(basic_ostream& (*pf)(basic_ostream&));\n    basic_ostream& operator<<(basic_ios<charT, traits>& (*pf)(basic_ios<charT,traits>&));\n    basic_ostream& operator<<(ios_base& (*pf)(ios_base&));\n    basic_ostream& operator<<(bool n);\n    basic_ostream& operator<<(short n);\n    basic_ostream& operator<<(unsigned short n);\n    basic_ostream& operator<<(int n);\n    basic_ostream& operator<<(unsigned int n);\n    basic_ostream& operator<<(long n);\n    basic_ostream& operator<<(unsigned long n);\n    basic_ostream& operator<<(long long n);\n    basic_ostream& operator<<(unsigned long long n);\n    basic_ostream& operator<<(float f);\n    basic_ostream& operator<<(double f);\n    basic_ostream& operator<<(long double f);\n    basic_ostream& operator<<(const void* p);\n    basic_ostream& operator<<(basic_streambuf<char_type,traits>* sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type c);\n    basic_ostream& write(const char_type* s, streamsize n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    pos_type tellp();\n    basic_ostream& seekp(pos_type);\n    basic_ostream& seekp(off_type, ios_base::seekdir);\nprotected:\n    basic_ostream(const basic_ostream& rhs) = delete;\n    basic_ostream(basic_ostream&& rhs);\n    // 27.7.3.3 Assign/swap\n    basic_ostream& operator=(basic_ostream& rhs) = delete;\n    basic_ostream& operator=(const basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n};\n\n// 27.7.2.6.4 character inserters\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, charT);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, char);\n\n// signed and unsigned\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, signed char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, unsigned char);\n\n// NTBS\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const charT*);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const char*);\n\n// signed and unsigned\ntemplate<class traits>\nbasic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const signed char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const unsigned char*);\n\n// swap:\ntemplate <class charT, class traits>\n  void swap(basic_ostream<charT, traits>& x, basic_ostream<charT, traits>& y);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);\n\n// rvalue stream insertion\ntemplate <class charT, class traits, class T>\n  basic_ostream<charT, traits>&\n  operator<<(basic_ostream<charT, traits>&& os, const T& x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ios>\n#include <streambuf>\n#include <locale>\n#include <iterator>\n#include <bitset>\n#include <version>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ostream\n    : virtual public basic_ios<_CharT, _Traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb)\n    { this->init(__sb); }\n    virtual ~basic_ostream();\nprotected:\n#ifndef _LIBCPP_CXX03_LANG\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_ostream(basic_ostream&& __rhs);\n\n    // 27.7.2.3 Assign/swap\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_ostream& operator=(basic_ostream&& __rhs);\n#endif\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    void swap(basic_ostream& __rhs)\n    { basic_ios<char_type, traits_type>::swap(__rhs); }\n\n#ifndef _LIBCPP_CXX03_LANG\n    basic_ostream           (const basic_ostream& __rhs) = delete;\n    basic_ostream& operator=(const basic_ostream& __rhs) = delete;\n#else\n    basic_ostream           (const basic_ostream& __rhs); // not defined\n    basic_ostream& operator=(const basic_ostream& __rhs); // not defined\n#endif\npublic:\n\n    // 27.7.2.4 Prefix/suffix:\n    class _LIBCPP_TEMPLATE_VIS sentry;\n\n    // 27.7.2.6 Formatted output:\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&))\n    { return __pf(*this); }\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    basic_ostream& operator<<(basic_ios<char_type, traits_type>&\n                              (*__pf)(basic_ios<char_type,traits_type>&))\n    { __pf(*this); return *this; }\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&))\n    { __pf(*this); return *this; }\n\n    basic_ostream& operator<<(bool __n);\n    basic_ostream& operator<<(short __n);\n    basic_ostream& operator<<(unsigned short __n);\n    basic_ostream& operator<<(int __n);\n    basic_ostream& operator<<(unsigned int __n);\n    basic_ostream& operator<<(long __n);\n    basic_ostream& operator<<(unsigned long __n);\n    basic_ostream& operator<<(long long __n);\n    basic_ostream& operator<<(unsigned long long __n);\n    basic_ostream& operator<<(float __f);\n    basic_ostream& operator<<(double __f);\n    basic_ostream& operator<<(long double __f);\n    basic_ostream& operator<<(const void* __p);\n    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type __c);\n    basic_ostream& write(const char_type* __s, streamsize __n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    pos_type tellp();\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    basic_ostream& seekp(pos_type __pos);\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream() {}  // extension, intentially does not initialize\n};\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ostream<_CharT, _Traits>::sentry\n{\n    bool __ok_;\n    basic_ostream<_CharT, _Traits>& __os_;\n\n    sentry(const sentry&); // = delete;\n    sentry& operator=(const sentry&); // = delete;\n\npublic:\n    explicit sentry(basic_ostream<_CharT, _Traits>& __os);\n    ~sentry();\n\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT\n        operator bool() const {return __ok_;}\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)\n    : __ok_(false),\n      __os_(__os)\n{\n    if (__os.good())\n    {\n        if (__os.tie())\n            __os.tie()->flush();\n        __ok_ = true;\n    }\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::~sentry()\n{\n    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)\n                      && !uncaught_exception())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__os_.rdbuf()->pubsync() == -1)\n                __os_.setstate(ios_base::badbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs)\n{\n    this->move(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::~basic_ostream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            if (__sb)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n                    _Ip __i(__sb);\n                    _Ip __eof;\n                    _Op __o(*this);\n                    size_t __c = 0;\n                    for (; __i != __eof; ++__i, ++__o, ++__c)\n                    {\n                        *__o = *__i;\n                        if (__o.failed())\n                            break;\n                    }\n                    if (__c == 0)\n                        this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    this->__set_failbit_and_consider_rethrow();\n                }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            else\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(bool __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned short>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned int>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(float __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(const void* __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\n__put_character_sequence(basic_ostream<_CharT, _Traits>& __os,\n                          const _CharT* __str, size_t __len)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 __str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __str + __len :\n                                     __str,\n                                 __str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)\n{\n    return _VSTD::__put_character_sequence(__os, &__c, 1);\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            _CharT __c = __os.widen(__cn);\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 &__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     &__c + 1 :\n                                     &__c,\n                                 &__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, char __c)\n{\n    return _VSTD::__put_character_sequence(__os, &__c, 1);\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, signed char __c)\n{\n    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)\n{\n    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            size_t __len = char_traits<char>::length(__strn);\n            const int __bs = 100;\n            _CharT __wbb[__bs];\n            _CharT* __wb = __wbb;\n            unique_ptr<_CharT, void(*)(void*)> __h(0, free);\n            if (__len > __bs)\n            {\n                __wb = (_CharT*)malloc(__len*sizeof(_CharT));\n                if (__wb == 0)\n                    __throw_bad_alloc();\n                __h.reset(__wb);\n            }\n            for (_CharT* __p = __wb; *__strn != '\\0'; ++__strn, ++__p)\n                *__p = __os.widen(*__strn);\n            if (__pad_and_output(_Ip(__os),\n                                 __wb,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __wb + __len :\n                                     __wb,\n                                 __wb + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const char* __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)\n{\n    const char *__s = (const char *) __str;\n    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)\n{\n    const char *__s = (const char *) __str;\n    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::put(char_type __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            _Op __o(*this);\n            *__o = __c;\n            if (__o.failed())\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this);\n        if (__sen && __n)\n        {\n            if (this->rdbuf()->sputn(__s, __n) != __n)\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::flush()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (this->rdbuf())\n        {\n            sentry __s(*this);\n            if (__s)\n            {\n                if (this->rdbuf()->pubsync() == -1)\n                    this->setstate(ios_base::badbit);\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_ostream<_CharT, _Traits>::pos_type\nbasic_ostream<_CharT, _Traits>::tellp()\n{\n    if (this->fail())\n        return pos_type(-1);\n    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(pos_type __pos)\n{\n    sentry __s(*this);\n    if (!this->fail())\n    {\n        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)\n{\n    sentry __s(*this);\n    if (!this->fail())\n    {\n        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nendl(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(__os.widen('\\n'));\n    __os.flush();\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nends(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(_CharT());\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nflush(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.flush();\n    return __os;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Stream, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_lvalue_reference<_Stream>::value &&\n    is_base_of<ios_base, _Stream>::value,\n    _Stream&&\n>::type\noperator<<(_Stream&& __os, const _Tp& __x)\n{\n    __os << __x;\n    return _VSTD::move(__os);\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str.data(), __str.size());\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string_view<_CharT, _Traits> __sv)\n{\n    return _VSTD::__put_character_sequence(__os, __sv.data(), __sv.size());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)\n{\n    return __os << __ec.category().name() << ':' << __ec.value();\n}\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)\n{\n    return __os << __p.get();\n}\n\ntemplate<class _CharT, class _Traits, class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<void, typename __void_t<decltype((declval<basic_ostream<_CharT, _Traits>&>() << declval<typename unique_ptr<_Yp, _Dp>::pointer>()))>::type>::value,\n    basic_ostream<_CharT, _Traits>&\n>::type\noperator<<(basic_ostream<_CharT, _Traits>& __os, unique_ptr<_Yp, _Dp> const& __p)\n{\n    return __os << __p.get();\n}\n\ntemplate <class _CharT, class _Traits, size_t _Size>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)\n{\n    return __os << __x.template to_string<_CharT, _Traits>\n                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),\n                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));\n}\n\n#ifndef _LIBCPP_DO_NOT_ASSUME_STREAMS_EXPLICIT_INSTANTIATION_IN_DYLIB\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ostream<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ostream<wchar_t>)\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_OSTREAM\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___LOCALE\n#define _LIBCPP___LOCALE\n\n#include <__config>\n#include <string>\n#include <memory>\n#include <utility>\n#include <mutex>\n#include <cstdint>\n#include <cctype>\n#include <locale.h>\n#if defined(_LIBCPP_MSVCRT_LIKE)\n# include <support/win32/locale_win32.h>\n#elif defined(_AIX)\n# include <support/ibm/xlocale.h>\n#elif defined(__ANDROID__)\n# include <support/android/locale_bionic.h>\n#elif defined(__sun__)\n# include <xlocale.h>\n# include <support/solaris/xlocale.h>\n#elif defined(_NEWLIB_VERSION)\n# include <support/newlib/xlocale.h>\n#elif (defined(__APPLE__)      || defined(__FreeBSD__) \\\n    || defined(__EMSCRIPTEN__) || defined(__IBMCPP__))\n# include <xlocale.h>\n#elif defined(__Fuchsia__)\n# include <support/fuchsia/xlocale.h>\n#elif defined(_LIBCPP_HAS_MUSL_LIBC)\n# include <support/musl/xlocale.h>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if !defined(_LIBCPP_LOCALE__L_EXTENSIONS)\nstruct __libcpp_locale_guard {\n  _LIBCPP_INLINE_VISIBILITY\n  __libcpp_locale_guard(locale_t& __loc) : __old_loc_(uselocale(__loc)) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  ~__libcpp_locale_guard() {\n    if (__old_loc_)\n      uselocale(__old_loc_);\n  }\n\n  locale_t __old_loc_;\nprivate:\n  __libcpp_locale_guard(__libcpp_locale_guard const&);\n  __libcpp_locale_guard& operator=(__libcpp_locale_guard const&);\n};\n#elif defined(_LIBCPP_MSVCRT_LIKE)\nstruct __libcpp_locale_guard {\n    __libcpp_locale_guard(locale_t __l) :\n        __status(_configthreadlocale(_ENABLE_PER_THREAD_LOCALE)),\n        __locale_collate(setlocale(LC_COLLATE, __l.__get_locale())),\n        __locale_ctype(setlocale(LC_CTYPE, __l.__get_locale())),\n        __locale_monetary(setlocale(LC_MONETARY, __l.__get_locale())),\n        __locale_numeric(setlocale(LC_NUMERIC, __l.__get_locale())),\n        __locale_time(setlocale(LC_TIME, __l.__get_locale()))\n        // LC_MESSAGES is not supported on Windows.\n    {}\n    ~__libcpp_locale_guard() {\n        setlocale(LC_COLLATE, __locale_collate);\n        setlocale(LC_CTYPE, __locale_ctype);\n        setlocale(LC_MONETARY, __locale_monetary);\n        setlocale(LC_NUMERIC, __locale_numeric);\n        setlocale(LC_TIME, __locale_time);\n        _configthreadlocale(__status);\n    }\n    int __status;\n    char* __locale_collate;\n    char* __locale_ctype;\n    char* __locale_monetary;\n    char* __locale_numeric;\n    char* __locale_time;\n};\n#endif\n\n\nclass _LIBCPP_TYPE_VIS locale;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale&) _NOEXCEPT;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale&);\n\nclass _LIBCPP_TYPE_VIS locale\n{\npublic:\n    // types:\n    class _LIBCPP_TYPE_VIS facet;\n    class _LIBCPP_TYPE_VIS id;\n\n    typedef int category;\n    _LIBCPP_AVAILABILITY_LOCALE_CATEGORY\n    static const category // values assigned here are for exposition only\n        none     = 0,\n        collate  = LC_COLLATE_MASK,\n        ctype    = LC_CTYPE_MASK,\n        monetary = LC_MONETARY_MASK,\n        numeric  = LC_NUMERIC_MASK,\n        time     = LC_TIME_MASK,\n        messages = LC_MESSAGES_MASK,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale()  _NOEXCEPT;\n    locale(const locale&)  _NOEXCEPT;\n    explicit locale(const char*);\n    explicit locale(const string&);\n    locale(const locale&, const char*, category);\n    locale(const locale&, const string&, category);\n    template <class _Facet>\n        _LIBCPP_INLINE_VISIBILITY locale(const locale&, _Facet*);\n    locale(const locale&, const locale&, category);\n\n    ~locale();\n\n    const locale& operator=(const locale&)  _NOEXCEPT;\n\n    template <class _Facet>\n      _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n      locale combine(const locale&) const;\n\n    // locale operations:\n    string name() const;\n    bool operator==(const locale&) const;\n    bool operator!=(const locale& __y) const {return !(*this == __y);}\n    template <class _CharT, class _Traits, class _Allocator>\n      _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,\n                      const basic_string<_CharT, _Traits, _Allocator>&) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n\nprivate:\n    class __imp;\n    __imp* __locale_;\n\n    void __install_ctor(const locale&, facet*, long);\n    static locale& __global();\n    bool has_facet(id&) const;\n    const facet* use_facet(id&) const;\n\n    template <class _Facet> friend bool has_facet(const locale&)  _NOEXCEPT;\n    template <class _Facet> friend const _Facet& use_facet(const locale&);\n};\n\nclass _LIBCPP_TYPE_VIS locale::facet\n    : public __shared_count\n{\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit facet(size_t __refs = 0)\n        : __shared_count(static_cast<long>(__refs)-1) {}\n\n    virtual ~facet();\n\n//    facet(const facet&) = delete;     // effectively done in __shared_count\n//    void operator=(const facet&) = delete;\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n};\n\nclass _LIBCPP_TYPE_VIS locale::id\n{\n    once_flag      __flag_;\n    int32_t        __id_;\n\n    static int32_t __next_id;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR id() :__id_(0) {}\nprivate:\n    void __init();\n    void operator=(const id&); // = delete;\n    id(const id&); // = delete;\npublic:  // only needed for tests\n    long __get();\n\n    friend class locale;\n    friend class locale::__imp;\n};\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale::locale(const locale& __other, _Facet* __f)\n{\n    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);\n}\n\ntemplate <class _Facet>\nlocale\nlocale::combine(const locale& __other) const\n{\n    if (!_VSTD::has_facet<_Facet>(__other))\n        __throw_runtime_error(\"locale::combine: locale missing facet\");\n\n    return locale(*this, &const_cast<_Facet&>(_VSTD::use_facet<_Facet>(__other)));\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale& __l)  _NOEXCEPT\n{\n    return __l.has_facet(_Facet::id);\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale& __l)\n{\n    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));\n}\n\n// template <class _CharT> class collate;\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS collate\n    : public locale::facet\n{\npublic:\n    typedef _CharT char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit collate(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const char_type* __lo1, const char_type* __hi1,\n                const char_type* __lo2, const char_type* __hi2) const\n    {\n        return do_compare(__lo1, __hi1, __lo2, __hi2);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    string_type transform(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_transform(__lo, __hi);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    long hash(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_hash(__lo, __hi);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~collate();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const\n        {return string_type(__lo, __hi);}\n    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT> locale::id collate<_CharT>::id;\n\ntemplate <class _CharT>\ncollate<_CharT>::~collate()\n{\n}\n\ntemplate <class _CharT>\nint\ncollate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,\n                            const char_type* __lo2, const char_type* __hi2) const\n{\n    for (; __lo2 != __hi2; ++__lo1, ++__lo2)\n    {\n        if (__lo1 == __hi1 || *__lo1 < *__lo2)\n            return -1;\n        if (*__lo2 < *__lo1)\n            return 1;\n    }\n    return __lo1 != __hi1;\n}\n\ntemplate <class _CharT>\nlong\ncollate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const\n{\n    size_t __h = 0;\n    const size_t __sr = __CHAR_BIT__ * sizeof(size_t) - 8;\n    const size_t __mask = size_t(0xF) << (__sr + 4);\n    for(const char_type* __p = __lo; __p != __hi; ++__p)\n    {\n        __h = (__h << 4) + static_cast<size_t>(*__p);\n        size_t __g = __h & __mask;\n        __h ^= __g | (__g >> __sr);\n    }\n    return static_cast<long>(__h);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS collate<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS collate<wchar_t>)\n\n// template <class CharT> class collate_byname;\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS collate_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<char>\n    : public collate<char>\n{\n    locale_t __l;\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<wchar_t>\n    : public collate<wchar_t>\n{\n    locale_t __l;\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbool\nlocale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,\n                   const basic_string<_CharT, _Traits, _Allocator>& __y) const\n{\n    return _VSTD::use_facet<_VSTD::collate<_CharT> >(*this).compare(\n                                       __x.data(), __x.data() + __x.size(),\n                                       __y.data(), __y.data() + __y.size()) < 0;\n}\n\n// template <class charT> class ctype\n\nclass _LIBCPP_TYPE_VIS ctype_base\n{\npublic:\n#if defined(__GLIBC__)\n    typedef unsigned short mask;\n    static const mask space  = _ISspace;\n    static const mask print  = _ISprint;\n    static const mask cntrl  = _IScntrl;\n    static const mask upper  = _ISupper;\n    static const mask lower  = _ISlower;\n    static const mask alpha  = _ISalpha;\n    static const mask digit  = _ISdigit;\n    static const mask punct  = _ISpunct;\n    static const mask xdigit = _ISxdigit;\n    static const mask blank  = _ISblank;\n#elif defined(_LIBCPP_MSVCRT_LIKE)\n    typedef unsigned short mask;\n    static const mask space  = _SPACE;\n    static const mask print  = _BLANK|_PUNCT|_ALPHA|_DIGIT;\n    static const mask cntrl  = _CONTROL;\n    static const mask upper  = _UPPER;\n    static const mask lower  = _LOWER;\n    static const mask alpha  = _ALPHA;\n    static const mask digit  = _DIGIT;\n    static const mask punct  = _PUNCT;\n    static const mask xdigit = _HEX;\n    static const mask blank  = _BLANK;\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_PRINT\n#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__EMSCRIPTEN__) || defined(__NetBSD__)\n# ifdef __APPLE__\n    typedef __uint32_t mask;\n# elif defined(__FreeBSD__)\n    typedef unsigned long mask;\n# elif defined(__EMSCRIPTEN__) || defined(__NetBSD__)\n    typedef unsigned short mask;\n# endif\n    static const mask space  = _CTYPE_S;\n    static const mask print  = _CTYPE_R;\n    static const mask cntrl  = _CTYPE_C;\n    static const mask upper  = _CTYPE_U;\n    static const mask lower  = _CTYPE_L;\n    static const mask alpha  = _CTYPE_A;\n    static const mask digit  = _CTYPE_D;\n    static const mask punct  = _CTYPE_P;\n    static const mask xdigit = _CTYPE_X;\n\n# if defined(__NetBSD__)\n    static const mask blank  = _CTYPE_BL;\n# else\n    static const mask blank  = _CTYPE_B;\n# endif\n#elif defined(__sun__) || defined(_AIX)\n    typedef unsigned int mask;\n    static const mask space  = _ISSPACE;\n    static const mask print  = _ISPRINT;\n    static const mask cntrl  = _ISCNTRL;\n    static const mask upper  = _ISUPPER;\n    static const mask lower  = _ISLOWER;\n    static const mask alpha  = _ISALPHA;\n    static const mask digit  = _ISDIGIT;\n    static const mask punct  = _ISPUNCT;\n    static const mask xdigit = _ISXDIGIT;\n    static const mask blank  = _ISBLANK;\n#elif defined(_NEWLIB_VERSION)\n    // Same type as Newlib's _ctype_ array in newlib/libc/include/ctype.h.\n    typedef char mask;\n    static const mask space  = _S;\n    static const mask print  = _P | _U | _L | _N | _B;\n    static const mask cntrl  = _C;\n    static const mask upper  = _U;\n    static const mask lower  = _L;\n    static const mask alpha  = _U | _L;\n    static const mask digit  = _N;\n    static const mask punct  = _P;\n    static const mask xdigit = _X | _N;\n    static const mask blank  = _B;\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_PRINT\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_ALPHA\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_XDIGIT\n#else\n    typedef unsigned long mask;\n    static const mask space  = 1<<0;\n    static const mask print  = 1<<1;\n    static const mask cntrl  = 1<<2;\n    static const mask upper  = 1<<3;\n    static const mask lower  = 1<<4;\n    static const mask alpha  = 1<<5;\n    static const mask digit  = 1<<6;\n    static const mask punct  = 1<<7;\n    static const mask xdigit = 1<<8;\n    static const mask blank  = 1<<9;\n#endif\n    static const mask alnum  = alpha | digit;\n    static const mask graph  = alnum | punct;\n\n    _LIBCPP_INLINE_VISIBILITY ctype_base() {}\n};\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS ctype;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<wchar_t>\n    : public locale::facet,\n      public ctype_base\n{\npublic:\n    typedef wchar_t char_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit ctype(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool is(mask __m, char_type __c) const\n    {\n        return do_is(__m, __c);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        return do_is(__low, __high, __vec);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_is(__m, __low, __high);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_not(__m, __low, __high);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~ctype();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<char>\n    : public locale::facet, public ctype_base\n{\n    const mask* __tab_;\n    bool        __del_;\npublic:\n    typedef char char_type;\n\n    explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool is(mask __m, char_type __c) const\n    {\n        return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        for (; __low != __high; ++__low, ++__vec)\n            *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;\n        return __low;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\n#ifdef _CACHED_RUNES\n    static const size_t table_size = _CACHED_RUNES;\n#else\n    static const size_t table_size = 256;  // FIXME: Don't hardcode this.\n#endif\n    _LIBCPP_INLINE_VISIBILITY const mask* table() const  _NOEXCEPT {return __tab_;}\n    static const mask* classic_table()  _NOEXCEPT;\n#if defined(__GLIBC__) || defined(__EMSCRIPTEN__)\n    static const int* __classic_upper_table() _NOEXCEPT;\n    static const int* __classic_lower_table() _NOEXCEPT;\n#endif\n#if defined(__NetBSD__)\n    static const short* __classic_upper_table() _NOEXCEPT;\n    static const short* __classic_lower_table() _NOEXCEPT;\n#endif\n\nprotected:\n    ~ctype();\n    virtual char_type do_toupper(char_type __c) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type __c) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char __c) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;\n    virtual char do_narrow(char_type __c, char __dfault) const;\n    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;\n};\n\n// template <class CharT> class ctype_byname;\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS ctype_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<char>\n    : public ctype<char>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<wchar_t>\n    : public ctype<wchar_t>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisspace(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisprint(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\niscntrl(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nislower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalpha(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nispunct(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisxdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalnum(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisgraph(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntoupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).toupper(__c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntolower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).tolower(__c);\n}\n\n// codecvt_base\n\nclass _LIBCPP_TYPE_VIS codecvt_base\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY codecvt_base() {}\n    enum result {ok, partial, error, noconv};\n};\n\n// template <class internT, class externT, class stateT> class codecvt;\n\ntemplate <class _InternT, class _ExternT, class _StateT> class _LIBCPP_TEMPLATE_VIS codecvt;\n\n// template <> class codecvt<char, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char      intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<wchar_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<wchar_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\n    locale_t __l;\npublic:\n    typedef wchar_t   intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    explicit codecvt(size_t __refs = 0);\n\n    _LIBCPP_INLINE_VISIBILITY\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    explicit codecvt(const char*, size_t __refs = 0);\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char16_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char16_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char16_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char32_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char32_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char32_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <class _InternT, class _ExternT, class _StateT> class codecvt_byname\n\ntemplate <class _InternT, class _ExternT, class _StateT>\nclass _LIBCPP_TEMPLATE_VIS codecvt_byname\n    : public codecvt<_InternT, _ExternT, _StateT>\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit codecvt_byname(const char* __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit codecvt_byname(const string& __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}\nprotected:\n    ~codecvt_byname();\n};\n\ntemplate <class _InternT, class _ExternT, class _StateT>\ncodecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()\n{\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<wchar_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char16_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char32_t, char, mbstate_t>)\n\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\ntemplate <size_t _Np>\nstruct __narrow_to_utf8\n{\n    template <class _OutputIterator, class _CharT>\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;\n};\n\ntemplate <>\nstruct __narrow_to_utf8<8>\n{\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_INLINE_VISIBILITY\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        for (; __wb < __we; ++__wb, ++__s)\n            *__s = *__wb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS __narrow_to_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    _LIBCPP_EXPORTED_FROM_ABI ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_INLINE_VISIBILITY\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char16_t* __wn = (const char16_t*)__wb;\n            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS __narrow_to_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    _LIBCPP_EXPORTED_FROM_ABI ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_INLINE_VISIBILITY\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char32_t* __wn = (const char32_t*)__wb;\n            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <size_t _Np>\nstruct __widen_from_utf8\n{\n    template <class _OutputIterator>\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;\n};\n\ntemplate <>\nstruct __widen_from_utf8<8>\n{\n    template <class _OutputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        for (; __nb < __ne; ++__nb, ++__s)\n            *__s = *__nb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS __widen_from_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    _LIBCPP_EXPORTED_FROM_ABI ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char16_t __buf[__sz];\n            char16_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS __widen_from_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    _LIBCPP_EXPORTED_FROM_ABI ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char32_t __buf[__sz];\n            char32_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\n// template <class charT> class numpunct\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS numpunct;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<char>\n    : public locale::facet\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_INLINE_VISIBILITY char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_INLINE_VISIBILITY char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_INLINE_VISIBILITY string grouping() const         {return do_grouping();}\n    _LIBCPP_INLINE_VISIBILITY string_type truename() const    {return do_truename();}\n    _LIBCPP_INLINE_VISIBILITY string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<wchar_t>\n    : public locale::facet\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_INLINE_VISIBILITY char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_INLINE_VISIBILITY char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_INLINE_VISIBILITY string grouping() const         {return do_grouping();}\n    _LIBCPP_INLINE_VISIBILITY string_type truename() const    {return do_truename();}\n    _LIBCPP_INLINE_VISIBILITY string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\n// template <class charT> class numpunct_byname\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS numpunct_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<char>\n: public numpunct<char>\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<wchar_t>\n: public numpunct<wchar_t>\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___LOCALE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2018\n *\n *  @file Canvas.hpp\n *  @brief Manage an HTML canvas object.\n *\n */\n\n#ifndef EMP_WEB_CANVAS_HPP_INCLUDE\n#define EMP_WEB_CANVAS_HPP_INCLUDE\n\n\n#include <string>\n\n#include \"../base/vector.hpp\"\n#include \"../geometry/Circle2D.hpp\"\n#include \"../tools/string_utils.hpp\"\n\n#include \"CanvasAction.hpp\"\n#include \"CanvasShape.hpp\"\n\nnamespace emp {\nnamespace web {\n\n  /// Manage an HTML Canvas object.\n  class Canvas : public internal::WidgetFacet<Canvas> {\n    friend class CanvasInfo;\n  protected:\n    #ifndef DOXYGEN_SHOULD_SKIP_THIS\n    class CanvasInfo : public internal::WidgetInfo {\n      friend Canvas;\n\n    protected:\n      double width;   ///< pixel width of the canvas.\n      double height;  ///< pixel height of the canvas.\n\n      emp::vector<CanvasAction *> actions;\n\n      CanvasInfo(const std::string & in_id=\"\") : internal::WidgetInfo(in_id) { ; }\n      CanvasInfo(const CanvasInfo &) = delete;               // No copies of INFO allowed\n      CanvasInfo & operator=(const CanvasInfo &) = delete;   // No copies of INFO allowed\n      virtual ~CanvasInfo() { ClearActions(); }\n\n      std::string GetTypeName() const override { return \"CanvasInfo\"; }\n\n      virtual void GetHTML(std::stringstream & HTML) override {\n        HTML.str(\"\");                                           // Clear the current text.\n        HTML << \"<canvas id=\\\"\" << id\n             << \"\\\" width=\\\"\" << width\n             << \"\\\" height=\\\"\" << height << \"\\\">\";\n        // @CAO We can include fallback content here for browsers that don't support canvas.\n        HTML << \"</canvas>\";\n\n        // create an offscreen canvas\n        #ifdef __EMSCRIPTEN_PTHREADS__\n        EM_ASM({\n          var cname = UTF8ToString($0);\n          emp_i.offscreen_canvases[ cname ] = new OffscreenCanvas($1, $2);\n        }, id.c_str(), width, height);\n        #endif // __EMSCRIPTEN_PTHREADS__\n      }\n\n      // Setup a canvas to be drawn on.\n      void TargetCanvas() {\n        #ifdef __EMSCRIPTEN_PTHREADS__\n        EM_ASM({\n          var cname = UTF8ToString($0);\n          var canvas = emp_i.offscreen_canvases[ cname ];\n          emp_i.pending_offscreen_canvas_ids.add( cname );\n          emp_i.ctx = canvas.getContext('2d');\n        }, id.c_str());\n        #else\n        EM_ASM({\n          var cname = UTF8ToString($0);\n          var canvas = document.getElementById(cname);\n          emp_i.ctx = canvas.getContext('2d');\n        }, id.c_str());\n        #endif\n      }\n\n      // Trigger any JS code needed on re-draw.\n      void TriggerJS() override {\n        if (state == Widget::ACTIVE) {            // Only draw on active canvases\n          TargetCanvas();                         // Prepare the canvas for drawing\n          for (auto & a : actions) a->Apply();    // Run all of the actions\n        }\n      }\n\n      void AddAction(CanvasAction * new_action) {\n        if (state == Widget::ACTIVE) {    // Only draw on active canvases\n          TargetCanvas();                 // Prepare the canvas for drawing\n          new_action->Apply();            // Draw the current action\n        }\n        actions.push_back(new_action);    // Store the current action.\n      }\n\n      void ClearActions() {\n        for (auto * a : actions) delete a;\n        actions.resize(0);\n      }\n\n\n    public:\n      virtual std::string GetType() override { return \"web::CanvasInfo\"; }\n\n    };  // End of ButtonInfo definition.\n    #endif // DOXYGEN_SHOULD_SKIP_THIS\n\n    // Get a properly cast version of indo.\n    CanvasInfo * Info() { return (CanvasInfo *) info; }\n    const CanvasInfo * Info() const { return (CanvasInfo *) info; }\n\n    Canvas(CanvasInfo * in_info) : WidgetFacet(in_info) { ; }\n\n  public:\n    /// Create a new canvas with the specified size and optional HTML identifier.\n    Canvas(double w, double h, const std::string & in_id=\"\")\n      : WidgetFacet(in_id)\n    {\n      info = new CanvasInfo(in_id);\n      Info()->width = w;\n      Info()->height = h;\n    }\n\n    /// Link to an existing canvas.\n    Canvas(const Canvas & in) : WidgetFacet(in) { ; }\n    Canvas(const Widget & in) : WidgetFacet(in) { emp_assert(in.IsCanvas()); }\n    Canvas() { ; }\n    virtual ~Canvas() { ; }\n\n    using INFO_TYPE = CanvasInfo;\n\n    double GetWidth() const { return Info()->width; }    ///< Get the pixel width of this Canvas.\n    double GetHeight() const { return Info()->height; }  ///< Get the pixel height of this Canvas.\n\n    void SetWidth(double w) { Info()->width=w; }         ///< Set a new width for this Canvas.\n    void SetHeight(double h) { Info()->height=h; }       ///< Set a new height for this Canvas.\n\n    /// Set Canvas size.\n    void SetSize(double w, double h) { Info()->width=w; Info()->height=h; }\n\n    /// Add a Circle to this canvas; provide constructor for the CanvasCircle with a position and radius\n    /// as well as optional face color, line color, and line width.\n    template <typename... Ts>\n    Canvas & Circle(Point center, double _r, Ts &&... vals) {\n      Info()->AddAction( new CanvasCircle(emp::Circle(center, _r), std::forward<Ts>(vals)...) );\n      return *this;\n    }\n\n    template <typename... Ts>\n    Canvas & Circle(double _x, double _y, double _r, Ts &&... vals) {\n      Info()->AddAction( new CanvasCircle(emp::Circle(_x, _y, _r), std::forward<Ts>(vals)...) );\n      return *this;\n    }\n\n    /// Add a Rectangle to this canvas at x,y with width w and heigh h.  Optional face color and\n    /// line color.\n    template <typename... Ts>\n    Canvas & Rect(Point corner, double w, double h, Ts &&... vals) {\n      Info()->AddAction( new CanvasRect(corner, w, h, std::forward<Ts>(vals)...) );\n      return *this;\n    }\n\n    template <typename... Ts>\n    Canvas & Rect(double x, double y, double w, double h, Ts &&... vals) {\n      Info()->AddAction( new CanvasRect(x, y, w, h, std::forward<Ts>(vals)...) );\n      return *this;\n    }\n\n    /// Add an Image to this canvas at x,y with width w and heigh h.\n    template <typename... Ts>\n    Canvas & Image(const emp::RawImage & image, Point corner, Ts &&... vals) {\n      Info()->AddAction( new CanvasImage(image, corner, std::forward<Ts>(vals)...) );\n      return *this;\n    }\n\n    template <typename... Ts>\n    Canvas & Image(const emp::RawImage & image, double x, double y, Ts &&... vals) {\n      Info()->AddAction( new CanvasImage(image, x, y, std::forward<Ts>(vals)...) );\n      return *this;\n    }\n\n\n    /// Add a Line from x1,y1 to x2,y2.  Optional face color and line color.\n    template <typename... Ts>\n    Canvas & Line(double x1, double y1, double x2, double y2, Ts &&... vals) {\n      Info()->AddAction( new CanvasLine(x1, y1, x2, y2, std::forward<Ts>(vals)...) );\n      return *this;\n    }\n\n    template <typename... Ts>\n    Canvas & Line(emp::Point p1, emp::Point p2, Ts &&... vals) {\n      Info()->AddAction( new CanvasLine(p1, p2, std::forward<Ts>(vals)...) );\n      return *this;\n    }\n\n    /// Add a Line from x1,y1 to x2,y2.  Optional face color and line color.\n    template <typename... Ts>\n    Canvas & MultiLine(emp::Point p1, const emp::vector<emp::Point> & points, Ts &&... vals) {\n      Info()->AddAction( new CanvasMultiLine(p1, points, std::forward<Ts>(vals)...) );\n      return *this;\n    }\n\n    /// Add a string to this canvas at x,y with specified text.  Optional face color and\n    /// line color.\n    template <typename... Ts>\n    Canvas & Text(emp::Point p, Ts &&... vals) {\n      Info()->AddAction( new CanvasText(p, std::forward<Ts>(vals)...) );\n      return *this;\n    }\n\n    template <typename... Ts>\n    Canvas & Text(double x, double y, Ts &&... vals) {\n      Info()->AddAction( new CanvasText(x, y, std::forward<Ts>(vals)...) );\n      return *this;\n    }\n\n    /// Add a string to this canvas centered at x,y with specified text.  Optional face color and\n    /// line color.\n    template <typename... Ts>\n    Canvas & CenterText(emp::Point p, Ts &&... vals) {\n      auto * ctext = new CanvasText(p, std::forward<Ts>(vals)...);\n      ctext->Center();\n      Info()->AddAction( ctext );\n      return *this;\n    }\n\n    template <typename... Ts>\n    Canvas & CenterText(double x, double y, Ts &&... vals) {\n      auto * ctext = new CanvasText({x, y}, std::forward<Ts>(vals)...);\n      ctext->Center();\n      Info()->AddAction( ctext );\n      return *this;\n    }\n\n    /// Update the default font for text.\n    Canvas & Font(const std::string font) {\n      Info()->AddAction( new CanvasFont(font) );\n      return *this;\n    }\n\n    /// Draw a circle onto this canvas.\n    Canvas & Draw(const emp::Circle & circle,\n                  const std::string & fc=\"\", const std::string & lc=\"\") {\n      Info()->AddAction( new CanvasCircle(circle, fc, lc) );\n      return *this;\n    }\n\n    /// Draw an arbitrary shape onto this canvas.\n    Canvas & Draw(const CanvasShape & shape) {\n      Info()->AddAction( shape.Clone() );\n      return *this;\n    }\n\n    /// Change the default stroke color.\n    Canvas & StrokeColor(std::string c) {\n      Info()->AddAction( new CanvasStrokeColor(c) );\n      return *this;\n    }\n\n    /// Rotate the entire canvas.\n    Canvas & Rotate(double angle) {\n      Info()->AddAction( new CanvasRotate(angle) );\n      return *this;\n    }\n\n    /// Clear everything off of this canvas.\n    Canvas & Clear() {\n      Info()->ClearActions();\n      Info()->AddAction( new CanvasClearRect({0,0}, GetWidth(), GetHeight()) );\n      return *this;\n    }\n\n    /// Clear to a specific background color.\n    Canvas & Clear(const std::string & bg_color) {\n      Info()->ClearActions();\n      Info()->AddAction( new CanvasClearRect({0,0}, GetWidth(), GetHeight()) );\n      Info()->AddAction( new CanvasRect({0,0}, GetWidth(), GetHeight(), bg_color, \"\") );\n      return *this;\n    }\n\n    /// Download a PNG image of a canvas.\n    void DownloadPNG() const { DownloadPNG(Info()->id + \".png\"); }\n\n    /// Download a PNG image of a canvas.\n    void DownloadPNG(const std::string & fname) const {\n\n      const std::string ext = \".png\";\n      emscripten_run_script(\n        (\n          std::string()\n          + \"emp.download(document.getElementById('\"\n          + Info()->id\n          + \"').toDataURL('img/png'), '\"\n          + fname\n          + (fname.rfind(ext, fname.length()) == std::string::npos ? ext : \"\")\n          + \"', 'img/png');\"\n        ).c_str()\n      );\n\n    }\n\n    /// Save a PNG image of a canvas with node.js.\n    void SavePNG(const std::string& fname) const {\n\n      // adapted from https://stackoverflow.com/a/11335500\n      const std::string command_template = R\"(\n        setTimeout(function(){\n\n          fs = require('fs');\n\n          canvas = document.getElementById('%s');\n\n          var url = canvas.toDataURL('image/png');\n          var regex = `^data:.+\\/(.+);base64,(.*)$`;\n\n          var matches = url.match(regex);\n          var data = matches[2];\n          var buffer = Buffer.from(data, 'base64');\n\n          fs.writeFileSync('%s' , buffer);\n\n        }, 10);\n      )\";\n\n\n      const std::string id{ Info()->id };\n      const std::string command{\n        emp::format_string( command_template, id.c_str(), fname.c_str() )\n      };\n\n      emscripten_run_script( command.c_str() );\n\n    }\n\n  };\n\n}\n}\n\n#endif // #ifndef EMP_WEB_CANVAS_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2019.\n *\n *  @file Widget.hpp\n *  @brief Widgets maintain individual components on a web page and link to Elements\n *\n *  Each HTML Widget has all of its details stored in a WidgetInfo object; Multiple Widgets can\n *  be attached to the same WidgetInfo, simplifying the usage.  All the library user needs to\n *  worry about is the Widget object itself; the WidgetInfo will be managed behind the scenes.\n *\n *  WidgetInfo contains the basic information for all Widgets\n *  Widget is a generic base class, with a shared pointer to WidgetInfo\n *  WidgetFacet is a template that allows Set* methods to return derived return-type.\n *\n *  In other files, Widgets will be used to define specific elements.\n *  ELEMENTInfo maintains information about the specific widget (derived from WidgetInfo)\n *  ELEMENT interfaces to ELEMENTInfo so multiple elements use same core; derived from WidgetFacet\n *\n *  Library users should not need to access Widgets directly, only specific derived types.\n *\n *  Tips for using widgets:\n *\n *  1. If you are about to make a lot of changes at once, run Freeze(), make the changes, and\n *     then run Activate() again.  Freeze prevents widgets from being updated immediately.\n *\n *  2. Trust the Widget to handle all of the manipulation behind the scenes\n *\n */\n\n#ifndef EMP_WEB_WIDGET_HPP_INCLUDE\n#define EMP_WEB_WIDGET_HPP_INCLUDE\n\n\n#include <string>\n\n#include \"../base/errors.hpp\"\n#include \"../base/vector.hpp\"\n#include \"../control/Signal.hpp\"\n#include \"../debug/mem_track.hpp\"\n#include \"../meta/meta.hpp\"\n\n#include \"events.hpp\"\n#include \"Font.hpp\"\n#include \"init.hpp\"\n#include \"WidgetExtras.hpp\"\n\nnamespace emp {\nnamespace web {\n\n    #ifndef DOXYGEN_SHOULD_SKIP_THIS\n  // Setup some types we will need later\n  namespace internal {\n    // Pre-declare WidgetInfo so classes can inter-operate.\n    class WidgetInfo;\n    class DivInfo;\n    class TableInfo;\n\n    /// Quick method for generating unique Widget ID numbers when not otherwise specified.\n    static size_t NextWidgetNum(bool inc_num=true) {\n      static size_t next_id = 0;\n      if (!inc_num) return next_id;\n      return next_id++;\n    }\n\n    /// Quick method for generating unique string IDs for Widgets.\n    static std::string NextWidgetID() {\n      return emp::to_string(\"emp__\", NextWidgetNum());\n    }\n\n    /// Base class for command-objects that can be fed into widgets.\n    class WidgetCommand {\n    public:\n      virtual ~WidgetCommand() { ; }\n      virtual bool Trigger(WidgetInfo &) const = 0;\n    };\n  }\n  #endif // DOXYGEN_SHOULD_SKIP_THIS\n\n  /// Widget is effectively a smart pointer to a WidgetInfo object, plus some basic accessors.\n  class Widget {\n    friend internal::WidgetInfo; friend internal::DivInfo; friend internal::TableInfo;\n  protected:\n    using WidgetInfo = internal::WidgetInfo;\n    WidgetInfo * info;                        ///< Information associated with this widget.\n\n    /// If an Append doesn't work with current class, forward it to the parent and try there.\n    template <typename FWD_TYPE> Widget & ForwardAppend(FWD_TYPE && arg);\n\n    /// Set the information associated with this widget.\n    Widget & SetInfo(WidgetInfo * in_info);\n\n    /// Internally, we can treat a Widget as a pointer to its WidgetInfo.\n    WidgetInfo * operator->() { return info; }\n\n    /// Give derived classes the ability to access widget info.\n    static WidgetInfo * Info(const Widget & w) { return w.info; }\n\n    /// Four activity states for any widget:\n    ///   INACTIVE - Not be in DOM at all.\n    ///   WAITING  - Will become active once the page finishes loading.\n    ///   FROZEN   - Part of DOM, but not updating on the screen.\n    ///   ACTIVE   - Fully active; changes are reflected as they happen.\n\n    enum ActivityState { INACTIVE, WAITING, FROZEN, ACTIVE };\n\n    /// Default name for un-initialized widgets.\n    static const std::string no_name;\n\n  public:\n    /// When Widgets are first created, they should be provided with an ID.\n    Widget(const std::string & id);\n    Widget(WidgetInfo * in_info=nullptr);\n    Widget(const Widget & in) : Widget(in.info) { ; }\n    Widget & operator=(const Widget & in) { return SetInfo(in.info); }\n\n    virtual ~Widget();\n\n    /// Test if this widget is valid.\n    bool IsNull() const { return info == nullptr; }\n\n    /// Some debugging helpers...\n    std::string GetInfoTypeName() const;\n\n    bool IsInactive() const;  ///< Test if the activity state of this widget is currently INACTIVE\n    bool IsWaiting() const;   ///< Test if the activity state of this widget is currently WAITING\n    bool IsFrozen() const;    ///< Test if the activity state of this widget is currently FROZEN\n    bool IsActive() const;    ///< Test if the activity state of this widget is currently ACTIVE\n\n    bool AppendOK() const;    ///< Is it okay to add more internal Widgets into this one?\n    void PreventAppend();     ///< Disallow further appending to this Widget.\n\n    bool IsButton()   const { return GetInfoTypeName() == \"ButtonInfo\"; }\n    bool IsCanvas()   const { return GetInfoTypeName() == \"CanvasInfo\"; }\n    bool IsDiv()      const { return GetInfoTypeName() == \"DivInfo\"; }\n    bool IsImage()    const { return GetInfoTypeName() == \"ImageInfo\"; }\n    bool IsInput()    const { return GetInfoTypeName() == \"InputInfo\"; }\n    bool IsSelector() const { return GetInfoTypeName() == \"SelectorInfo\"; }\n    bool IsTable()    const { return GetInfoTypeName() == \"TableInfo\"; }\n    bool IsText()     const { return GetInfoTypeName() == \"TextInfo\"; }\n    bool IsTextArea() const { return GetInfoTypeName() == \"TextAreaInfo\"; }\n    bool IsTextFeed() const { return GetInfoTypeName() == \"TextFeedInfo\"; }\n\n    bool IsD3Visualization() const { return GetInfoTypeName() == \"D3VisualizationInfo\"; }\n\n    const std::string & GetID() const;  ///< What is the HTML string ID for this Widget?\n\n    /// Retrieve a specific CSS trait associated with this Widget.\n    /// Note: CSS-related options may be overridden in derived classes that have multiple styles.\n    virtual const std::string & GetCSS(const std::string & setting) const;\n\n    /// Determine is a CSS trait has been set on this Widget.\n    virtual bool HasCSS(const std::string & setting);\n\n    /// Retrieve a specific attribute associated with this Widget.\n    virtual const std::string & GetAttr(const std::string & setting) const;\n\n    /// Determine is an attribute has been set on this Widget.\n    virtual bool HasAttr(const std::string & setting);\n\n    /// Are two Widgets refering to the same HTML object?\n    bool operator==(const Widget & in) const { return info == in.info; }\n\n    /// Are two Widgets refering to different HTML objects?\n    bool operator!=(const Widget & in) const { return info != in.info; }\n\n    /// Conver Widget to bool (I.e., is this Widget active?)\n    operator bool() const { return info != nullptr; }\n\n    const std::string & GetTitle() const { return GetAttr(\"title\"); }  /// Get current tooltip on this widget.\n\n    double GetXPos();          ///< Get the X-position of this Widget within its parent.\n    double GetYPos();          ///< Get the Y-position of this Widget within its parent.\n    double GetWidth();         ///< Get the width of this Widget on screen.\n    double GetHeight();        ///< Get the height of this Widget on screen.\n    double GetInnerWidth();    ///< Get the width of this Widget not including padding.\n    double GetInnerHeight();   ///< Get the height of this Widget not including padding.\n    double GetOuterWidth();    ///< Get the width of this Widget including all padding.\n    double GetOuterHeight();   ///< Get the height of this Widget including all padding.\n\n    /// Make this widget live, so changes occur immediately (once document is ready)\n    void Activate();\n\n    /// Record changes internally, but keep static screen until Activate() is called.\n    void Freeze();\n\n    /// Record changes internally and REMOVE from screen until Activate is called.\n    /// (Argument is for recursive, internal use only.)\n    virtual void Deactivate(bool top_level=true);\n\n    /// Toggle between Active and Deactivated.\n    bool ToggleActive();\n\n    /// Clear and redraw the current widget on the screen.\n    void Redraw();\n\n    /// Look up previously created elements, by type.\n    Widget & Find(const std::string & test_name);\n\n    /// Add a dependant to this Widget that should be redrawn when it is.\n    Widget & AddDependant(const Widget & w);\n\n    /// Setup << operator to redirect to Append; option preparation can be overridden.\n    virtual void PrepareAppend() { ; }\n    template <typename IN_TYPE> Widget operator<<(IN_TYPE && in_val);\n\n    /// Debug...\n    std::string GetInfoType() const;\n  };\n\n  #ifndef DOXYGEN_SHOULD_SKIP_THIS\n  namespace internal {\n\n    // WidgetInfo is a base class containing information needed by all GUI widget classes\n    // (Buttons, Images, etc...).  It take in a return type to be cast to for accessors.\n\n    class WidgetInfo {\n    public:\n      // Smart-pointer info\n      int ptr_count;                  ///< How many widgets are pointing to this info?\n\n      // Basic info about a widget\n      std::string id;                 ///< ID used for associated DOM element.\n      WidgetExtras extras;            ///< HTML attributes, CSS style, and listeners for web events.\n\n      // Track hierarchy\n      WidgetInfo * parent;            ///< Which WidgetInfo is this one contained within?\n      emp::vector<Widget> dependants; ///< Widgets to be refreshed if this one is triggered\n      Widget::ActivityState state;    ///< Is this element active in DOM?\n\n      emp::Signal<void()> on_update_js_signal; /// Signal for JavaScript functions to be called with TriggerJS()\n\n      /// WidgetInfo cannot be built unless within derived class, so constructor is protected\n      WidgetInfo(const std::string & in_id=\"\")\n        : ptr_count(1), id(in_id), parent(nullptr), state(Widget::INACTIVE)\n      {\n        EMP_TRACK_CONSTRUCT(WebWidgetInfo);\n        if (id == \"\") id = NextWidgetID();\n      }\n\n      /// No copies of INFO allowed\n      WidgetInfo(const WidgetInfo &) = delete;\n      WidgetInfo & operator=(const WidgetInfo &) = delete;\n\n      virtual ~WidgetInfo() {\n        EMP_TRACK_DESTRUCT(WebWidgetInfo);\n      }\n\n      /// Debugging helpers...\n      virtual std::string GetTypeName() const { return \"WidgetInfo\"; }\n\n      // If not overloaded, pass along widget registration to parent.\n      virtual void Register_recurse(Widget & w) { if (parent) parent->Register_recurse(w); }\n      virtual void Register(Widget & w) { if (parent) parent->Register(w); }\n      virtual void Unregister_recurse(Widget & w) { if (parent) parent->Unregister_recurse(w); }\n      virtual void Unregister(Widget & w) { if (parent) parent->Unregister(w); }\n\n      // Some nodes can have children and need to be able to recursively register them.\n      virtual void RegisterChildren(DivInfo * registrar) { ; }   // No children by default.\n      virtual void UnregisterChildren(DivInfo * registrar) { ; } // No children by default.\n\n      virtual void AddChild(Widget in) { ; }\n      virtual void RemoveChild(Widget & child) { ; }\n\n      // Record dependants.  Dependants are only acted upon when this widget's action is\n      // triggered (e.g. a button is pressed)\n      void AddDependant(Widget in) {\n        dependants.emplace_back(in);\n      }\n\n      template <typename... T>\n      void AddDependants(Widget first, T... widgets) {\n        AddDependant(first);\n        AddDependants(widgets...);\n      }\n\n      void AddDependants() { ; }\n\n      void UpdateDependants() { for (auto & d : dependants) d->ReplaceHTML(); }\n\n\n      // Activate is delayed until the document is ready, when DoActivate will be called.\n      virtual void DoActivate(bool top_level=true) {\n\n        if ( state != Widget::ACTIVE ) {\n          state = Widget::ACTIVE;\n          if ( top_level ) ReplaceHTML();\n        }\n\n      }\n\n      virtual bool AppendOK() const { return false; } // Most widgets can't be appended to.\n      virtual void PreventAppend() { emp_assert(false, GetTypeName()); } // Only for appendable widgets.\n\n      // By default, elements should forward unknown appends to their parents.\n      virtual Widget Append(const std::string & text) { return ForwardAppend(text); }\n      virtual Widget Append(const std::function<std::string()> & fn) { return ForwardAppend(fn); }\n      virtual Widget Append(Widget info) { return ForwardAppend(info); }\n      virtual Widget Append(const Font & font) { return ForwardAppend(font); }\n\n      // Handle special commands\n      virtual Widget Append(const emp::web::internal::WidgetCommand & cmd) {\n        if (cmd.Trigger(*this)) return Widget(this);\n        return ForwardAppend(cmd);  // Otherwise pass the Close to parent!\n      }\n\n      // If overloaded versions of Append don't resolve properly, collect everything else\n      // with this generic version and try to collect more information about it.\n      template <typename T>\n      Widget Append(const T & val) {\n        // First, test if we are working with a Widget command.\n        if constexpr ( std::is_base_of<Widget,T>() ) {\n          const Widget widget = val;\n          return Append(widget);\n        }\n\n        // First, test if we are working with a Widget command.\n        if constexpr ( std::is_base_of<WidgetCommand,T>() ) {\n          const WidgetCommand & cmd = val;\n          return Append(cmd);\n        }\n\n        // Next, test if this if an invocable function\n        // @CAO: We should make sure it returns a string when called with no arguments.\n        else if constexpr ( std::is_invocable<T>() ) {\n          std::function<std::string()> fun_val( val );\n          return Append(fun_val);\n        }\n\n        // If we are given a vector, we should try and add each element individually.\n        // Allows one to stream ___.Children() to get similar behavior to display: contents\n        // which is unsupported on some browsers\n        else if constexpr ( is_emp_vector<T>::value ) {\n          Widget last(this);\n          for (auto & item : val) {\n            last = Append(item);\n          }\n          return last;\n        }\n\n        // Anything else we should just try to convert to a string, and used that.\n        else {\n          return Append(emp::to_string(val));\n        }\n      }\n\n      // If an Append doesn't work with current class, forward it to the parent.\n      template <typename FWD_TYPE>\n      Widget ForwardAppend(FWD_TYPE && arg) {\n        emp_assert(parent && \"Trying to forward append to parent, but no parent!\", id);\n        return parent->Append(std::forward<FWD_TYPE>(arg));\n      }\n\n      // All derived widgets must supply a mechanism for providing associated HTML code.\n      virtual void GetHTML(std::stringstream & ss) = 0;\n\n      // Derived widgets may also provide JavaScript code to be run on redraw.\n      virtual void TriggerJS() {\n        on_update_js_signal.Trigger();\n      }\n\n      // Add JS function to be executed when TriggerJS() is called\n      SignalKey RegisterUpdateJS(const std::function<void()> &fun){\n        return on_update_js_signal.AddAction(fun);\n      }\n\n      // Assume that the associated ID exists and replace it with the current HTML code.\n      virtual void ReplaceHTML() {\n        // If this node is frozen, don't change it!\n        if (state == Widget::FROZEN) return;\n\n        // If this node is active, put its contents in ss; otherwise make ss an empty span.\n        std::stringstream ss;\n        if (state == Widget::ACTIVE) GetHTML(ss);\n        else ss << \"<span id='\" << id << \"'></span>\";\n\n        // Now do the replacement.\n        MAIN_THREAD_EM_ASM({\n            var widget_id = UTF8ToString($0);\n            var out_html = UTF8ToString($1);\n            $('#' + widget_id).replaceWith(out_html);\n          }, id.c_str(), ss.str().c_str());\n\n        // If active update style, trigger JS, and recurse to children!\n        if (state == Widget::ACTIVE) {\n          extras.Apply(id); // Update the attributes, style, and listeners.\n          TriggerJS();      // Run associated Javascript code, if any (e.g., to fill out a canvas)\n        }\n      }\n\n    public:\n      virtual std::string GetType() { return \"web::WidgetInfo\"; }\n    };\n\n  }  // end namespaceinternal\n  #endif // DOXYGEN_SHOULD_SKIP_THIS\n\n  // Implementation of Widget methods...\n\n  Widget::Widget(const std::string & id) {\n    emp_assert(has_whitespace(id) == false);\n    // We are creating a new widget; in derived class, make sure:\n    // ... to assign info pointer to new object of proper *Info type\n    // ... NOT to increment info->ptr_count since it's initialized to 1.\n    EMP_TRACK_CONSTRUCT(WebWidget);\n  }\n\n  Widget::Widget(WidgetInfo * in_info) {\n    info = in_info;\n    if (info) info->ptr_count++;\n    EMP_TRACK_CONSTRUCT(WebWidget);\n  }\n\n  Widget::~Widget() {\n    // We are deleting a widget.\n    if (info) {\n      info->ptr_count--;\n      if (info->ptr_count == 0) delete info;\n    }\n    EMP_TRACK_DESTRUCT(WebWidget);\n  }\n\n  std::string Widget::GetInfoTypeName() const { if (IsNull()) return \"NULL\"; return info->GetTypeName(); }\n\n  Widget & Widget::SetInfo(WidgetInfo * in_info) {\n    // If the widget is already set correctly, stop here.\n    if (info == in_info) return *this;\n\n    // Clean up the old info that was previously pointed to.\n    if (info) {\n      info->ptr_count--;\n      if (info->ptr_count == 0) delete info;\n    }\n\n    // Setup new info.\n    info = in_info;\n    if (info) info->ptr_count++;\n\n    return *this;\n  }\n\n  bool Widget::IsInactive() const { if (!info) return false; return info->state == INACTIVE; }\n  bool Widget::IsWaiting() const { if (!info) return false; return info->state == WAITING; }\n  bool Widget::IsFrozen() const { if (!info) return false; return info->state == FROZEN; }\n  bool Widget::IsActive() const { if (!info) return false; return info->state == ACTIVE; }\n\n  bool Widget::AppendOK() const { if (!info) return false; return info->AppendOK(); }\n  void Widget::PreventAppend() { emp_assert(info); info->PreventAppend(); }\n\n  const std::string Widget::no_name = \"(none)\";\n  const std::string & Widget::GetID() const { return info ? info->id : no_name; }\n\n  const std::string & Widget::GetCSS(const std::string & setting) const {\n    return info ? info->extras.GetStyle(setting) : emp::empty_string();\n  }\n  bool Widget::HasCSS(const std::string & setting) {\n    return info ? info->extras.HasStyle(setting) : false;\n  }\n\n  const std::string & Widget::GetAttr(const std::string & setting) const {\n    return info ? info->extras.GetAttr(setting) : emp::empty_string();\n  }\n  bool Widget::HasAttr(const std::string & setting) {\n    return info ? info->extras.HasAttr(setting) : false;\n  }\n\n  double Widget::GetXPos() {\n    if (!info) return -1.0;\n    emp_assert(GetID() != \"\");  // Must have a name!\n    return MAIN_THREAD_EM_ASM_DOUBLE({\n      var id = UTF8ToString($0);\n      var rect = $('#' + id).position();\n      if (rect === undefined) return -1.0;\n      return rect.left;\n    }, GetID().c_str());\n  }\n\n  double Widget::GetYPos() {\n    if (!info) return -1.0;\n    emp_assert(GetID() != \"\");  // Must have a name!\n    return MAIN_THREAD_EM_ASM_DOUBLE({\n      var id = UTF8ToString($0);\n      var rect = $('#' + id).position();\n      if (rect === undefined) return -1.0;\n      return rect.top;\n    }, GetID().c_str());\n  }\n\n  double Widget::GetWidth(){\n    if (!info) return -1.0;\n    emp_assert(GetID() != \"\");  // Must have a name!\n    return MAIN_THREAD_EM_ASM_DOUBLE({\n      var id = UTF8ToString($0);\n      return $('#' + id).width();\n    }, GetID().c_str());\n  }\n  double Widget::GetHeight(){\n    if (!info) return -1.0;\n    emp_assert(GetID() != \"\");  // Must have a name!\n    return MAIN_THREAD_EM_ASM_DOUBLE({\n      var id = UTF8ToString($0);\n      return $('#' + id).height();\n    }, GetID().c_str());\n  }\n  double Widget::GetInnerWidth(){\n    if (!info) return -1.0;\n    emp_assert(GetID() != \"\");  // Must have a name!\n    return MAIN_THREAD_EM_ASM_DOUBLE({\n      var id = UTF8ToString($0);\n      return $('#' + id).innerWidth();\n    }, GetID().c_str());\n  }\n  double Widget::GetInnerHeight(){\n    if (!info) return -1.0;\n    emp_assert(GetID() != \"\");  // Must have a name!\n    return MAIN_THREAD_EM_ASM_DOUBLE({\n      var id = UTF8ToString($0);\n      return $('#' + id).innerHeight();\n    }, GetID().c_str());\n  }\n  double Widget::GetOuterWidth(){\n    if (!info) return -1.0;\n    emp_assert(GetID() != \"\");  // Must have a name!\n    return MAIN_THREAD_EM_ASM_DOUBLE({\n      var id = UTF8ToString($0);\n      return $('#' + id).outerWidth();\n    }, GetID().c_str());\n  }\n  double Widget::GetOuterHeight(){\n    if (!info) return -1.0;\n    emp_assert(GetID() != \"\");  // Must have a name!\n    return MAIN_THREAD_EM_ASM_DOUBLE({\n      var id = UTF8ToString($0);\n      return $('#' + id).outerHeight();\n    }, GetID().c_str());\n  }\n\n  void Widget::Activate() {\n    auto * cur_info = info;\n    info->state = WAITING;\n    OnDocumentReady( std::function<void(void)>([cur_info](){ cur_info->DoActivate(); }) );\n    OnDocumentLoad( std::function<void(void)>([cur_info](){ cur_info->DoActivate(); }) );\n  }\n\n  void Widget::Freeze() {\n    info->state = FROZEN;\n  }\n\n  void Widget::Deactivate(bool top_level) {\n    if (!info || info->state == INACTIVE) return;  // Skip if we are not active.\n    info->state = INACTIVE;\n    if (top_level) info->ReplaceHTML();            // If at top level, clear the contents\n  }\n\n  bool Widget::ToggleActive() {\n    emp_assert(info);\n    if (info->state != INACTIVE) Deactivate();\n    else Activate();\n    return info->state;\n  }\n\n  void Widget::Redraw() {\n    emp_assert(info);\n    info->ReplaceHTML();\n  }\n\n  Widget & Widget::AddDependant(const Widget & w) {\n    info->AddDependant(w);\n    return *this;\n  }\n\n  template <typename IN_TYPE>\n  Widget Widget::operator<<(IN_TYPE && in_val) {\n    PrepareAppend();\n    return info->Append(std::forward<IN_TYPE>(in_val));\n  }\n\n  std::string Widget::GetInfoType() const {\n    if (!info) return \"UNINITIALIZED\";\n    return info->GetType();\n  }\n\n  #ifndef DOXYGEN_SHOULD_SKIP_THIS\n  namespace internal {\n\n    /// WidgetFacet is a template that provides accessors into Widget with a derived return type.\n    template <typename RETURN_TYPE>\n    class WidgetFacet : public Widget {\n    protected:\n      /// WidgetFacet cannot be built unless within derived class, so constructors are protected\n      WidgetFacet(const std::string & in_id=\"\") : Widget(in_id) { ; }\n      WidgetFacet(const WidgetFacet & in) : Widget(in) { ; }\n      WidgetFacet(const Widget & in) : Widget(in) {\n        // Converting from a generic widget; make sure type is correct or non-existant!\n        emp_assert(!in || dynamic_cast<typename RETURN_TYPE::INFO_TYPE *>( Info(in) ) != NULL,\n                   in.GetID());\n      }\n      WidgetFacet(WidgetInfo * in_info) : Widget(in_info) { ; }\n      WidgetFacet & operator=(const WidgetFacet & in) { Widget::operator=(in); return *this; }\n      virtual ~WidgetFacet() { ; }\n\n      /// CSS-related options may be overridden in derived classes that have multiple styles.\n      /// By default DoCSS will track the new information and apply it (if active) to the widget.\n      virtual void DoCSS(const std::string & setting, const std::string & value) {\n        info->extras.style.DoSet(setting, value);\n        if (IsActive()) Style::Apply(info->id, setting, value);\n      }\n\n      virtual void DoCSS(const std::string & class_) {\n        info->extras.style.AddClass(class_);\n        if (IsActive()) Style::ApplyClass(info->id, class_);\n      }\n\n      /// Attr-related options may be overridden in derived classes that have multiple attributes.\n      /// By default DoAttr will track the new information and apply it (if active) to the widget.\n      virtual void DoAttr(const std::string & setting, const std::string & value) {\n        info->extras.attr.DoSet(setting, value);\n        if (IsActive()) Attributes::Apply(info->id, setting, value);\n      }\n\n      /// New attribute value will be appended to any existing values for this widget, not overridden.\n      virtual void DoAddAttr(const std::string attr, const std::string & value){\n        info->extras.attr.DoAddAttr(attr, value);\n        if (IsActive()) Attributes::Apply(info->id, attr, info->extras.attr.GetAttrValue(attr));\n      }\n\n      /// Listener options may be overridden in derived classes that have multiple listen targets.\n      /// By default DoListen will track new listens and set them up immediately, if active.\n      virtual void DoListen(const std::string & event_name, size_t fun_id) {\n        info->extras.listen.Set(event_name, fun_id);\n        if (IsActive()) Listeners::Apply(info->id, event_name, fun_id);\n      }\n\n    public:\n      using return_t = RETURN_TYPE;\n\n      std::string GetHTML(){\n        std::stringstream ss;\n        info->GetHTML(ss);\n        return ss.str();\n      }\n      /// Set a specific CSS value for this widget.\n      template <typename SETTING_TYPE>\n      return_t & SetCSS(const std::string & setting, SETTING_TYPE && value) {\n        emp_assert(info != nullptr);\n        DoCSS(setting, emp::to_string(value));\n        return (return_t &) *this;\n      }\n\n      /// Set a specific Attribute value for this widget.\n      template <typename SETTING_TYPE>\n      return_t & SetAttr(const std::string & setting, SETTING_TYPE && value) {\n        emp_assert(info != nullptr);\n        DoAttr(setting, emp::to_string(value));\n        return (return_t &) *this;\n      }\n\n      /// Multiple CSS settings can be provided simultaneously.\n      template <typename T1, typename T2, typename... OTHER_SETTINGS>\n      return_t & SetCSS(const std::string & setting1, T1 && val1,\n                        const std::string & setting2, T2 && val2,\n                        OTHER_SETTINGS... others) {\n        SetCSS(setting1, val1);                      // Set the first CSS value.\n        return SetCSS(setting2, val2, others...);    // Recurse to the others.\n      }\n\n      /// Add more than one value to an attribute.\n      template <typename T>\n      return_t & AddAttr(const std::string attr, T && value){\n        emp_assert(info != nullptr);\n        DoAddAttr(attr, emp::to_string(value));\n        return (return_t &) *this;\n      }\n\n      /// Multiple Attributes can be added to simultaneously.\n      template <typename T1, typename T2, typename... OTHER_SETTINGS>\n      return_t & AddAttr(const std::string & setting1, T1 && val1,\n                            const std::string & setting2, T2 && val2,\n                            OTHER_SETTINGS... others) {\n        AddAttr(setting1, val1);                      // Set the first CSS value.\n        return AddAttr(setting2, val2, others...);    // Recurse to the others.\n      }\n\n      /// Multiple Attributes can be provided simultaneously.\n      template <typename T1, typename T2, typename... OTHER_SETTINGS>\n      return_t & SetAttr(const std::string & setting1, T1 && val1,\n                            const std::string & setting2, T2 && val2,\n                            OTHER_SETTINGS... others) {\n        SetAttr(setting1, val1);                      // Set the first CSS value.\n        return SetAttr(setting2, val2, others...);    // Recurse to the others.\n      }\n\n      /// Allow multiple CSS settings to be provided as a single object.\n      /// (still go through DoCSS given need for virtual re-routing.)\n      return_t & SetCSS(const Style & in_style) {\n\n        emp_assert(info != nullptr);\n        for (const auto & s : in_style.GetMap()) {\n          DoCSS(s.first, s.second);\n        }\n        for (const auto & s : in_style.GetClasses()) {\n          DoCSS(s);\n        }\n        return (return_t &) *this;\n      }\n\n      /// Allow multiple Attr settings to be provided as a single object.\n      /// (still go through DoAttr given need for virtual re-routing.)\n      return_t & SetAttr(const Attributes & in_attr) {\n        emp_assert(info != nullptr);\n        for (const auto & a : in_attr.GetMap()) {\n          DoAttr(a.first, a.second);\n        }\n        return (return_t &) *this;\n      }\n\n      /// Provide an event and a function that will be called when that event is triggered.\n      /// In this case, the function as no arguments.\n      return_t & On(const std::string & event_name, const std::function<void()> & fun) {\n        emp_assert(info != nullptr);\n        size_t fun_id = JSWrap(fun);\n        DoListen(event_name, fun_id);\n        return (return_t &) *this;\n      }\n\n      /// Provide an event and a function that will be called when that event is triggered.\n      /// In this case, the function takes a keyboard event as an argument, with full info about keyboard.\n      return_t & On(const std::string & event_name,\n                    const std::function<void(KeyboardEvent evt)> & fun) {\n        emp_assert(info != nullptr);\n        size_t fun_id = JSWrap(fun);\n        DoListen(event_name, fun_id);\n        return (return_t &) *this;\n      }\n\n      /// Provide an event and a function that will be called when that event is triggered.\n      /// In this case, the function takes a mouse event as an argument, with full info about mouse.\n      return_t & On(const std::string & event_name,\n                    const std::function<void(MouseEvent evt)> & fun) {\n        emp_assert(info != nullptr);\n        size_t fun_id = JSWrap(fun);\n        DoListen(event_name, fun_id);\n        return (return_t &) *this;\n      }\n\n      /// Provide an event and a function that will be called when that event is triggered.\n      /// In this case, the function takes two doubles which will be filled in with mouse coordinates.\n      return_t & On(const std::string & event_name,\n                    const std::function<void(double,double)> & fun) {\n        emp_assert(info != nullptr);\n        auto fun_cb = [this, fun](MouseEvent evt){\n          double x = evt.clientX - GetXPos();\n          double y = evt.clientY - GetYPos();\n          fun(x,y);\n        };\n        size_t fun_id = JSWrap(fun_cb);\n        DoListen(event_name, fun_id);\n        return (return_t &) *this;\n      }\n\n      /// Provide a function to be called when the window is resized.\n      template <typename T> return_t & OnResize(T && arg) { return On(\"resize\", arg); }\n\n      /// Provide a function to be called when the mouse button is clicked in this Widget.\n      template <typename T> return_t & OnClick(T && arg) { return On(\"click\", arg); }\n\n      /// Provide a function to be called when the mouse button is double clicked in this Widget.\n      template <typename T> return_t & OnDoubleClick(T && arg) { return On(\"dblclick\", arg); }\n\n      /// Provide a function to be called when the mouse button is pushed down in this Widget.\n      template <typename T> return_t & OnMouseDown(T && arg) { return On(\"mousedown\", arg); }\n\n      /// Provide a function to be called when the mouse button is released in this Widget.\n      template <typename T> return_t & OnMouseUp(T && arg) { return On(\"mouseup\", arg); }\n\n      /// Provide a function to be called whenever the mouse moves in this Widget.\n      template <typename T> return_t & OnMouseMove(T && arg) { return On(\"mousemove\", arg); }\n\n      /// Provide a function to be called whenever the mouse leaves the Widget.\n      template <typename T> return_t & OnMouseOut(T && arg) { return On(\"mouseout\", arg); }\n\n      /// Provide a function to be called whenever the mouse moves over the Widget.\n      template <typename T> return_t & OnMouseOver(T && arg) { return On(\"mouseover\", arg); }\n\n      /// Provide a function to be called whenever the mouse wheel moves in this Widget.\n      template <typename T> return_t & OnMouseWheel(T && arg) { return On(\"mousewheel\", arg); }\n\n      /// Provide a function to be called whenever a key is pressed down in this Widget.\n      template <typename T> return_t & OnKeydown(T && arg) { return On(\"keydown\", arg); }\n\n      /// Provide a function to be called whenever a key is pressed down and released in this Widget.\n      template <typename T> return_t & OnKeypress(T && arg) { return On(\"keypress\", arg); }\n\n      /// Provide a function to be called whenever a key is pressed released in this Widget.\n      template <typename T> return_t & OnKeyup(T && arg) { return On(\"keyup\", arg); }\n\n      /// Provide a function to be called whenever text is copied in this Widget.\n      template <typename T> return_t & OnCopy(T && arg) { return On(\"copy\", arg); }\n\n      /// Provide a function to be called whenever text is cut in this Widget.\n      template <typename T> return_t & OnCut(T && arg) { return On(\"cut\", arg); }\n\n      /// Provide a function to be called whenever text is pasted in this Widget.\n      template <typename T> return_t & OnPaste(T && arg) { return On(\"paste\", arg); }\n\n      /// Create a tooltip for this Widget.\n      return_t & SetTitle(const std::string & _in) { return SetAttr(\"title\", _in); }\n\n      /// Update the width of this Widget.\n      /// @param w new width of the widget\n      /// @param unit defaults to pixels (\"px\"), but can also be a measured distance (e.g, \"inches\") or a percentage(\"%\")\n      return_t & SetWidth(double w, const std::string & unit=\"px\") {\n        return SetCSS(\"width\", emp::to_string(w, unit) );\n      }\n\n      /// Update the height of this Widget.\n      /// @param h new height for the widget\n      /// @param unit defaults to pixels (\"px\"), but can also be a measured distance (e.g, \"inches\") or a percentage(\"%\")\n      return_t & SetHeight(double h, const std::string & unit=\"px\") {\n        return SetCSS(\"height\", emp::to_string(h, unit) );\n      }\n\n      /// Update the size (width and height) of this widget.\n      /// @param w widget width\n      /// @param h widget height\n      /// @param unit defaults to pixels (\"px\"), but can also be a measured distance (e.g, \"inches\") or a percentage(\"%\")\n      return_t & SetSize(double w, double h, const std::string & unit=\"px\") {\n        SetWidth(w, unit); return SetHeight(h, unit);\n      }\n\n      /// Move this widget to the center of its container.\n      return_t & Center() { return SetCSS(\"margin\", \"auto\"); }\n\n      /// Set the x-y position of this widget within its container.\n      return_t & SetPosition(int x, int y, const std::string & unit=\"px\",\n                             const std::string & pos_type=\"absolute\",\n                             const std::string & x_anchor=\"left\",\n                             const std::string & y_anchor=\"top\") {\n        return SetCSS(\"position\", pos_type,\n                      x_anchor, emp::to_string(x, unit),\n                      y_anchor, emp::to_string(y, unit));\n      }\n\n      /// Set the x-y position of this Widget within its container, using the TOP-RIGHT as an anchor.\n      return_t & SetPositionRT(int x, int y, const std::string & unit=\"px\")\n        { return SetPosition(x, y, unit, \"absolute\", \"right\", \"top\"); }\n\n      /// Set the x-y position of this Widget within its container, using the BOTTOM-RIGHT as an anchor.\n      return_t & SetPositionRB(int x, int y, const std::string & unit=\"px\")\n        { return SetPosition(x, y, unit, \"absolute\", \"right\", \"bottom\"); }\n\n      /// Set the x-y position of this Widget within its container, using the BOTTOM-LEFT as an anchor.\n      return_t & SetPositionLB(int x, int y, const std::string & unit=\"px\")\n        { return SetPosition(x, y, unit, \"absolute\", \"left\", \"bottom\"); }\n\n      /// Set the x-y position of this Widget, fixed within the browser window.\n      return_t & SetPositionFixed(int x, int y, const std::string & unit=\"px\")\n        { return SetPosition(x, y, unit, \"fixed\", \"left\", \"top\"); }\n\n      /// Set the x-y position of the top-right corner this Widget, fixed within the browser window.\n      return_t & SetPositionFixedRT(int x, int y, const std::string & unit=\"px\")\n        { return SetPosition(x, y, unit, \"fixed\", \"right\", \"top\"); }\n\n      /// Set the x-y position of the bottom-right corner this Widget, fixed within the browser window.\n      return_t & SetPositionFixedRB(int x, int y, const std::string & unit=\"px\")\n        { return SetPosition(x, y, unit, \"fixed\", \"right\", \"bottom\"); }\n\n      /// Set the x-y position of the bottom-left corner this Widget, fixed within the browser window.\n      return_t & SetPositionFixedLB(int x, int y, const std::string & unit=\"px\")\n        { return SetPosition(x, y, unit, \"fixed\", \"left\", \"bottom\"); }\n\n\n      /// Set this Widget to float appropriately within its containter.\n      return_t & SetFloat(const std::string & f=\"left\") { return SetCSS(\"float\", f); }\n\n      /// Setup how this Widget should handle overflow.\n      return_t & SetOverflow(const std::string & o=\"auto\") { return SetCSS(\"overflow\", o); }\n\n      /// Setup how this Widget to always have scrollbars.\n      return_t & SetScroll() { return SetCSS(\"overflow\", \"scroll\"); }\n\n      /// Setup how this Widget to have scrollbars if needed for overflow.\n      return_t & SetScrollAuto() { return SetCSS(\"overflow\", \"auto\"); }\n\n      /// Setup how this Widget to be user-resizable.\n      return_t & SetResizable() { return SetCSS(\"resize\", \"both\"); }\n\n      /// Setup how this Widget for the x only to be user-resizable.\n      return_t & SetResizableX() { return SetCSS(\"resize\", \"horizontal\"); }\n\n      /// Setup how this Widget for the y only to be user-resizable.\n      return_t & SetResizableY() { return SetCSS(\"resize\", \"vertical\"); }\n\n      /// Setup how this Widget to NOT be resizable.\n      return_t & SetResizableOff() { return SetCSS(\"resize\", \"none\"); }\n\n      /// Provide a Font object to setup the font for this widget.\n      return_t & SetFont(const Font & font) {\n        font.ConfigStyle(info->extras.style);\n        return (return_t &) *this;\n      }\n\n      /// Setup the Font to be used in this Widget.\n      return_t & SetFont(const std::string & font) { return SetCSS(\"font-family\", font); }\n\n      /// Setup the size of the Font to be used in this Widget.\n      return_t & SetFontSize(int s) { return SetCSS(\"font-size\", emp::to_string(s, \"px\")); }\n\n      /// Setup the size of the Font to be used in this Widget in units of % of viewport width.\n      return_t & SetFontSizeVW(double s) { return SetCSS(\"font-size\", emp::to_string(s, \"vw\")); }\n\n      /// Align text to be centered.\n      return_t & SetCenterText() { return SetCSS(\"text-align\", \"center\"); }\n\n      /// Set the background color of this Widget.\n      return_t & SetBackground(const std::string & v) { return SetCSS(\"background-color\", v); }\n\n      /// Set the foreground color of this Widget.\n      return_t & SetColor(const std::string & v) { return SetCSS(\"color\", v); }\n\n      /// Set the opacity level of this Widget.\n      return_t & SetOpacity(double v) { return SetCSS(\"opacity\", v); }\n\n      /// Set information about the Widget board.\n      return_t & SetBorder(const std::string & border_info) {\n        return SetCSS(\"border\", border_info);\n      }\n\n      /// The the number of pixels (or alternate unit) for the padding around cells (used with Tables)\n      return_t & SetPadding(double p, const std::string & unit=\"px\") {\n        return SetCSS(\"padding\", emp::to_string(p, unit));\n      }\n\n      /// Wrap a wrapper around this Widget.\n      /// @param wrapper the wrapper that will be placed around this Widget\n      /// @return this Widget\n      return_t & WrapWith(Widget wrapper) {\n\n        // if this Widget is already nested within a parent\n        // we'll need to wedge the wrapper between this Widget and the parent\n        // e.g., parent->child will become parent->wrapper->child\n        if (Info(*this)->parent) {\n\n          // parent should be a DivInfo\n          emp_assert(dynamic_cast<internal::DivInfo*>(\n            Info(*this)->parent\n          ));\n\n          const auto parent_info = Info((return_t &) *this)->parent;\n\n          // switch out parent's existing child for wrapper\n          parent_info->RemoveChild((return_t &) *this);\n          parent_info->AddChild(wrapper);\n        }\n\n        // put this Widget inside of the wrapper\n        wrapper << (return_t &) *this;\n\n        return (return_t &) *this;\n      }\n\n      // Add JS function to on_update_js_sig\n      SignalKey RegisterUpdateJS(const std::function<void()> & fun){\n        return info->RegisterUpdateJS(fun);\n      }\n\n    };\n\n  }\n  #endif // DOXYGEN_SHOULD_SKIP_THIS\n\n}\n}\n\n\n#endif // #ifndef EMP_WEB_WIDGET_HPP_INCLUDE\n","// -*- C++ -*-\n//===------------------------ type_traits ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TYPE_TRAITS\n#define _LIBCPP_TYPE_TRAITS\n\n/*\n    type_traits synopsis\n\nnamespace std\n{\n\n    // helper class:\n    template <class T, T v> struct integral_constant;\n    typedef integral_constant<bool, true>  true_type;   // C++11\n    typedef integral_constant<bool, false> false_type;  // C++11\n\n    template <bool B>                                   // C++14\n    using bool_constant = integral_constant<bool, B>;   // C++14\n    typedef bool_constant<true> true_type;              // C++14\n    typedef bool_constant<false> false_type;            // C++14\n\n    // helper traits\n    template <bool, class T = void> struct enable_if;\n    template <bool, class T, class F> struct conditional;\n\n    // Primary classification traits:\n    template <class T> struct is_void;\n    template <class T> struct is_null_pointer;  // C++14\n    template <class T> struct is_integral;\n    template <class T> struct is_floating_point;\n    template <class T> struct is_array;\n    template <class T> struct is_pointer;\n    template <class T> struct is_lvalue_reference;\n    template <class T> struct is_rvalue_reference;\n    template <class T> struct is_member_object_pointer;\n    template <class T> struct is_member_function_pointer;\n    template <class T> struct is_enum;\n    template <class T> struct is_union;\n    template <class T> struct is_class;\n    template <class T> struct is_function;\n\n    // Secondary classification traits:\n    template <class T> struct is_reference;\n    template <class T> struct is_arithmetic;\n    template <class T> struct is_fundamental;\n    template <class T> struct is_member_pointer;\n    template <class T> struct is_scalar;\n    template <class T> struct is_object;\n    template <class T> struct is_compound;\n\n    // Const-volatile properties and transformations:\n    template <class T> struct is_const;\n    template <class T> struct is_volatile;\n    template <class T> struct remove_const;\n    template <class T> struct remove_volatile;\n    template <class T> struct remove_cv;\n    template <class T> struct add_const;\n    template <class T> struct add_volatile;\n    template <class T> struct add_cv;\n\n    // Reference transformations:\n    template <class T> struct remove_reference;\n    template <class T> struct add_lvalue_reference;\n    template <class T> struct add_rvalue_reference;\n\n    // Pointer transformations:\n    template <class T> struct remove_pointer;\n    template <class T> struct add_pointer;\n\n    template<class T> struct type_identity;                     // C++20\n    template<class T>\n      using type_identity_t = typename type_identity<T>::type;  // C++20\n\n    // Integral properties:\n    template <class T> struct is_signed;\n    template <class T> struct is_unsigned;\n    template <class T> struct make_signed;\n    template <class T> struct make_unsigned;\n\n    // Array properties and transformations:\n    template <class T> struct rank;\n    template <class T, unsigned I = 0> struct extent;\n    template <class T> struct remove_extent;\n    template <class T> struct remove_all_extents;\n\n    // Member introspection:\n    template <class T> struct is_pod;\n    template <class T> struct is_trivial;\n    template <class T> struct is_trivially_copyable;\n    template <class T> struct is_standard_layout;\n    template <class T> struct is_literal_type;\n    template <class T> struct is_empty;\n    template <class T> struct is_polymorphic;\n    template <class T> struct is_abstract;\n    template <class T> struct is_final; // C++14\n    template <class T> struct is_aggregate; // C++17\n\n    template <class T, class... Args> struct is_constructible;\n    template <class T>                struct is_default_constructible;\n    template <class T>                struct is_copy_constructible;\n    template <class T>                struct is_move_constructible;\n    template <class T, class U>       struct is_assignable;\n    template <class T>                struct is_copy_assignable;\n    template <class T>                struct is_move_assignable;\n    template <class T, class U>       struct is_swappable_with;       // C++17\n    template <class T>                struct is_swappable;            // C++17\n    template <class T>                struct is_destructible;\n\n    template <class T, class... Args> struct is_trivially_constructible;\n    template <class T>                struct is_trivially_default_constructible;\n    template <class T>                struct is_trivially_copy_constructible;\n    template <class T>                struct is_trivially_move_constructible;\n    template <class T, class U>       struct is_trivially_assignable;\n    template <class T>                struct is_trivially_copy_assignable;\n    template <class T>                struct is_trivially_move_assignable;\n    template <class T>                struct is_trivially_destructible;\n\n    template <class T, class... Args> struct is_nothrow_constructible;\n    template <class T>                struct is_nothrow_default_constructible;\n    template <class T>                struct is_nothrow_copy_constructible;\n    template <class T>                struct is_nothrow_move_constructible;\n    template <class T, class U>       struct is_nothrow_assignable;\n    template <class T>                struct is_nothrow_copy_assignable;\n    template <class T>                struct is_nothrow_move_assignable;\n    template <class T, class U>       struct is_nothrow_swappable_with; // C++17\n    template <class T>                struct is_nothrow_swappable;      // C++17\n    template <class T>                struct is_nothrow_destructible;\n\n    template <class T> struct has_virtual_destructor;\n\n    template<class T> struct has_unique_object_representations;         // C++17\n\n    // Relationships between types:\n    template <class T, class U> struct is_same;\n    template <class Base, class Derived> struct is_base_of;\n    template <class From, class To> struct is_convertible;\n\n    template <class Fn, class... ArgTypes> struct is_invocable;\n    template <class R, class Fn, class... ArgTypes> struct is_invocable_r;\n\n    template <class Fn, class... ArgTypes> struct is_nothrow_invocable;\n    template <class R, class Fn, class... ArgTypes> struct is_nothrow_invocable_r;\n\n    // Alignment properties and transformations:\n    template <class T> struct alignment_of;\n    template <size_t Len, size_t Align = most_stringent_alignment_requirement>\n        struct aligned_storage;\n    template <size_t Len, class... Types> struct aligned_union;\n    template <class T> struct remove_cvref; // C++20\n\n    template <class T> struct decay;\n    template <class... T> struct common_type;\n    template <class T> struct underlying_type;\n    template <class> class result_of; // undefined\n    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;\n    template <class Fn, class... ArgTypes> struct invoke_result;  // C++17\n\n    // const-volatile modifications:\n    template <class T>\n      using remove_const_t    = typename remove_const<T>::type;  // C++14\n    template <class T>\n      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14\n    template <class T>\n      using remove_cv_t       = typename remove_cv<T>::type;  // C++14\n    template <class T>\n      using add_const_t       = typename add_const<T>::type;  // C++14\n    template <class T>\n      using add_volatile_t    = typename add_volatile<T>::type;  // C++14\n    template <class T>\n      using add_cv_t          = typename add_cv<T>::type;  // C++14\n\n    // reference modifications:\n    template <class T>\n      using remove_reference_t     = typename remove_reference<T>::type;  // C++14\n    template <class T>\n      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14\n    template <class T>\n      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14\n\n    // sign modifications:\n    template <class T>\n      using make_signed_t   = typename make_signed<T>::type;  // C++14\n    template <class T>\n      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14\n\n    // array modifications:\n    template <class T>\n      using remove_extent_t      = typename remove_extent<T>::type;  // C++14\n    template <class T>\n      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14\n\n    // pointer modifications:\n    template <class T>\n      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14\n    template <class T>\n      using add_pointer_t    = typename add_pointer<T>::type;  // C++14\n\n    // other transformations:\n    template <size_t Len, std::size_t Align=default-alignment>\n      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14\n    template <std::size_t Len, class... Types>\n      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14\n    template <class T>\n      using remove_cvref_t    = typename remove_cvref<T>::type;  // C++20\n    template <class T>\n      using decay_t           = typename decay<T>::type;  // C++14\n    template <bool b, class T=void>\n      using enable_if_t       = typename enable_if<b,T>::type;  // C++14\n    template <bool b, class T, class F>\n      using conditional_t     = typename conditional<b,T,F>::type;  // C++14\n    template <class... T>\n      using common_type_t     = typename common_type<T...>::type;  // C++14\n    template <class T>\n      using underlying_type_t = typename underlying_type<T>::type;  // C++14\n    template <class T>\n      using result_of_t       = typename result_of<T>::type;  // C++14\n    template <class Fn, class... ArgTypes>\n      using invoke_result_t   = typename invoke_result<Fn, ArgTypes...>::type;  // C++17\n\n    template <class...>\n      using void_t = void;   // C++17\n\n      // See C++14 20.10.4.1, primary type categories\n      template <class T> inline constexpr bool is_void_v\n        = is_void<T>::value;                                             // C++17\n      template <class T> inline constexpr bool is_null_pointer_v\n        = is_null_pointer<T>::value;                                     // C++17\n      template <class T> inline constexpr bool is_integral_v\n        = is_integral<T>::value;                                         // C++17\n      template <class T> inline constexpr bool is_floating_point_v\n        = is_floating_point<T>::value;                                   // C++17\n      template <class T> inline constexpr bool is_array_v\n        = is_array<T>::value;                                            // C++17\n      template <class T> inline constexpr bool is_pointer_v\n        = is_pointer<T>::value;                                          // C++17\n      template <class T> inline constexpr bool is_lvalue_reference_v\n        = is_lvalue_reference<T>::value;                                 // C++17\n      template <class T> inline constexpr bool is_rvalue_reference_v\n        = is_rvalue_reference<T>::value;                                 // C++17\n      template <class T> inline constexpr bool is_member_object_pointer_v\n        = is_member_object_pointer<T>::value;                            // C++17\n      template <class T> inline constexpr bool is_member_function_pointer_v\n        = is_member_function_pointer<T>::value;                          // C++17\n      template <class T> inline constexpr bool is_enum_v\n        = is_enum<T>::value;                                             // C++17\n      template <class T> inline constexpr bool is_union_v\n        = is_union<T>::value;                                            // C++17\n      template <class T> inline constexpr bool is_class_v\n        = is_class<T>::value;                                            // C++17\n      template <class T> inline constexpr bool is_function_v\n        = is_function<T>::value;                                         // C++17\n\n      // See C++14 20.10.4.2, composite type categories\n      template <class T> inline constexpr bool is_reference_v\n        = is_reference<T>::value;                                        // C++17\n      template <class T> inline constexpr bool is_arithmetic_v\n        = is_arithmetic<T>::value;                                       // C++17\n      template <class T> inline constexpr bool is_fundamental_v\n        = is_fundamental<T>::value;                                      // C++17\n      template <class T> inline constexpr bool is_object_v\n        = is_object<T>::value;                                           // C++17\n      template <class T> inline constexpr bool is_scalar_v\n        = is_scalar<T>::value;                                           // C++17\n      template <class T> inline constexpr bool is_compound_v\n        = is_compound<T>::value;                                         // C++17\n      template <class T> inline constexpr bool is_member_pointer_v\n        = is_member_pointer<T>::value;                                   // C++17\n\n      // See C++14 20.10.4.3, type properties\n      template <class T> inline constexpr bool is_const_v\n        = is_const<T>::value;                                            // C++17\n      template <class T> inline constexpr bool is_volatile_v\n        = is_volatile<T>::value;                                         // C++17\n      template <class T> inline constexpr bool is_trivial_v\n        = is_trivial<T>::value;                                          // C++17\n      template <class T> inline constexpr bool is_trivially_copyable_v\n        = is_trivially_copyable<T>::value;                               // C++17\n      template <class T> inline constexpr bool is_standard_layout_v\n        = is_standard_layout<T>::value;                                  // C++17\n      template <class T> inline constexpr bool is_pod_v\n        = is_pod<T>::value;                                              // C++17\n      template <class T> inline constexpr bool is_literal_type_v\n        = is_literal_type<T>::value;                                     // C++17\n      template <class T> inline constexpr bool is_empty_v\n        = is_empty<T>::value;                                            // C++17\n      template <class T> inline constexpr bool is_polymorphic_v\n        = is_polymorphic<T>::value;                                      // C++17\n      template <class T> inline constexpr bool is_abstract_v\n        = is_abstract<T>::value;                                         // C++17\n      template <class T> inline constexpr bool is_final_v\n        = is_final<T>::value;                                            // C++17\n      template <class T> inline constexpr bool is_aggregate_v\n        = is_aggregate<T>::value;                                        // C++17\n      template <class T> inline constexpr bool is_signed_v\n        = is_signed<T>::value;                                           // C++17\n      template <class T> inline constexpr bool is_unsigned_v\n        = is_unsigned<T>::value;                                         // C++17\n      template <class T, class... Args> inline constexpr bool is_constructible_v\n        = is_constructible<T, Args...>::value;                           // C++17\n      template <class T> inline constexpr bool is_default_constructible_v\n        = is_default_constructible<T>::value;                            // C++17\n      template <class T> inline constexpr bool is_copy_constructible_v\n        = is_copy_constructible<T>::value;                               // C++17\n      template <class T> inline constexpr bool is_move_constructible_v\n        = is_move_constructible<T>::value;                               // C++17\n      template <class T, class U> inline constexpr bool is_assignable_v\n        = is_assignable<T, U>::value;                                    // C++17\n      template <class T> inline constexpr bool is_copy_assignable_v\n        = is_copy_assignable<T>::value;                                  // C++17\n      template <class T> inline constexpr bool is_move_assignable_v\n        = is_move_assignable<T>::value;                                  // C++17\n      template <class T, class U> inline constexpr bool is_swappable_with_v\n        = is_swappable_with<T, U>::value;                                // C++17\n      template <class T> inline constexpr bool is_swappable_v\n        = is_swappable<T>::value;                                        // C++17\n      template <class T> inline constexpr bool is_destructible_v\n        = is_destructible<T>::value;                                     // C++17\n      template <class T, class... Args> inline constexpr bool is_trivially_constructible_v\n        = is_trivially_constructible<T, Args...>::value;                 // C++17\n      template <class T> inline constexpr bool is_trivially_default_constructible_v\n        = is_trivially_default_constructible<T>::value;                  // C++17\n      template <class T> inline constexpr bool is_trivially_copy_constructible_v\n        = is_trivially_copy_constructible<T>::value;                     // C++17\n      template <class T> inline constexpr bool is_trivially_move_constructible_v\n        = is_trivially_move_constructible<T>::value;                     // C++17\n      template <class T, class U> inline constexpr bool is_trivially_assignable_v\n        = is_trivially_assignable<T, U>::value;                          // C++17\n      template <class T> inline constexpr bool is_trivially_copy_assignable_v\n        = is_trivially_copy_assignable<T>::value;                        // C++17\n      template <class T> inline constexpr bool is_trivially_move_assignable_v\n        = is_trivially_move_assignable<T>::value;                        // C++17\n      template <class T> inline constexpr bool is_trivially_destructible_v\n        = is_trivially_destructible<T>::value;                           // C++17\n      template <class T, class... Args> inline constexpr bool is_nothrow_constructible_v\n        = is_nothrow_constructible<T, Args...>::value;                   // C++17\n      template <class T> inline constexpr bool is_nothrow_default_constructible_v\n        = is_nothrow_default_constructible<T>::value;                    // C++17\n      template <class T> inline constexpr bool is_nothrow_copy_constructible_v\n        = is_nothrow_copy_constructible<T>::value;                       // C++17\n      template <class T> inline constexpr bool is_nothrow_move_constructible_v\n        = is_nothrow_move_constructible<T>::value;                       // C++17\n      template <class T, class U> inline constexpr bool is_nothrow_assignable_v\n        = is_nothrow_assignable<T, U>::value;                            // C++17\n      template <class T> inline constexpr bool is_nothrow_copy_assignable_v\n        = is_nothrow_copy_assignable<T>::value;                          // C++17\n      template <class T> inline constexpr bool is_nothrow_move_assignable_v\n        = is_nothrow_move_assignable<T>::value;                          // C++17\n      template <class T, class U> inline constexpr bool is_nothrow_swappable_with_v\n        = is_nothrow_swappable_with<T, U>::value;                       // C++17\n      template <class T> inline constexpr bool is_nothrow_swappable_v\n        = is_nothrow_swappable<T>::value;                               // C++17\n      template <class T> inline constexpr bool is_nothrow_destructible_v\n        = is_nothrow_destructible<T>::value;                             // C++17\n      template <class T> inline constexpr bool has_virtual_destructor_v\n        = has_virtual_destructor<T>::value;                              // C++17\n      template<class T> inline constexpr bool has_unique_object_representations_v // C++17\n        = has_unique_object_representations<T>::value;\n\n      // See C++14 20.10.5, type property queries\n      template <class T> inline constexpr size_t alignment_of_v\n        = alignment_of<T>::value;                                        // C++17\n      template <class T> inline constexpr size_t rank_v\n        = rank<T>::value;                                                // C++17\n      template <class T, unsigned I = 0> inline constexpr size_t extent_v\n        = extent<T, I>::value;                                           // C++17\n\n      // See C++14 20.10.6, type relations\n      template <class T, class U> inline constexpr bool is_same_v\n        = is_same<T, U>::value;                                          // C++17\n      template <class Base, class Derived> inline constexpr bool is_base_of_v\n        = is_base_of<Base, Derived>::value;                              // C++17\n      template <class From, class To> inline constexpr bool is_convertible_v\n        = is_convertible<From, To>::value;                               // C++17\n      template <class Fn, class... ArgTypes> inline constexpr bool is_invocable_v\n        = is_invocable<Fn, ArgTypes...>::value;                          // C++17\n      template <class R, class Fn, class... ArgTypes> inline constexpr bool is_invocable_r_v\n        = is_invocable_r<R, Fn, ArgTypes...>::value;                     // C++17\n      template <class Fn, class... ArgTypes> inline constexpr bool is_nothrow_invocable_v\n        = is_nothrow_invocable<Fn, ArgTypes...>::value;                  // C++17\n      template <class R, class Fn, class... ArgTypes> inline constexpr bool is_nothrow_invocable_r_v\n        = is_nothrow_invocable_r<R, Fn, ArgTypes...>::value;             // C++17\n\n      // [meta.logical], logical operator traits:\n      template<class... B> struct conjunction;                           // C++17\n      template<class... B>\n        inline constexpr bool conjunction_v = conjunction<B...>::value;  // C++17\n      template<class... B> struct disjunction;                           // C++17\n      template<class... B>\n        inline constexpr bool disjunction_v = disjunction<B...>::value;  // C++17\n      template<class B> struct negation;                                 // C++17\n      template<class B>\n        inline constexpr bool negation_v = negation<B>::value;           // C++17\n\n}\n\n*/\n#include <__config>\n#include <cstddef>\n#include <version>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair;\ntemplate <class _Tp> class _LIBCPP_TEMPLATE_VIS reference_wrapper;\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash;\n\ntemplate <class>\nstruct __void_t { typedef void type; };\n\ntemplate <class _Tp>\nstruct __identity { typedef _Tp type; };\n\ntemplate <class _Tp, bool>\nstruct _LIBCPP_TEMPLATE_VIS __dependent_type : public _Tp {};\n\ntemplate <bool _Bp, class _If, class _Then>\n    struct _LIBCPP_TEMPLATE_VIS conditional {typedef _If type;};\ntemplate <class _If, class _Then>\n    struct _LIBCPP_TEMPLATE_VIS conditional<false, _If, _Then> {typedef _Then type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;\n#endif\n\ntemplate <bool, class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};\n\ntemplate <bool, class _Tp = void> struct _LIBCPP_TEMPLATE_VIS enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS enable_if<true, _Tp> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;\n#endif\n\n// addressof\n#ifndef _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n\ntemplate <class _Tp>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\n_LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return __builtin_addressof(__x);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n  return reinterpret_cast<_Tp *>(\n      const_cast<char *>(&reinterpret_cast<const volatile char &>(__x)));\n}\n\n#endif // _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\n#if !defined(_LIBCPP_CXX03_LANG)\ntemplate <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;\n#endif\n\nstruct __two {char __lx[2];};\n\n// helper class:\n\ntemplate <class _Tp, _Tp __v>\nstruct _LIBCPP_TEMPLATE_VIS integral_constant\n{\n    static _LIBCPP_CONSTEXPR const _Tp      value = __v;\n    typedef _Tp               value_type;\n    typedef integral_constant type;\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n         constexpr value_type operator ()() const _NOEXCEPT {return value;}\n#endif\n};\n\ntemplate <class _Tp, _Tp __v>\n_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;\n\n#if _LIBCPP_STD_VER > 14\ntemplate <bool __b>\nusing bool_constant = integral_constant<bool, __b>;\n#define _LIBCPP_BOOL_CONSTANT(__b) bool_constant<(__b)>\n#else\n#define _LIBCPP_BOOL_CONSTANT(__b) integral_constant<bool,(__b)>\n#endif\n\ntypedef _LIBCPP_BOOL_CONSTANT(true)  true_type;\ntypedef _LIBCPP_BOOL_CONSTANT(false) false_type;\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\n// __lazy_and\n\ntemplate <bool _Last, class ..._Preds>\nstruct __lazy_and_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_and_impl<false, _Preds...> : false_type {};\n\ntemplate <>\nstruct __lazy_and_impl<true> : true_type {};\n\ntemplate <class _Pred>\nstruct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_or\n\ntemplate <bool _List, class ..._Preds>\nstruct __lazy_or_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_or_impl<true, _Preds...> : true_type {};\n\ntemplate <>\nstruct __lazy_or_impl<false> : false_type {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_or_impl<false, _Hp, _Tp...>\n        : __lazy_or_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_not\n\ntemplate <class _Pred>\nstruct __lazy_not : integral_constant<bool, !_Pred::type::value> {};\n\n// __and_\ntemplate<class...> struct __and_;\ntemplate<> struct __and_<> : true_type {};\n\ntemplate<class _B0> struct __and_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __and_<_B0, _B1, _B2, _Bn...>\n        : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};\n\n// __or_\ntemplate<class...> struct __or_;\ntemplate<> struct __or_<> : false_type {};\n\ntemplate<class _B0> struct __or_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __or_<_B0, _B1, _B2, _Bn...>\n        : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};\n\n// __not_\ntemplate<class _Tp>\nstruct __not_ : conditional<_Tp::value, false_type, true_type>::type {};\n\n#endif // !defined(_LIBCPP_CXX03_LANG)\n\n// is_const\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const            : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const<_Tp const> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_const_v\n    = is_const<_Tp>::value;\n#endif\n\n// is_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile               : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile<_Tp volatile> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_volatile_v\n    = is_volatile<_Tp>::value;\n#endif\n\n// remove_const\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const            {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const<const _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;\n#endif\n\n// remove_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile               {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile<volatile _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;\n#endif\n\n// remove_cv\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_cv\n{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n#endif\n\n// is_void\n\ntemplate <class _Tp> struct __libcpp_is_void       : public false_type {};\ntemplate <>          struct __libcpp_is_void<void> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_void\n    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_void_v\n    = is_void<_Tp>::value;\n#endif\n\n// __is_nullptr_t\n\ntemplate <class _Tp> struct __is_nullptr_t_impl       : public false_type {};\ntemplate <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __is_nullptr_t\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_null_pointer\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_null_pointer_v\n    = is_null_pointer<_Tp>::value;\n#endif\n#endif\n\n// is_integral\n\ntemplate <class _Tp> struct __libcpp_is_integral                     : public false_type {};\ntemplate <>          struct __libcpp_is_integral<bool>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<signed char>        : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};\n#ifndef _LIBCPP_NO_HAS_CHAR8_T\ntemplate <>          struct __libcpp_is_integral<char8_t>            : public true_type {};\n#endif\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<char16_t>           : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char32_t>           : public true_type {};\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<short>              : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};\ntemplate <>          struct __libcpp_is_integral<int>                : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long long>          : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};\ntemplate <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_integral\n    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_integral_v\n    = is_integral<_Tp>::value;\n#endif\n\n// is_floating_point\n\ntemplate <class _Tp> struct __libcpp_is_floating_point              : public false_type {};\ntemplate <>          struct __libcpp_is_floating_point<float>       : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<double>      : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<long double> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_floating_point\n    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_floating_point_v\n    = is_floating_point<_Tp>::value;\n#endif\n\n// is_array\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array\n    : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[]>\n    : public true_type {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[_Np]>\n    : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_array_v\n    = is_array<_Tp>::value;\n#endif\n\n// is_pointer\n\ntemplate <class _Tp> struct __libcpp_is_pointer       : public false_type {};\ntemplate <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pointer\n    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_pointer_v\n    = is_pointer<_Tp>::value;\n#endif\n\n// is_reference\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference       : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference<_Tp&> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference        : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference<_Tp&&> : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference        : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&>  : public true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&&> : public true_type {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_reference_v\n    = is_reference<_Tp>::value;\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_lvalue_reference_v\n    = is_lvalue_reference<_Tp>::value;\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_rvalue_reference_v\n    = is_rvalue_reference<_Tp>::value;\n#endif\n// is_union\n\n#if __has_feature(is_union) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union\n    : public integral_constant<bool, __is_union(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_union : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union\n    : public __libcpp_union<typename remove_cv<_Tp>::type> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_union_v\n    = is_union<_Tp>::value;\n#endif\n\n// is_class\n\n#if __has_feature(is_class) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class\n    : public integral_constant<bool, __is_class(_Tp)> {};\n\n#else\n\nnamespace __is_class_imp\n{\ntemplate <class _Tp> char  __test(int _Tp::*);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class\n    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_class_v\n    = is_class<_Tp>::value;\n#endif\n\n// is_same\n\ntemplate <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS is_same           : public false_type {};\ntemplate <class _Tp>            struct _LIBCPP_TEMPLATE_VIS is_same<_Tp, _Tp> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_same_v\n    = is_same<_Tp, _Up>::value;\n#endif\n\n// is_function\n\nnamespace __libcpp_is_function_imp\n{\nstruct __dummy_type {};\ntemplate <class _Tp> char  __test(_Tp*);\ntemplate <class _Tp> char __test(__dummy_type);\ntemplate <class _Tp> __two __test(...);\ntemplate <class _Tp> _Tp&  __source(int);\ntemplate <class _Tp> __dummy_type __source(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value ||\n                            is_union<_Tp>::value ||\n                            is_void<_Tp>::value  ||\n                            is_reference<_Tp>::value ||\n                            __is_nullptr_t<_Tp>::value >\nstruct __libcpp_is_function\n    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>\n    {};\ntemplate <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_function\n    : public __libcpp_is_function<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_function_v\n    = is_function<_Tp>::value;\n#endif\n\n// is_member_function_pointer\n\n// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};\n// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};\n//\n\ntemplate <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>\nstruct __member_pointer_traits_imp\n{  // forward declaration; specializations later\n};\n\n\ntemplate <class _Tp> struct __libcpp_is_member_function_pointer\n    : public false_type {};\n\ntemplate <class _Ret, class _Class>\nstruct __libcpp_is_member_function_pointer<_Ret _Class::*>\n    : public is_function<_Ret> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_function_pointer\n    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_member_function_pointer_v\n    = is_member_function_pointer<_Tp>::value;\n#endif\n\n// is_member_pointer\n\ntemplate <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_pointer\n    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_member_pointer_v\n    = is_member_pointer<_Tp>::value;\n#endif\n\n// is_member_object_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_object_pointer\n    : public integral_constant<bool, is_member_pointer<_Tp>::value &&\n                                    !is_member_function_pointer<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_member_object_pointer_v\n    = is_member_object_pointer<_Tp>::value;\n#endif\n\n// is_enum\n\n#if __has_feature(is_enum) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum\n    : public integral_constant<bool, __is_enum(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum\n    : public integral_constant<bool, !is_void<_Tp>::value             &&\n                                     !is_integral<_Tp>::value         &&\n                                     !is_floating_point<_Tp>::value   &&\n                                     !is_array<_Tp>::value            &&\n                                     !is_pointer<_Tp>::value          &&\n                                     !is_reference<_Tp>::value        &&\n                                     !is_member_pointer<_Tp>::value   &&\n                                     !is_union<_Tp>::value            &&\n                                     !is_class<_Tp>::value            &&\n                                     !is_function<_Tp>::value         > {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_enum_v\n    = is_enum<_Tp>::value;\n#endif\n\n// is_arithmetic\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_arithmetic\n    : public integral_constant<bool, is_integral<_Tp>::value      ||\n                                     is_floating_point<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_arithmetic_v\n    = is_arithmetic<_Tp>::value;\n#endif\n\n// is_fundamental\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_fundamental\n    : public integral_constant<bool, is_void<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value ||\n                                     is_arithmetic<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_fundamental_v\n    = is_fundamental<_Tp>::value;\n#endif\n\n// is_scalar\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_scalar\n    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||\n                                     is_member_pointer<_Tp>::value ||\n                                     is_pointer<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value    ||\n                                     is_enum<_Tp>::value           > {};\n\ntemplate <> struct _LIBCPP_TEMPLATE_VIS is_scalar<nullptr_t> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_scalar_v\n    = is_scalar<_Tp>::value;\n#endif\n\n// is_object\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_object\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_array<_Tp>::value  ||\n                                     is_union<_Tp>::value  ||\n                                     is_class<_Tp>::value  > {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_object_v\n    = is_object<_Tp>::value;\n#endif\n\n// is_compound\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_compound\n    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_compound_v\n    = is_compound<_Tp>::value;\n#endif\n\n\n// __is_referenceable  [defns.referenceable]\n\nstruct __is_referenceable_impl {\n    template <class _Tp> static _Tp& __test(int);\n    template <class _Tp> static __two __test(...);\n};\n\ntemplate <class _Tp>\nstruct __is_referenceable : integral_constant<bool,\n    !is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};\n\n\n// add_const\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_const<_Tp>::value     >\nstruct __add_const             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_const<_Tp, false> {typedef const _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_const\n    {typedef typename __add_const<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;\n#endif\n\n// add_volatile\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_volatile<_Tp>::value  >\nstruct __add_volatile             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_volatile\n    {typedef typename __add_volatile<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;\n#endif\n\n// add_cv\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_cv\n    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n// remove_reference\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference        {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&>  {typedef _Tp type;};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&&> {typedef _Tp type;};\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;\n#endif\n\n// add_lvalue_reference\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl            { typedef _Tp  type; };\ntemplate <class _Tp                                       > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_lvalue_reference\n{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl            { typedef _Tp   type; };\ntemplate <class _Tp                                       > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_rvalue_reference\n{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> _Tp&& __declval(int);\ntemplate <class _Tp> _Tp   __declval(long);\n\ntemplate <class _Tp>\ndecltype(_VSTD::__declval<_Tp>(0))\ndeclval() _NOEXCEPT;\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_lvalue_reference<_Tp>::type\ndeclval();\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// __uncvref\n\ntemplate <class _Tp>\nstruct __uncvref  {\n    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __unconstref {\n    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;\n};\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp>\nusing __uncvref_t = typename __uncvref<_Tp>::type;\n#endif\n\n// __is_same_uncvref\n\ntemplate <class _Tp, class _Up>\nstruct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,\n                                   typename __uncvref<_Up>::type> {};\n\n#if _LIBCPP_STD_VER > 17\n// remove_cvref - same as __uncvref\ntemplate <class _Tp>\nstruct remove_cvref : public __uncvref<_Tp> {};\n\ntemplate <class _Tp> using remove_cvref_t = typename remove_cvref<_Tp>::type;\n#endif\n\n\nstruct __any\n{\n    __any(...);\n};\n\n// remove_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer                      {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp*>                {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const>          {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* volatile>       {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const volatile> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;\n#endif\n\n// add_pointer\n\ntemplate <class _Tp,\n        bool = __is_referenceable<_Tp>::value ||\n                is_same<typename remove_cv<_Tp>::type, void>::value>\nstruct __add_pointer_impl\n    {typedef typename remove_reference<_Tp>::type* type;};\ntemplate <class _Tp> struct __add_pointer_impl<_Tp, false>\n    {typedef _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_pointer\n    {typedef typename __add_pointer_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n// type_identity\n#if _LIBCPP_STD_VER > 17\ntemplate<class _Tp> struct type_identity { typedef _Tp type; };\ntemplate<class _Tp> using type_identity_t = typename type_identity<_Tp>::type;\n#endif\n\n// is_signed\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_signed_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(-1) < _Tp(0)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_signed : public __libcpp_is_signed<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_signed_v\n    = is_signed<_Tp>::value;\n#endif\n\n// is_unsigned\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_unsigned_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(0) < _Tp(-1)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_unsigned : public __libcpp_is_unsigned<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_unsigned_v\n    = is_unsigned<_Tp>::value;\n#endif\n\n// rank\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[_Np]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR size_t rank_v\n    = rank<_Tp>::value;\n#endif\n\n// extent\n\ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TEMPLATE_VIS extent\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], 0>\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], 0>\n    : public integral_constant<size_t, _Np> {};\ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, unsigned _Ip = 0>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR size_t extent_v\n    = extent<_Tp, _Ip>::value;\n#endif\n\n// remove_extent\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[]>\n    {typedef _Tp type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[_Np]>\n    {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;\n#endif\n\n// remove_all_extents\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[_Np]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n// decay\n\ntemplate <class _Up, bool>\nstruct __decay {\n    typedef typename remove_cv<_Up>::type type;\n};\n\ntemplate <class _Up>\nstruct __decay<_Up, true> {\npublic:\n    typedef typename conditional\n                     <\n                         is_array<_Up>::value,\n                         typename remove_extent<_Up>::type*,\n                         typename conditional\n                         <\n                              is_function<_Up>::value,\n                              typename add_pointer<_Up>::type,\n                              typename remove_cv<_Up>::type\n                         >::type\n                     >::type type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS decay\n{\nprivate:\n    typedef typename remove_reference<_Tp>::type _Up;\npublic:\n    typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;\n#endif\n\n// is_abstract\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_abstract\n    : public integral_constant<bool, __is_abstract(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_abstract_v\n    = is_abstract<_Tp>::value;\n#endif\n\n// is_final\n\n#if defined(_LIBCPP_HAS_IS_FINAL)\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\n__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};\n#else\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\n__libcpp_is_final : public false_type {};\n#endif\n\n#if defined(_LIBCPP_HAS_IS_FINAL) && _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\nis_final : public integral_constant<bool, __is_final(_Tp)> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_final_v\n    = is_final<_Tp>::value;\n#endif\n\n// is_aggregate\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_IS_AGGREGATE)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\nis_aggregate : public integral_constant<bool, __is_aggregate(_Tp)> {};\n\n#if !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR constexpr bool is_aggregate_v\n    = is_aggregate<_Tp>::value;\n#endif\n\n#endif // _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_IS_AGGREGATE)\n\n// is_base_of\n\n#ifdef _LIBCPP_HAS_IS_BASE_OF\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS is_base_of\n    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};\n\n#else  // _LIBCPP_HAS_IS_BASE_OF\n\nnamespace __is_base_of_imp\n{\ntemplate <class _Tp>\nstruct _Dst\n{\n    _Dst(const volatile _Tp &);\n};\ntemplate <class _Tp>\nstruct _Src\n{\n    operator const volatile _Tp &();\n    template <class _Up> operator const _Dst<_Up> &();\n};\ntemplate <size_t> struct __one { typedef char type; };\ntemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);\ntemplate <class _Bp, class _Dp> __two __test(...);\n}\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS is_base_of\n    : public integral_constant<bool, is_class<_Bp>::value &&\n                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};\n\n#endif  // _LIBCPP_HAS_IS_BASE_OF\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Bp, class _Dp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_base_of_v\n    = is_base_of<_Bp, _Dp>::value;\n#endif\n\n// is_convertible\n\n#if __has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&\n                                     !is_abstract<_T2>::value> {};\n\n#else  // __has_feature(is_convertible_to)\n\nnamespace __is_convertible_imp\n{\ntemplate <class _Tp> void  __test_convert(_Tp);\n\ntemplate <class _From, class _To, class = void>\nstruct __is_convertible_test : public false_type {};\n\ntemplate <class _From, class _To>\nstruct __is_convertible_test<_From, _To,\n    decltype(_VSTD::__is_convertible_imp::__test_convert<_To>(_VSTD::declval<_From>()))> : public true_type\n{};\n\ntemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,\n                     bool _IsFunction = is_function<_Tp>::value,\n                     bool _IsVoid =     is_void<_Tp>::value>\n                     struct __is_array_function_or_void                          {enum {value = 0};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};\n}\n\ntemplate <class _Tp,\n    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>\nstruct __is_convertible_check\n{\n    static const size_t __v = 0;\n};\n\ntemplate <class _Tp>\nstruct __is_convertible_check<_Tp, 0>\n{\n    static const size_t __v = sizeof(_Tp);\n};\n\ntemplate <class _T1, class _T2,\n    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,\n    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>\nstruct __is_convertible\n    : public integral_constant<bool,\n        __is_convertible_imp::__is_convertible_test<_T1, _T2>::value\n#if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value\n              && (!is_const<typename remove_reference<_T2>::type>::value\n                  || is_volatile<typename remove_reference<_T2>::type>::value)\n                  && (is_same<typename remove_cv<_T1>::type,\n                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value\n                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))\n#endif\n    >\n{};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible\n    : public __is_convertible<_T1, _T2>\n{\n    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;\n    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;\n};\n\n#endif  // __has_feature(is_convertible_to)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _From, class _To>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_convertible_v\n    = is_convertible<_From, _To>::value;\n#endif\n\n// is_empty\n\n#if __has_feature(is_empty) || (_GNUC_VER >= 407)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_empty\n    : public integral_constant<bool, __is_empty(_Tp)> {};\n\n#else  // __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct __is_empty1\n    : public _Tp\n{\n    double __lx;\n};\n\nstruct __is_empty2\n{\n    double __lx;\n};\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};\n\ntemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_empty : public __libcpp_empty<_Tp> {};\n\n#endif  // __has_feature(is_empty)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_empty_v\n    = is_empty<_Tp>::value;\n#endif\n\n// is_polymorphic\n\n#if __has_feature(is_polymorphic) || defined(_LIBCPP_COMPILER_MSVC)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)> {};\n\n#else\n\ntemplate<typename _Tp> char &__is_polymorphic_impl(\n    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,\n                       int>::type);\ntemplate<typename _Tp> __two &__is_polymorphic_impl(...);\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_polymorphic\n    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};\n\n#endif // __has_feature(is_polymorphic)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_polymorphic_v\n    = is_polymorphic<_Tp>::value;\n#endif\n\n// has_virtual_destructor\n\n#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool has_virtual_destructor_v\n    = has_virtual_destructor<_Tp>::value;\n#endif\n\n// has_unique_object_representations\n\n#if _LIBCPP_STD_VER > 14 && defined(_LIBCPP_HAS_UNIQUE_OBJECT_REPRESENTATIONS)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_unique_object_representations\n    : public integral_constant<bool,\n       __has_unique_object_representations(remove_cv_t<remove_all_extents_t<_Tp>>)> {};\n\n#if !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool has_unique_object_representations_v\n    = has_unique_object_representations<_Tp>::value;\n#endif\n\n#endif\n\n// alignment_of\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS alignment_of\n    : public integral_constant<size_t, _LIBCPP_ALIGNOF(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR size_t alignment_of_v\n    = alignment_of<_Tp>::value;\n#endif\n\n// aligned_storage\n\ntemplate <class _Hp, class _Tp>\nstruct __type_list\n{\n    typedef _Hp _Head;\n    typedef _Tp _Tail;\n};\n\nstruct __nat\n{\n#ifndef _LIBCPP_CXX03_LANG\n    __nat() = delete;\n    __nat(const __nat&) = delete;\n    __nat& operator=(const __nat&) = delete;\n    ~__nat() = delete;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __align_type\n{\n    static const size_t value = _LIBCPP_PREFERRED_ALIGNOF(_Tp);\n    typedef _Tp type;\n};\n\nstruct __struct_double {long double __lx;};\nstruct __struct_double4 {double __lx[4];};\n\ntypedef\n    __type_list<__align_type<unsigned char>,\n    __type_list<__align_type<unsigned short>,\n    __type_list<__align_type<unsigned int>,\n    __type_list<__align_type<unsigned long>,\n    __type_list<__align_type<unsigned long long>,\n    __type_list<__align_type<double>,\n    __type_list<__align_type<long double>,\n    __type_list<__align_type<__struct_double>,\n    __type_list<__align_type<__struct_double4>,\n    __type_list<__align_type<int*>,\n    __nat\n    > > > > > > > > > > __all_types;\n\ntemplate <class _TL, size_t _Align> struct __find_pod;\n\ntemplate <class _Hp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, __nat>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             void\n                         >::type type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             typename __find_pod<_Tp, _Align>::type\n                         >::type type;\n};\n\ntemplate <class _TL, size_t _Len> struct __find_max_align;\n\ntemplate <class _Hp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};\n\ntemplate <size_t _Len, size_t _A1, size_t _A2>\nstruct __select_align\n{\nprivate:\n    static const size_t __min = _A2 < _A1 ? _A2 : _A1;\n    static const size_t __max = _A1 < _A2 ? _A2 : _A1;\npublic:\n    static const size_t value = _Len < __max ? __min : __max;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>\n    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};\n\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\nstruct _LIBCPP_TEMPLATE_VIS aligned_storage\n{\n    typedef typename __find_pod<__all_types, _Align>::type _Aligner;\n    static_assert(!is_void<_Aligner>::value, \"\");\n    union type\n    {\n        _Aligner __align;\n        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];\n    };\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n#endif\n\n#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \\\ntemplate <size_t _Len>\\\nstruct _LIBCPP_TEMPLATE_VIS aligned_storage<_Len, n>\\\n{\\\n    struct _ALIGNAS(n) type\\\n    {\\\n        unsigned char __lx[(_Len + n - 1)/n * n];\\\n    };\\\n}\n\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);\n// PE/COFF does not support alignment beyond 8192 (=0x2000)\n#if !defined(_LIBCPP_OBJECT_FORMAT_COFF)\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);\n#endif // !defined(_LIBCPP_OBJECT_FORMAT_COFF)\n\n#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// aligned_union\n\ntemplate <size_t _I0, size_t ..._In>\nstruct __static_max;\n\ntemplate <size_t _I0>\nstruct __static_max<_I0>\n{\n    static const size_t value = _I0;\n};\n\ntemplate <size_t _I0, size_t _I1, size_t ..._In>\nstruct __static_max<_I0, _I1, _In...>\n{\n    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :\n                                             __static_max<_I1, _In...>::value;\n};\n\ntemplate <size_t _Len, class _Type0, class ..._Types>\nstruct aligned_union\n{\n    static const size_t alignment_value = __static_max<_LIBCPP_PREFERRED_ALIGNOF(_Type0),\n                                                       _LIBCPP_PREFERRED_ALIGNOF(_Types)...>::value;\n    static const size_t __len = __static_max<_Len, sizeof(_Type0),\n                                             sizeof(_Types)...>::value;\n    typedef typename aligned_storage<__len, alignment_value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __numeric_type\n{\n   static void __test(...);\n   static float __test(float);\n   static double __test(char);\n   static double __test(int);\n   static double __test(unsigned);\n   static double __test(long);\n   static double __test(unsigned long);\n   static double __test(long long);\n   static double __test(unsigned long long);\n   static double __test(double);\n   static long double __test(long double);\n\n   typedef decltype(__test(declval<_Tp>())) type;\n   static const bool value = !is_same<type, void>::value;\n};\n\ntemplate <>\nstruct __numeric_type<void>\n{\n   static const bool value = true;\n};\n\n// __promote\n\ntemplate <class _A1, class _A2 = void, class _A3 = void,\n          bool = __numeric_type<_A1>::value &&\n                 __numeric_type<_A2>::value &&\n                 __numeric_type<_A3>::value>\nclass __promote_imp\n{\npublic:\n    static const bool value = false;\n};\n\ntemplate <class _A1, class _A2, class _A3>\nclass __promote_imp<_A1, _A2, _A3, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\n    typedef typename __promote_imp<_A3>::type __type3;\npublic:\n    typedef decltype(__type1() + __type2() + __type3()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2>\nclass __promote_imp<_A1, _A2, void, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\npublic:\n    typedef decltype(__type1() + __type2()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1>\nclass __promote_imp<_A1, void, void, true>\n{\npublic:\n    typedef typename __numeric_type<_A1>::type type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2 = void, class _A3 = void>\nclass __promote : public __promote_imp<_A1, _A2, _A3> {};\n\n// make_signed / make_unsigned\n\ntypedef\n    __type_list<signed char,\n    __type_list<signed short,\n    __type_list<signed int,\n    __type_list<signed long,\n    __type_list<signed long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__int128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __signed_types;\n\ntypedef\n    __type_list<unsigned char,\n    __type_list<unsigned short,\n    __type_list<unsigned int,\n    __type_list<unsigned long,\n    __type_list<unsigned long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__uint128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __unsigned_types;\n\ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>\n{\n    typedef _Hp type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>\n{\n    typedef typename __find_first<_Tp, _Size>::type type;\n};\n\ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,\n                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>\nstruct __apply_cv\n{\n    typedef _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, false>\n{\n    typedef const _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, false, true>\n{\n    typedef volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, true>\n{\n    typedef const volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, false>\n{\n    typedef _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, false>\n{\n    typedef const _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, true>\n{\n    typedef volatile _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, true>\n{\n    typedef const volatile _Up& type;\n};\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_signed {};\n\ntemplate <class _Tp>\nstruct __make_signed<_Tp, true>\n{\n    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_signed<bool,               true> {};\ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};\ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};\ntemplate <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS make_signed\n{\n    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;\n#endif\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_unsigned {};\n\ntemplate <class _Tp>\nstruct __make_unsigned<_Tp, true>\n{\n    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_unsigned<bool,               true> {};\ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};\ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};\ntemplate <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS make_unsigned\n{\n    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Up = void, class _Vp = void>\nstruct _LIBCPP_TEMPLATE_VIS common_type\n{\npublic:\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp>::type type;\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS common_type<void, void, void>\n{\npublic:\n    typedef void type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, void, void>\n{\npublic:\n    typedef typename common_type<_Tp, _Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, void>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n      )>::type type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// bullet 1 - sizeof...(Tp) == 0\n\ntemplate <class ..._Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type {};\n\n// bullet 2 - sizeof...(Tp) == 1\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp>\n    : public common_type<_Tp, _Tp> {};\n\n// bullet 3 - sizeof...(Tp) == 2\n\ntemplate <class _Tp, class _Up, class = void>\nstruct __common_type2_imp {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type2_imp<_Tp, _Up,\n    typename __void_t<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type type;\n};\n\ntemplate <class _Tp, class _Up,\n          class _DTp = typename decay<_Tp>::type,\n          class _DUp = typename decay<_Up>::type>\nusing __common_type2 =\n  typename conditional<\n    is_same<_Tp, _DTp>::value && is_same<_Up, _DUp>::value,\n    __common_type2_imp<_Tp, _Up>,\n    common_type<_DTp, _DUp>\n  >::type;\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up>\n    : __common_type2<_Tp, _Up> {};\n\n// bullet 4 - sizeof...(Tp) > 2\n\ntemplate <class ...Tp> struct __common_types;\n\ntemplate <class, class = void>\nstruct __common_type_impl {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type_impl<\n    __common_types<_Tp, _Up>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n{\n  typedef typename common_type<_Tp, _Up>::type type;\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n  : __common_type_impl<\n      __common_types<typename common_type<_Tp, _Up>::type, _Vp...> >\n{\n\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, _Vp...>\n    : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_assignable\n\ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };\n\ntemplate <class _Tp, class _Arg>\ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type\n__is_assignable_test(int);\n\ntemplate <class, class>\nfalse_type __is_assignable_test(...);\n\n\ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>\nstruct __is_assignable_imp\n    : public decltype((_VSTD::__is_assignable_test<_Tp, _Arg>(0))) {};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_assignable_imp<_Tp, _Arg, true>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct is_assignable\n    : public __is_assignable_imp<_Tp, _Arg> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_assignable_v\n    = is_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_copy_assignable\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_copy_assignable_v\n    = is_copy_assignable<_Tp>::value;\n#endif\n\n// is_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_move_assignable\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                           typename add_rvalue_reference<_Tp>::type> {};\n#else\n    : public is_copy_assignable<_Tp> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_move_assignable_v\n    = is_move_assignable<_Tp>::value;\n#endif\n\n// is_destructible\n\n//  if it's a reference, return true\n//  if it's a function, return false\n//  if it's   void,     return false\n//  if it's an array of unknown bound, return false\n//  Otherwise, return \"std::declval<_Up&>().~_Up()\" is well-formed\n//    where _Up is remove_all_extents<_Tp>::type\n\ntemplate <class>\nstruct __is_destructible_apply { typedef int type; };\n\ntemplate <typename _Tp>\nstruct __is_destructor_wellformed {\n    template <typename _Tp1>\n    static char  __test (\n        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type\n    );\n\n    template <typename _Tp1>\n    static __two __test (...);\n\n    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);\n};\n\ntemplate <class _Tp, bool>\nstruct __destructible_imp;\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, false>\n   : public _VSTD::integral_constant<bool,\n        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, true>\n    : public _VSTD::true_type {};\n\ntemplate <class _Tp, bool>\nstruct __destructible_false;\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, true> : public _VSTD::false_type {};\n\ntemplate <class _Tp>\nstruct is_destructible\n    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_destructible<_Tp[]>\n    : public _VSTD::false_type {};\n\ntemplate <>\nstruct is_destructible<void>\n    : public _VSTD::false_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_destructible_v\n    = is_destructible<_Tp>::value;\n#endif\n\n// move\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename remove_reference<_Tp>::type&&\nmove(_Tp&& __t) _NOEXCEPT\n{\n    typedef typename remove_reference<_Tp>::type _Up;\n    return static_cast<_Up&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp&&\nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp&&\nforward(typename remove_reference<_Tp>::type&& __t) _NOEXCEPT\n{\n    static_assert(!is_lvalue_reference<_Tp>::value,\n                  \"can not forward an rvalue as an lvalue\");\n    return static_cast<_Tp&&>(__t);\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nmove(_Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmove(const _Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return __t;\n}\n\n\ntemplate <class _Tp>\nclass __rv\n{\n    typedef typename remove_reference<_Tp>::type _Trr;\n    _Trr& t_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Trr* operator->() {return &t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __rv(_Trr& __t) : t_(__t) {}\n};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(_Tp&& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(const _Tp& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#endif\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#if __has_feature(cxx_reference_qualified_functions) || \\\n    (defined(_GNUC_VER) && _GNUC_VER >= 409)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#endif  // __has_feature(cxx_reference_qualified_functions) || _GNUC_VER >= 409\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _MP>\nstruct __member_pointer_traits\n    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,\n                    is_member_function_pointer<_MP>::value,\n                    is_member_object_pointer<_MP>::value>\n{\n//     typedef ... _ClassType;\n//     typedef ... _ReturnType;\n//     typedef ... _FnType;\n};\n\n\ntemplate <class _DecayedFp>\nstruct __member_pointer_class_type {};\n\ntemplate <class _Ret, class _ClassType>\nstruct __member_pointer_class_type<_Ret _ClassType::*> {\n  typedef _ClassType type;\n};\n\n// result_of\n\ntemplate <class _Callable> class result_of;\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fn, bool, bool>\nclass __result_of\n{\n};\n\ntemplate <class _Fn>\nclass __result_of<_Fn(), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()()) type;\n};\n\ntemplate <class _Fn, class _A0>\nclass __result_of<_Fn(_A0), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass __result_of<_Fn(_A0, _A1), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_A0, _A1, _A2), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;\n};\n\ntemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>\nstruct __result_of_mp;\n\n// member function pointer\n\ntemplate <class _MP, class _Tp>\nstruct __result_of_mp<_MP, _Tp, true>\n    : public __identity<typename __member_pointer_traits<_MP>::_ReturnType>\n{\n};\n\n// member data pointer\n\ntemplate <class _MP, class _Tp, bool>\nstruct __result_of_mdp;\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, false>\n{\n    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, true>\n{\n    typedef typename __apply_cv<_Tp, _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mp<_Rp _Class::*, _Tp, false>\n    : public __result_of_mdp<_Rp _Class::*, _Tp,\n            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>\n{\n};\n\n\n\ntemplate <class _Fn, class _Tp>\nclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0>\nclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1>\nclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\n// result_of\n\ntemplate <class _Fn>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn()>\n    : public __result_of<_Fn(),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0)>\n    : public __result_of<_Fn(_A0),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1)>\n    : public __result_of<_Fn(_A0, _A1),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1, _A2)>\n    : public __result_of<_Fn(_A0, _A1, _A2),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T, class... Args> struct is_constructible;\n\nnamespace __is_construct\n{\nstruct __nat {};\n}\n\n#if !defined(_LIBCPP_CXX03_LANG) && (!__has_feature(is_constructible) || \\\n    defined(_LIBCPP_TESTING_FALLBACK_IS_CONSTRUCTIBLE))\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_constructible;\n\ntemplate <class _To, class _From>\nstruct __is_invalid_base_to_derived_cast {\n  static_assert(is_reference<_To>::value, \"Wrong specialization\");\n  using _RawFrom = __uncvref_t<_From>;\n  using _RawTo = __uncvref_t<_To>;\n  static const bool value = __lazy_and<\n        __lazy_not<is_same<_RawFrom, _RawTo>>,\n        is_base_of<_RawFrom, _RawTo>,\n        __lazy_not<__libcpp_is_constructible<_RawTo, _From>>\n  >::value;\n};\n\ntemplate <class _To, class _From>\nstruct __is_invalid_lvalue_to_rvalue_cast : false_type {\n  static_assert(is_reference<_To>::value, \"Wrong specialization\");\n};\n\ntemplate <class _ToRef, class _FromRef>\nstruct __is_invalid_lvalue_to_rvalue_cast<_ToRef&&, _FromRef&> {\n  using _RawFrom = __uncvref_t<_FromRef>;\n  using _RawTo = __uncvref_t<_ToRef>;\n  static const bool value = __lazy_and<\n      __lazy_not<is_function<_RawTo>>,\n      __lazy_or<\n        is_same<_RawFrom, _RawTo>,\n        is_base_of<_RawTo, _RawFrom>>\n    >::value;\n};\n\nstruct __is_constructible_helper\n{\n    template <class _To>\n    static void __eat(_To);\n\n    // This overload is needed to work around a Clang bug that disallows\n    // static_cast<T&&>(e) for non-reference-compatible types.\n    // Example: static_cast<int&&>(declval<double>());\n    // NOTE: The static_cast implementation below is required to support\n    //  classes with explicit conversion operators.\n    template <class _To, class _From,\n              class = decltype(__eat<_To>(_VSTD::declval<_From>()))>\n    static true_type __test_cast(int);\n\n    template <class _To, class _From,\n              class = decltype(static_cast<_To>(_VSTD::declval<_From>()))>\n    static integral_constant<bool,\n        !__is_invalid_base_to_derived_cast<_To, _From>::value &&\n        !__is_invalid_lvalue_to_rvalue_cast<_To, _From>::value\n    > __test_cast(long);\n\n    template <class, class>\n    static false_type __test_cast(...);\n\n    template <class _Tp, class ..._Args,\n        class = decltype(_Tp(_VSTD::declval<_Args>()...))>\n    static true_type __test_nary(int);\n    template <class _Tp, class...>\n    static false_type __test_nary(...);\n\n    template <class _Tp, class _A0, class = decltype(::new _Tp(_VSTD::declval<_A0>()))>\n    static is_destructible<_Tp> __test_unary(int);\n    template <class, class>\n    static false_type __test_unary(...);\n};\n\ntemplate <class _Tp, bool = is_void<_Tp>::value>\nstruct __is_default_constructible\n    : decltype(__is_constructible_helper::__test_nary<_Tp>(0))\n{};\n\ntemplate <class _Tp>\nstruct __is_default_constructible<_Tp, true> : false_type {};\n\ntemplate <class _Tp>\nstruct __is_default_constructible<_Tp[], false> : false_type {};\n\ntemplate <class _Tp, size_t _Nx>\nstruct __is_default_constructible<_Tp[_Nx], false>\n    : __is_default_constructible<typename remove_all_extents<_Tp>::type>  {};\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_constructible\n{\n  static_assert(sizeof...(_Args) > 1, \"Wrong specialization\");\n  typedef decltype(__is_constructible_helper::__test_nary<_Tp, _Args...>(0))\n      type;\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_constructible<_Tp> : __is_default_constructible<_Tp> {};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp, _A0>\n    : public decltype(__is_constructible_helper::__test_unary<_Tp, _A0>(0))\n{};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp&, _A0>\n    : public decltype(__is_constructible_helper::\n    __test_cast<_Tp&, _A0>(0))\n{};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp&&, _A0>\n    : public decltype(__is_constructible_helper::\n    __test_cast<_Tp&&, _A0>(0))\n{};\n\n#endif\n\n#if __has_feature(is_constructible)\ntemplate <class _Tp, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>\n    {};\n#elif !defined(_LIBCPP_CXX03_LANG)\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public __libcpp_is_constructible<_Tp, _Args...>::type {};\n#else\n// template <class T> struct is_constructible0;\n\n//      main is_constructible0 test\n\ntemplate <class _Tp>\ndecltype((_Tp(), true_type()))\n__is_constructible0_test(_Tp&);\n\nfalse_type\n__is_constructible0_test(__any);\n\ntemplate <class _Tp, class _A0>\ndecltype((_Tp(_VSTD::declval<_A0>()), true_type()))\n__is_constructible1_test(_Tp&, _A0&);\n\ntemplate <class _A0>\nfalse_type\n__is_constructible1_test(__any, _A0&);\n\ntemplate <class _Tp, class _A0, class _A1>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))\n__is_constructible2_test(_Tp&, _A0&, _A1&);\n\ntemplate <class _A0, class _A1>\nfalse_type\n__is_constructible2_test(__any, _A0&, _A1&);\n\ntemplate <class _Tp, class _A0, class _A1, class _A2>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>(), _VSTD::declval<_A2>()), true_type()))\n__is_constructible3_test(_Tp&, _A0&, _A1&, _A2&);\n\ntemplate <class _A0, class _A1, class _A2>\nfalse_type\n__is_constructible3_test(__any, _A0&, _A1&, _A2&);\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible0_test(declval<_Tp&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1, class _A2>\nstruct __is_constructible3_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible3_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>(), declval<_A2>()))\n             >::type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible0_imp<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_imp<true, _Tp, _A0>\n    : public is_convertible<_A0, _Tp>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1, class _A2>\nstruct __is_constructible3_imp<true, _Tp, _A0, _A1, _A2>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_void_check\n    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp>\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_void_check\n    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check\n    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1, class _A2>\nstruct __is_constructible3_void_check\n    : public __is_constructible3_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1, _A2>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp>\nstruct __is_constructible0_void_check<true, _Tp>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_void_check<true, _Tp, _A0>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1, class _A2>\nstruct __is_constructible3_void_check<true, _Tp, _A0, _A1, _A2>\n    : public false_type\n    {};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat,\n                     class _A2 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public __is_constructible3_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value\n                                        || is_void<_A2>::value,\n                                           _Tp, _A0, _A1, _A2>\n    {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>\n    : public __is_constructible0_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value,\n                                           _Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, _A0, __is_construct::__nat>\n    : public __is_constructible1_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value,\n                                           _Tp, _A0>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, _A0, _A1, __is_construct::__nat>\n    : public __is_constructible2_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value,\n                                           _Tp, _A0, _A1>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible0_imp<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0>\nstruct __is_constructible1_imp<false, _Ap[_Np], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1, class _A2>\nstruct __is_constructible3_imp<false, _Ap[_Np], _A0, _A1, _A2>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap>\nstruct __is_constructible0_imp<false, _Ap[]>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0>\nstruct __is_constructible1_imp<false, _Ap[], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1, class _A2>\nstruct __is_constructible3_imp<false, _Ap[], _A0, _A1, _A2>\n    : public false_type\n    {};\n\n#endif // __has_feature(is_constructible)\n\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_constructible_v\n    = is_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_default_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_default_constructible\n    : public is_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_default_constructible_v\n    = is_default_constructible<_Tp>::value;\n#endif\n\n// is_copy_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_copy_constructible\n    : public is_constructible<_Tp,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_copy_constructible_v\n    = is_copy_constructible<_Tp>::value;\n#endif\n\n// is_move_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_move_constructible_v\n    = is_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp>\n#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_trivial_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp>\n#endif\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : false_type\n{\n};\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class... _Args>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_constructible_v\n    = is_trivially_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_trivially_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_default_constructible\n    : public is_trivially_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_default_constructible_v\n    = is_trivially_default_constructible<_Tp>::value;\n#endif\n\n// is_trivially_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_constructible\n    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_copy_constructible_v\n    = is_trivially_copy_constructible<_Tp>::value;\n#endif\n\n// is_trivially_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_trivially_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_move_constructible_v\n    = is_trivially_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_assignable\n\n#if __has_feature(is_trivially_assignable) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>\n{\n};\n\n#else  // !__has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // !__has_feature(is_trivially_assignable)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_assignable_v\n    = is_trivially_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_trivially_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_copy_assignable_v\n    = is_trivially_copy_assignable<_Tp>::value;\n#endif\n\n// is_trivially_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_move_assignable_v\n    = is_trivially_move_assignable<_Tp>::value;\n#endif\n\n// is_trivially_destructible\n\n#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible\n    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_trivial_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible\n    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_destructible_v\n    = is_trivially_destructible<_Tp>::value;\n#endif\n\n// is_nothrow_constructible\n\n#if 0\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>\n{\n};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>\n    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n{\n};\n\ntemplate <class _Tp>\nvoid __implicit_conversion_to(_Tp) noexcept { }\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>\n{\n};\n\ntemplate <class _Tp, bool _IsReference, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/false, _IsReference, _Tp, _Args...>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp[_Ns]>\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp>\n#endif\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_nothrow_constructible)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_constructible_v\n    = is_nothrow_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_nothrow_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_default_constructible\n    : public is_nothrow_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_default_constructible_v\n    = is_nothrow_default_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_constructible\n    : public is_nothrow_constructible<_Tp,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_copy_constructible_v\n    = is_nothrow_copy_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_nothrow_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_move_constructible_v\n    = is_nothrow_move_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_assignable\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable\n    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, const _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_nothrow_assignable<_Tp&, _Tp&&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // __has_feature(cxx_noexcept)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_assignable_v\n    = is_nothrow_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_nothrow_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_copy_assignable_v\n    = is_nothrow_copy_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_move_assignable_v\n    = is_nothrow_move_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_destructible\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp> struct __libcpp_is_nothrow_destructible;\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<true, _Tp>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible\n    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[_Ns]>\n    : public is_nothrow_destructible<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&>\n    : public true_type\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&&>\n    : public true_type\n{\n};\n\n#endif\n\n#else\n\ntemplate <class _Tp> struct __libcpp_nothrow_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible\n    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_destructible_v\n    = is_nothrow_destructible<_Tp>::value;\n#endif\n\n// is_pod\n\n#if __has_feature(is_pod) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod\n    : public integral_constant<bool, __is_pod(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod\n    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&\n                                     is_trivially_copy_constructible<_Tp>::value      &&\n                                     is_trivially_copy_assignable<_Tp>::value    &&\n                                     is_trivially_destructible<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_pod_v\n    = is_pod<_Tp>::value;\n#endif\n\n// is_literal_type;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_literal_type\n#ifdef _LIBCPP_IS_LITERAL\n    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||\n                              is_reference<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_literal_type_v\n    = is_literal_type<_Tp>::value;\n#endif\n\n// is_standard_layout;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_standard_layout\n#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_standard_layout_v\n    = is_standard_layout<_Tp>::value;\n#endif\n\n// is_trivially_copyable;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copyable\n#if __has_feature(is_trivially_copyable)\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n#elif _GNUC_VER >= 501\n    : public integral_constant<bool, !is_volatile<_Tp>::value && __is_trivially_copyable(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_copyable_v\n    = is_trivially_copyable<_Tp>::value;\n#endif\n\n// is_trivial;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivial\n#if __has_feature(is_trivial) || _GNUC_VER >= 407\n    : public integral_constant<bool, __is_trivial(_Tp)>\n#else\n    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&\n                                 is_trivially_default_constructible<_Tp>::value>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivial_v\n    = is_trivial<_Tp>::value;\n#endif\n\ntemplate <class _Tp> struct __is_reference_wrapper_impl : public false_type {};\ntemplate <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet1 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet2 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet3 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet4 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet5 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet6 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\n// __invoke forward declarations\n\n// fall back - none of the bullets\n\n#define _LIBCPP_INVOKE_RETURN(...) \\\n    noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__) \\\n    { return __VA_ARGS__; }\n\ntemplate <class ..._Args>\nauto __invoke(__any, _Args&& ...__args) -> __nat;\n\ntemplate <class ..._Args>\nauto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;\n\n// bullets 1, 2 and 3\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\n// bullets 4, 5 and 6\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\n// bullet 7\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\n#undef _LIBCPP_INVOKE_RETURN\n\n// __invokable\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __invokable_r\n{\n    // FIXME: Check that _Ret, _Fp, and _Args... are all complete types, cv void,\n    // or incomplete array types as required by the standard.\n    using _Result = decltype(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n\n    using type =\n        typename conditional<\n            !is_same<_Result, __nat>::value,\n            typename conditional<\n                is_void<_Ret>::value,\n                true_type,\n                is_convertible<_Result, _Ret>\n            >::type,\n            false_type\n        >::type;\n    static const bool value = type::value;\n};\n\ntemplate <class _Fp, class ..._Args>\nusing __invokable = __invokable_r<void, _Fp, _Args...>;\n\ntemplate <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp {\n  static const bool value = false;\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>\n{\n    typedef __nothrow_invokable_r_imp _ThisT;\n\n    template <class _Tp>\n    static void __test_noexcept(_Tp) noexcept;\n\n    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>\n{\n    static const bool value = noexcept(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nusing __nothrow_invokable_r =\n    __nothrow_invokable_r_imp<\n            __invokable_r<_Ret, _Fp, _Args...>::value,\n            is_void<_Ret>::value,\n            _Ret, _Fp, _Args...\n    >;\n\ntemplate <class _Fp, class ..._Args>\nusing __nothrow_invokable =\n    __nothrow_invokable_r_imp<\n            __invokable<_Fp, _Args...>::value,\n            true, void, _Fp, _Args...\n    >;\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of\n    : public enable_if<\n        __invokable<_Fp, _Args...>::value,\n        typename __invokable_r<void, _Fp, _Args...>::_Result>\n{\n};\n\n// result_of\n\ntemplate <class _Fp, class ..._Args>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fp(_Args...)>\n    : public __invoke_of<_Fp, _Args...>\n{\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n#endif\n\n#if _LIBCPP_STD_VER > 14\n\n// invoke_result\n\ntemplate <class _Fn, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS invoke_result\n    : __invoke_of<_Fn, _Args...>\n{\n};\n\ntemplate <class _Fn, class... _Args>\nusing invoke_result_t = typename invoke_result<_Fn, _Args...>::type;\n\n// is_invocable\n\ntemplate <class _Fn, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_invocable\n    : integral_constant<bool, __invokable<_Fn, _Args...>::value> {};\n\ntemplate <class _Ret, class _Fn, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_invocable_r\n    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};\n\ntemplate <class _Fn, class ..._Args>\n_LIBCPP_INLINE_VAR constexpr bool is_invocable_v\n    = is_invocable<_Fn, _Args...>::value;\n\ntemplate <class _Ret, class _Fn, class ..._Args>\n_LIBCPP_INLINE_VAR constexpr bool is_invocable_r_v\n    = is_invocable_r<_Ret, _Fn, _Args...>::value;\n\n// is_nothrow_invocable\n\ntemplate <class _Fn, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_invocable\n    : integral_constant<bool, __nothrow_invokable<_Fn, _Args...>::value> {};\n\ntemplate <class _Ret, class _Fn, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_invocable_r\n    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value> {};\n\ntemplate <class _Fn, class ..._Args>\n_LIBCPP_INLINE_VAR constexpr bool is_nothrow_invocable_v\n    = is_nothrow_invocable<_Fn, _Args...>::value;\n\ntemplate <class _Ret, class _Fn, class ..._Args>\n_LIBCPP_INLINE_VAR constexpr bool is_nothrow_invocable_r_v\n    = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Tp> struct __is_swappable;\ntemplate <class _Tp> struct __is_nothrow_swappable;\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_CXX03_LANG\ntypename enable_if\n<\n    is_move_constructible<_Tp>::value &&\n    is_move_assignable<_Tp>::value\n>::type\n#else\nvoid\n#endif\nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&\n                                    is_nothrow_move_assignable<_Tp>::value)\n{\n    _Tp __t(_VSTD::move(__x));\n    __x = _VSTD::move(__y);\n    __y = _VSTD::move(__t);\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Tp>::value\n>::type\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value);\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))\n               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),\n                                          *_VSTD::declval<_ForwardIterator2>())))\n{\n    swap(*__a, *__b);\n}\n\n// __swappable\n\nnamespace __detail\n{\n// ALL generic swap overloads MUST already have a declaration available at this point.\n\ntemplate <class _Tp, class _Up = _Tp,\n          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>\nstruct __swappable_with\n{\n    template <class _LHS, class _RHS>\n    static decltype(swap(_VSTD::declval<_LHS>(), _VSTD::declval<_RHS>()))\n    __test_swap(int);\n    template <class, class>\n    static __nat __test_swap(long);\n\n    // Extra parens are needed for the C++03 definition of decltype.\n    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;\n    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;\n\n    static const bool value = !is_same<__swap1, __nat>::value\n                           && !is_same<__swap2, __nat>::value;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __swappable_with<_Tp, _Up,  false> : false_type {};\n\ntemplate <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>\nstruct __nothrow_swappable_with {\n  static const bool value =\n#ifndef _LIBCPP_HAS_NO_NOEXCEPT\n      noexcept(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>()))\n  &&  noexcept(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>()));\n#else\n      false;\n#endif\n};\n\ntemplate <class _Tp, class _Up>\nstruct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};\n\n}  // __detail\n\ntemplate <class _Tp>\nstruct __is_swappable\n    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>\n{\n};\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS is_swappable_with\n    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable_with\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_nothrow_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VAR constexpr bool is_swappable_with_v\n    = is_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR constexpr bool is_swappable_v\n    = is_swappable<_Tp>::value;\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VAR constexpr bool is_nothrow_swappable_with_v\n    = is_nothrow_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR constexpr bool is_nothrow_swappable_v\n    = is_nothrow_swappable<_Tp>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#ifdef _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp>\nstruct underlying_type\n{\n    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;\n#endif\n\n#else  // _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp, bool _Support = false>\nstruct underlying_type\n{\n    static_assert(_Support, \"The underyling_type trait requires compiler \"\n                            \"support. Either no such support exists or \"\n                            \"libc++ does not know how to use it.\");\n};\n\n#endif // _LIBCPP_UNDERLYING_TYPE\n\n\ntemplate <class _Tp, bool = is_enum<_Tp>::value>\nstruct __sfinae_underlying_type\n{\n    typedef typename underlying_type<_Tp>::type type;\n    typedef decltype(((type)1) + 0) __promoted_type;\n};\n\ntemplate <class _Tp>\nstruct __sfinae_underlying_type<_Tp, false> {};\n\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nint __convert_to_integral(int __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nunsigned __convert_to_integral(unsigned __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nlong __convert_to_integral(long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nunsigned long __convert_to_integral(unsigned long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nlong long __convert_to_integral(long long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nunsigned long long __convert_to_integral(unsigned long long __val) {return __val; }\n\ntemplate<typename _Fp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename enable_if<is_floating_point<_Fp>::value, long long>::type\n __convert_to_integral(_Fp __val) { return __val; }\n\n#ifndef _LIBCPP_HAS_NO_INT128\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n__int128_t __convert_to_integral(__int128_t __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename __sfinae_underlying_type<_Tp>::__promoted_type\n__convert_to_integral(_Tp __val) { return __val; }\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_member_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(_VSTD::declval<_Up>().operator&()), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_free_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(operator&(_VSTD::declval<_Up>())), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof\n    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value\n                                  || __has_operator_addressof_free_imp<_Tp>::value>\n{};\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class...> using void_t = void;\n\n# ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class... _Args>\nstruct conjunction : __and_<_Args...> {};\ntemplate<class... _Args>\n_LIBCPP_INLINE_VAR constexpr bool conjunction_v\n    = conjunction<_Args...>::value;\n\ntemplate <class... _Args>\nstruct disjunction : __or_<_Args...> {};\ntemplate<class... _Args>\n_LIBCPP_INLINE_VAR constexpr bool disjunction_v\n    = disjunction<_Args...>::value;\n\ntemplate <class _Tp>\nstruct negation : __not_<_Tp> {};\ntemplate<class _Tp>\n_LIBCPP_INLINE_VAR constexpr bool negation_v\n    = negation<_Tp>::value;\n# endif // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_STD_VER > 14\n\n// These traits are used in __tree and __hash_table\n#ifndef _LIBCPP_CXX03_LANG\nstruct __extract_key_fail_tag {};\nstruct __extract_key_self_tag {};\nstruct __extract_key_first_tag {};\n\ntemplate <class _ValTy, class _Key,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_key\n    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,\n                  __extract_key_fail_tag>::type {};\n\ntemplate <class _Pair, class _Key, class _First, class _Second>\nstruct __can_extract_key<_Pair, _Key, pair<_First, _Second>>\n    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,\n                  __extract_key_first_tag, __extract_key_fail_tag>::type {};\n\n// __can_extract_map_key uses true_type/false_type instead of the tags.\n// It returns true if _Key != _ContainerValueTy (the container is a map not a set)\n// and _ValTy == _Key.\ntemplate <class _ValTy, class _Key, class _ContainerValueTy,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_map_key\n    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};\n\n// This specialization returns __extract_key_fail_tag for non-map containers\n// because _Key == _ContainerValueTy\ntemplate <class _ValTy, class _Key, class _RawValTy>\nstruct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>\n    : false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 17\nenum class endian\n{\n    little = 0xDEAD,\n    big    = 0xFACE,\n#if defined(_LIBCPP_LITTLE_ENDIAN)\n    native = little\n#elif defined(_LIBCPP_BIG_ENDIAN)\n    native = big\n#else\n    native = 0xCAFE\n#endif\n};\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#if _LIBCPP_STD_VER > 14\n// std::byte\nnamespace std  // purposefully not versioned\n{\ntemplate <class _Integer>\n  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &\n  operator<<=(byte& __lhs, _Integer __shift) noexcept\n  { return __lhs = __lhs << __shift; }\n\ntemplate <class _Integer>\n  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type\n  operator<< (byte  __lhs, _Integer __shift) noexcept\n  { return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) << __shift)); }\n\ntemplate <class _Integer>\n  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &\n  operator>>=(byte& __lhs, _Integer __shift) noexcept\n  { return __lhs = __lhs >> __shift; }\n\ntemplate <class _Integer>\n  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type\n  operator>> (byte  __lhs, _Integer __shift) noexcept\n  { return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) >> __shift)); }\n\ntemplate <class _Integer>\n  constexpr typename enable_if<is_integral_v<_Integer>, _Integer>::type\n  to_integer(byte __b) noexcept { return static_cast<_Integer>(__b); }\n\n}\n#endif\n\n#endif  // _LIBCPP_TYPE_TRAITS\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2018\n *\n *  @file NullStream.hpp\n *  @brief A handy no-operation output stream.\n *  @note Status: BETA\n */\n\n#ifndef EMP_IO_NULLSTREAM_HPP_INCLUDE\n#define EMP_IO_NULLSTREAM_HPP_INCLUDE\n\n#include <iostream>\n\nnamespace emp {\n\n  /// A no-operation buffer class\n  class NullBuffer : public std::streambuf {\n    public:\n      int overflow(int c) {\n        return c;\n      }\n  };\n\n  /// A no-operation output stream class\n  class NullStream : public std::ostream {\n    public:\n      NullStream() : std::ostream(&m_sb) { ; }\n    private:\n      NullBuffer m_sb{};\n  };\n\n  /// No-operation drop-in replacement for std::cout\n  static NullStream nout;\n\n}\n\n#endif // #ifndef EMP_IO_NULLSTREAM_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2018\n *\n *  @file Document.hpp\n *  @brief Manage an entire document.\n *\n *  The Document class is built off of Div, but initializes the EMP web framework, if\n *  neeeded, and activates itself.  It also provides quick ways to add and lookup\n *  widgets.\n *\n *  For example, you can use doc.AddButon(...) to add a new button to the document,\n *  where the ... can be any of the mechanisms to build a new button.  This technique\n *  works for any widget type.\n *\n *  You can also look up any widget by name.  For example, if you previously created a\n *  Canvas widget with the HTML id \"my_canvas\", you can look it up later by using\n *  doc.Canvas(\"my_canvas\")\n */\n\n#ifndef EMP_WEB_DOCUMENT_HPP_INCLUDE\n#define EMP_WEB_DOCUMENT_HPP_INCLUDE\n\n#include \"events.hpp\"\n\n#include \"Button.hpp\"\n#include \"Canvas.hpp\"\n#include \"Div.hpp\"\n#include \"Element.hpp\"\n#include \"FileInput.hpp\"\n#include \"Image.hpp\"\n#include \"Input.hpp\"\n#include \"Selector.hpp\"\n#include \"Table.hpp\"\n#include \"TextArea.hpp\"\n#include \"Text.hpp\"\n\n#include \"canvas_utils.hpp\"\n#include \"color_map.hpp\"\n\n// Create an optional alternative to main, emp_main, that is only available after a document\n// has loaded and is ready.\n#ifdef EMPIRICAL\n\n#define emp_main() emp_main_on_ready();              \\\n  int main() {                                       \\\n    emp::web::OnDocumentReady( emp_main_on_ready );  \\\n  }                                                  \\\n  emp_main_on_ready()\n\n#else\n#define emp_main main\n#endif\n\nnamespace emp {\nnamespace web {\n\n  class Document : public web::Div {\n  public:\n    Document(const std::string & doc_id) : web::Div(doc_id) { Activate(); }\n    ~Document() { ; }\n\n    // Retrieve specific types of widgets.\n\n    // Shortcut adders for Widgets\n    template <class... T> web::Button AddButton(T &&... args){\n      web::Button new_widget(std::forward<T>(args)...);\n      info->Append(new_widget);\n      return new_widget;\n    }\n    template <class... T> web::Canvas AddCanvas(T &&... args){\n      web::Canvas new_widget(std::forward<T>(args)...);\n      info->Append(new_widget);\n      return new_widget;\n    }\n    template <class... T> web::FileInput AddFileInput(T &&... args){\n      web::FileInput new_widget(std::forward<T>(args)...);\n      info->Append(new_widget);\n      return new_widget;\n    }\n    template <class... T> web::Image AddImage(T &&... args) {\n      web::Image new_widget(std::forward<T>(args)...);\n      info->Append(new_widget);\n      return new_widget;\n    }\n    template <class... T> web::Selector AddSelector(T &&... args){\n      web::Selector new_widget(std::forward<T>(args)...);\n      info->Append(new_widget);\n      return new_widget;\n    }\n    template <class... T> web::Div AddDiv(T &&... args) {\n      web::Div new_widget(std::forward<T>(args)...);\n      info->Append(new_widget);\n      return new_widget;\n    }\n    template <class... T> web::Table AddTable(T &&... args) {\n      web::Table new_widget(std::forward<T>(args)...);\n      info->Append(new_widget);\n      return new_widget;\n    }\n    template <class... T> web::Text AddText(T &&... args)  {\n      web::Text new_widget(std::forward<T>(args)...);\n      info->Append(new_widget);\n      return new_widget;\n    }\n    template <class... T> web::TextArea AddTextArea(T &&... args)  {\n      web::TextArea new_widget(std::forward<T>(args)...);\n      info->Append(new_widget);\n      return new_widget;\n    }\n\n\n    // Setup a quick way to retrieve old widgets by name.\n    web::Button Button (const std::string & in_id) { return web::Button(Find(in_id)); }\n    web::Canvas Canvas (const std::string & in_id) { return web::Canvas(Find(in_id)); }\n    web::Element Element (const std::string & in_id) { return web::Element(Find(in_id)); }\n    web::FileInput FileInput (const std::string & in_id) { return web::FileInput(Find(in_id)); }\n    web::Input Input (const std::string & in_id) { return web::Input(Find(in_id)); }\n    web::Image Image (const std::string & in_id) { return web::Image(Find(in_id)); }\n    web::Selector Selector (const std::string & in_id) { return web::Selector(Find(in_id)); }\n    web::Div Div (const std::string & in_id) { return web::Div(Find(in_id)); }\n    web::Table Table (const std::string & in_id) { return web::Table(Find(in_id)); }\n    web::Text Text (const std::string & in_id) { return web::Text(Find(in_id)); }\n    web::TextArea TextArea (const std::string & in_id) { return web::TextArea(Find(in_id)); }\n\n  };\n\n}\n}\n\n\n#endif // #ifndef EMP_WEB_DOCUMENT_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2018\n *\n *  @file Div.hpp\n *  @brief Div Widgets maintain an ordered collection of other widgets in an HTML div.\n *\n *  When printed to the web page, these internal widgets are presented in order.\n *\n *  To create a Div:\n *\n *    emp::web::Div my_div(\"name\");\n *\n *  To use a Div:\n *\n *    my_div << \"Add this text!\"\n *           << emp::web::Image(\"my_image.png\")\n *           << \"<br>\";\n *\n *  To register a Div in a Document:\n *\n *    my_doc << my_div;\n *\n *  @todo Should we move all widget_dict info into Document?\n *  @note Formerly called Slate.h\n */\n\n#ifndef EMP_WEB_DIV_HPP_INCLUDE\n#define EMP_WEB_DIV_HPP_INCLUDE\n\n#include \"Animate.hpp\"\n#include \"init.hpp\"\n#include \"Text.hpp\"\n#include \"Widget.hpp\"\n\nnamespace emp {\nnamespace web {\n\n  class Button;\n  class Canvas;\n  class Image;\n  class Selector;\n  class Div;\n  class Table;\n  class Element;\n\n  #ifndef DOXYGEN_SHOULD_SKIP_THIS\n  namespace internal {\n\n    class TableInfo;\n    class DivInfo : public internal::WidgetInfo {\n      friend Element; friend Div; friend TableInfo;\n    protected:\n      double scroll_top;                              ///< Where should div scroll to? (0.0 to 1.0)\n      emp::vector<Widget> m_children;                 ///< Widgets contained in this one.\n      bool append_ok;                                 ///< Can we add more children?\n      bool text_append;                               ///< Can we append to a current text widget?\n      std::map<std::string, Widget> widget_dict;      ///< By-name lookup for descendent widgets\n      std::map<std::string, web::Animate *> anim_map; ///< Streamline creation of Animate objects.\n      std::string tag; ///< Jury rig this class for non-div duty (i.e., footer, header, p, etc.)\n\n      /// @param in_tag sets the html tag for used this object (i.e., div, footer, header, p, etc.)\n      /// @param in_id the id to assign to the html element for this object\n      DivInfo(const std::string & in_id=\"\", const std::string & in_tag=\"div\")\n        : internal::WidgetInfo(in_id), scroll_top(0.0), append_ok(true), text_append(false)\n        , widget_dict(), anim_map(), tag(in_tag)\n      {\n        emp::Initialize();\n      }\n      DivInfo(const DivInfo &) = delete;              // No copies of INFO allowed\n      DivInfo & operator=(const DivInfo &) = delete;  // No copies of INFO allowed\n      virtual ~DivInfo() {\n        for (auto & p : anim_map) delete p.second;    // Delete this document's animations.\n      }\n\n      std::string GetTypeName() const override { return \"DivInfo\"; }\n\n       /// Set the html tag for used this object (i.e., div, footer, header, p, etc.)\n      void DoSetTag(const std::string & tag_name) {\n        tag = tag_name;\n        if (state == Widget::ACTIVE) ReplaceHTML();\n      }\n\n\n      bool IsRegistered(const std::string & test_name) const {\n        return (widget_dict.find(test_name) != widget_dict.end());\n      }\n\n      Widget & GetRegistered(const std::string & find_name) {\n        emp_assert(IsRegistered(find_name), find_name, widget_dict.size());\n        return widget_dict[find_name];\n      }\n\n      void Register_recurse(Widget & new_widget) override {\n        emp_assert(IsRegistered(new_widget.GetID()) == false, new_widget.GetID());\n        widget_dict[new_widget.GetID()] = new_widget;     // Track widget by name\n        if (parent) parent->Register_recurse(new_widget); // Also register in parent, if available\n      }\n\n      // Register is used so we can lookup classes by name.\n      void Register(Widget & new_widget) override {\n        Register_recurse(new_widget);          // Register THIS widget here and in ancestors.\n        new_widget->RegisterChildren( this );  // Register CHILD widgets, if any\n      }\n\n      void RegisterChildren(DivInfo * registrar) override {\n        for (Widget & child : m_children) registrar->Register(child);\n      }\n\n      void Unregister_recurse(Widget & old_widget) override {\n        emp_assert(IsRegistered(old_widget.GetID()) == true, old_widget.GetID());\n        widget_dict.erase(old_widget.GetID());\n        if (parent) parent->Unregister_recurse(old_widget); // Unregister in parent, if available\n      }\n\n      void Unregister(Widget & old_widget) override {\n        Unregister_recurse(old_widget);          // Unregister this node from all above.\n        old_widget->UnregisterChildren( this );  // Unregister all children, if any.\n        old_widget->parent = nullptr;\n        old_widget.Deactivate(false);\n      }\n\n      void UnregisterChildren(DivInfo * registrar) override {\n        for (Widget & child : m_children) registrar->Unregister(child);\n      }\n\n      void ClearChildren() {\n        // Unregister all children and then delete links to them.\n        for (Widget & child : m_children) Unregister(child);\n        m_children.clear();\n        if (state == Widget::ACTIVE) ReplaceHTML();\n      }\n\n      /// Remove a specific Widget child.\n      /// @param child the Widget to remove\n      void RemoveChild(Widget & child) override {\n        // ensure child is present\n        emp_assert(1 == std::count(\n          std::begin(m_children),\n          std::end(m_children),\n          child\n        ));\n        // unregister and remove child\n        Unregister(*std::find(\n          std::begin(m_children),\n          std::end(m_children),\n          child\n        ));\n        m_children.erase(\n          std::remove(\n            std::begin(m_children),\n            std::end(m_children),\n            child\n          ),\n          std::end(m_children)\n        );\n        // render changes\n        if (state == Widget::ACTIVE) ReplaceHTML();\n      }\n\n      void Clear() {\n        ClearChildren();\n        extras.Clear();\n        if (state == Widget::ACTIVE) ReplaceHTML();\n      }\n\n      // Add a child Widget\n      // @param in the Widget to add\n      void AddChild(Widget in) override {\n        // If the inserted widget is already active, remove it from its old position.\n        emp_assert(in->parent == nullptr && \"Cannot insert widget if already has parent!\", in->id, in->parent->id);\n        emp_assert(in->state != Widget::ACTIVE && \"Cannot insert a stand-alone active widget!\");\n\n        // Setup parent-child relationship\n        m_children.emplace_back(in);\n        in->parent = this;\n        Register(in);\n\n        // If this element (as new parent) is active, anchor widget and activate it!\n        if (state == Widget::ACTIVE) {\n          // Create a span tag to anchor the new widget.\n          MAIN_THREAD_ASYNC_EM_ASM({\n            parent_id = UTF8ToString($0);\n            child_id = UTF8ToString($1);\n            $(`#${parent_id}`).append(`<span id=\"${child_id}\"></span>`);\n          }, id.c_str(), in.GetID().c_str());\n\n          // Now that the new widget has some place to hook in, activate it!\n          in->DoActivate();\n        }\n      }\n\n      void DoActivate(bool top_level=true) override {\n        for (auto & child : m_children) child->DoActivate(false);\n        internal::WidgetInfo::DoActivate(top_level);\n      }\n\n\n      // Return a text element for appending.  Use the last element unless there are no elements,\n      // the last element is not text, or it is not appendable (instead, build a new one).\n      web::Text & GetTextWidget() {\n        // If the final element is not appendable text, add a new Text widget.\n        if (m_children.size() == 0\n            || m_children.back().IsText() == false\n            || m_children.back().AppendOK() == false\n            || text_append == false)  {\n          AddChild(Text());\n          text_append = true;\n        }\n        return (Text &) m_children.back();\n      }\n\n      bool AppendOK() const override { return append_ok; }\n      void PreventAppend() override { append_ok = false; }\n\n      // Add additional children on to this element.\n      Widget Append(const std::string & text) override {\n        if (!append_ok) return ForwardAppend(text);\n        return GetTextWidget() << text;\n      }\n      Widget Append(const std::function<std::string()> & in_fun) override {\n        if (!append_ok) return ForwardAppend(in_fun);\n        return GetTextWidget() << in_fun;\n      }\n\n      Widget Append(Widget info) override {\n        if (!append_ok) return ForwardAppend(info);\n        AddChild(info);\n        text_append = false;   // A widget is being passed in, so don't all text appends.\n        return info;\n      }\n\n      /// Start a new set of Text with this font (even if one already exists.)\n      Widget Append(const Font & font) override {\n        if (!append_ok) return ForwardAppend(font);\n        Text new_text;          // Build a new text widget for this font.\n        new_text.SetFont(font); // Setup the new text widget with the provided font.\n        AddChild(new_text);     // Add this new text widget to this div.\n        text_append = true;     // Since we added a Text widget with this font, it can be extended.\n        return new_text;\n      }\n\n      // All derived widgets must supply a mechanism for providing associated HTML code.\n      virtual void GetHTML(std::stringstream & HTML) override {\n        HTML.str(\"\");       // Clear the current text.\n\n        // Loop through all children and build a span element for each to replace.\n        HTML << \"<\" << tag << \" id=\\'\" << id << \"\\'>\"; // Tag to envelop Div\n        for (Widget & w : m_children) {\n          HTML << \"<span id=\\'\" << w.GetID() << \"'></span>\";  // Span element for current widget.\n        }\n        HTML << \"</\" << tag << \">\";\n      }\n\n\n      void ReplaceHTML() override {\n        // Replace Div's HTML...\n        internal::WidgetInfo::ReplaceHTML();\n\n        // Then replace children.\n        if (state == Widget::ACTIVE) {\n          for (auto & child : m_children) child->ReplaceHTML();\n        }\n\n        if (scroll_top >= 0.0) {\n          MAIN_THREAD_ASYNC_EM_ASM({\n              var div_id = UTF8ToString($0);\n              var div_obj = $(`#${div_id}`);\n              if (div_obj == null) alert(div_id);\n              // alert('id=' + div_id + '  top=' + $1 +\n              //       '  height=' + div_obj.scrollHeight);\n              var scroll_top = $1 * div_obj.scrollHeight;\n              div_obj.scrollTop = scroll_top;\n            }, id.c_str(), scroll_top);\n        }\n\n        // @CAO If scrolltop is set, handle scrolling!\n    // float scroll_frac = ((float) (hardware->GetIP() - 3)) / (float) hardware->GetNumInsts();\n    // if (scroll_frac < 0.0) scroll_frac = 0.0;\n\n    // MAIN_THREAD_EM_ASM({\n    //     var code = UTF8ToString($0);\n    //     var code_obj = document.getElementById(\"code\");\n    //     code_obj.innerHTML = code;\n    //     code_obj.scrollTop = $1 * code_obj.scrollHeight;\n    //     var cycle_obj = document.getElementById(\"cycle_count\");\n    //     cycle_obj.innerHTML = \"&nbsp;&nbsp;&nbsp;Cycles Used = \" + $2;\n    // }, ss.str().c_str(), scroll_frac, hardware->GetExeCount());\n\n        internal::WidgetInfo::TriggerJS();\n\n      }\n\n    public:\n      virtual std::string GetType() override { return \"web::DivInfo\"; }\n    };\n  }\n  #endif // DOXYGEN_SHOULD_SKIP_THIS\n\n  /// A widget to track a div in an HTML file, and all of its contents.\n  class Div : public internal::WidgetFacet<Div> {\n  protected:\n    // Get a properly cast version of info.\n    internal::DivInfo * Info() { return (internal::DivInfo *) info; }\n    const internal::DivInfo * Info() const { return (internal::DivInfo *) info; }\n    Div(internal::DivInfo * in_info) : WidgetFacet(in_info) { ; }\n\n  public:\n    Div(const std::string & in_name=\"\") : WidgetFacet(in_name) {\n      // When a name is provided, create an associated Widget info.\n      info = new internal::DivInfo(in_name);\n    }\n    Div(const Div & in) : WidgetFacet(in) { ; }\n    Div(const Widget & in) : WidgetFacet(in) { emp_assert(in.IsDiv()); }\n    ~Div() { ; }\n\n    using INFO_TYPE = internal::DivInfo;\n\n    /// Where is the top of the scroll region?\n    double ScrollTop() const { return Info()->scroll_top; }\n\n    /// Set the scroll position.\n    Div & ScrollTop(double in_top) { Info()->scroll_top = in_top; return *this; }\n\n    /// Clear the contents of this div.\n    void Clear() { if (info) Info()->Clear(); }\n\n    /// Remove all child widgets from this div.\n    void ClearChildren() { if (info) Info()->ClearChildren(); }\n\n    /// Determine if a specified widget is internal to this one.\n    bool HasChild(const Widget & test_child) const {\n      if (!info) return false;\n      for (const Widget & c : Info()->m_children) if (c == test_child) return true;\n      return false;\n    }\n\n    /// Remove this widget from the current document.\n    void Deactivate(bool top_level) override {\n      // Deactivate children before this node.\n      for (auto & child : Info()->m_children) child.Deactivate(false);\n      Widget::Deactivate(top_level);\n    }\n\n    /// Get an internal widget to this div, by the specified name.\n    Widget & Find(const std::string & test_name) {\n      emp_assert(info);\n      return Info()->GetRegistered(test_name);\n    }\n\n    /// Determine if a specified widget is internal to this one.\n    bool HasChild(const std::string & test_name) const {\n      emp_assert(info);\n      return Info()->IsRegistered(test_name);\n    }\n\n\n    /// Get all direct child widgets to this div.\n    emp::vector<Widget> & Children() { return Info()->m_children; }\n\n    /// Shortcut adder for animations.\n    template <class... T> web::Animate & AddAnimation(const std::string & name, T &&... args){\n      web::Animate * new_anim = new web::Animate(std::forward<T>(args)...);\n      emp_assert(Info()->anim_map.find(name) == Info()->anim_map.end());  // Make sure not in map already!\n      Info()->anim_map[name] = new_anim;\n      return *new_anim;\n    }\n\n    // A quick way to retrieve Animate widgets by name.\n    // TODO: may want to change this to use .at() rather than [] since this default\n    // constructs an Animate object if one doesn't exist!\n    web::Animate & Animate (const std::string & in_id) { return *(Info()->anim_map[in_id]); }\n  };\n\n  // using Slate = Div;    // For backward compatability...\n}\n}\n\n#endif // #ifndef EMP_WEB_DIV_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2018.\n *\n *  @file init.hpp\n *  @brief Define Initialize() and other functions to set up Empirical to build Emscripten projects.\n *\n * Init.hpp should always be included if you are compiling Empirical's web tools with Emscripten. It\n * handles making sure that behind the scenes stuff is all set up properly. It also defines some\n * useful stubs and dummy functions so that your code will still be possible to comple with a normal\n * C++ compiler (although the web part won't do anything, of course). These stubs are also helpful\n * for avoiding confusion in linters and IDEs.\n */\n\n#ifndef EMP_WEB_INIT_HPP_INCLUDE\n#define EMP_WEB_INIT_HPP_INCLUDE\n\n#ifndef DOXYGEN_SHOULD_SKIP_THIS // This file is just going to confuse doxygen\n\n#include <type_traits>\n\n#include \"../base/assert_warning.hpp\"\n#include \"../tools/string_utils.hpp\"\n\n/// If __EMSCRIPTEN__ is defined, initialize everything.  Otherwise create useful stubs.\n#ifdef __EMSCRIPTEN__\n\n#include <emscripten.h>\n\n#ifdef  __EMSCRIPTEN_PTHREADS__\n#include <pthread.h>\n#endif //  __EMSCRIPTEN_PTHREADS__\n\nextern \"C\" {\n  extern void EMP_Initialize();\n}\n\nnamespace emp {\n\n  /// Setup timings on animations through Emscripten.\n  static void InitializeAnim() {\n    thread_local bool init = false;      // Make sure we only initialize once!\n    if (!init) {\n      // Setup the animation callback in Javascript\n      MAIN_THREAD_EM_ASM({\n        window.requestAnimFrame = (function(callback) {\n            return window.requestAnimationFrame\n              || window.webkitRequestAnimationFrame\n              || window.mozRequestAnimationFrame\n              || window.oRequestAnimationFrame\n              || window.msRequestAnimationFrame\n              || function(callback) { window.setTimeout(callback, 1000 / 60); };\n          })();\n      });\n    }\n    init = true;\n  }\n\n  /// Add a listener on the browser thread that will look for incoming\n  /// bitmaps and transfer them into web canvases.\n  static void InitializeBitmapListener() {\n    #ifdef __EMSCRIPTEN_PTHREADS__\n\n    // adapted from https://stackoverflow.com/a/18002694\n    if ( EM_ASM_INT({ // detect if we are a web worker\n      return typeof WorkerGlobalScope !== 'undefined'\n        && self instanceof WorkerGlobalScope;\n    }) ) {\n      MAIN_THREAD_EM_ASM({\n        console.assert( Object.keys( PThread.pthreads ).length === 1 );\n        Object.values(PThread.pthreads)[0].worker.addEventListener(\n          'message',\n          function( event ){\n            if ( event.data.emp_canvas_id ) {\n              document.getElementById(\n                event.data.emp_canvas_id\n              ).getContext(\"bitmaprenderer\").transferFromImageBitmap( event.data.emp_bitmap\n              );\n            }\n          }\n        )\n      });\n    }\n\n    #endif // __EMSCRIPTEN_PTHREADS__\n  }\n\n  /// Create a offscreen canvases registry that maps id to impl and a registry\n  /// for updated canvases that need to be sent to the main thread.\n  static void InitializeOffscreenCanvasRegistries() {\n    #ifdef __EMSCRIPTEN_PTHREADS__\n\n    // adapted from https://stackoverflow.com/a/18002694\n    if ( EM_ASM_INT({ // detect if we are a web worker\n      return typeof WorkerGlobalScope !== 'undefined'\n        && self instanceof WorkerGlobalScope;\n    }) ) EM_ASM({\n      emp_i.offscreen_canvases = {};\n      emp_i.pending_offscreen_canvas_ids = new Set();\n    });\n\n    #endif // __EMSCRIPTEN_PTHREADS__\n  }\n\n  /// globalThis polyfill to provide globalThis support in older environments\n  /// adapted from https://mathiasbynens.be/notes/globalthis\n  static void SetupGlobalThisPolyfill() {\n    EM_ASM({\n      (function() {\n        if (typeof globalThis === 'object') return;\n        Object.prototype.__defineGetter__('__magic__', function() {\n          return this;\n        });\n        __magic__.globalThis = __magic__; // lolwat\n        delete Object.prototype.__magic__;\n      }());\n    });\n  }\n\n  /// Do all initializations for using EMP tricks with Emscripten.\n  static void Initialize() {\n\n    SetupGlobalThisPolyfill();\n\n    // have to dip into javascript because static and thread_local are wonky\n    // with pthreads\n    const bool should_run = EM_ASM_INT({\n      if ( !globalThis.emp_init_once_flag ) {\n        globalThis.emp_init_once_flag = true;\n        return true;\n      } else return false;\n    });\n\n    if ( should_run ) {\n      EMP_Initialize();   // Call JS initializations\n      InitializeAnim();\n\n      #ifdef __EMSCRIPTEN_PTHREADS__\n      MAIN_THREAD_EM_ASM({ _EMP_Initialize(); });\n      InitializeBitmapListener();\n      InitializeOffscreenCanvasRegistries();\n      #endif\n\n    }\n  }\n\n\n  namespace web {\n    // Some helper functions.\n    // Live keyword means that whatever is passed in needs to be re-evaluated every update.\n    namespace internal {\n      /// If a variable is passed in to Live(), construct a function to look up its current value.\n      template <typename VAR_TYPE>\n      std::function<std::string()> Live_impl(VAR_TYPE & var, int) {\n        return [&var](){ return emp::to_string(var); };\n      }\n\n      /// If a non-variable is passed in to Live(), assume it is a function and print it each redraw.\n      template <\n        typename IN_TYPE,\n        typename = std::enable_if_t< std::is_invocable<IN_TYPE>::value >\n      >\n      std::function<std::string()> Live_impl(IN_TYPE && fun, bool) {\n        return [fun](){ return emp::to_string(fun()); };\n      }\n    }\n\n    /// Take a function or variable and set it up so that it can update each time a text box is redrawn.\n    template <typename T>\n    std::function<std::string()> Live(T && val) {\n      return internal::Live_impl(std::forward<T>(val), bool{});\n    }\n\n    inline std::string ToJSLiteral(bool x) {\n      if (x == true) return \"true\";\n      else return \"false\";\n    }\n  }\n\n}\n\n\n// === Initialization for NON-emscripten to ignore macros ===\n\n#else\n\n#define EM_ASM(...)\n#define EM_ASM_ARGS(...)\n#define MAIN_THREAD_EM_ASM(...)\n#define MAIN_THREAD_ASYNC_EM_ASM(...)\n#define MAIN_THREAD_EM_ASM_INT(...) 0\n#define MAIN_THREAD_EM_ASM_DOUBLE(...) 0.0\n#define MAIN_THREAD_EM_ASM_INT_V(...) 0\n#define MAIN_THREAD_EM_ASM_DOUBLE_V(...) 0.0\n\n#define emscripten_run_script(...)\n\n#include <fstream>\n\nnamespace emp {\n\n  std::ofstream debug_file(\"debug_file\");\n  bool init = false;      // Make sure we only initialize once!\n\n  /// Stub for when Emscripten is not in use.\n  static bool Initialize() {\n    // Nothing to do here yet...\n    if (!init) {\n      emp_assert_warning(false && \"Warning: you're using Empirical web features but not compiling with emcc. These features will not do anything unless you use emcc.\");\n    }\n    init = true;\n    return true;\n  }\n\n  /// Stub for when Emscripten is not in use.\n  static bool InitializeAnim() {\n    // Nothing to do here yet...\n    return true;\n  }\n\n  namespace web {\n    inline std::string ToJSLiteral(bool x) {\n      if (x == true) return \"true\";\n      else return \"false\";\n    }\n\n    template <typename T>\n    int Live(T x) {return 0;} // Dummy implementation\n  }\n\n}\n\n#endif\n\n#else // Let doxygen document a non-confusing version of Live\n\n/// Take a function or variable and set it up so that it can update each time a text box is redrawn.\ntemplate <typename T>\nstd::function<std::string()> emp::Live(T && val) {;}\n\n#endif\n\n#endif // #ifndef EMP_WEB_INIT_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2016-2018\n *\n *  @file Signal.hpp\n *  @brief Allow functions to be bundled (as Actions) and triggered enmasse.\n *  @note Status: Beta\n *\n *  @todo Setup easier mechanism to control the order in which actions are triggered.\n *  @todo Signals should have default parameters so not all need be supplied when triggered.\n */\n\n#ifndef EMP_CONTROL_SIGNAL_HPP_INCLUDE\n#define EMP_CONTROL_SIGNAL_HPP_INCLUDE\n\n\n#include <map>\n#include <string>\n\n#include \"../datastructs/map_utils.hpp\"\n#include \"../functional/FunctionSet.hpp\"\n#include \"../meta/TypePack.hpp\"\n\n#include \"Action.hpp\"\n\nnamespace emp {\n\n  /// SignalKey tracks a specific function triggered by a signal. For now, its just a value pair.\n  class SignalKey {\n  private:\n    uint32_t signal_id;   ///< Which signal is this key associated with?\n    uint32_t key_id;      ///< Which key id is this.\n\n    // Internal function to compare two signal kays.\n    int Compare(const SignalKey& in) const {\n      if (signal_id < in.signal_id) return -1;\n      if (signal_id > in.signal_id) return 1;\n      if (key_id < in.key_id) return -1;\n      if (key_id > in.key_id) return 1;\n      return 0;\n    }\n  public:\n    SignalKey(uint32_t _kid=0, uint32_t _sid=0) : signal_id(_sid), key_id(_kid) { ; }\n    SignalKey(const SignalKey &) = default;\n    SignalKey & operator=(const SignalKey &) = default;\n    ~SignalKey() { ; }\n\n    /// Are two signal keys identical?\n    bool operator==(const SignalKey& in) const { return Compare(in) == 0; }\n\n    /// Are two signal keys different?\n    bool operator!=(const SignalKey& in) const { return Compare(in) != 0; }\n\n    bool operator<(const SignalKey& in)  const { return Compare(in) < 0; }\n    bool operator>(const SignalKey& in)  const { return Compare(in) > 0; }\n    bool operator<=(const SignalKey& in) const { return Compare(in) <= 0; }\n    bool operator>=(const SignalKey& in) const { return Compare(in) >= 0; }\n\n    /// What is the KeyID associated with this signal key.\n    uint32_t GetID() const { return key_id; }\n\n    /// What is the ID of the signal that this key is associated with.\n    uint32_t GetSignalID() const { return signal_id; }\n\n    /// Is this key currently pointing to a signal action?\n    bool IsActive() const { return key_id > 0; }\n\n    /// Set this key to specified values.\n    void Set(uint32_t _kid=0, uint32_t _sid=0) { signal_id = _sid; key_id = _kid; }\n\n    /// Clear this key.\n    void Clear() { signal_id = 0; key_id = 0; }\n\n    operator bool() { return key_id > 0; }\n  };\n\n  // Forward declarations.\n  class SignalBase;     // ...for pointers to signals.\n  class SignalManager;  // ...for setting up as friend.\n\n  // Mechanisms for Signals to report to a manager.\n  #ifndef DOXYGEN_SHOULD_SKIP_THIS\n  namespace internal {\n    struct SignalManager_Base {\n      virtual void NotifyConstruct(SignalBase * sig_ptr) = 0;\n      virtual void NotifyDestruct(SignalBase * sig_ptr) = 0;\n      virtual ~SignalManager_Base() { ; }\n    };\n    struct SignalControl_Base {\n      virtual SignalManager_Base & GetSignalManager() = 0;\n      virtual void NotifyConstruct(SignalBase * sig_ptr) = 0;\n      virtual ~SignalControl_Base() { ; }\n    };\n  }\n  #endif // DOXYGEN_SHOULD_SKIP_THIS\n\n  /// Base class for all signals.\n  class SignalBase {\n    friend class SignalManager;  // Allow SignalManager to alter internals of a signal.\n  protected:\n    using man_t = internal::SignalManager_Base;\n\n    std::string name;                          ///< What is the unique name of this signal?\n    uint32_t signal_id;                        ///< What is the unique ID of this signal?\n    uint32_t next_link_id;                     ///< What ID shouild the next link have?\n    std::map<SignalKey, size_t> link_key_map;  ///< Map unique link keys to link index for actions.\n    emp::vector<man_t *> managers;             ///< What manager is handling this signal?\n    man_t * prime_manager;                     ///< Which manager leads deletion? (nullptr for self)\n\n    // Helper Functions\n    SignalKey NextSignalKey() { return SignalKey(signal_id,++next_link_id); }\n\n    // SignalBase should only be constructable from derrived classes.\n    SignalBase(const std::string & n, internal::SignalManager_Base * manager=nullptr)\n    : name(n), signal_id(0), next_link_id(0), link_key_map(), managers(), prime_manager(nullptr)\n    {\n      if (manager) manager->NotifyConstruct(this);\n    }\n  public:\n    SignalBase() = delete;\n    SignalBase(const SignalBase &) = delete;\n    SignalBase(SignalBase &&) = delete;\n    SignalBase & operator=(const SignalBase &) = delete;\n    SignalBase & operator=(SignalBase &&) = delete;\n    virtual ~SignalBase() {\n      // Let all managers other than prime know about destruction (prime must have triggered it.)\n      for (auto * m : managers) if (m != prime_manager) m->NotifyDestruct(this);\n    }\n    virtual SignalBase * Clone() const = 0;\n\n    const std::string & GetName() const { return name; }\n    virtual size_t GetNumArgs() const = 0;\n    virtual size_t GetNumActions() const = 0;\n\n    // NOTE: If a Trigger is called on a base class, convert the signal assuming that the args\n    // map to the correct types (defined below with a dynamic cast to ensure correctness)\n    template <typename... ARGS>\n    void BaseTrigger(ARGS... args);\n\n    /// Actions without arguments or a return type can be associated with any signal.\n    template <typename... ARGS>\n    SignalKey AddAction(const std::function<void(ARGS...)> & in_fun);\n\n    /// Add an action using an Action object.\n    virtual SignalKey AddAction(ActionBase &) = 0;\n\n    /// Test if an action is compatible with a signal.\n    virtual bool TestMatch(ActionBase &) = 0;\n\n    /// Remove an action specified by its key.\n    virtual void Remove(SignalKey key) = 0;\n\n    /// Remove all actions from this signal.\n    void Clear() {\n      // While we still have keys, remove them!\n      while (link_key_map.size()) Remove(link_key_map.begin()->first);\n    }\n\n    bool Has(SignalKey key) const { return emp::Has(link_key_map, key); }\n  };\n\n  /// Generic version of Signals; needs specialization to a function type..\n  template <typename... ARGS> class Signal;\n\n  /// Signals with void return.\n  template <typename... ARGS>\n  class Signal<void(ARGS...)> : public SignalBase {\n  protected:\n    FunctionSet<void(ARGS...)> actions;  ///< Set of functions (actions) to be triggered with this signal.\n  public:\n    using fun_t = void(ARGS...);\n    using this_t = Signal<fun_t>;\n\n    Signal(const std::string & name=\"\", internal::SignalManager_Base * manager=nullptr)\n      : SignalBase(name, manager), actions() { ; }\n    Signal(const std::string & name, internal::SignalControl_Base & control)\n      : this_t(name, &(control.GetSignalManager())) { ; }\n    virtual this_t * Clone() const {\n      this_t * new_copy = new this_t(name);\n      // @CAO: Make sure to copy over actions into new copy.\n      return new_copy;\n    }\n\n    size_t GetNumArgs() const { return sizeof...(ARGS); }\n    size_t GetNumActions() const { return actions.GetSize(); }\n\n    /// Trigger this signal, providing all needed arguments.\n    void Trigger(ARGS... args) { actions.Run(args...); }\n\n    /// Add an action that takes the proper arguments.\n    SignalKey AddAction(const std::function<void(ARGS...)> & in_fun) {\n      const SignalKey link_id = NextSignalKey();\n      link_key_map[link_id] = actions.size();\n      actions.Add(in_fun);\n      return link_id;\n    }\n\n    /// Add a specified action to this signal.\n    SignalKey AddAction(ActionBase & in_action) {\n      Action<fun_t> * a = dynamic_cast< Action<fun_t>* >(&in_action);\n      emp_assert( a != nullptr && \"action type must match signal type.\" );\n      return AddAction(a->GetFun());\n    }\n\n    bool TestMatch(ActionBase & in_action) {\n      return dynamic_cast< Action<fun_t>* >(&in_action);\n    }\n\n    /// Add an action that takes too few arguments... but provide specific padding info.\n    template <typename... FUN_ARGS, typename... EXTRA_ARGS>\n    SignalKey AddAction(const std::function<void(FUN_ARGS...)> & in_fun, TypePack<EXTRA_ARGS...>)\n    {\n      // If we made it here, we have isolated the extra arguments that we need to throw away to\n      // call this function correctly.\n      const SignalKey link_id = NextSignalKey();\n      link_key_map[link_id] = actions.size();\n      std::function<void(ARGS...)> expand_fun =\n        [in_fun](FUN_ARGS &&... args, EXTRA_ARGS...){ in_fun(std::forward<FUN_ARGS>(args)...); };\n      actions.Add(expand_fun);\n      return link_id;\n    }\n\n    /// Add an std::function that takes the wrong number of arguments.  For now, we will assume\n    /// that there are too few and we need to figure out how to pad it out.\n    template <typename... FUN_ARGS>\n    SignalKey AddAction(const std::function<void(FUN_ARGS...)> & in_fun) {\n      // Identify the extra arguments by removing the ones that we know about.\n      using extra_type = typename TypePack<ARGS...>::template popN<sizeof...(FUN_ARGS)>;\n      return AddAction(in_fun, extra_type());\n    }\n\n    /// Add a regular function that takes the wrong number of arguments.  For now, we will assume\n    /// that there are too few and we need to figure out how to pad it out.\n    template <typename... FUN_ARGS>\n    SignalKey AddAction(void in_fun(FUN_ARGS...)) {\n      // Identify the extra arguments by removing the ones that we know about.\n      using extra_type = typename TypePack<ARGS...>::template popN<sizeof...(FUN_ARGS)>;\n      return AddAction(std::function<void(FUN_ARGS...)>(in_fun), extra_type());\n    }\n\n    /// Remove an action from this signal by providing its key.\n    void Remove(SignalKey key) {\n      // Find the action associate with this key.\n      emp_assert(emp::Has(link_key_map, key));\n      size_t pos = link_key_map[key];\n\n      // Remove the action\n      actions.Remove(pos);\n      link_key_map.erase(key);\n\n      // Adjust all of the positions of the actions that came after this one.\n      for (auto & x : link_key_map) {\n        if (x.second > pos) x.second = x.second - 1;\n      }\n    }\n\n    /// Retrieve the relative priority associated with a specific\n    size_t GetPriority(SignalKey key) {\n      emp_assert(emp::Has(link_key_map, key));\n      return link_key_map[key];\n    }\n\n  };\n\n  // Signals with NON-void return.\n  template <typename RETURN, typename... ARGS>\n  class Signal<RETURN(ARGS...)> : public SignalBase {\n  protected:\n    FunctionSet<RETURN(ARGS...)> actions;\n  public:\n    using fun_t = RETURN(ARGS...);\n    using this_t = Signal<fun_t>;\n\n    Signal(const std::string & name=\"\", internal::SignalManager_Base * manager=nullptr)\n      : SignalBase(name, manager) { ; }\n    Signal(const std::string & name, internal::SignalControl_Base & control)\n      : this_t(name, &(control.GetSignalManager())) { ; }\n    virtual this_t * Clone() const {\n      this_t * new_copy = new this_t(name);\n      // @CAO: Make sure to copy over actions into new copy.\n      return new_copy;\n    }\n\n    size_t GetNumArgs() const { return sizeof...(ARGS); }\n    size_t GetNumActions() const { return actions.GetSize(); }\n\n    const emp::vector<RETURN> & Trigger(ARGS... args) { return actions.Run(args...); }\n\n    // Add an action that takes the proper arguments.\n    SignalKey AddAction(const std::function<fun_t> & in_fun) {\n      const SignalKey link_id = NextSignalKey();\n      link_key_map[link_id] = actions.size();\n      actions.Add(in_fun);\n      return link_id;\n    }\n\n    SignalKey AddAction(ActionBase & in_action) {\n      Action<fun_t> * a = dynamic_cast< Action<fun_t>* >(&in_action);\n      emp_assert( a != nullptr && \"action type must match signal type.\" );\n      return AddAction(a->GetFun());\n    }\n\n    bool TestMatch(ActionBase & in_action) {\n      return dynamic_cast< Action<fun_t>* >(&in_action);\n    }\n\n    // Add an action that takes too few arguments... but provide specific padding info.\n    template <typename... FUN_ARGS, typename... EXTRA_ARGS>\n    SignalKey AddAction(const std::function<RETURN(FUN_ARGS...)> & in_fun, TypePack<EXTRA_ARGS...>)\n    {\n      // If we made it here, we have isolated the extra arguments that we need to throw away to\n      // call this function correctly.\n      const SignalKey link_id = NextSignalKey();\n      link_key_map[link_id] = actions.size();\n      std::function<fun_t> expand_fun =\n        [in_fun](FUN_ARGS &&... args, EXTRA_ARGS...){ in_fun(std::forward<FUN_ARGS>(args)...); };\n      actions.Add(expand_fun);\n      return link_id;\n    }\n\n    // Add an std::function that takes the wrong number of arguments.  For now, we will assume\n    // that there are too few and we need to figure out how to pad it out.\n    template <typename... FUN_ARGS>\n    SignalKey AddAction(const std::function<RETURN(FUN_ARGS...)> & in_fun) {\n      // Identify the extra arguments by removing the ones that we know about.\n      using extra_type = typename TypePack<ARGS...>::template popN<sizeof...(FUN_ARGS)>;\n      return AddAction(in_fun, extra_type());\n    }\n\n    // Add a regular function that takes the wrong number of arguments.  For now, we will assume\n    // that there are too few and we need to figure out how to pad it out.\n    template <typename... FUN_ARGS>\n    SignalKey AddAction(RETURN in_fun(FUN_ARGS...)) {\n      // Identify the extra arguments by removing the ones that we know about.\n      using extra_type = typename TypePack<ARGS...>::template popN<sizeof...(FUN_ARGS)>;\n      return AddAction(std::function<RETURN(FUN_ARGS...)>(in_fun), extra_type());\n    }\n\n    void Remove(SignalKey key) {\n      // Find the action associate with this key.\n      emp_assert(emp::Has(link_key_map, key));\n      size_t pos = link_key_map[key];\n\n      // Remove the action\n      actions.Remove(pos);\n      link_key_map.erase(key);\n\n      // Adjust all of the positions of the actions that came after this one.\n      for (auto & x : link_key_map) {\n        if (x.second > pos) x.second = x.second - 1;\n      }\n    }\n\n    size_t GetPriority(SignalKey key) {\n      emp_assert(emp::Has(link_key_map, key));\n      return link_key_map[key];\n    }\n\n  };\n\n  template<typename... ARGS>\n  inline void SignalBase::BaseTrigger(ARGS... args) {\n    // Make sure this base class is really of the correct derrived type (but do so in an\n    // assert since triggers may be called frequently and should be fast!)\n    emp_assert(dynamic_cast< Signal<void(ARGS...)> * >(this));\n    ((Signal<void(ARGS...)> *) this)->Trigger(args...);\n  }\n\n  template <typename... ARGS>\n  inline SignalKey SignalBase::AddAction(const std::function<void(ARGS...)> & in_fun) {\n    // @CAO: Assert for now; ideally try to find solution with fewer args.\n    emp_assert(dynamic_cast< Signal<void(ARGS...)> * >(this));\n    return ((Signal<void(ARGS...)> *) this)->AddAction(in_fun);\n  }\n\n}\n\n#endif // #ifndef EMP_CONTROL_SIGNAL_HPP_INCLUDE\n","// -*- C++ -*-\n//===------------------------- streambuf ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STEAMBUF\n#define _LIBCPP_STEAMBUF\n\n/*\n    streambuf synopsis\n\nnamespace std\n{\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_streambuf\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    locale pubimbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.6.2.2.2 buffer and positioning:\n    basic_streambuf* pubsetbuf(char_type* s, streamsize n);\n    pos_type pubseekoff(off_type off, ios_base::seekdir way,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    pos_type pubseekpos(pos_type sp,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    int pubsync();\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    streamsize in_avail();\n    int_type snextc();\n    int_type sbumpc();\n    int_type sgetc();\n    streamsize sgetn(char_type* s, streamsize n);\n\n    // 27.6.2.2.4 Putback:\n    int_type sputbackc(char_type c);\n    int_type sungetc();\n\n    // 27.6.2.2.5 Put area:\n    int_type sputc(char_type c);\n    streamsize sputn(const char_type* s, streamsize n);\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& rhs);\n    basic_streambuf& operator=(const basic_streambuf& rhs);\n    void swap(basic_streambuf& rhs);\n\n    // 27.6.2.3.2 Get area:\n    char_type* eback() const;\n    char_type* gptr() const;\n    char_type* egptr() const;\n    void gbump(int n);\n    void setg(char_type* gbeg, char_type* gnext, char_type* gend);\n\n    // 27.6.2.3.3 Put area:\n    char_type* pbase() const;\n    char_type* pptr() const;\n    char_type* epptr() const;\n    void pbump(int n);\n    void setp(char_type* pbeg, char_type* pend);\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* s, streamsize n);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* s, streamsize n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* s, streamsize n);\n    virtual int_type overflow (int_type c = traits_type::eof());\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <ios>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_streambuf\n{\npublic:\n    // types:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    static_assert((is_same<_CharT, typename traits_type::char_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    locale pubimbue(const locale& __loc) {\n        imbue(__loc);\n        locale __r = __loc_;\n        __loc_ = __loc;\n        return __r;\n    }\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    locale getloc() const { return __loc_; }\n\n    // 27.6.2.2.2 buffer and positioning:\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n)\n    { return setbuf(__s, __n); }\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,\n                        ios_base::openmode __which = ios_base::in | ios_base::out)\n    { return seekoff(__off, __way, __which); }\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    pos_type pubseekpos(pos_type __sp,\n                        ios_base::openmode __which = ios_base::in | ios_base::out)\n    { return seekpos(__sp, __which); }\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    int pubsync() { return sync(); }\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    streamsize in_avail() {\n        if (__ninp_ < __einp_)\n            return static_cast<streamsize>(__einp_ - __ninp_);\n        return showmanyc();\n    }\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    int_type snextc() {\n        if (sbumpc() == traits_type::eof())\n            return traits_type::eof();\n        return sgetc();\n    }\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    int_type sbumpc() {\n        if (__ninp_ == __einp_)\n            return uflow();\n        return traits_type::to_int_type(*__ninp_++);\n    }\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    int_type sgetc() {\n        if (__ninp_ == __einp_)\n            return underflow();\n        return traits_type::to_int_type(*__ninp_);\n    }\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    streamsize sgetn(char_type* __s, streamsize __n)\n    { return xsgetn(__s, __n); }\n\n    // 27.6.2.2.4 Putback:\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    int_type sputbackc(char_type __c) {\n        if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))\n            return pbackfail(traits_type::to_int_type(__c));\n        return traits_type::to_int_type(*--__ninp_);\n    }\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    int_type sungetc() {\n        if (__binp_ == __ninp_)\n          return pbackfail();\n        return traits_type::to_int_type(*--__ninp_);\n    }\n\n    // 27.6.2.2.5 Put area:\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    int_type sputc(char_type __c) {\n        if (__nout_ == __eout_)\n            return overflow(traits_type::to_int_type(__c));\n        *__nout_++ = __c;\n        return traits_type::to_int_type(__c);\n    }\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    streamsize sputn(const char_type* __s, streamsize __n)\n    { return xsputn(__s, __n); }\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& __rhs);\n    basic_streambuf& operator=(const basic_streambuf& __rhs);\n    void swap(basic_streambuf& __rhs);\n\n    // 27.6.2.3.2 Get area:\n    _LIBCPP_INLINE_VISIBILITY char_type* eback() const {return __binp_;}\n    _LIBCPP_INLINE_VISIBILITY char_type* gptr()  const {return __ninp_;}\n    _LIBCPP_INLINE_VISIBILITY char_type* egptr() const {return __einp_;}\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    void gbump(int __n) { __ninp_ += __n; }\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend) {\n        __binp_ = __gbeg;\n        __ninp_ = __gnext;\n        __einp_ = __gend;\n    }\n\n    // 27.6.2.3.3 Put area:\n    _LIBCPP_INLINE_VISIBILITY char_type* pbase() const {return __bout_;}\n    _LIBCPP_INLINE_VISIBILITY char_type* pptr()  const {return __nout_;}\n    _LIBCPP_INLINE_VISIBILITY char_type* epptr() const {return __eout_;}\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    void pbump(int __n) { __nout_ += __n; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __pbump(streamsize __n) { __nout_ += __n; }\n\n    inline _LIBCPP_HIDE_FROM_ABI_AFTER_V1\n    void setp(char_type* __pbeg, char_type* __pend) {\n        __bout_ = __nout_ = __pbeg;\n        __eout_ = __pend;\n    }\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& __loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* __s, streamsize __n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* __s, streamsize __n);\n    virtual int_type overflow(int_type __c = traits_type::eof());\n\nprivate:\n    locale __loc_;\n    char_type* __binp_;\n    char_type* __ninp_;\n    char_type* __einp_;\n    char_type* __bout_;\n    char_type* __nout_;\n    char_type* __eout_;\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::~basic_streambuf()\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf()\n    : __binp_(0),\n      __ninp_(0),\n      __einp_(0),\n      __bout_(0),\n      __nout_(0),\n      __eout_(0)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)\n    : __loc_(__sb.__loc_),\n      __binp_(__sb.__binp_),\n      __ninp_(__sb.__ninp_),\n      __einp_(__sb.__einp_),\n      __bout_(__sb.__bout_),\n      __nout_(__sb.__nout_),\n      __eout_(__sb.__eout_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>&\nbasic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)\n{\n    __loc_ = __sb.__loc_;\n    __binp_ = __sb.__binp_;\n    __ninp_ = __sb.__ninp_;\n    __einp_ = __sb.__einp_;\n    __bout_ = __sb.__bout_;\n    __nout_ = __sb.__nout_;\n    __eout_ = __sb.__eout_;\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)\n{\n    _VSTD::swap(__loc_, __sb.__loc_);\n    _VSTD::swap(__binp_, __sb.__binp_);\n    _VSTD::swap(__ninp_, __sb.__ninp_);\n    _VSTD::swap(__einp_, __sb.__einp_);\n    _VSTD::swap(__bout_, __sb.__bout_);\n    _VSTD::swap(__nout_, __sb.__nout_);\n    _VSTD::swap(__eout_, __sb.__eout_);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::imbue(const locale&)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>*\nbasic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)\n{\n    return this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,\n                                          ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\nint\nbasic_streambuf<_CharT, _Traits>::sync()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::showmanyc()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)\n{\n    const int_type __eof = traits_type::eof();\n    int_type __c;\n    streamsize __i = 0;\n    while(__i < __n)\n    {\n        if (__ninp_ < __einp_)\n        {\n            const streamsize __len = _VSTD::min(static_cast<streamsize>(INT_MAX),\n                                _VSTD::min(__einp_ - __ninp_, __n - __i));\n            traits_type::copy(__s, __ninp_, __len);\n            __s +=  __len;\n            __i +=  __len;\n            this->gbump(__len);\n        }\n        else if ((__c = uflow()) != __eof)\n        {\n            *__s = traits_type::to_char_type(__c);\n            ++__s;\n            ++__i;\n        }\n        else\n            break;\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::underflow()\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::uflow()\n{\n    if (underflow() == traits_type::eof())\n        return traits_type::eof();\n    return traits_type::to_int_type(*__ninp_++);\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::pbackfail(int_type)\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)\n{\n    streamsize __i = 0;\n    int_type __eof = traits_type::eof();\n    while( __i < __n)\n    {\n        if (__nout_ >= __eout_)\n        {\n            if (overflow(traits_type::to_int_type(*__s)) == __eof)\n                break;\n            ++__s;\n            ++__i;\n        }\n        else\n        {\n            streamsize __chunk_size = _VSTD::min(__eout_ - __nout_, __n - __i);\n            traits_type::copy(__nout_, __s, __chunk_size);\n            __nout_ += __chunk_size;\n            __s     += __chunk_size;\n            __i     += __chunk_size;\n        }\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::overflow(int_type)\n{\n    return traits_type::eof();\n}\n\n#ifndef _LIBCPP_DO_NOT_ASSUME_STREAMS_EXPLICIT_INSTANTIATION_IN_DYLIB\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_streambuf<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_streambuf<wchar_t>)\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ios<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ios<wchar_t>)\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_STEAMBUF\n","// -*- C++ -*-\n//===------------------------- fstream ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FSTREAM\n#define _LIBCPP_FSTREAM\n\n/*\n    fstream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_filebuf\n    : public basic_streambuf<charT, traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.9.1.2 Constructors/destructor:\n    basic_filebuf();\n    basic_filebuf(basic_filebuf&& rhs);\n    virtual ~basic_filebuf();\n\n    // 27.9.1.3 Assign/swap:\n    basic_filebuf& operator=(basic_filebuf&& rhs);\n    void swap(basic_filebuf& rhs);\n\n    // 27.9.1.4 Members:\n    bool is_open() const;\n    basic_filebuf* open(const char* s, ios_base::openmode mode);\n    basic_filebuf* open(const string& s, ios_base::openmode mode);\n    basic_filebuf* open(const filesystem::path& p, ios_base::openmode mode); // C++17\n    basic_filebuf* close();\n\nprotected:\n    // 27.9.1.5 Overridden virtual functions:\n    virtual streamsize showmanyc();\n    virtual int_type underflow();\n    virtual int_type uflow();\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n    virtual int_type overflow (int_type c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* s, streamsize n);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual int sync();\n    virtual void imbue(const locale& loc);\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_filebuf<charT, traits>& x, basic_filebuf<charT, traits>& y);\n\ntypedef basic_filebuf<char>    filebuf;\ntypedef basic_filebuf<wchar_t> wfilebuf;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ifstream\n    : public basic_istream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ifstream();\n    explicit basic_ifstream(const char* s, ios_base::openmode mode = ios_base::in);\n    explicit basic_ifstream(const string& s, ios_base::openmode mode = ios_base::in);\n    explicit basic_ifstream(const filesystem::path& p,\n                            ios_base::openmode mode = ios_base::in); // C++17\n    basic_ifstream(basic_ifstream&& rhs);\n\n    basic_ifstream& operator=(basic_ifstream&& rhs);\n    void swap(basic_ifstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::in);\n    void open(const string& s, ios_base::openmode mode = ios_base::in);\n    void open(const filesystem::path& s, ios_base::openmode mode = ios_base::in); // C++17\n\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_ifstream<charT, traits>& x, basic_ifstream<charT, traits>& y);\n\ntypedef basic_ifstream<char>    ifstream;\ntypedef basic_ifstream<wchar_t> wifstream;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ofstream\n    : public basic_ostream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ofstream();\n    explicit basic_ofstream(const char* s, ios_base::openmode mode = ios_base::out);\n    explicit basic_ofstream(const string& s, ios_base::openmode mode = ios_base::out);\n    explicit basic_ofstream(const filesystem::path& p,\n                            ios_base::openmode mode = ios_base::out); // C++17\n    basic_ofstream(basic_ofstream&& rhs);\n\n    basic_ofstream& operator=(basic_ofstream&& rhs);\n    void swap(basic_ofstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::out);\n    void open(const string& s, ios_base::openmode mode = ios_base::out);\n    void open(const filesystem::path& p,\n              ios_base::openmode mode = ios_base::out); // C++17\n\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_ofstream<charT, traits>& x, basic_ofstream<charT, traits>& y);\n\ntypedef basic_ofstream<char>    ofstream;\ntypedef basic_ofstream<wchar_t> wofstream;\n\ntemplate <class charT, class traits=char_traits<charT> >\nclass basic_fstream\n    : public basic_iostream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_fstream();\n    explicit basic_fstream(const char* s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    explicit basic_fstream(const string& s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    explicit basic_fstream(const filesystem::path& p,\n                           ios_base::openmode mode = ios_base::in|ios_base::out); C++17\n    basic_fstream(basic_fstream&& rhs);\n\n    basic_fstream& operator=(basic_fstream&& rhs);\n    void swap(basic_fstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    void open(const string& s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    void open(const filesystem::path& s,\n              ios_base::openmode mode = ios_base::in|ios_base::out); // C++17\n\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void swap(basic_fstream<charT, traits>& x, basic_fstream<charT, traits>& y);\n\ntypedef basic_fstream<char>    fstream;\ntypedef basic_fstream<wchar_t> wfstream;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ostream>\n#include <istream>\n#include <__locale>\n#include <cstdio>\n#include <cstdlib>\n#include <filesystem>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_filebuf\n    : public basic_streambuf<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                           char_type;\n    typedef _Traits                          traits_type;\n    typedef typename traits_type::int_type   int_type;\n    typedef typename traits_type::pos_type   pos_type;\n    typedef typename traits_type::off_type   off_type;\n    typedef typename traits_type::state_type state_type;\n\n    // 27.9.1.2 Constructors/destructor:\n    basic_filebuf();\n#ifndef _LIBCPP_CXX03_LANG\n    basic_filebuf(basic_filebuf&& __rhs);\n#endif\n    virtual ~basic_filebuf();\n\n    // 27.9.1.3 Assign/swap:\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf& operator=(basic_filebuf&& __rhs);\n#endif\n    void swap(basic_filebuf& __rhs);\n\n    // 27.9.1.4 Members:\n    _LIBCPP_INLINE_VISIBILITY\n    bool is_open() const;\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    basic_filebuf* open(const char* __s, ios_base::openmode __mode);\n#ifdef _LIBCPP_HAS_OPEN_WITH_WCHAR\n    basic_filebuf* open(const wchar_t* __s, ios_base::openmode __mode);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf* open(const string& __s, ios_base::openmode __mode);\n\n#if _LIBCPP_STD_VER >= 17\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf* open(const _VSTD_FS::path& __p, ios_base::openmode __mode) {\n      return open(__p.c_str(), __mode);\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf* __open(int __fd, ios_base::openmode __mode);\n#endif\n    basic_filebuf* close();\n\n    _LIBCPP_INLINE_VISIBILITY\n    inline static const char*\n    __make_mdstring(ios_base::openmode __mode) _NOEXCEPT;\n\n  protected:\n    // 27.9.1.5 Overridden virtual functions:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s, streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual int sync();\n    virtual void imbue(const locale& __loc);\n\nprivate:\n  char* __extbuf_;\n  const char* __extbufnext_;\n  const char* __extbufend_;\n  char __extbuf_min_[8];\n  size_t __ebs_;\n  char_type* __intbuf_;\n  size_t __ibs_;\n  FILE* __file_;\n  const codecvt<char_type, char, state_type>* __cv_;\n  state_type __st_;\n  state_type __st_last_;\n  ios_base::openmode __om_;\n  ios_base::openmode __cm_;\n  bool __owns_eb_;\n  bool __owns_ib_;\n  bool __always_noconv_;\n\n  bool __read_mode();\n  void __write_mode();\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::basic_filebuf()\n    : __extbuf_(0),\n      __extbufnext_(0),\n      __extbufend_(0),\n      __ebs_(0),\n      __intbuf_(0),\n      __ibs_(0),\n      __file_(0),\n      __cv_(nullptr),\n      __st_(),\n      __st_last_(),\n      __om_(0),\n      __cm_(0),\n      __owns_eb_(false),\n      __owns_ib_(false),\n      __always_noconv_(false)\n{\n    if (has_facet<codecvt<char_type, char, state_type> >(this->getloc()))\n    {\n        __cv_ = &use_facet<codecvt<char_type, char, state_type> >(this->getloc());\n        __always_noconv_ = __cv_->always_noconv();\n    }\n    setbuf(0, 4096);\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::basic_filebuf(basic_filebuf&& __rhs)\n    : basic_streambuf<_CharT, _Traits>(__rhs)\n{\n    if (__rhs.__extbuf_ == __rhs.__extbuf_min_)\n    {\n        __extbuf_ = __extbuf_min_;\n        __extbufnext_ = __extbuf_ + (__rhs.__extbufnext_ - __rhs.__extbuf_);\n        __extbufend_ = __extbuf_ + (__rhs.__extbufend_ - __rhs.__extbuf_);\n    }\n    else\n    {\n        __extbuf_ = __rhs.__extbuf_;\n        __extbufnext_ = __rhs.__extbufnext_;\n        __extbufend_ = __rhs.__extbufend_;\n    }\n    __ebs_ = __rhs.__ebs_;\n    __intbuf_ = __rhs.__intbuf_;\n    __ibs_ = __rhs.__ibs_;\n    __file_ = __rhs.__file_;\n    __cv_ = __rhs.__cv_;\n    __st_ = __rhs.__st_;\n    __st_last_ = __rhs.__st_last_;\n    __om_ = __rhs.__om_;\n    __cm_ = __rhs.__cm_;\n    __owns_eb_ = __rhs.__owns_eb_;\n    __owns_ib_ = __rhs.__owns_ib_;\n    __always_noconv_ = __rhs.__always_noconv_;\n    if (__rhs.pbase())\n    {\n        if (__rhs.pbase() == __rhs.__intbuf_)\n            this->setp(__intbuf_, __intbuf_ + (__rhs. epptr() - __rhs.pbase()));\n        else\n            this->setp((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + (__rhs. epptr() - __rhs.pbase()));\n        this->__pbump(__rhs. pptr() - __rhs.pbase());\n    }\n    else if (__rhs.eback())\n    {\n        if (__rhs.eback() == __rhs.__intbuf_)\n            this->setg(__intbuf_, __intbuf_ + (__rhs.gptr() - __rhs.eback()),\n                                  __intbuf_ + (__rhs.egptr() - __rhs.eback()));\n        else\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + (__rhs.gptr() - __rhs.eback()),\n                       (char_type*)__extbuf_ + (__rhs.egptr() - __rhs.eback()));\n    }\n    __rhs.__extbuf_ = 0;\n    __rhs.__extbufnext_ = 0;\n    __rhs.__extbufend_ = 0;\n    __rhs.__ebs_ = 0;\n    __rhs.__intbuf_ = 0;\n    __rhs.__ibs_ = 0;\n    __rhs.__file_ = 0;\n    __rhs.__st_ = state_type();\n    __rhs.__st_last_ = state_type();\n    __rhs.__om_ = 0;\n    __rhs.__cm_ = 0;\n    __rhs.__owns_eb_ = false;\n    __rhs.__owns_ib_ = false;\n    __rhs.setg(0, 0, 0);\n    __rhs.setp(0, 0);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>&\nbasic_filebuf<_CharT, _Traits>::operator=(basic_filebuf&& __rhs)\n{\n    close();\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::~basic_filebuf()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        close();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::swap(basic_filebuf& __rhs)\n{\n    basic_streambuf<char_type, traits_type>::swap(__rhs);\n    if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)\n    {\n        _VSTD::swap(__extbuf_, __rhs.__extbuf_);\n        _VSTD::swap(__extbufnext_, __rhs.__extbufnext_);\n        _VSTD::swap(__extbufend_, __rhs.__extbufend_);\n    }\n    else\n    {\n        ptrdiff_t __ln = __extbufnext_ - __extbuf_;\n        ptrdiff_t __le = __extbufend_ - __extbuf_;\n        ptrdiff_t __rn = __rhs.__extbufnext_ - __rhs.__extbuf_;\n        ptrdiff_t __re = __rhs.__extbufend_ - __rhs.__extbuf_;\n        if (__extbuf_ == __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)\n        {\n            __extbuf_ = __rhs.__extbuf_;\n            __rhs.__extbuf_ = __rhs.__extbuf_min_;\n        }\n        else if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ == __rhs.__extbuf_min_)\n        {\n            __rhs.__extbuf_ = __extbuf_;\n            __extbuf_ = __extbuf_min_;\n        }\n        __extbufnext_ = __extbuf_ + __rn;\n        __extbufend_ = __extbuf_ + __re;\n        __rhs.__extbufnext_ = __rhs.__extbuf_ + __ln;\n        __rhs.__extbufend_ = __rhs.__extbuf_ + __le;\n    }\n    _VSTD::swap(__ebs_, __rhs.__ebs_);\n    _VSTD::swap(__intbuf_, __rhs.__intbuf_);\n    _VSTD::swap(__ibs_, __rhs.__ibs_);\n    _VSTD::swap(__file_, __rhs.__file_);\n    _VSTD::swap(__cv_, __rhs.__cv_);\n    _VSTD::swap(__st_, __rhs.__st_);\n    _VSTD::swap(__st_last_, __rhs.__st_last_);\n    _VSTD::swap(__om_, __rhs.__om_);\n    _VSTD::swap(__cm_, __rhs.__cm_);\n    _VSTD::swap(__owns_eb_, __rhs.__owns_eb_);\n    _VSTD::swap(__owns_ib_, __rhs.__owns_ib_);\n    _VSTD::swap(__always_noconv_, __rhs.__always_noconv_);\n    if (this->eback() == (char_type*)__rhs.__extbuf_min_)\n    {\n        ptrdiff_t __n = this->gptr() - this->eback();\n        ptrdiff_t __e = this->egptr() - this->eback();\n        this->setg((char_type*)__extbuf_min_,\n                   (char_type*)__extbuf_min_ + __n,\n                   (char_type*)__extbuf_min_ + __e);\n    }\n    else if (this->pbase() == (char_type*)__rhs.__extbuf_min_)\n    {\n        ptrdiff_t __n = this->pptr() - this->pbase();\n        ptrdiff_t __e = this->epptr() - this->pbase();\n        this->setp((char_type*)__extbuf_min_,\n                   (char_type*)__extbuf_min_ + __e);\n        this->__pbump(__n);\n    }\n    if (__rhs.eback() == (char_type*)__extbuf_min_)\n    {\n        ptrdiff_t __n = __rhs.gptr() - __rhs.eback();\n        ptrdiff_t __e = __rhs.egptr() - __rhs.eback();\n        __rhs.setg((char_type*)__rhs.__extbuf_min_,\n                   (char_type*)__rhs.__extbuf_min_ + __n,\n                   (char_type*)__rhs.__extbuf_min_ + __e);\n    }\n    else if (__rhs.pbase() == (char_type*)__extbuf_min_)\n    {\n        ptrdiff_t __n = __rhs.pptr() - __rhs.pbase();\n        ptrdiff_t __e = __rhs.epptr() - __rhs.pbase();\n        __rhs.setp((char_type*)__rhs.__extbuf_min_,\n                   (char_type*)__rhs.__extbuf_min_ + __e);\n        __rhs.__pbump(__n);\n    }\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_filebuf<_CharT, _Traits>& __x, basic_filebuf<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbool\nbasic_filebuf<_CharT, _Traits>::is_open() const\n{\n    return __file_ != 0;\n}\n\ntemplate <class _CharT, class _Traits>\nconst char* basic_filebuf<_CharT, _Traits>::__make_mdstring(\n    ios_base::openmode __mode) _NOEXCEPT {\n  switch (__mode & ~ios_base::ate) {\n  case ios_base::out:\n  case ios_base::out | ios_base::trunc:\n    return \"w\";\n  case ios_base::out | ios_base::app:\n  case ios_base::app:\n    return \"a\";\n  case ios_base::in:\n    return \"r\";\n  case ios_base::in | ios_base::out:\n    return \"r+\";\n  case ios_base::in | ios_base::out | ios_base::trunc:\n    return \"w+\";\n  case ios_base::in | ios_base::out | ios_base::app:\n  case ios_base::in | ios_base::app:\n    return \"a+\";\n  case ios_base::out | ios_base::binary:\n  case ios_base::out | ios_base::trunc | ios_base::binary:\n    return \"wb\";\n  case ios_base::out | ios_base::app | ios_base::binary:\n  case ios_base::app | ios_base::binary:\n    return \"ab\";\n  case ios_base::in | ios_base::binary:\n    return \"rb\";\n  case ios_base::in | ios_base::out | ios_base::binary:\n    return \"r+b\";\n  case ios_base::in | ios_base::out | ios_base::trunc | ios_base::binary:\n    return \"w+b\";\n  case ios_base::in | ios_base::out | ios_base::app | ios_base::binary:\n  case ios_base::in | ios_base::app | ios_base::binary:\n    return \"a+b\";\n  default:\n    return nullptr;\n  }\n  _LIBCPP_UNREACHABLE();\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    basic_filebuf<_CharT, _Traits>* __rt = 0;\n    if (__file_ == 0)\n    {\n      if (const char* __mdstr = __make_mdstring(__mode)) {\n        __rt = this;\n        __file_ = fopen(__s, __mdstr);\n        if (__file_) {\n          __om_ = __mode;\n          if (__mode & ios_base::ate) {\n            if (fseek(__file_, 0, SEEK_END)) {\n              fclose(__file_);\n              __file_ = 0;\n              __rt = 0;\n            }\n          }\n        } else\n          __rt = 0;\n      }\n    }\n    return __rt;\n}\n\ntemplate <class _CharT, class _Traits>\n_LIBCPP_INLINE_VISIBILITY basic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::__open(int __fd, ios_base::openmode __mode) {\n  basic_filebuf<_CharT, _Traits>* __rt = 0;\n  if (__file_ == 0) {\n    if (const char* __mdstr = __make_mdstring(__mode)) {\n      __rt = this;\n      __file_ = fdopen(__fd, __mdstr);\n      if (__file_) {\n        __om_ = __mode;\n        if (__mode & ios_base::ate) {\n          if (fseek(__file_, 0, SEEK_END)) {\n            fclose(__file_);\n            __file_ = 0;\n            __rt = 0;\n          }\n        }\n      } else\n        __rt = 0;\n    }\n  }\n  return __rt;\n}\n\n#ifdef _LIBCPP_HAS_OPEN_WITH_WCHAR\n// This is basically the same as the char* overload except that it uses _wfopen\n// and long mode strings.\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::open(const wchar_t* __s, ios_base::openmode __mode)\n{\n    basic_filebuf<_CharT, _Traits>* __rt = 0;\n    if (__file_ == 0)\n    {\n        __rt = this;\n        const wchar_t* __mdstr;\n        switch (__mode & ~ios_base::ate)\n        {\n        case ios_base::out:\n        case ios_base::out | ios_base::trunc:\n            __mdstr = L\"w\";\n            break;\n        case ios_base::out | ios_base::app:\n        case ios_base::app:\n            __mdstr = L\"a\";\n            break;\n        case ios_base::in:\n            __mdstr = L\"r\";\n            break;\n        case ios_base::in | ios_base::out:\n            __mdstr = L\"r+\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::trunc:\n            __mdstr = L\"w+\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::app:\n        case ios_base::in | ios_base::app:\n            __mdstr = L\"a+\";\n            break;\n        case ios_base::out | ios_base::binary:\n        case ios_base::out | ios_base::trunc | ios_base::binary:\n            __mdstr = L\"wb\";\n            break;\n        case ios_base::out | ios_base::app | ios_base::binary:\n        case ios_base::app | ios_base::binary:\n            __mdstr = L\"ab\";\n            break;\n        case ios_base::in | ios_base::binary:\n            __mdstr = L\"rb\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::binary:\n            __mdstr = L\"r+b\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::trunc | ios_base::binary:\n            __mdstr = L\"w+b\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::app | ios_base::binary:\n        case ios_base::in | ios_base::app | ios_base::binary:\n            __mdstr = L\"a+b\";\n            break;\n        default:\n            __rt = 0;\n            break;\n        }\n        if (__rt)\n        {\n            __file_ = _wfopen(__s, __mdstr);\n            if (__file_)\n            {\n                __om_ = __mode;\n                if (__mode & ios_base::ate)\n                {\n                    if (fseek(__file_, 0, SEEK_END))\n                    {\n                        fclose(__file_);\n                        __file_ = 0;\n                        __rt = 0;\n                    }\n                }\n            }\n            else\n                __rt = 0;\n        }\n    }\n    return __rt;\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    return open(__s.c_str(), __mode);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::close()\n{\n    basic_filebuf<_CharT, _Traits>* __rt = 0;\n    if (__file_)\n    {\n        __rt = this;\n        unique_ptr<FILE, int(*)(FILE*)> __h(__file_, fclose);\n        if (sync())\n            __rt = 0;\n        if (fclose(__h.release()) == 0)\n            __file_ = 0;\n        else\n            __rt = 0;\n        setbuf(0, 0);\n    }\n    return __rt;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::underflow()\n{\n    if (__file_ == 0)\n        return traits_type::eof();\n    bool __initial = __read_mode();\n    char_type __1buf;\n    if (this->gptr() == 0)\n        this->setg(&__1buf, &__1buf+1, &__1buf+1);\n    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);\n    int_type __c = traits_type::eof();\n    if (this->gptr() == this->egptr())\n    {\n        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));\n        if (__always_noconv_)\n        {\n            size_t __nmemb = static_cast<size_t>(this->egptr() - this->eback() - __unget_sz);\n            __nmemb = fread(this->eback() + __unget_sz, 1, __nmemb, __file_);\n            if (__nmemb != 0)\n            {\n                this->setg(this->eback(),\n                           this->eback() + __unget_sz,\n                           this->eback() + __unget_sz + __nmemb);\n                __c = traits_type::to_int_type(*this->gptr());\n            }\n        }\n        else\n        {\n            _LIBCPP_ASSERT ( !(__extbufnext_ == NULL && (__extbufend_ != __extbufnext_)), \"underflow moving from NULL\" );\n            if (__extbufend_ != __extbufnext_)\n                memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);\n            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);\n            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);\n            size_t __nmemb = _VSTD::min(static_cast<size_t>(__ibs_ - __unget_sz),\n                                 static_cast<size_t>(__extbufend_ - __extbufnext_));\n            codecvt_base::result __r;\n            __st_last_ = __st_;\n            size_t __nr = fread((void*) const_cast<char *>(__extbufnext_), 1, __nmemb, __file_);\n            if (__nr != 0)\n            {\n                if (!__cv_)\n                    __throw_bad_cast();\n\n                __extbufend_ = __extbufnext_ + __nr;\n                char_type*  __inext;\n                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,\n                                       this->eback() + __unget_sz,\n                                       this->eback() + __ibs_, __inext);\n                if (__r == codecvt_base::noconv)\n                {\n                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, \n                                          (char_type*)const_cast<char *>(__extbufend_));\n                    __c = traits_type::to_int_type(*this->gptr());\n                }\n                else if (__inext != this->eback() + __unget_sz)\n                {\n                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);\n                    __c = traits_type::to_int_type(*this->gptr());\n                }\n            }\n        }\n    }\n    else\n        __c = traits_type::to_int_type(*this->gptr());\n    if (this->eback() == &__1buf)\n        this->setg(0, 0, 0);\n    return __c;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::pbackfail(int_type __c)\n{\n    if (__file_ && this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->gbump(-1);\n            return traits_type::not_eof(__c);\n        }\n        if ((__om_ & ios_base::out) ||\n            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->gbump(-1);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::overflow(int_type __c)\n{\n    if (__file_ == 0)\n        return traits_type::eof();\n    __write_mode();\n    char_type __1buf;\n    char_type* __pb_save = this->pbase();\n    char_type* __epb_save = this->epptr();\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        if (this->pptr() == 0)\n            this->setp(&__1buf, &__1buf+1);\n        *this->pptr() = traits_type::to_char_type(__c);\n        this->pbump(1);\n    }\n    if (this->pptr() != this->pbase())\n    {\n        if (__always_noconv_)\n        {\n            size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n            if (fwrite(this->pbase(), sizeof(char_type), __nmemb, __file_) != __nmemb)\n                return traits_type::eof();\n        }\n        else\n        {\n            char* __extbe = __extbuf_;\n            codecvt_base::result __r;\n            do\n            {\n                if (!__cv_)\n                    __throw_bad_cast();\n\n                const char_type* __e;\n                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,\n                                        __extbuf_, __extbuf_ + __ebs_, __extbe);\n                if (__e == this->pbase())\n                    return traits_type::eof();\n                if (__r == codecvt_base::noconv)\n                {\n                    size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n                    if (fwrite(this->pbase(), 1, __nmemb, __file_) != __nmemb)\n                        return traits_type::eof();\n                }\n                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n                {\n                    size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n                    if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)\n                        return traits_type::eof();\n                    if (__r == codecvt_base::partial)\n                    {\n                        this->setp(const_cast<char_type*>(__e), this->pptr());\n                        this->__pbump(this->epptr() - this->pbase());\n                    }\n                }\n                else\n                    return traits_type::eof();\n            } while (__r == codecvt_base::partial);\n        }\n        this->setp(__pb_save, __epb_save);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::setbuf(char_type* __s, streamsize __n)\n{\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n    __ebs_ = __n;\n    if (__ebs_ > sizeof(__extbuf_min_))\n    {\n        if (__always_noconv_ && __s)\n        {\n            __extbuf_ = (char*)__s;\n            __owns_eb_ = false;\n        }\n        else\n        {\n            __extbuf_ = new char[__ebs_];\n            __owns_eb_ = true;\n        }\n    }\n    else\n    {\n        __extbuf_ = __extbuf_min_;\n        __ebs_ = sizeof(__extbuf_min_);\n        __owns_eb_ = false;\n    }\n    if (!__always_noconv_)\n    {\n        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));\n        if (__s && __ibs_ >= sizeof(__extbuf_min_))\n        {\n            __intbuf_ = __s;\n            __owns_ib_ = false;\n        }\n        else\n        {\n            __intbuf_ = new char_type[__ibs_];\n            __owns_ib_ = true;\n        }\n    }\n    else\n    {\n        __ibs_ = 0;\n        __intbuf_ = 0;\n        __owns_ib_ = false;\n    }\n    return this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::pos_type\nbasic_filebuf<_CharT, _Traits>::seekoff(off_type __off, ios_base::seekdir __way,\n                                        ios_base::openmode)\n{\n    if (!__cv_)\n        __throw_bad_cast();\n\n    int __width = __cv_->encoding();\n    if (__file_ == 0 || (__width <= 0 && __off != 0) || sync())\n        return pos_type(off_type(-1));\n    // __width > 0 || __off == 0\n    int __whence;\n    switch (__way)\n    {\n    case ios_base::beg:\n        __whence = SEEK_SET;\n        break;\n    case ios_base::cur:\n        __whence = SEEK_CUR;\n        break;\n    case ios_base::end:\n        __whence = SEEK_END;\n        break;\n    default:\n        return pos_type(off_type(-1));\n    }\n#if defined(_LIBCPP_HAS_NO_OFF_T_FUNCTIONS)\n    if (fseek(__file_, __width > 0 ? __width * __off : 0, __whence))\n        return pos_type(off_type(-1));\n    pos_type __r = ftell(__file_);\n#else\n    if (fseeko(__file_, __width > 0 ? __width * __off : 0, __whence))\n        return pos_type(off_type(-1));\n    pos_type __r = ftello(__file_);\n#endif\n    __r.state(__st_);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::pos_type\nbasic_filebuf<_CharT, _Traits>::seekpos(pos_type __sp, ios_base::openmode)\n{\n    if (__file_ == 0 || sync())\n        return pos_type(off_type(-1));\n#if defined(_LIBCPP_HAS_NO_OFF_T_FUNCTIONS)\n    if (fseek(__file_, __sp, SEEK_SET))\n        return pos_type(off_type(-1));\n#else\n    if (fseeko(__file_, __sp, SEEK_SET))\n        return pos_type(off_type(-1));\n#endif\n    __st_ = __sp.state();\n    return __sp;\n}\n\ntemplate <class _CharT, class _Traits>\nint\nbasic_filebuf<_CharT, _Traits>::sync()\n{\n    if (__file_ == 0)\n        return 0;\n    if (!__cv_)\n        __throw_bad_cast();\n\n    if (__cm_ & ios_base::out)\n    {\n        if (this->pptr() != this->pbase())\n            if (overflow() == traits_type::eof())\n                return -1;\n        codecvt_base::result __r;\n        do\n        {\n            char* __extbe;\n            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);\n            size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n            if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)\n                return -1;\n        } while (__r == codecvt_base::partial);\n        if (__r == codecvt_base::error)\n            return -1;\n        if (fflush(__file_))\n            return -1;\n    }\n    else if (__cm_ & ios_base::in)\n    {\n        off_type __c;\n        state_type __state = __st_last_;\n        bool __update_st = false;\n        if (__always_noconv_)\n            __c = this->egptr() - this->gptr();\n        else\n        {\n            int __width = __cv_->encoding();\n            __c = __extbufend_ - __extbufnext_;\n            if (__width > 0)\n                __c += __width * (this->egptr() - this->gptr());\n            else\n            {\n                if (this->gptr() != this->egptr())\n                {\n                    const int __off =  __cv_->length(__state, __extbuf_,\n                                                     __extbufnext_,\n                                                     this->gptr() - this->eback());\n                    __c += __extbufnext_ - __extbuf_ - __off;\n                    __update_st = true;\n                }\n            }\n        }\n#if defined(_LIBCPP_HAS_NO_OFF_T_FUNCTIONS)\n        if (fseek(__file_, -__c, SEEK_CUR))\n            return -1;\n#else\n        if (fseeko(__file_, -__c, SEEK_CUR))\n            return -1;\n#endif\n        if (__update_st)\n            __st_ = __state;\n        __extbufnext_ = __extbufend_ = __extbuf_;\n        this->setg(0, 0, 0);\n        __cm_ = 0;\n    }\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    sync();\n    __cv_ = &use_facet<codecvt<char_type, char, state_type> >(__loc);\n    bool __old_anc = __always_noconv_;\n    __always_noconv_ = __cv_->always_noconv();\n    if (__old_anc != __always_noconv_)\n    {\n        this->setg(0, 0, 0);\n        this->setp(0, 0);\n        // invariant, char_type is char, else we couldn't get here\n        if (__always_noconv_)  // need to dump __intbuf_\n        {\n            if (__owns_eb_)\n                delete [] __extbuf_;\n            __owns_eb_ = __owns_ib_;\n            __ebs_ = __ibs_;\n            __extbuf_ = (char*)__intbuf_;\n            __ibs_ = 0;\n            __intbuf_ = 0;\n            __owns_ib_ = false;\n        }\n        else  // need to obtain an __intbuf_.\n        {     // If __extbuf_ is user-supplied, use it, else new __intbuf_\n            if (!__owns_eb_ && __extbuf_ != __extbuf_min_)\n            {\n                __ibs_ = __ebs_;\n                __intbuf_ = (char_type*)__extbuf_;\n                __owns_ib_ = false;\n                __extbuf_ = new char[__ebs_];\n                __owns_eb_ = true;\n            }\n            else\n            {\n                __ibs_ = __ebs_;\n                __intbuf_ = new char_type[__ibs_];\n                __owns_ib_ = true;\n            }\n        }\n    }\n}\n\ntemplate <class _CharT, class _Traits>\nbool\nbasic_filebuf<_CharT, _Traits>::__read_mode()\n{\n    if (!(__cm_ & ios_base::in))\n    {\n        this->setp(0, 0);\n        if (__always_noconv_)\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + __ebs_,\n                       (char_type*)__extbuf_ + __ebs_);\n        else\n            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);\n        __cm_ = ios_base::in;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::__write_mode()\n{\n    if (!(__cm_ & ios_base::out))\n    {\n        this->setg(0, 0, 0);\n        if (__ebs_ > sizeof(__extbuf_min_))\n        {\n            if (__always_noconv_)\n                this->setp((char_type*)__extbuf_,\n                           (char_type*)__extbuf_ + (__ebs_ - 1));\n            else\n                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));\n        }\n        else\n            this->setp(0, 0);\n        __cm_ = ios_base::out;\n    }\n}\n\n// basic_ifstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ifstream\n    : public basic_istream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ifstream();\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in);\n#ifdef _LIBCPP_HAS_OPEN_WITH_WCHAR\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ifstream(const wchar_t* __s, ios_base::openmode __mode = ios_base::in);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ifstream(const string& __s, ios_base::openmode __mode = ios_base::in);\n#if _LIBCPP_STD_VER >= 17\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ifstream(const filesystem::path& __p, ios_base::openmode __mode = ios_base::in)\n      : basic_ifstream(__p.c_str(), __mode) {}\n#endif // _LIBCPP_STD_VER >= 17\n#endif\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ifstream(basic_ifstream&& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ifstream& operator=(basic_ifstream&& __rhs);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_ifstream& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY\n    bool is_open() const;\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    void open(const char* __s, ios_base::openmode __mode = ios_base::in);\n#ifdef _LIBCPP_HAS_OPEN_WITH_WCHAR\n    void open(const wchar_t* __s, ios_base::openmode __mode = ios_base::in);\n#endif\n    void open(const string& __s, ios_base::openmode __mode = ios_base::in);\n#if _LIBCPP_STD_VER >= 17\n    _LIBCPP_INLINE_VISIBILITY\n    void open(const filesystem::path& __p,\n              ios_base::openmode __mode = ios_base::in) {\n      return open(__p.c_str(), __mode);\n    }\n#endif // _LIBCPP_STD_VER >= 17\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __open(int __fd, ios_base::openmode __mode);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>::basic_ifstream()\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(const char* __s, ios_base::openmode __mode)\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::in) == 0)\n        this->setstate(ios_base::failbit);\n}\n\n#ifdef _LIBCPP_HAS_OPEN_WITH_WCHAR\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(const wchar_t* __s, ios_base::openmode __mode)\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::in) == 0)\n        this->setstate(ios_base::failbit);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(const string& __s, ios_base::openmode __mode)\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::in) == 0)\n        this->setstate(ios_base::failbit);\n}\n#endif\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(basic_ifstream&& __rhs)\n    : basic_istream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>&\nbasic_ifstream<_CharT, _Traits>::operator=(basic_ifstream&& __rhs)\n{\n    basic_istream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_ifstream<_CharT, _Traits>::swap(basic_ifstream& __rhs)\n{\n    basic_istream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ifstream<_CharT, _Traits>& __x, basic_ifstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>*\nbasic_ifstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbool\nbasic_ifstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ifstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::in))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\n#ifdef _LIBCPP_HAS_OPEN_WITH_WCHAR\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ifstream<_CharT, _Traits>::open(const wchar_t* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::in))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ifstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::in))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid basic_ifstream<_CharT, _Traits>::__open(int __fd,\n                                             ios_base::openmode __mode) {\n  if (__sb_.__open(__fd, __mode | ios_base::in))\n    this->clear();\n  else\n    this->setstate(ios_base::failbit);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_ifstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n// basic_ofstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ofstream\n    : public basic_ostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ofstream();\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ofstream(const char* __s, ios_base::openmode __mode = ios_base::out);\n#ifdef _LIBCPP_HAS_OPEN_WITH_WCHAR\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ofstream(const wchar_t* __s, ios_base::openmode __mode = ios_base::out);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ofstream(const string& __s, ios_base::openmode __mode = ios_base::out);\n\n#if _LIBCPP_STD_VER >= 17\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ofstream(const filesystem::path& __p, ios_base::openmode __mode = ios_base::out)\n      : basic_ofstream(__p.c_str(), __mode) {}\n#endif // _LIBCPP_STD_VER >= 17\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ofstream(basic_ofstream&& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ofstream& operator=(basic_ofstream&& __rhs);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_ofstream& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY\n    bool is_open() const;\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    void open(const char* __s, ios_base::openmode __mode = ios_base::out);\n#ifdef _LIBCPP_HAS_OPEN_WITH_WCHAR\n    void open(const wchar_t* __s, ios_base::openmode __mode = ios_base::out);\n#endif\n    void open(const string& __s, ios_base::openmode __mode = ios_base::out);\n\n#if _LIBCPP_STD_VER >= 17\n    _LIBCPP_INLINE_VISIBILITY\n    void open(const filesystem::path& __p, ios_base::openmode __mode = ios_base::out)\n    { return open(__p.c_str(), __mode); }\n#endif // _LIBCPP_STD_VER >= 17\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __open(int __fd, ios_base::openmode __mode);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>::basic_ofstream()\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(const char* __s, ios_base::openmode __mode)\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::out) == 0)\n        this->setstate(ios_base::failbit);\n}\n\n#ifdef _LIBCPP_HAS_OPEN_WITH_WCHAR\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(const wchar_t* __s, ios_base::openmode __mode)\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::out) == 0)\n        this->setstate(ios_base::failbit);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(const string& __s, ios_base::openmode __mode)\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::out) == 0)\n        this->setstate(ios_base::failbit);\n}\n#endif\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(basic_ofstream&& __rhs)\n    : basic_ostream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>&\nbasic_ofstream<_CharT, _Traits>::operator=(basic_ofstream&& __rhs)\n{\n    basic_ostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_ofstream<_CharT, _Traits>::swap(basic_ofstream& __rhs)\n{\n    basic_ostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ofstream<_CharT, _Traits>& __x, basic_ofstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>*\nbasic_ofstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbool\nbasic_ofstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ofstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::out))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\n#ifdef _LIBCPP_HAS_OPEN_WITH_WCHAR\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ofstream<_CharT, _Traits>::open(const wchar_t* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::out))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ofstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::out))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid basic_ofstream<_CharT, _Traits>::__open(int __fd,\n                                             ios_base::openmode __mode) {\n  if (__sb_.__open(__fd, __mode | ios_base::out))\n    this->clear();\n  else\n    this->setstate(ios_base::failbit);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_ofstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n// basic_fstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_fstream\n    : public basic_iostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_fstream();\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_fstream(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n#ifdef _LIBCPP_HAS_OPEN_WITH_WCHAR\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_fstream(const wchar_t* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_fstream(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n\n#if _LIBCPP_STD_VER >= 17\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_fstream(const filesystem::path& __p, ios_base::openmode __mode = ios_base::in | ios_base::out)\n      : basic_fstream(__p.c_str(), __mode) {}\n#endif // _LIBCPP_STD_VER >= 17\n\n#endif\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_fstream(basic_fstream&& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_fstream& operator=(basic_fstream&& __rhs);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_fstream& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY\n    bool is_open() const;\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    void open(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n#ifdef _LIBCPP_HAS_OPEN_WITH_WCHAR\n    void open(const wchar_t* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n#endif\n    void open(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n\n#if _LIBCPP_STD_VER >= 17\n    _LIBCPP_INLINE_VISIBILITY\n    void open(const filesystem::path& __p, ios_base::openmode __mode = ios_base::in|ios_base::out)\n    { return open(__p.c_str(), __mode); }\n#endif // _LIBCPP_STD_VER >= 17\n\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>::basic_fstream()\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>::basic_fstream(const char* __s, ios_base::openmode __mode)\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode) == 0)\n        this->setstate(ios_base::failbit);\n}\n\n#ifdef _LIBCPP_HAS_OPEN_WITH_WCHAR\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>::basic_fstream(const wchar_t* __s, ios_base::openmode __mode)\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode) == 0)\n        this->setstate(ios_base::failbit);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>::basic_fstream(const string& __s, ios_base::openmode __mode)\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode) == 0)\n        this->setstate(ios_base::failbit);\n}\n#endif\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>::basic_fstream(basic_fstream&& __rhs)\n    : basic_iostream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>&\nbasic_fstream<_CharT, _Traits>::operator=(basic_fstream&& __rhs)\n{\n    basic_iostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_fstream<_CharT, _Traits>::swap(basic_fstream& __rhs)\n{\n    basic_iostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_fstream<_CharT, _Traits>& __x, basic_fstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>*\nbasic_fstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbool\nbasic_fstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_fstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\n#ifdef _LIBCPP_HAS_OPEN_WITH_WCHAR\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_fstream<_CharT, _Traits>::open(const wchar_t* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_fstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_fstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_FSTREAM\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2016-2018\n *\n *  @file errors.hpp\n *  @brief Tools to help manage various problems in command-line or Emscripten-based applications.\n *  @note Status: ALPHA\n *\n *  There are three possible recipiants for all errors/warnings.\n *  - The end-user if the problem stems from inputs they provided to the executable.\n *  - The library user if the problem is due to mis-use of library functionality.\n *  - The library developers if something that should be impossible occurs.\n *\n *  There are also three types of problmes to notify about:\n *  - Warnings if something looks suspicious, but isn't technically a problem.\n *  - Errors if something has gone so horribly wrong that it is impossible to recover from.\n *  - Exceptions if something didn't go the way we expected, but we can still recover.\n *\n *  In general, most of the content of this file is targeted at providing useful tools for library\n *  users; end-users should receive more customized messages and asserts should capture\n *  suposedly \"impossible\" situations that none-the-less occur in the library itself.\n *\n *  NOTES:\n *  - Whenever possible, exceptions should be preferred.  They are more specific than warnings,\n *    but don't halt execution like errors.\n *  - Warnings should always detail what should be done differently to surpress the warning.\n *\n *\n *  @todo We should move over to a pure replacement for exceptions.\n *    - Different types of exceptions can trigger a signal.  Actions should return a bool\n *      indicating whether the exception was fixed.\n *    - Remaining exceptions are recorded and passed back up the chain to (hopefully) be caught.\n *    - Uncaught exceptions should have a default behavior when Resolved.  Exceptions could have\n *      various resolve times: Next exception added, Next exception check, when ResolveExceptions()\n *      is run, End of program, or ASAP. (perhaps)\n */\n\n#ifndef EMP_BASE_ERRORS_HPP_INCLUDE\n#define EMP_BASE_ERRORS_HPP_INCLUDE\n\n#include <iostream>\n#include <map>\n#include <sstream>\n#include <string>\n\n/// If we are in emscripten, make sure to include the header.\n#ifdef __EMSCRIPTEN__\n#include <emscripten.h>\n#endif\n\nnamespace emp {\n\n  /// Information about an exception that has occured.\n  struct ExceptInfo {\n    std::string id;         ///< A unique string ID for this exception type.\n    std::string desc;       ///< A detailed description of thie exception.\n    bool default_to_error;  ///< Should we default to an error (or a warning) if not resolved?\n  };\n\n  /// Function to generate an empty exception (returned when an exception is checked, but none exist.)\n  static const ExceptInfo & GetEmptyExcept() {\n    static ExceptInfo fail_info{\"\",\"\",false};\n    return fail_info;\n  }\n\n  /// A map of all exceptions that have occurred and are awaiting to be dealt with.\n  static std::multimap<std::string, ExceptInfo> & GetExceptMap() {\n    static std::multimap<std::string, ExceptInfo> except_map;\n    return except_map;\n  }\n\n  /// Provide information about an exception that needs to be triggered.\n  inline void TriggerExcept(const std::string & in_id, const std::string & in_desc, bool in_error=true) {\n    GetExceptMap().emplace(in_id, ExceptInfo({in_id, in_desc, in_error}));\n  }\n\n  /// Get the first waiting exception.\n  inline const ExceptInfo & GetExcept(const std::string & id) {\n    auto & fail_map = GetExceptMap();\n    auto it = fail_map.find(id);\n    if (it != fail_map.end()) return it->second;\n    return GetEmptyExcept();\n  }\n\n  /// Get and *remove* a waiting exception.\n  inline ExceptInfo PopExcept(const std::string & id) {\n    auto & fail_map = GetExceptMap();\n    auto it = fail_map.find(id);\n    auto out = GetEmptyExcept();\n    if (it != fail_map.end()) { out = it->second; fail_map.erase(it); }\n    return out;\n  }\n\n  /// How many exceptions are waiting to be dealt with?\n  inline size_t CountExcepts() { return GetExceptMap().size(); }\n\n  /// Are any exceptions waiting?\n  inline bool HasExcept() { return CountExcepts(); }\n\n  /// Are any exceptions of a particular type waiting?\n  inline bool HasExcept(const std::string & id) { return GetExceptMap().count(id); }\n\n  /// Remove all waiting exceptions.\n  inline void ClearExcepts() { GetExceptMap().clear(); }\n\n  /// Remove all waiting exceptions of the desginated type.\n  inline void ClearExcept(const std::string & id) {\n    auto & fail_map = GetExceptMap();\n    auto it = fail_map.find(id);\n    if (it != fail_map.end()) fail_map.erase(it);\n  }\n\n  namespace {\n    // Copy all of the args into the stringstream.\n    // Base case\n    void Notify_impl(std::stringstream &) { ; }\n\n    // For each arg, copy it into the provided stringstream and recurse to do the rest.\n    template <typename T, typename... Ts>\n    void Notify_impl(std::stringstream & ss, T && arg1, Ts &&... args) {\n      ss << std::forward<T>(arg1);\n      Notify_impl(ss, std::forward<Ts>(args)...);\n    }\n  }\n\n  /// Send information to a program user (via standard error in native mode, or alert in Emscripten)\n  template <typename... Ts>\n  void Notify(Ts &&... args) {\n    std::stringstream ss;\n    Notify_impl(ss, std::forward<Ts>(args)...);\n#ifdef __EMSCRIPTEN__\n    EM_ASM_ARGS({\n      msg = UTF8ToString($0);\n      if (typeof alert == \"undefined\") {\n        // node polyfill\n        globalThis.alert = console.log;\n      }\n      alert(msg);\n    }, ss.str().c_str());\n#else\n    std::cerr << ss.str() << std::endl;\n#endif\n  }\n\n  /// End user has done something possibly a problem.\n  template <typename... Ts>\n  void NotifyWarning(Ts &&... msg) { Notify(\"WARNING: \", std::forward<Ts>(msg)...); }\n\n  /// End user has done something resulting in an non-recoverable problem.\n  template <typename... Ts>\n  void NotifyError(Ts &&... msg) { Notify(\"ERROR: \", std::forward<Ts>(msg)...); }\n\n  /// Library user has made an error in how they are using the library.\n  template <typename... Ts>\n  void LibraryWarning(Ts &&... msg) { Notify(\"EMPIRICAL USE WARNING: \", std::forward<Ts>(msg)...); }\n\n  /// Library user has made an error in how they are using the library.\n  template <typename... Ts>\n  void LibraryError(Ts &&... msg) { Notify(\"EMPIRICAL USE ERROR: \", std::forward<Ts>(msg)...); }\n\n  /// Original library implementers must have made an error.\n  template <typename... Ts>\n  void InternalError(Ts &&... msg) { Notify(\"INTERNAL EMPIRICAL ERROR: \", std::forward<Ts>(msg)...); }\n\n}\n\n\n#endif // #ifndef EMP_BASE_ERRORS_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2016-2019.\n *\n *  @file config.hpp\n *  @brief Maintains a set of configuration options.\n *\n *  This file defines a master configuration option Config, whose values can be loaded\n *  at runtime or else set as constant values throughout the code.\n *\n *  Assuming you have an emp::Config object called config, you can:\n *\n *  access a setting value:            config.SETTING_NAME()\n *  adjust a setting value:            config.SETTING_NAME(new_value)\n *  determine if a setting is locked:  config.SETTING_NAME_is_const()\n *  lookup a setting dynamically:      config(\"SETTING_NAME\")\n *  adjust a setting dynamically:      config(\"SETTING_NAME\", \"new_value\")\n *\n *  load settings from a stream:       config.Read(stream);\n *  load settings from a file:         config.Read(filename);\n *  save settings to a stream:         config.Write(stream);\n *  save settings to a file:           config.Write(filename);\n *  generate a query string:           config.WriteUrlQueryString(stream);\n *\n *  write settings macros to a stream: config.WriteMacros(stream);\n *  write settings macros to a file:   config.WriteMacros(filename);\n *\n *\n *  The configuration files generated can use the following keywords in order to\n *  configure this object:\n *   include OTHER_FILENAME         -- Load in all data from another file.\n *   set SETTING_NAME VALUE         -- Set a basic configuration setting.\n *   new OBJECT_TYPE OBJECT_NAME    -- Create a new config object of a managed class.\n *   use OBJECT_TYPE OBJECT_NAME    -- Use a previouly created configuration object.\n */\n\n#ifndef EMP_CONFIG_CONFIG_HPP_INCLUDE\n#define EMP_CONFIG_CONFIG_HPP_INCLUDE\n\n#include <fstream>\n#include <functional>\n#include <ostream>\n#include <sstream>\n#include <string>\n#include <unordered_set>\n\n#include \"../base/errors.hpp\"\n#include \"../base/unordered_map.hpp\"\n#include \"../base/vector.hpp\"\n#include \"../datastructs/map_utils.hpp\"\n#include \"../meta/macros.hpp\"\n#include \"../tools/string_utils.hpp\"\n\n#include \"ConfigManager.hpp\"\n\nnamespace emp {\n  using namespace std::placeholders;\n\n  /// Base class for all configuration settings.\n  class ConfigEntry {\n  protected:\n    std::string name;\n    std::string type;\n    std::string default_val;\n    std::string desc;\n\n    std::unordered_set<std::string> alias_set;\n\n  public:\n    ConfigEntry(const std::string _name, const std::string _type,\n                 const std::string _d_val, const std::string _desc)\n      : name(_name), type(_type), default_val(_d_val), desc(_desc), alias_set()\n    { ; }\n    virtual ~ConfigEntry() { ; }\n\n    const std::string & GetName() const { return name; }\n    const std::string & GetType() const { return type; }\n    const std::string & GetDefault() const { return default_val; }\n    const std::string & GetDescription() const { return desc; }\n\n    ConfigEntry & SetName(const std::string & _in) { name = _in; return *this; }\n    ConfigEntry & SetType(const std::string & _in) { type = _in; return *this; }\n    ConfigEntry & SetDefault(const std::string & _in) { default_val = _in; return *this; }\n    ConfigEntry & SetDescription(const std::string & _in) { desc = _in; return *this; }\n\n    /// Alert this setting that it is aliased to alternate possible names.\n    ConfigEntry & AddAlias(const std::string & _in) { alias_set.insert(_in); return *this; }\n\n    /// Are there any alternate names for this setting?\n    bool HasAlias(const std::string & _in) { return alias_set.find(_in) != alias_set.end(); }\n\n    /// Will the provided name match this setting?\n    bool IsMatch(const std::string & _in) { return name == _in || HasAlias(_in); }\n\n    /// Retrieve the full set of aliases.\n    const std::unordered_set<std::string> & GetAliases() { return alias_set; }\n\n    /// Retrieve the value of this setting as a string.\n    virtual std::string GetValue() const = 0;\n\n    /// Conver the value of this setting into a literal that C++ would recognize as its current value.\n    virtual std::string GetLiteralValue() const = 0;\n\n    /// Use a string to set the value of this setting.\n    virtual ConfigEntry & SetValue(const std::string & in_val, std::stringstream & warnings) = 0;\n\n    /// Identify if this setting is fixed at compile time.\n    virtual bool IsConst() const = 0;\n  };\n\n  /// Master configuration class that manages all of the settings.\n  class Config {\n  protected:\n\n    /// Type-specific versions of ConfigEntry class to manage settings.\n    template <class VAR_TYPE> class tConfigEntry : public ConfigEntry {\n    protected:\n      VAR_TYPE & entry_ref;\n    public:\n      tConfigEntry(const std::string _name, const std::string _type,\n                   const std::string _d_val, const std::string _desc,\n                   VAR_TYPE & _ref)\n        : ConfigEntry(_name, _type, _d_val, _desc), entry_ref(_ref) { ; }\n      ~tConfigEntry() { ; }\n\n      std::string GetValue() const { return emp::to_string(entry_ref); }\n      std::string GetLiteralValue() const { return to_literal(entry_ref); }\n      ConfigEntry & SetValue(const std::string & in_val, std::stringstream & /* warnings */) {\n        if constexpr (std::is_same<VAR_TYPE, std::string>::value) {\n          // Using a stringstream on a string with whitespace will only get\n          // first word, so only right trim for extra white space\n          size_t end = in_val.find_last_not_of(\" \\n\\r\\t\\f\\v\");\n          entry_ref = (end == std::string::npos) ? \"\" : in_val.substr(0, end+1);\n        } else {\n          // For other values, use the power of a stringstream to do a quick\n          // conversion\n          std::stringstream ss; ss << in_val; ss >> entry_ref;\n        }\n        return *this;\n      }\n      bool IsConst() const { return false; }\n    };\n\n    /// Type-specific and CONST versions of ConfigEntry class to manage fixed settings.\n    template <class VAR_TYPE> class tConfigConstEntry : public ConfigEntry {\n    protected:\n      const VAR_TYPE literal_val;\n    public:\n      tConfigConstEntry(const std::string _name, const std::string _type,\n                        const std::string _d_val, const std::string _desc,\n                        const VAR_TYPE & _literal_val)\n        : ConfigEntry(_name, _type, _d_val, _desc), literal_val(_literal_val) { ; }\n      ~tConfigConstEntry() { ; }\n\n      std::string GetValue() const { return default_val; }\n      std::string GetLiteralValue() const { return to_literal(literal_val); }\n      ConfigEntry & SetValue(const std::string & in_val, std::stringstream & warnings) {\n        // This is a constant setting.  If we are actually trying to change it, give a warning.\n        if (in_val != GetValue()) {\n          warnings << \"Trying to adjust locked setting '\"\n                   << name << \"' from '\" << GetValue()\n                   << \"' to '\" << in_val << \"'. Ignoring.\" << std::endl;\n        }\n        return *this;\n      }\n      bool IsConst() const { return true; }\n    };\n\n    /// Special settings entry for settings created during the run (only accissibly dynamically)\n    class ConfigLiveEntry : public ConfigEntry {\n    public:\n      ConfigLiveEntry(const std::string _name, const std::string _type,\n                       const std::string _d_val, const std::string _desc)\n        : ConfigEntry(_name, _type, _d_val, _desc) { ; }\n      ~ConfigLiveEntry() { ; }\n\n      std::string GetValue() const { return default_val; }\n      std::string GetLiteralValue() const { return to_literal(default_val); }\n      ConfigEntry & SetValue(const std::string & in_val, std::stringstream & warnings) {\n        (void) warnings;\n        default_val = in_val;\n        return *this;\n      }\n      bool IsConst() const { return false; }\n    };\n\n    /// Information about a sub-group of settings.\n    class ConfigGroup {\n    protected:\n      std::string name;\n      std::string desc;\n      emp::vector<ConfigEntry *> entry_set;\n    public:\n      ConfigGroup(const std::string & _name, const std::string & _desc)\n        : name(_name), desc(_desc), entry_set()\n      { ; }\n      ~ConfigGroup() { ; }\n\n      size_t GetSize() const { return entry_set.size(); }\n\n      std::string GetName() const { return name; }\n      std::string GetDesc() const { return desc; }\n\n      ConfigEntry * GetEntry(size_t id) { return entry_set[id]; }\n      ConfigEntry * GetLastEntry() { emp_assert(GetSize() > 0); return entry_set.back(); }\n\n      void Add(ConfigEntry * new_entry) { entry_set.push_back(new_entry); }\n\n      void Write(std::ostream & out) const {\n        // Print header information with the group name.\n        out << \"### \" << name << \" ###\" << std::endl;\n        // Print group description.\n        auto desc_lines = slice(desc);\n        for (size_t comment_line = 0; comment_line < desc_lines.size(); comment_line++) {\n          out << \"# \" << desc_lines[comment_line] << std::endl;\n        }\n        out << std::endl;\n\n        const size_t entry_count = entry_set.size();\n        emp::vector<std::string> setting_info(entry_count);\n        size_t max_length = 0;\n\n        // Loop through once to figure out non-comment output\n        for (size_t i = 0; i < entry_count; i++) {\n          setting_info[i] = \"set \";\n          setting_info[i] += entry_set[i]->GetName();\n          setting_info[i] += \" \";\n          setting_info[i] += entry_set[i]->GetValue();\n          if (max_length < setting_info[i].size()) max_length = setting_info[i].size();\n        }\n\n        // Loop through a second time to actually do the printing with properly spaced comments.\n        max_length += 2;\n        for (size_t i = 0; i < entry_count; i++) {\n          out << setting_info[i];\n\n          // Break the description up over multiple lines.\n          auto desc_lines = emp::slice(entry_set[i]->GetDescription());\n\n          size_t start_col = setting_info[i].size();\n          for (size_t comment_line = 0; comment_line < desc_lines.size(); comment_line++) {\n            for (size_t ws = start_col; ws < max_length; ws++) out << ' ';\n            out << \"# \" << desc_lines[comment_line] << std::endl;\n            start_col = 0;\n          }\n        }\n\n        out << std::endl; // Skip a line after each group.\n      }\n\n      void WriteUrlQueryString(std::ostream & out) const {\n        for (auto entry : entry_set) {\n          out << url_encode<false>(entry->GetName());\n          out << \"=\";\n          out << url_encode<false>(entry->GetValue());\n          out << \"&\";\n        }\n      }\n\n      void WriteMacros(std::ostream & out, bool as_const) const {\n        // Print header information to register group.\n        out << \"  GROUP(\" << name << \", \\\"\" << desc << \"\\\"),\\n\";\n\n        // Loop through once to figure out non-comment output\n        for (ConfigEntry * cur_entry : entry_set) {\n          if (as_const || cur_entry->IsConst()) { out << \"    CONST(\"; }\n          else { out << \"    VALUE(\"; }\n\n          out << cur_entry->GetName() << \", \"\n              << cur_entry->GetType() << \", \"\n              << cur_entry->GetLiteralValue() << \", \"\n              << to_literal( cur_entry->GetDescription() )\n              << \"),\\n\";\n\n          // Output aliases.\n          const std::unordered_set<std::string> & alias_set = cur_entry->GetAliases();\n          for (const std::string & cur_alias : alias_set) {\n            out << \"      ALIAS(\" << cur_alias << \"),\\n\";\n          }\n        }\n\n        out << std::endl; // Skip a line after each group.\n      }\n    };\n\n    // === Helper Functions ===\n    ConfigGroup * GetActiveGroup() {\n      if (group_set.size() == 0) {\n        group_set.push_back(new ConfigGroup(\"DEFAULT\", \"Default settings group\"));\n      }\n      return group_set.back();\n    }\n\n    ConfigEntry * GetActiveEntry() {\n      ConfigGroup * group = GetActiveGroup();\n      emp_assert(group->GetSize() > 0);\n      return group->GetLastEntry();\n    }\n\n    // Which characters can legally be part of a variable identifier?\n    bool IsVarChar(const char c) {\n      if (c >= 'a' && c <= 'z') return true;\n      if (c >= 'A' && c <= 'Z') return true;\n      if (c >= '0' && c <= '9') return true;\n      if (c == '_') return true;\n      return false;\n    }\n\n    // Process a line by:\n    // * Remove excess whitespace\n    // * Expand all variables beginning with a $ in config line.\n    // * If wrap-around, move line to extras\n    void ProcessLine(std::string & cur_line, std::string & extras) {\n      size_t start_pos = extras.size();          // If there were extras last time, skip them.\n      if (extras.size()) cur_line.insert(0, extras);\n      extras.resize(0);\n      emp::left_justify(cur_line);               // Clear out leading whitespace.\n\n      for (size_t pos = start_pos; pos < cur_line.size(); pos++) {\n        const char cur_char = cur_line[pos];\n        // Check for escape characters and convert them appropriately.\n        if (cur_char == '\\\\') {\n          if (pos+1 == cur_line.size()) {                    // If backslash is at end of line...\n            extras = cur_line.substr(0, cur_line.size()-1);  // ...move string to extras\n            cur_line.resize(0);                              // ...don't process current line\n            return;                                          // ...since this is the line end, stop\n          }\n          // If we make it this far, we have a regular character being escaped.  Make the swap!\n          const char esc_char = cur_line[pos+1];\n          switch (esc_char) {\n            case '$': cur_line.replace(pos, 2, \"$\"); break;\n            case '#': cur_line.replace(pos, 2, \"#\"); break;\n            case '\\\\': cur_line.replace(pos, 2, \"\\\\\"); break;\n            case 'n': cur_line.replace(pos, 2, \"\\n\"); break;\n            case 'r': cur_line.replace(pos, 2, \"\\r\"); break;\n            case 't': cur_line.replace(pos, 2, \"\\t\"); break;\n          }\n        }\n        // A '#' indicates that a comment is starting that the rest of the line should be removed.\n        else if (cur_char == '#') {\n          cur_line.resize(pos);\n        }\n        // A '$' indicates that we should expand a variable in place.\n        else if (cur_char == '$' && expand_ok) {\n          size_t end_pos = pos+1;\n          while (end_pos < cur_line.size() && IsVarChar(cur_line[end_pos])) end_pos++;\n          const size_t var_size = end_pos - pos - 1;\n          std::string var_name(cur_line, pos+1, var_size);\n\n          if (ResolveAlias(var_name)) {\n            std::string new_val = var_map[var_name]->GetValue();  // Lookup variable value.\n            cur_line.replace(pos, var_size+1, new_val);           // Replace var name with value.\n            pos += new_val.size();                                // Skip new text.\n          } else {\n            std::stringstream ss;\n            ss << \"Unable to process config setting '$\" << var_name << \"'. Ignoring.\" << std::endl;\n            emp::NotifyError(ss.str());\n          }\n          // @CAO CONTINUE\n        }\n      }\n\n    }\n\n    // === Protected member variables ===\n    emp::vector<std::string> class_names;           // Names in class heiarchy.\n    emp::unordered_map<std::string, ConfigEntry *> var_map;   // All variables across groups.\n    std::string version_id;                         // Unique version ID to ensure synced config.\n    emp::vector<ConfigGroup *> group_set;           // All of the config groups.\n    std::stringstream warnings;                     // Aggregate warnings for combined display.\n    int delay_warnings;                             // Count of delays to collect warnings for printing.\n    emp::unordered_map<std::string, std::string> alias_map;   // Map all aliases to original name.\n\n    // Map namespaces to the appropriate config object.\n    emp::unordered_map<std::string, Config *> namespace_map;\n\n    // Map new type names to the manager that handles them.\n    emp::unordered_map<std::string, ConfigManager_Base *> type_manager_map;\n\n    // Build a map of extra input commands to the function that they should call if triggered.\n    emp::unordered_map<std::string, std::function<bool(std::string)> > command_map;\n    emp::unordered_map<std::string, std::function<bool(std::string)> > new_map;\n    emp::unordered_map<std::string, std::function<bool(std::string)> > use_map;\n\n    // Instructions on how config should behave.\n    bool expand_ok;          // Should we expand variables in the config file.\n\n  public:\n    Config(const std::string & in_version = \"\")\n      : class_names(), var_map(), version_id(in_version), group_set(), warnings()\n      , delay_warnings(0), alias_map(), namespace_map(), type_manager_map(), command_map()\n      , new_map(), use_map(), expand_ok(true)\n    {\n      class_names.push_back(\"emp::Config\");\n    }\n\n    ~Config() {\n      // Delete all alocated memory!\n      for (auto & x : var_map) delete x.second;\n      for (auto & x : group_set) delete x;\n      for (auto & x : type_manager_map) delete x.second;\n    }\n\n    friend class ConfigWebUI;\n\n    ConfigEntry * operator[](const std::string & name) { return var_map[name]; }\n    auto begin() -> decltype(var_map.begin()) { return var_map.begin(); }\n    auto end() -> decltype(var_map.end()) { return var_map.end(); }\n\n    const ConfigEntry * operator[](const std::string & name) const { return var_map.at(name); }\n    auto cbegin() -> decltype(var_map.cbegin()) { return var_map.cbegin(); }\n    auto cend() -> decltype(var_map.cend()) { return var_map.cend(); }\n\n    auto begin() const -> const decltype(var_map.begin()) { return var_map.begin(); }\n    auto end() const -> const decltype(var_map.end()) { return var_map.end(); }\n\n    Config & SetExpandOK(bool ok=true) { expand_ok = ok; return *this; }\n\n    bool Has(const std::string & setting_name) const {\n      return (var_map.find(setting_name) != var_map.end()) ||\n        (alias_map.find(setting_name) != alias_map.end());\n    }\n\n    bool ResolveAlias(std::string & setting_name) const {\n      if (var_map.find(setting_name) != var_map.end()) return true;\n      if (alias_map.find(setting_name) != alias_map.end()) {\n        setting_name = alias_map.find(setting_name)->second;\n        return true;\n      }\n      return false;\n    }\n\n    std::string Get(std::string setting_name) {\n      if (!ResolveAlias(setting_name)) return \"\";  // @CAO Print warning?\n      return var_map[setting_name]->GetValue();\n    }\n\n    Config & Set(std::string setting_name, const std::string & new_value,\n                  const std::string & in_desc=\"\") {\n      if (!ResolveAlias(setting_name)) {\n        // This setting is not currently in the map!  We should put it in, but let user know.\n        warnings << \"Unknown setting '\" << setting_name << \"'.  Creating.\" << std::endl;\n        var_map[setting_name] = new ConfigLiveEntry(setting_name, \"std::string\", new_value, in_desc);\n        GetActiveGroup()->Add(var_map[setting_name]);\n      }\n      var_map[setting_name]->SetValue(new_value, warnings);\n      if (!delay_warnings && warnings.rdbuf()->in_avail()) {\n        emp::NotifyWarning(warnings.str());\n        warnings.str(std::string()); // Clear the warnings.\n      }\n      return *this;\n    }\n\n    std::string operator()(const std::string & setting_name) { return Get(setting_name); }\n\n    Config & operator()(const std::string & setting_name, const std::string & new_value) {\n      return Set(setting_name, new_value);\n    }\n\n    void AddAlias(const std::string & base_name, const std::string & alias_name) {\n      emp_assert( var_map.find(base_name) != var_map.end() );  // Make sure base exists.\n      emp_assert( !Has(alias_name) ); // Make sure alias does not!\n      alias_map[alias_name] = base_name;\n      var_map[base_name]->AddAlias(alias_name);\n    }\n\n    // Generate a text representation (typically a file) for the state of Config\n    void Write(std::ostream & out) const {\n      // @CAO Start by printing some file header information?\n\n      // Next print each group and its information.\n      for (auto it = group_set.begin(); it != group_set.end(); it++) {\n        (*it)->Write(out);\n      }\n\n      // Next, loop through all internal namespaces and print them out.\n      for (auto & x : namespace_map) {\n        out << \"\\n############################################################\\n\";\n        out << \"namespace \" << x.first << \"\\n\\n\";\n        x.second->Write(out);\n        out << \"end_namespace \" << x.first << \"\\n\";\n      }\n    }\n\n    // If a string is passed into Write, treat it as a filename.\n    void Write(std::string filename) const {\n      std::ofstream out(filename);\n      Write(out);\n      out.close();\n    }\n\n    // Generates url query parameters for the state of Config\n    void WriteUrlQueryString(std::ostream & out) const {\n      std::stringstream ss;\n      ss << \"?\";\n      for (auto it = group_set.begin(); it != group_set.end(); it++) {\n        (*it)->WriteUrlQueryString(ss);\n      }\n      std::string query(ss.str());\n      // Erase the trailing & to prevent parsing as an illegal (empty) argument to query\n      query.erase(query.end()-1);\n      out << query;\n    }\n\n    // Generate a text representation (typically a file) for the state of Config\n    void WriteMacros(std::ostream & out, bool as_const=false) const {\n      out << \"/////////////////////////////////////////////////////////////////////////////////\\n\"\n          << \"//  This is an auto-generated file that defines a set of configuration options.\\n\"\n          << \"//\\n\"\n          << \"//  To create a new config from scratch, the format is:\\n\"\n          << \"//    EMP_BUILD_CONFIG( CLASS_NAME, OPTIONS... )\\n\"\n          << \"//\\n\"\n          << \"//  To extend an existing config, simply use:\\n\"\n          << \"//    EMP_EXTEND_CONFIG( NEW_NAME, BASE_CLASS, OPTIONS... )\\n\"\n          << \"//\\n\"\n          << \"//  The available OPTIONS are:\\n\"\n          << \"//\\n\"\n          << \"//  GROUP(group name, group description string)\\n\"\n          << \"//   Start a new group of configuration options.  Group structure is preserved\\n\"\n          << \"//   when user-accessible configuration options are generated.\\n\"\n          << \"//\\n\"\n          << \"//  VALUE(variable name, type, default value, description string)\\n\"\n          << \"//   Create a new setting in the emp::Config object that can be easily accessed.\\n\"\n          << \"//\\n\"\n          << \"//  CONST(variable name, type, fixed value, description string)\\n\"\n          << \"//   Create a new configuration constant that cannot be changed.  In practice,\\n\"\n          << \"//   allows broader optimizations in the code.\\n\"\n          << \"//\\n\"\n          << \"//  ALIAS(alias name)\\n\"\n          << \"//   Include an alias for the previous setting.  This command is useful to\\n\"\n          << \"//   maintain backward compatibility if names change in newer software versions.\\n\"\n          << \"\\n\"\n          << \"EMP_BUILD_CONFIG(\" << class_names.back() << \",\"\n          << std::endl;\n\n      // Next print each group and it's information.\n      for (auto it = group_set.begin(); it != group_set.end(); it++) {\n        (*it)->WriteMacros(out, as_const);\n      }\n\n      out << \")\" << std::endl;\n    }\n\n    // If a string is passed into Write, treat it as a filename.\n    void WriteMacros(std::string filename, bool as_const=false) const {\n      std::ofstream out(filename);\n      WriteMacros(out, as_const);\n      out.close();\n    }\n\n\n    /// Read in from a text representation (typically a file) to set the state of Config.\n    /// Return success state.\n    bool Read(std::istream & input, const std::string & cur_namespace=\"\") {\n      // Load in the file one line at a time and process each line.\n      std::string cur_line, extras;\n      delay_warnings++;\n\n      // Loop through the file until eof is hit (does this work for other streams?)\n      while (!input.eof()) {\n        std::getline(input, cur_line);         // Get the current input line.\n        ProcessLine(cur_line, extras);         // Clean up line; act on aliases.\n\n        if (cur_line == \"\") continue;          // Skip empty lines.\n\n        std::string command = emp::string_pop_word(cur_line);\n\n        if (command == \"set\") {\n          // Set a specific value.\n          std::string setting_name = emp::string_pop_word(cur_line);\n          Set(setting_name, cur_line);\n        }\n        else if (command == \"include\") {\n          // Determine the filename to include.\n          std::string filename = emp::string_pop_word(cur_line);\n\n          // Process the new file (before automatically coming back to this one)\n          Read(filename);\n        }\n        else if (command == \"namespace\") {\n          std::string namespace_name = emp::string_pop_word(cur_line);\n          if (cur_line.size() > 0) {\n            warnings << \"namespace \" << namespace_name\n                     << \" cannot have additional arguments.  Ignoring.\\n\";\n          }\n          if (emp::Has(namespace_map, namespace_name) == false) {\n            emp::NotifyError(emp::to_string(\"Unknown namespace '\", namespace_name, \"'.  Aborting.\"));\n            return false;\n          }\n          Config * ns_config = namespace_map[namespace_name];\n          ns_config->Read(input, namespace_name);\n        }\n        else if (command == \"end_namespace\") {\n          std::string namespace_name = emp::string_pop_word(cur_line);\n          if (cur_line.size() > 0) {\n            warnings << \"end_namespace \" << namespace_name\n                     << \" cannot have additional arguments.  Ignoring.\\n\";\n          }\n          if (namespace_name != cur_namespace) {\n            emp::NotifyError(emp::to_string(\"Cannot end namespace '\", namespace_name,\n                                            \"' while in namespace '\", cur_namespace, \"'.  Aborting.\"));\n            return false;\n          }\n          return true;\n        }\n        else if (command == \"new\") {\n          std::string type_name = emp::string_pop_word(cur_line);\n          if (emp::Has(new_map, type_name) == false) {\n            emp::NotifyError(emp::to_string(\"Command 'new' failede: Unknown type '\",\n                                            type_name, \"'.  Aborting.\"));\n            return false;\n          }\n          // @CAO Make sure remainder of line is a single identifier?\n          new_map[type_name](cur_line);\n        }\n        else if (command == \"use\") {\n          std::string type_name = emp::string_pop_word(cur_line);\n          // @CAO Make sure type exists!\n          use_map[type_name](cur_line);\n        }\n        else if (command_map.find(command) != command_map.end()) {\n          // Run this custom command.\n          command_map[command](cur_line);\n        }\n        else {\n          // We don't know this command... give an error and move on.\n          std::stringstream ss;\n          ss << \"Unknown configuration command '\" << command << \"'. Ignoring.\" << std::endl;\n          emp::NotifyError(ss.str());\n        }\n      }\n\n      // Print out all accumulated warnings (if any).\n      if (warnings.rdbuf()->in_avail()) {\n        emp::NotifyWarning(warnings.str());\n        warnings.str(std::string()); // Clear the warnings.\n      }\n      delay_warnings--;\n\n      return true;\n    }\n\n    bool Read(std::string filename, bool error_on_missing_file=true) {\n      std::ifstream in_file(filename);\n      if (in_file.fail()) {\n        std::stringstream ss;\n        ss << \"Unable to open config file '\" << filename << \"'. Ignoring.\" << std::endl;\n        if (error_on_missing_file) emp::NotifyError(ss.str());\n        return false;\n      }\n      bool success = Read(in_file);\n      in_file.close();\n      return success;\n    }\n\n    void AddNameSpace(Config & config, const std::string & namespace_name) {\n      namespace_map[namespace_name] = &config;\n    }\n\n    void AddCommand(const std::string & command_name, std::function<bool(std::string)> command_fun) {\n      // Give a warning if we are re-defining an existing command.\n      if (command_map.find(command_name) != command_map.end()) {\n        warnings << \"Re-defining command '\" << command_name << \"'. Allowing.\" << std::endl;\n        if (!delay_warnings) {\n          emp::NotifyWarning(warnings.str());\n          warnings.str(std::string()); // Clear the warnings.\n        }\n      }\n      command_map[command_name] = command_fun;\n    }\n\n    void AddNewCallback(const std::string & type_name, std::function<bool(std::string)> new_fun) {\n      // Give a warning if we are re-defining an existing command.\n      if (new_map.find(type_name) != new_map.end()) {\n        warnings << \"Re-defining config type '\" << type_name << \"'. Allowing.\" << std::endl;\n        if (!delay_warnings) {\n          emp::NotifyWarning(warnings.str());\n          warnings.str(std::string()); // Clear the warnings.\n        }\n      }\n      new_map[type_name] = new_fun;\n    }\n\n    void AddUseCallback(const std::string & type_name, std::function<bool(std::string)> use_fun) {\n      // Give a warning if we are re-defining an existing command.\n      if (emp::Has(use_map, type_name)) {\n        warnings << \"Re-defining config type '\" << type_name << \"'. Allowing.\" << std::endl;\n        if (!delay_warnings) {\n          emp::NotifyWarning(warnings.str());\n          warnings.str(std::string()); // Clear the warnings.\n        }\n      }\n      use_map[type_name] = use_fun;\n    }\n\n\n    template <class MANAGED_TYPE>\n    void AddManagedType(const std::string & type_keyword, const std::string & command_keyword,\n                        std::function<bool(MANAGED_TYPE &, std::string)> fun_callback)\n    {\n      ConfigManager<MANAGED_TYPE> * new_manager = new ConfigManager<MANAGED_TYPE>(type_keyword, command_keyword, fun_callback);\n      type_manager_map[type_keyword] = new_manager;\n\n      AddCommand(command_keyword,\n                 std::bind(&ConfigManager<MANAGED_TYPE>::CommandCallback, new_manager, _1) );\n      AddNewCallback(type_keyword,\n                     std::bind(&ConfigManager<MANAGED_TYPE>::NewObject, new_manager, _1) );\n      AddUseCallback(type_keyword,\n                     std::bind(&ConfigManager<MANAGED_TYPE>::UseObject, new_manager, _1) );\n    }\n\n    /// Access group_set using this method since it is protected\n    emp::vector<ConfigGroup *> GetGroupSet(){\n      return group_set;\n    }\n\n  };\n\n}\n\n// Below are macros that help build the config classes.\n\n// Check that all of the commands are legal so that sensible errors can be produced.\n// (legal commands convert to two arguments; illeagal ones stay as one, so second arg is error!)\n#define EMP_CONFIG__ERROR_CHECK(CMD) EMP_GET_ARG(2, EMP_CONFIG__ARG_OKAY_ ## CMD, \\\n                                     static_assert(false, \"Unknown Config option: \" #CMD);, ~)\n#define EMP_CONFIG__ARG_OKAY_VALUE(...) ~,\n#define EMP_CONFIG__ARG_OKAY_CONST(...) ~,\n#define EMP_CONFIG__ARG_OKAY_const(...) ~,\n#define EMP_CONFIG__ARG_OKAY_GROUP(...) ~,\n#define EMP_CONFIG__ARG_OKAY_ALIAS(...) ~,\n#define EMP_CONFIG__ARG_OKAY_ ~,\n\n\n// Macros to handle declaration of protected member variables.\n// Note, unneeded macros defined to nothing, as is extra ending in '_' to allow trailing comma.\n#define EMP_CONFIG__DECLARE(CMD) EMP_CONFIG__DECLARE_ ## CMD\n#define EMP_CONFIG__DECLARE_VALUE(NAME, TYPE, DEFAULT, DESC) TYPE m_ ## NAME;\n#define EMP_CONFIG__DECLARE_CONST(NAME, TYPE, DEFAULT, DESC)\n#define EMP_CONFIG__DECLARE_const(NAME, TYPE, DEFAULT, DESC)\n#define EMP_CONFIG__DECLARE_GROUP(NAME, DESC)\n#define EMP_CONFIG__DECLARE_ALIAS(NAME)\n#define EMP_CONFIG__DECLARE_\n\n// Macros to handle construction of vars.\n#define EMP_CONFIG__CONSTRUCT(CMD) EMP_CONFIG__CONSTRUCT_ ## CMD\n#define EMP_CONFIG__CONSTRUCT_VALUE(NAME, TYPE, DEFAULT, DESC) , m_ ## NAME(DEFAULT)\n#define EMP_CONFIG__CONSTRUCT_CONST(NAME, TYPE, DEFAULT, DESC)\n#define EMP_CONFIG__CONSTRUCT_const(NAME, TYPE, DEFAULT, DESC)\n#define EMP_CONFIG__CONSTRUCT_GROUP(NAME, DESC)\n#define EMP_CONFIG__CONSTRUCT_ALIAS(NAME)\n#define EMP_CONFIG__CONSTRUCT_\n\n// Macros to initialize internal representation of variables.\n#define EMP_CONFIG__INIT(CMD) EMP_CONFIG__INIT_ ## CMD\n#define EMP_CONFIG__INIT_VALUE(NAME, TYPE, DEFAULT, DESC)                               \\\n  var_map[#NAME] = new tConfigEntry<TYPE>(#NAME, #TYPE, #DEFAULT, DESC, m_ ## NAME);    \\\n  GetActiveGroup()->Add(var_map[#NAME]);\n#define EMP_CONFIG__INIT_CONST(NAME, TYPE, VALUE, DESC)                                 \\\n  var_map[#NAME] = new tConfigConstEntry<TYPE>(#NAME, #TYPE, #VALUE, DESC, VALUE);      \\\n  GetActiveGroup()->Add(var_map[#NAME]);\n#define EMP_CONFIG__INIT_const(NAME, TYPE, VALUE, DESC)                                 \\\n  var_map[#NAME] = new tConfigConstEntry<TYPE>(#NAME, #TYPE, #VALUE, DESC, VALUE);      \\\n  GetActiveGroup()->Add(var_map[#NAME]);\n#define EMP_CONFIG__INIT_GROUP(NAME, DESC)                                              \\\n  group_set.push_back(new ConfigGroup(#NAME, DESC));\n#define EMP_CONFIG__INIT_ALIAS(NAME)                                                    \\\n  AddAlias(GetActiveEntry()->GetName(), #NAME);\n#define EMP_CONFIG__INIT_\n\n// Build Get and Set Accessors, as well as const check\n#define EMP_CONFIG__ACCESS(CMD) EMP_CONFIG__ACCESS_ ## CMD\n#define EMP_CONFIG__ACCESS_VALUE(NAME, TYPE, DEFAULT, DESC)                     \\\n  inline const TYPE & NAME() const { return m_ ## NAME; }                       \\\n  const TYPE & NAME(const TYPE & _in) { m_ ## NAME = _in; return m_ ## NAME; }  \\\n  bool NAME ## _is_const() const { return false; }\n#define EMP_CONFIG__ACCESS_CONST(NAME, TYPE, VALUE, DESC)                       \\\n  constexpr static TYPE NAME() { return VALUE; }                                \\\n  TYPE NAME(const TYPE & _in) {                                                 \\\n    std::stringstream ss;                                                       \\\n    ss << \"Trying to set const '\" << #NAME << \"'. Ignoring.\" << std::endl;      \\\n    emp::NotifyWarning(ss.str());                                               \\\n    return VALUE;                                                               \\\n  }                                                                             \\\n  bool NAME ## _is_const() const { return true; }\n#define EMP_CONFIG__ACCESS_const(NAME, TYPE, VALUE, DESC) EMP_CONFIG__ACCESS_CONST(NAME, TYPE, VALUE, DESC)\n#define EMP_CONFIG__ACCESS_GROUP(NAME, DESC)\n#define EMP_CONFIG__ACCESS_ALIAS(NAME)\n#define EMP_CONFIG__ACCESS_\n\n#define EMP_BUILD_CONFIG(CLASS_NAME, ...) EMP_EXTEND_CONFIG(CLASS_NAME, emp::Config, __VA_ARGS__)\n\n#define EMP_EXTEND_CONFIG(CLASS_NAME, BASE_NAME, ...)     \\\n  EMP_WRAP_EACH(EMP_CONFIG__ERROR_CHECK, __VA_ARGS__)     \\\n  class CLASS_NAME : public BASE_NAME {                   \\\n  protected:                                              \\\n    bool is_ ## CLASS_NAME;                               \\\n    EMP_WRAP_EACH(EMP_CONFIG__DECLARE, __VA_ARGS__)       \\\n  public:                                                 \\\n    CLASS_NAME() : is_ ## CLASS_NAME(true)                \\\n    EMP_WRAP_EACH(EMP_CONFIG__CONSTRUCT, __VA_ARGS__)     \\\n    {                                                     \\\n      class_names.push_back(#CLASS_NAME);                 \\\n      EMP_WRAP_EACH(EMP_CONFIG__INIT, __VA_ARGS__)        \\\n    }                                                     \\\n    EMP_WRAP_EACH(EMP_CONFIG__ACCESS, __VA_ARGS__)        \\\n  };\n\n#endif // #ifndef EMP_CONFIG_CONFIG_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2019\n *\n *  @file UrlParams.hpp\n *  @brief Get an unordered_map containing url query key/value parameters.\n *\n */\n\n#ifndef EMP_WEB_URLPARAMS_HPP_INCLUDE\n#define EMP_WEB_URLPARAMS_HPP_INCLUDE\n\n#include <map>\n#include <string>\n\n#include \"js_utils.hpp\"\n#include \"JSWrap.hpp\"\n\nnamespace emp {\nnamespace web {\n  /**\n   * Extracts the query portion of a url and parses for key value pairs.\n   *\n   * @note In a query space encoded by \"%20\" is interpreted as a space character\n   * while the space encoded by \"+\" is used to separate a list of values for a key.\n   * For example querying \"?seed=100&strings=hi%20there+blah\" will be parsed\n   * to the parameter array [[\"seed\", \"100\"], [\"strings\", \"hi there\", \"blah\"]]\n   * then converted to a multimap.\n   *\n   * Some esoterica: \"?string=this+that\" and \"?string=this&string=that\"\n   * have different meanings and may result in different behavior.\n   * Similarly \"?test\" becomes [[\"test\"]] while \"?test=\" becomes\n   * [[\"test\", \"\"]].\n   */\n  std::multimap<std::string, emp::vector<std::string>> GetUrlParams() {\n\n    emp::vector<emp::vector<std::string>> incoming;\n\n    MAIN_THREAD_EM_ASM({\n      emp_i.__outgoing_array = location.search.includes('?')\n      ? location.search.substring(1).split('&'\n        ).map(\n          expr => expr.split(\"=\")\n        ).map(\n          (list) => [list[0].split(\"+\").join(\" \")].concat(\n            list[1] && list[1].split('+')\n          ).filter(\n            item => item !== undefined\n          )\n        ).map(\n          list => list.map(decodeURIComponent)\n        ).map(\n          p => p[0].split(\" \").join(\"\").length == 0\n            ?  [\"_illegal\", \"_empty=\" + p[1]] : p\n        ).map(\n          p => p[0].includes(\" \") ? [\"_illegal\", p[0] + \"=\" + p[1]] : p\n        )\n      : [];\n    });\n\n    emp::pass_vector_to_cpp(incoming);\n\n    std::multimap<std::string, emp::vector<std::string>> res;\n\n    for (const auto & pack : incoming) {\n      res.insert({\n        pack.front(),\n        emp::vector<std::string>(\n          std::next(std::begin(pack)),\n          std::end(pack)\n        )\n      });\n    }\n\n    return res;\n\n  }\n\n}\n}\n\n#endif // #ifndef EMP_WEB_URLPARAMS_HPP_INCLUDE\n","// -*- C++ -*-\n//===--------------------------- filesystem -------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n#ifndef _LIBCPP_FILESYSTEM\n#define _LIBCPP_FILESYSTEM\n/*\n    filesystem synopsis\n\n    namespace std { namespace filesystem {\n\n    class path;\n\n    void swap(path& lhs, path& rhs) noexcept;\n    size_t hash_value(const path& p) noexcept;\n\n    bool operator==(const path& lhs, const path& rhs) noexcept;\n    bool operator!=(const path& lhs, const path& rhs) noexcept;\n    bool operator< (const path& lhs, const path& rhs) noexcept;\n    bool operator<=(const path& lhs, const path& rhs) noexcept;\n    bool operator> (const path& lhs, const path& rhs) noexcept;\n    bool operator>=(const path& lhs, const path& rhs) noexcept;\n\n    path operator/ (const path& lhs, const path& rhs);\n\n    // fs.path.io operators are friends of path.\n    template <class charT, class traits>\n    friend basic_ostream<charT, traits>&\n    operator<<(basic_ostream<charT, traits>& os, const path& p);\n\n    template <class charT, class traits>\n    friend basic_istream<charT, traits>&\n    operator>>(basic_istream<charT, traits>& is, path& p);\n\n    template <class Source>\n      path u8path(const Source& source);\n    template <class InputIterator>\n      path u8path(InputIterator first, InputIterator last);\n\n    class filesystem_error;\n    class directory_entry;\n\n    class directory_iterator;\n\n    // enable directory_iterator range-based for statements\n    directory_iterator begin(directory_iterator iter) noexcept;\n    directory_iterator end(const directory_iterator&) noexcept;\n\n    class recursive_directory_iterator;\n\n    // enable recursive_directory_iterator range-based for statements\n    recursive_directory_iterator begin(recursive_directory_iterator iter) noexcept;\n    recursive_directory_iterator end(const recursive_directory_iterator&) noexcept;\n\n    class file_status;\n\n    struct space_info\n    {\n      uintmax_t capacity;\n      uintmax_t free;\n      uintmax_t available;\n    };\n\n    enum class file_type;\n    enum class perms;\n    enum class perm_options;\n    enum class copy_options;\n    enum class directory_options;\n\n    typedef chrono::time_point<trivial-clock>  file_time_type;\n\n    // operational functions\n\n    path absolute(const path& p);\n    path absolute(const path& p, error_code &ec);\n\n    path canonical(const path& p);\n    path canonical(const path& p, error_code& ec);\n\n    void copy(const path& from, const path& to);\n    void copy(const path& from, const path& to, error_code& ec);\n    void copy(const path& from, const path& to, copy_options options);\n    void copy(const path& from, const path& to, copy_options options,\n                   error_code& ec);\n\n    bool copy_file(const path& from, const path& to);\n    bool copy_file(const path& from, const path& to, error_code& ec);\n    bool copy_file(const path& from, const path& to, copy_options option);\n    bool copy_file(const path& from, const path& to, copy_options option,\n                           error_code& ec);\n\n    void copy_symlink(const path& existing_symlink, const path& new_symlink);\n    void copy_symlink(const path& existing_symlink, const path& new_symlink,\n                              error_code& ec) noexcept;\n\n    bool create_directories(const path& p);\n    bool create_directories(const path& p, error_code& ec);\n\n    bool create_directory(const path& p);\n    bool create_directory(const path& p, error_code& ec) noexcept;\n\n    bool create_directory(const path& p, const path& attributes);\n    bool create_directory(const path& p, const path& attributes,\n                                  error_code& ec) noexcept;\n\n    void create_directory_symlink(const path& to, const path& new_symlink);\n    void create_directory_symlink(const path& to, const path& new_symlink,\n                                          error_code& ec) noexcept;\n\n    void create_hard_link(const path& to, const path& new_hard_link);\n    void create_hard_link(const path& to, const path& new_hard_link,\n                                  error_code& ec) noexcept;\n\n    void create_symlink(const path& to, const path& new_symlink);\n    void create_symlink(const path& to, const path& new_symlink,\n                                error_code& ec) noexcept;\n\n    path current_path();\n    path current_path(error_code& ec);\n    void current_path(const path& p);\n    void current_path(const path& p, error_code& ec) noexcept;\n\n    bool exists(file_status s) noexcept;\n    bool exists(const path& p);\n    bool exists(const path& p, error_code& ec) noexcept;\n\n    bool equivalent(const path& p1, const path& p2);\n    bool equivalent(const path& p1, const path& p2, error_code& ec) noexcept;\n\n    uintmax_t    file_size(const path& p);\n    uintmax_t    file_size(const path& p, error_code& ec) noexcept;\n\n    uintmax_t    hard_link_count(const path& p);\n    uintmax_t    hard_link_count(const path& p, error_code& ec) noexcept;\n\n    bool is_block_file(file_status s) noexcept;\n    bool is_block_file(const path& p);\n    bool is_block_file(const path& p, error_code& ec) noexcept;\n\n    bool is_character_file(file_status s) noexcept;\n    bool is_character_file(const path& p);\n    bool is_character_file(const path& p, error_code& ec) noexcept;\n\n    bool is_directory(file_status s) noexcept;\n    bool is_directory(const path& p);\n    bool is_directory(const path& p, error_code& ec) noexcept;\n\n    bool is_empty(const path& p);\n    bool is_empty(const path& p, error_code& ec) noexcept;\n\n    bool is_fifo(file_status s) noexcept;\n    bool is_fifo(const path& p);\n    bool is_fifo(const path& p, error_code& ec) noexcept;\n\n    bool is_other(file_status s) noexcept;\n    bool is_other(const path& p);\n    bool is_other(const path& p, error_code& ec) noexcept;\n\n    bool is_regular_file(file_status s) noexcept;\n    bool is_regular_file(const path& p);\n    bool is_regular_file(const path& p, error_code& ec) noexcept;\n\n    bool is_socket(file_status s) noexcept;\n    bool is_socket(const path& p);\n    bool is_socket(const path& p, error_code& ec) noexcept;\n\n    bool is_symlink(file_status s) noexcept;\n    bool is_symlink(const path& p);\n    bool is_symlink(const path& p, error_code& ec) noexcept;\n\n    file_time_type  last_write_time(const path& p);\n    file_time_type  last_write_time(const path& p, error_code& ec) noexcept;\n    void last_write_time(const path& p, file_time_type new_time);\n    void last_write_time(const path& p, file_time_type new_time,\n                                 error_code& ec) noexcept;\n\n    void permissions(const path& p, perms prms,\n                     perm_options opts=perm_options::replace);\n    void permissions(const path& p, perms prms, error_code& ec) noexcept;\n    void permissions(const path& p, perms prms, perm_options opts,\n                     error_code& ec);\n\n    path proximate(const path& p, error_code& ec);\n    path proximate(const path& p, const path& base = current_path());\n    path proximate(const path& p, const path& base, error_code &ec);\n\n    path read_symlink(const path& p);\n    path read_symlink(const path& p, error_code& ec);\n\n    path relative(const path& p, error_code& ec);\n    path relative(const path& p, const path& base=current_path());\n    path relative(const path& p, const path& base, error_code& ec);\n\n    bool remove(const path& p);\n    bool remove(const path& p, error_code& ec) noexcept;\n\n    uintmax_t    remove_all(const path& p);\n    uintmax_t    remove_all(const path& p, error_code& ec);\n\n    void rename(const path& from, const path& to);\n    void rename(const path& from, const path& to, error_code& ec) noexcept;\n\n    void resize_file(const path& p, uintmax_t size);\n    void resize_file(const path& p, uintmax_t size, error_code& ec) noexcept;\n\n    space_info   space(const path& p);\n    space_info   space(const path& p, error_code& ec) noexcept;\n\n    file_status  status(const path& p);\n    file_status  status(const path& p, error_code& ec) noexcept;\n\n    bool status_known(file_status s) noexcept;\n\n    file_status  symlink_status(const path& p);\n    file_status  symlink_status(const path& p, error_code& ec) noexcept;\n\n    path temp_directory_path();\n    path temp_directory_path(error_code& ec);\n\n    path weakly_canonical(path const& p);\n    path weakly_canonical(path const& p, error_code& ec);\n\n\n} }  // namespaces std::filesystem\n\n*/\n\n#include <__config>\n#include <cstddef>\n#include <cstdlib>\n#include <chrono>\n#include <iterator>\n#include <iosfwd>\n#include <locale>\n#include <memory>\n#include <stack>\n#include <string>\n#include <system_error>\n#include <utility>\n#include <iomanip> // for quoted\n#include <string_view>\n#include <version>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n#ifndef _LIBCPP_CXX03_LANG\n\n_LIBCPP_BEGIN_NAMESPACE_FILESYSTEM\n\ntypedef chrono::time_point<_FilesystemClock> file_time_type;\n\nstruct _LIBCPP_TYPE_VIS space_info {\n  uintmax_t capacity;\n  uintmax_t free;\n  uintmax_t available;\n};\n\nenum class _LIBCPP_ENUM_VIS file_type : signed char {\n  none = 0,\n  not_found = -1,\n  regular = 1,\n  directory = 2,\n  symlink = 3,\n  block = 4,\n  character = 5,\n  fifo = 6,\n  socket = 7,\n  unknown = 8\n};\n\nenum class _LIBCPP_ENUM_VIS perms : unsigned {\n  none = 0,\n\n  owner_read = 0400,\n  owner_write = 0200,\n  owner_exec = 0100,\n  owner_all = 0700,\n\n  group_read = 040,\n  group_write = 020,\n  group_exec = 010,\n  group_all = 070,\n\n  others_read = 04,\n  others_write = 02,\n  others_exec = 01,\n  others_all = 07,\n\n  all = 0777,\n\n  set_uid = 04000,\n  set_gid = 02000,\n  sticky_bit = 01000,\n  mask = 07777,\n  unknown = 0xFFFF,\n};\n\n_LIBCPP_INLINE_VISIBILITY\ninline constexpr perms operator&(perms _LHS, perms _RHS) {\n  return static_cast<perms>(static_cast<unsigned>(_LHS) &\n                            static_cast<unsigned>(_RHS));\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline constexpr perms operator|(perms _LHS, perms _RHS) {\n  return static_cast<perms>(static_cast<unsigned>(_LHS) |\n                            static_cast<unsigned>(_RHS));\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline constexpr perms operator^(perms _LHS, perms _RHS) {\n  return static_cast<perms>(static_cast<unsigned>(_LHS) ^\n                            static_cast<unsigned>(_RHS));\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline constexpr perms operator~(perms _LHS) {\n  return static_cast<perms>(~static_cast<unsigned>(_LHS));\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline perms& operator&=(perms& _LHS, perms _RHS) { return _LHS = _LHS & _RHS; }\n\n_LIBCPP_INLINE_VISIBILITY\ninline perms& operator|=(perms& _LHS, perms _RHS) { return _LHS = _LHS | _RHS; }\n\n_LIBCPP_INLINE_VISIBILITY\ninline perms& operator^=(perms& _LHS, perms _RHS) { return _LHS = _LHS ^ _RHS; }\n\nenum class _LIBCPP_ENUM_VIS perm_options : unsigned char {\n  replace = 1,\n  add = 2,\n  remove = 4,\n  nofollow = 8\n};\n\n_LIBCPP_INLINE_VISIBILITY\ninline constexpr perm_options operator&(perm_options _LHS, perm_options _RHS) {\n  return static_cast<perm_options>(static_cast<unsigned>(_LHS) &\n                                   static_cast<unsigned>(_RHS));\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline constexpr perm_options operator|(perm_options _LHS, perm_options _RHS) {\n  return static_cast<perm_options>(static_cast<unsigned>(_LHS) |\n                                   static_cast<unsigned>(_RHS));\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline constexpr perm_options operator^(perm_options _LHS, perm_options _RHS) {\n  return static_cast<perm_options>(static_cast<unsigned>(_LHS) ^\n                                   static_cast<unsigned>(_RHS));\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline constexpr perm_options operator~(perm_options _LHS) {\n  return static_cast<perm_options>(~static_cast<unsigned>(_LHS));\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline perm_options& operator&=(perm_options& _LHS, perm_options _RHS) {\n  return _LHS = _LHS & _RHS;\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline perm_options& operator|=(perm_options& _LHS, perm_options _RHS) {\n  return _LHS = _LHS | _RHS;\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline perm_options& operator^=(perm_options& _LHS, perm_options _RHS) {\n  return _LHS = _LHS ^ _RHS;\n}\n\nenum class _LIBCPP_ENUM_VIS copy_options : unsigned short {\n  none = 0,\n  skip_existing = 1,\n  overwrite_existing = 2,\n  update_existing = 4,\n  recursive = 8,\n  copy_symlinks = 16,\n  skip_symlinks = 32,\n  directories_only = 64,\n  create_symlinks = 128,\n  create_hard_links = 256,\n  __in_recursive_copy = 512,\n};\n\n_LIBCPP_INLINE_VISIBILITY\ninline constexpr copy_options operator&(copy_options _LHS, copy_options _RHS) {\n  return static_cast<copy_options>(static_cast<unsigned short>(_LHS) &\n                                   static_cast<unsigned short>(_RHS));\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline constexpr copy_options operator|(copy_options _LHS, copy_options _RHS) {\n  return static_cast<copy_options>(static_cast<unsigned short>(_LHS) |\n                                   static_cast<unsigned short>(_RHS));\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline constexpr copy_options operator^(copy_options _LHS, copy_options _RHS) {\n  return static_cast<copy_options>(static_cast<unsigned short>(_LHS) ^\n                                   static_cast<unsigned short>(_RHS));\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline constexpr copy_options operator~(copy_options _LHS) {\n  return static_cast<copy_options>(~static_cast<unsigned short>(_LHS));\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline copy_options& operator&=(copy_options& _LHS, copy_options _RHS) {\n  return _LHS = _LHS & _RHS;\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline copy_options& operator|=(copy_options& _LHS, copy_options _RHS) {\n  return _LHS = _LHS | _RHS;\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline copy_options& operator^=(copy_options& _LHS, copy_options _RHS) {\n  return _LHS = _LHS ^ _RHS;\n}\n\nenum class _LIBCPP_ENUM_VIS directory_options : unsigned char {\n  none = 0,\n  follow_directory_symlink = 1,\n  skip_permission_denied = 2\n};\n\n_LIBCPP_INLINE_VISIBILITY\ninline constexpr directory_options operator&(directory_options _LHS,\n                                             directory_options _RHS) {\n  return static_cast<directory_options>(static_cast<unsigned char>(_LHS) &\n                                        static_cast<unsigned char>(_RHS));\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline constexpr directory_options operator|(directory_options _LHS,\n                                             directory_options _RHS) {\n  return static_cast<directory_options>(static_cast<unsigned char>(_LHS) |\n                                        static_cast<unsigned char>(_RHS));\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline constexpr directory_options operator^(directory_options _LHS,\n                                             directory_options _RHS) {\n  return static_cast<directory_options>(static_cast<unsigned char>(_LHS) ^\n                                        static_cast<unsigned char>(_RHS));\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline constexpr directory_options operator~(directory_options _LHS) {\n  return static_cast<directory_options>(~static_cast<unsigned char>(_LHS));\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline directory_options& operator&=(directory_options& _LHS,\n                                     directory_options _RHS) {\n  return _LHS = _LHS & _RHS;\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline directory_options& operator|=(directory_options& _LHS,\n                                     directory_options _RHS) {\n  return _LHS = _LHS | _RHS;\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline directory_options& operator^=(directory_options& _LHS,\n                                     directory_options _RHS) {\n  return _LHS = _LHS ^ _RHS;\n}\n\nclass _LIBCPP_TYPE_VIS file_status {\npublic:\n  // constructors\n  _LIBCPP_INLINE_VISIBILITY\n  file_status() noexcept : file_status(file_type::none) {}\n  _LIBCPP_INLINE_VISIBILITY\n  explicit file_status(file_type __ft, perms __prms = perms::unknown) noexcept\n      : __ft_(__ft),\n        __prms_(__prms) {}\n\n  file_status(const file_status&) noexcept = default;\n  file_status(file_status&&) noexcept = default;\n\n  _LIBCPP_INLINE_VISIBILITY\n  ~file_status() {}\n\n  file_status& operator=(const file_status&) noexcept = default;\n  file_status& operator=(file_status&&) noexcept = default;\n\n  // observers\n  _LIBCPP_INLINE_VISIBILITY\n  file_type type() const noexcept { return __ft_; }\n\n  _LIBCPP_INLINE_VISIBILITY\n  perms permissions() const noexcept { return __prms_; }\n\n  // modifiers\n  _LIBCPP_INLINE_VISIBILITY\n  void type(file_type __ft) noexcept { __ft_ = __ft; }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void permissions(perms __p) noexcept { __prms_ = __p; }\n\nprivate:\n  file_type __ft_;\n  perms __prms_;\n};\n\nclass _LIBCPP_TYPE_VIS directory_entry;\n\ntemplate <class _Tp>\nstruct __can_convert_char {\n  static const bool value = false;\n};\ntemplate <class _Tp>\nstruct __can_convert_char<const _Tp> : public __can_convert_char<_Tp> {};\ntemplate <>\nstruct __can_convert_char<char> {\n  static const bool value = true;\n  using __char_type = char;\n};\ntemplate <>\nstruct __can_convert_char<wchar_t> {\n  static const bool value = true;\n  using __char_type = wchar_t;\n};\ntemplate <>\nstruct __can_convert_char<char16_t> {\n  static const bool value = true;\n  using __char_type = char16_t;\n};\ntemplate <>\nstruct __can_convert_char<char32_t> {\n  static const bool value = true;\n  using __char_type = char32_t;\n};\n\ntemplate <class _ECharT>\ntypename enable_if<__can_convert_char<_ECharT>::value, bool>::type\n__is_separator(_ECharT __e) {\n  return __e == _ECharT('/');\n}\n\nstruct _NullSentinal {};\n\ntemplate <class _Tp>\nusing _Void = void;\n\ntemplate <class _Tp, class = void>\nstruct __is_pathable_string : public false_type {};\n\ntemplate <class _ECharT, class _Traits, class _Alloc>\nstruct __is_pathable_string<\n    basic_string<_ECharT, _Traits, _Alloc>,\n    _Void<typename __can_convert_char<_ECharT>::__char_type> >\n    : public __can_convert_char<_ECharT> {\n  using _Str = basic_string<_ECharT, _Traits, _Alloc>;\n  using _Base = __can_convert_char<_ECharT>;\n  static _ECharT const* __range_begin(_Str const& __s) { return __s.data(); }\n  static _ECharT const* __range_end(_Str const& __s) {\n    return __s.data() + __s.length();\n  }\n  static _ECharT __first_or_null(_Str const& __s) {\n    return __s.empty() ? _ECharT{} : __s[0];\n  }\n};\n\ntemplate <class _ECharT, class _Traits>\nstruct __is_pathable_string<\n    basic_string_view<_ECharT, _Traits>,\n    _Void<typename __can_convert_char<_ECharT>::__char_type> >\n    : public __can_convert_char<_ECharT> {\n  using _Str = basic_string_view<_ECharT, _Traits>;\n  using _Base = __can_convert_char<_ECharT>;\n  static _ECharT const* __range_begin(_Str const& __s) { return __s.data(); }\n  static _ECharT const* __range_end(_Str const& __s) {\n    return __s.data() + __s.length();\n  }\n  static _ECharT __first_or_null(_Str const& __s) {\n    return __s.empty() ? _ECharT{} : __s[0];\n  }\n};\n\ntemplate <class _Source, class _DS = typename decay<_Source>::type,\n          class _UnqualPtrType =\n              typename remove_const<typename remove_pointer<_DS>::type>::type,\n          bool _IsCharPtr = is_pointer<_DS>::value&&\n              __can_convert_char<_UnqualPtrType>::value>\nstruct __is_pathable_char_array : false_type {};\n\ntemplate <class _Source, class _ECharT, class _UPtr>\nstruct __is_pathable_char_array<_Source, _ECharT*, _UPtr, true>\n    : __can_convert_char<typename remove_const<_ECharT>::type> {\n  using _Base = __can_convert_char<typename remove_const<_ECharT>::type>;\n\n  static _ECharT const* __range_begin(const _ECharT* __b) { return __b; }\n  static _ECharT const* __range_end(const _ECharT* __b) {\n    using _Iter = const _ECharT*;\n    const _ECharT __sentinal = _ECharT{};\n    _Iter __e = __b;\n    for (; *__e != __sentinal; ++__e)\n      ;\n    return __e;\n  }\n\n  static _ECharT __first_or_null(const _ECharT* __b) { return *__b; }\n};\n\ntemplate <class _Iter, bool _IsIt = __is_input_iterator<_Iter>::value,\n          class = void>\nstruct __is_pathable_iter : false_type {};\n\ntemplate <class _Iter>\nstruct __is_pathable_iter<\n    _Iter, true,\n    _Void<typename __can_convert_char<\n        typename iterator_traits<_Iter>::value_type>::__char_type> >\n    : __can_convert_char<typename iterator_traits<_Iter>::value_type> {\n  using _ECharT = typename iterator_traits<_Iter>::value_type;\n  using _Base = __can_convert_char<_ECharT>;\n\n  static _Iter __range_begin(_Iter __b) { return __b; }\n  static _NullSentinal __range_end(_Iter) { return _NullSentinal{}; }\n\n  static _ECharT __first_or_null(_Iter __b) { return *__b; }\n};\n\ntemplate <class _Tp, bool _IsStringT = __is_pathable_string<_Tp>::value,\n          bool _IsCharIterT = __is_pathable_char_array<_Tp>::value,\n          bool _IsIterT = !_IsCharIterT && __is_pathable_iter<_Tp>::value>\nstruct __is_pathable : false_type {\n  static_assert(!_IsStringT && !_IsCharIterT && !_IsIterT, \"Must all be false\");\n};\n\ntemplate <class _Tp>\nstruct __is_pathable<_Tp, true, false, false> : __is_pathable_string<_Tp> {};\n\ntemplate <class _Tp>\nstruct __is_pathable<_Tp, false, true, false> : __is_pathable_char_array<_Tp> {\n};\n\ntemplate <class _Tp>\nstruct __is_pathable<_Tp, false, false, true> : __is_pathable_iter<_Tp> {};\n\ntemplate <class _ECharT>\nstruct _PathCVT {\n  static_assert(__can_convert_char<_ECharT>::value,\n                \"Char type not convertible\");\n\n  typedef __narrow_to_utf8<sizeof(_ECharT) * __CHAR_BIT__> _Narrower;\n\n  static void __append_range(string& __dest, _ECharT const* __b,\n                             _ECharT const* __e) {\n    _Narrower()(back_inserter(__dest), __b, __e);\n  }\n\n  template <class _Iter>\n  static void __append_range(string& __dest, _Iter __b, _Iter __e) {\n    static_assert(!is_same<_Iter, _ECharT*>::value, \"Call const overload\");\n    if (__b == __e)\n      return;\n    basic_string<_ECharT> __tmp(__b, __e);\n    _Narrower()(back_inserter(__dest), __tmp.data(),\n                __tmp.data() + __tmp.length());\n  }\n\n  template <class _Iter>\n  static void __append_range(string& __dest, _Iter __b, _NullSentinal) {\n    static_assert(!is_same<_Iter, _ECharT*>::value, \"Call const overload\");\n    const _ECharT __sentinal = _ECharT{};\n    if (*__b == __sentinal)\n      return;\n    basic_string<_ECharT> __tmp;\n    for (; *__b != __sentinal; ++__b)\n      __tmp.push_back(*__b);\n    _Narrower()(back_inserter(__dest), __tmp.data(),\n                __tmp.data() + __tmp.length());\n  }\n\n  template <class _Source>\n  static void __append_source(string& __dest, _Source const& __s) {\n    using _Traits = __is_pathable<_Source>;\n    __append_range(__dest, _Traits::__range_begin(__s),\n                   _Traits::__range_end(__s));\n  }\n};\n\ntemplate <>\nstruct _PathCVT<char> {\n\n  template <class _Iter>\n  static typename enable_if<__is_exactly_input_iterator<_Iter>::value>::type\n  __append_range(string& __dest, _Iter __b, _Iter __e) {\n    for (; __b != __e; ++__b)\n      __dest.push_back(*__b);\n  }\n\n  template <class _Iter>\n  static typename enable_if<__is_forward_iterator<_Iter>::value>::type\n  __append_range(string& __dest, _Iter __b, _Iter __e) {\n    __dest.__append_forward_unsafe(__b, __e);\n  }\n\n  template <class _Iter>\n  static void __append_range(string& __dest, _Iter __b, _NullSentinal) {\n    const char __sentinal = char{};\n    for (; *__b != __sentinal; ++__b)\n      __dest.push_back(*__b);\n  }\n\n  template <class _Source>\n  static void __append_source(string& __dest, _Source const& __s) {\n    using _Traits = __is_pathable<_Source>;\n    __append_range(__dest, _Traits::__range_begin(__s),\n                   _Traits::__range_end(__s));\n  }\n};\n\nclass _LIBCPP_TYPE_VIS path {\n  template <class _SourceOrIter, class _Tp = path&>\n  using _EnableIfPathable =\n      typename enable_if<__is_pathable<_SourceOrIter>::value, _Tp>::type;\n\n  template <class _Tp>\n  using _SourceChar = typename __is_pathable<_Tp>::__char_type;\n\n  template <class _Tp>\n  using _SourceCVT = _PathCVT<_SourceChar<_Tp> >;\n\npublic:\n  typedef char value_type;\n  typedef basic_string<value_type> string_type;\n  typedef _VSTD::string_view __string_view;\n  static constexpr value_type preferred_separator = '/';\n\n  enum class _LIBCPP_ENUM_VIS format : unsigned char {\n    auto_format,\n    native_format,\n    generic_format\n  };\n\n  // constructors and destructor\n  _LIBCPP_INLINE_VISIBILITY path() noexcept {}\n  _LIBCPP_INLINE_VISIBILITY path(const path& __p) : __pn_(__p.__pn_) {}\n  _LIBCPP_INLINE_VISIBILITY path(path&& __p) noexcept\n      : __pn_(_VSTD::move(__p.__pn_)) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  path(string_type&& __s, format = format::auto_format) noexcept\n      : __pn_(_VSTD::move(__s)) {}\n\n  template <class _Source, class = _EnableIfPathable<_Source, void> >\n  path(const _Source& __src, format = format::auto_format) {\n    _SourceCVT<_Source>::__append_source(__pn_, __src);\n  }\n\n  template <class _InputIt>\n  path(_InputIt __first, _InputIt __last, format = format::auto_format) {\n    typedef typename iterator_traits<_InputIt>::value_type _ItVal;\n    _PathCVT<_ItVal>::__append_range(__pn_, __first, __last);\n  }\n\n  // TODO Implement locale conversions.\n  template <class _Source, class = _EnableIfPathable<_Source, void> >\n  path(const _Source& __src, const locale& __loc, format = format::auto_format);\n  template <class _InputIt>\n  path(_InputIt __first, _InputIt _last, const locale& __loc,\n       format = format::auto_format);\n\n  _LIBCPP_INLINE_VISIBILITY\n  ~path() = default;\n\n  // assignments\n  _LIBCPP_INLINE_VISIBILITY\n  path& operator=(const path& __p) {\n    __pn_ = __p.__pn_;\n    return *this;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  path& operator=(path&& __p) noexcept {\n    __pn_ = _VSTD::move(__p.__pn_);\n    return *this;\n  }\n\n  template <class = void>\n  _LIBCPP_INLINE_VISIBILITY path& operator=(string_type&& __s) noexcept {\n    __pn_ = _VSTD::move(__s);\n    return *this;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  path& assign(string_type&& __s) noexcept {\n    __pn_ = _VSTD::move(__s);\n    return *this;\n  }\n\n  template <class _Source>\n  _LIBCPP_INLINE_VISIBILITY _EnableIfPathable<_Source>\n  operator=(const _Source& __src) {\n    return this->assign(__src);\n  }\n\n  template <class _Source>\n  _EnableIfPathable<_Source> assign(const _Source& __src) {\n    __pn_.clear();\n    _SourceCVT<_Source>::__append_source(__pn_, __src);\n    return *this;\n  }\n\n  template <class _InputIt>\n  path& assign(_InputIt __first, _InputIt __last) {\n    typedef typename iterator_traits<_InputIt>::value_type _ItVal;\n    __pn_.clear();\n    _PathCVT<_ItVal>::__append_range(__pn_, __first, __last);\n    return *this;\n  }\n\nprivate:\n  template <class _ECharT>\n  static bool __source_is_absolute(_ECharT __first_or_null) {\n    return __is_separator(__first_or_null);\n  }\n\npublic:\n  // appends\n  path& operator/=(const path& __p) {\n    if (__p.is_absolute()) {\n      __pn_ = __p.__pn_;\n      return *this;\n    }\n    if (has_filename())\n      __pn_ += preferred_separator;\n    __pn_ += __p.native();\n    return *this;\n  }\n\n  // FIXME: Use _LIBCPP_DIAGNOSE_WARNING to produce a diagnostic when __src\n  // is known at compile time to be \"/' since the user almost certainly intended\n  // to append a separator instead of overwriting the path with \"/\"\n  template <class _Source>\n  _LIBCPP_INLINE_VISIBILITY _EnableIfPathable<_Source>\n  operator/=(const _Source& __src) {\n    return this->append(__src);\n  }\n\n  template <class _Source>\n  _EnableIfPathable<_Source> append(const _Source& __src) {\n    using _Traits = __is_pathable<_Source>;\n    using _CVT = _PathCVT<_SourceChar<_Source> >;\n    if (__source_is_absolute(_Traits::__first_or_null(__src)))\n      __pn_.clear();\n    else if (has_filename())\n      __pn_ += preferred_separator;\n    _CVT::__append_source(__pn_, __src);\n    return *this;\n  }\n\n  template <class _InputIt>\n  path& append(_InputIt __first, _InputIt __last) {\n    typedef typename iterator_traits<_InputIt>::value_type _ItVal;\n    static_assert(__can_convert_char<_ItVal>::value, \"Must convertible\");\n    using _CVT = _PathCVT<_ItVal>;\n    if (__first != __last && __source_is_absolute(*__first))\n      __pn_.clear();\n    else if (has_filename())\n      __pn_ += preferred_separator;\n    _CVT::__append_range(__pn_, __first, __last);\n    return *this;\n  }\n\n  // concatenation\n  _LIBCPP_INLINE_VISIBILITY\n  path& operator+=(const path& __x) {\n    __pn_ += __x.__pn_;\n    return *this;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  path& operator+=(const string_type& __x) {\n    __pn_ += __x;\n    return *this;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  path& operator+=(__string_view __x) {\n    __pn_ += __x;\n    return *this;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  path& operator+=(const value_type* __x) {\n    __pn_ += __x;\n    return *this;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  path& operator+=(value_type __x) {\n    __pn_ += __x;\n    return *this;\n  }\n\n  template <class _ECharT>\n  typename enable_if<__can_convert_char<_ECharT>::value, path&>::type\n  operator+=(_ECharT __x) {\n    basic_string<_ECharT> __tmp;\n    __tmp += __x;\n    _PathCVT<_ECharT>::__append_source(__pn_, __tmp);\n    return *this;\n  }\n\n  template <class _Source>\n  _EnableIfPathable<_Source> operator+=(const _Source& __x) {\n    return this->concat(__x);\n  }\n\n  template <class _Source>\n  _EnableIfPathable<_Source> concat(const _Source& __x) {\n    _SourceCVT<_Source>::__append_source(__pn_, __x);\n    return *this;\n  }\n\n  template <class _InputIt>\n  path& concat(_InputIt __first, _InputIt __last) {\n    typedef typename iterator_traits<_InputIt>::value_type _ItVal;\n    _PathCVT<_ItVal>::__append_range(__pn_, __first, __last);\n    return *this;\n  }\n\n  // modifiers\n  _LIBCPP_INLINE_VISIBILITY\n  void clear() noexcept { __pn_.clear(); }\n\n  path& make_preferred() { return *this; }\n\n  _LIBCPP_INLINE_VISIBILITY\n  path& remove_filename() {\n    auto __fname = __filename();\n    if (!__fname.empty())\n      __pn_.erase(__fname.data() - __pn_.data());\n    return *this;\n  }\n\n  path& replace_filename(const path& __replacement) {\n    remove_filename();\n    return (*this /= __replacement);\n  }\n\n  path& replace_extension(const path& __replacement = path());\n\n  _LIBCPP_INLINE_VISIBILITY\n  void swap(path& __rhs) noexcept { __pn_.swap(__rhs.__pn_); }\n\n  // private helper to allow reserving memory in the path\n  _LIBCPP_INLINE_VISIBILITY\n  void __reserve(size_t __s) { __pn_.reserve(__s); }\n\n  // native format observers\n  _LIBCPP_INLINE_VISIBILITY\n  const string_type& native() const noexcept { return __pn_; }\n\n  _LIBCPP_INLINE_VISIBILITY\n  const value_type* c_str() const noexcept { return __pn_.c_str(); }\n\n  _LIBCPP_INLINE_VISIBILITY operator string_type() const { return __pn_; }\n\n  template <class _ECharT, class _Traits = char_traits<_ECharT>,\n            class _Allocator = allocator<_ECharT> >\n  basic_string<_ECharT, _Traits, _Allocator>\n  string(const _Allocator& __a = _Allocator()) const {\n    using _CVT = __widen_from_utf8<sizeof(_ECharT) * __CHAR_BIT__>;\n    using _Str = basic_string<_ECharT, _Traits, _Allocator>;\n    _Str __s(__a);\n    __s.reserve(__pn_.size());\n    _CVT()(back_inserter(__s), __pn_.data(), __pn_.data() + __pn_.size());\n    return __s;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY std::string string() const { return __pn_; }\n  _LIBCPP_INLINE_VISIBILITY std::wstring wstring() const {\n    return string<wchar_t>();\n  }\n  _LIBCPP_INLINE_VISIBILITY std::string u8string() const { return __pn_; }\n  _LIBCPP_INLINE_VISIBILITY std::u16string u16string() const {\n    return string<char16_t>();\n  }\n  _LIBCPP_INLINE_VISIBILITY std::u32string u32string() const {\n    return string<char32_t>();\n  }\n\n  // generic format observers\n  template <class _ECharT, class _Traits = char_traits<_ECharT>,\n            class _Allocator = allocator<_ECharT> >\n  basic_string<_ECharT, _Traits, _Allocator>\n  generic_string(const _Allocator& __a = _Allocator()) const {\n    return string<_ECharT, _Traits, _Allocator>(__a);\n  }\n\n  std::string generic_string() const { return __pn_; }\n  std::wstring generic_wstring() const { return string<wchar_t>(); }\n  std::string generic_u8string() const { return __pn_; }\n  std::u16string generic_u16string() const { return string<char16_t>(); }\n  std::u32string generic_u32string() const { return string<char32_t>(); }\n\nprivate:\n  int __compare(__string_view) const;\n  __string_view __root_name() const;\n  __string_view __root_directory() const;\n  __string_view __root_path_raw() const;\n  __string_view __relative_path() const;\n  __string_view __parent_path() const;\n  __string_view __filename() const;\n  __string_view __stem() const;\n  __string_view __extension() const;\n\npublic:\n  // compare\n  _LIBCPP_INLINE_VISIBILITY int compare(const path& __p) const noexcept {\n    return __compare(__p.__pn_);\n  }\n  _LIBCPP_INLINE_VISIBILITY int compare(const string_type& __s) const {\n    return __compare(__s);\n  }\n  _LIBCPP_INLINE_VISIBILITY int compare(__string_view __s) const {\n    return __compare(__s);\n  }\n  _LIBCPP_INLINE_VISIBILITY int compare(const value_type* __s) const {\n    return __compare(__s);\n  }\n\n  // decomposition\n  _LIBCPP_INLINE_VISIBILITY path root_name() const {\n    return string_type(__root_name());\n  }\n  _LIBCPP_INLINE_VISIBILITY path root_directory() const {\n    return string_type(__root_directory());\n  }\n  _LIBCPP_INLINE_VISIBILITY path root_path() const {\n    return root_name().append(string_type(__root_directory()));\n  }\n  _LIBCPP_INLINE_VISIBILITY path relative_path() const {\n    return string_type(__relative_path());\n  }\n  _LIBCPP_INLINE_VISIBILITY path parent_path() const {\n    return string_type(__parent_path());\n  }\n  _LIBCPP_INLINE_VISIBILITY path filename() const {\n    return string_type(__filename());\n  }\n  _LIBCPP_INLINE_VISIBILITY path stem() const { return string_type(__stem()); }\n  _LIBCPP_INLINE_VISIBILITY path extension() const {\n    return string_type(__extension());\n  }\n\n  // query\n  _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY bool\n  empty() const noexcept {\n    return __pn_.empty();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY bool has_root_name() const {\n    return !__root_name().empty();\n  }\n  _LIBCPP_INLINE_VISIBILITY bool has_root_directory() const {\n    return !__root_directory().empty();\n  }\n  _LIBCPP_INLINE_VISIBILITY bool has_root_path() const {\n    return !__root_path_raw().empty();\n  }\n  _LIBCPP_INLINE_VISIBILITY bool has_relative_path() const {\n    return !__relative_path().empty();\n  }\n  _LIBCPP_INLINE_VISIBILITY bool has_parent_path() const {\n    return !__parent_path().empty();\n  }\n  _LIBCPP_INLINE_VISIBILITY bool has_filename() const {\n    return !__filename().empty();\n  }\n  _LIBCPP_INLINE_VISIBILITY bool has_stem() const { return !__stem().empty(); }\n  _LIBCPP_INLINE_VISIBILITY bool has_extension() const {\n    return !__extension().empty();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY bool is_absolute() const {\n    return has_root_directory();\n  }\n  _LIBCPP_INLINE_VISIBILITY bool is_relative() const { return !is_absolute(); }\n\n  // relative paths\n  path lexically_normal() const;\n  path lexically_relative(const path& __base) const;\n\n  _LIBCPP_INLINE_VISIBILITY path lexically_proximate(const path& __base) const {\n    path __result = this->lexically_relative(__base);\n    if (__result.native().empty())\n      return *this;\n    return __result;\n  }\n\n  // iterators\n  class _LIBCPP_TYPE_VIS iterator;\n  typedef iterator const_iterator;\n\n  iterator begin() const;\n  iterator end() const;\n\n  template <class _CharT, class _Traits>\n  _LIBCPP_INLINE_VISIBILITY friend\n      typename enable_if<is_same<_CharT, char>::value &&\n                             is_same<_Traits, char_traits<char> >::value,\n                         basic_ostream<_CharT, _Traits>&>::type\n      operator<<(basic_ostream<_CharT, _Traits>& __os, const path& __p) {\n    __os << std::__quoted(__p.native());\n    return __os;\n  }\n\n  template <class _CharT, class _Traits>\n  _LIBCPP_INLINE_VISIBILITY friend\n      typename enable_if<!is_same<_CharT, char>::value ||\n                             !is_same<_Traits, char_traits<char> >::value,\n                         basic_ostream<_CharT, _Traits>&>::type\n      operator<<(basic_ostream<_CharT, _Traits>& __os, const path& __p) {\n    __os << std::__quoted(__p.string<_CharT, _Traits>());\n    return __os;\n  }\n\n  template <class _CharT, class _Traits>\n  _LIBCPP_INLINE_VISIBILITY friend basic_istream<_CharT, _Traits>&\n  operator>>(basic_istream<_CharT, _Traits>& __is, path& __p) {\n    basic_string<_CharT, _Traits> __tmp;\n    __is >> __quoted(__tmp);\n    __p = __tmp;\n    return __is;\n  }\n\n  friend _LIBCPP_INLINE_VISIBILITY bool operator==(const path& __lhs, const path& __rhs) noexcept {\n    return __lhs.compare(__rhs) == 0;\n  }\n  friend _LIBCPP_INLINE_VISIBILITY bool operator!=(const path& __lhs, const path& __rhs) noexcept {\n    return __lhs.compare(__rhs) != 0;\n  }\n  friend _LIBCPP_INLINE_VISIBILITY bool operator<(const path& __lhs, const path& __rhs) noexcept {\n    return __lhs.compare(__rhs) < 0;\n  }\n  friend _LIBCPP_INLINE_VISIBILITY bool operator<=(const path& __lhs, const path& __rhs) noexcept {\n    return __lhs.compare(__rhs) <= 0;\n  }\n  friend _LIBCPP_INLINE_VISIBILITY bool operator>(const path& __lhs, const path& __rhs) noexcept {\n    return __lhs.compare(__rhs) > 0;\n  }\n  friend _LIBCPP_INLINE_VISIBILITY bool operator>=(const path& __lhs, const path& __rhs) noexcept {\n    return __lhs.compare(__rhs) >= 0;\n  }\n\n  friend _LIBCPP_INLINE_VISIBILITY path operator/(const path& __lhs,\n                                                  const path& __rhs) {\n    path __result(__lhs);\n    __result /= __rhs;\n    return __result;\n  }\nprivate:\n  inline _LIBCPP_INLINE_VISIBILITY path&\n  __assign_view(__string_view const& __s) noexcept {\n    __pn_ = string_type(__s);\n    return *this;\n  }\n  string_type __pn_;\n};\n\ninline _LIBCPP_INLINE_VISIBILITY void swap(path& __lhs, path& __rhs) noexcept {\n  __lhs.swap(__rhs);\n}\n\n_LIBCPP_FUNC_VIS\nsize_t hash_value(const path& __p) noexcept;\n\ntemplate <class _Source>\n_LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_pathable<_Source>::value, path>::type\n    u8path(const _Source& __s) {\n  static_assert(\n      is_same<typename __is_pathable<_Source>::__char_type, char>::value,\n      \"u8path(Source const&) requires Source have a character type of type \"\n      \"'char'\");\n  return path(__s);\n}\n\ntemplate <class _InputIt>\n_LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_pathable<_InputIt>::value, path>::type\n    u8path(_InputIt __f, _InputIt __l) {\n  static_assert(\n      is_same<typename __is_pathable<_InputIt>::__char_type, char>::value,\n      \"u8path(Iter, Iter) requires Iter have a value_type of type 'char'\");\n  return path(__f, __l);\n}\n\nclass _LIBCPP_TYPE_VIS path::iterator {\npublic:\n  enum _ParserState : unsigned char {\n    _Singular,\n    _BeforeBegin,\n    _InRootName,\n    _InRootDir,\n    _InFilenames,\n    _InTrailingSep,\n    _AtEnd\n  };\n\npublic:\n  typedef bidirectional_iterator_tag iterator_category;\n\n  typedef path value_type;\n  typedef std::ptrdiff_t difference_type;\n  typedef const path* pointer;\n  typedef const path& reference;\n\n  typedef void\n      __stashing_iterator_tag; // See reverse_iterator and __is_stashing_iterator\n\npublic:\n  _LIBCPP_INLINE_VISIBILITY\n  iterator()\n      : __stashed_elem_(), __path_ptr_(nullptr), __entry_(),\n        __state_(_Singular) {}\n\n  iterator(const iterator&) = default;\n  ~iterator() = default;\n\n  iterator& operator=(const iterator&) = default;\n\n  _LIBCPP_INLINE_VISIBILITY\n  reference operator*() const { return __stashed_elem_; }\n\n  _LIBCPP_INLINE_VISIBILITY\n  pointer operator->() const { return &__stashed_elem_; }\n\n  _LIBCPP_INLINE_VISIBILITY\n  iterator& operator++() {\n    _LIBCPP_ASSERT(__state_ != _Singular,\n                   \"attempting to increment a singular iterator\");\n    _LIBCPP_ASSERT(__state_ != _AtEnd,\n                   \"attempting to increment the end iterator\");\n    return __increment();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  iterator operator++(int) {\n    iterator __it(*this);\n    this->operator++();\n    return __it;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  iterator& operator--() {\n    _LIBCPP_ASSERT(__state_ != _Singular,\n                   \"attempting to decrement a singular iterator\");\n    _LIBCPP_ASSERT(__entry_.data() != __path_ptr_->native().data(),\n                   \"attempting to decrement the begin iterator\");\n    return __decrement();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  iterator operator--(int) {\n    iterator __it(*this);\n    this->operator--();\n    return __it;\n  }\n\nprivate:\n  friend class path;\n\n  inline _LIBCPP_INLINE_VISIBILITY friend bool operator==(const iterator&,\n                                                          const iterator&);\n\n  iterator& __increment();\n  iterator& __decrement();\n\n  path __stashed_elem_;\n  const path* __path_ptr_;\n  path::__string_view __entry_;\n  _ParserState __state_;\n};\n\ninline _LIBCPP_INLINE_VISIBILITY bool operator==(const path::iterator& __lhs,\n                                                 const path::iterator& __rhs) {\n  return __lhs.__path_ptr_ == __rhs.__path_ptr_ &&\n         __lhs.__entry_.data() == __rhs.__entry_.data();\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool operator!=(const path::iterator& __lhs,\n                                                 const path::iterator& __rhs) {\n  return !(__lhs == __rhs);\n}\n\nclass _LIBCPP_EXCEPTION_ABI filesystem_error : public system_error {\npublic:\n  _LIBCPP_INLINE_VISIBILITY\n  filesystem_error(const string& __what, error_code __ec)\n      : system_error(__ec, __what),\n        __storage_(make_shared<_Storage>(path(), path())) {\n    __create_what(0);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  filesystem_error(const string& __what, const path& __p1, error_code __ec)\n      : system_error(__ec, __what),\n        __storage_(make_shared<_Storage>(__p1, path())) {\n    __create_what(1);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  filesystem_error(const string& __what, const path& __p1, const path& __p2,\n                   error_code __ec)\n      : system_error(__ec, __what),\n        __storage_(make_shared<_Storage>(__p1, __p2)) {\n    __create_what(2);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  const path& path1() const noexcept { return __storage_->__p1_; }\n\n  _LIBCPP_INLINE_VISIBILITY\n  const path& path2() const noexcept { return __storage_->__p2_; }\n\n  ~filesystem_error() override; // key function\n\n  _LIBCPP_INLINE_VISIBILITY\n  const char* what() const noexcept override {\n    return __storage_->__what_.c_str();\n  }\n\n  _LIBCPP_FUNC_VIS\n  void __create_what(int __num_paths);\n\nprivate:\n  struct _Storage {\n    _LIBCPP_INLINE_VISIBILITY\n    _Storage(const path& __p1, const path& __p2) : __p1_(__p1), __p2_(__p2) {}\n\n    path __p1_;\n    path __p2_;\n    string __what_;\n  };\n  shared_ptr<_Storage> __storage_;\n};\n\ntemplate <class... _Args>\n_LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    void\n    __throw_filesystem_error(_Args&&... __args) {\n  throw filesystem_error(std::forward<_Args>(__args)...);\n}\n#else\n    void\n    __throw_filesystem_error(_Args&&...) {\n  _VSTD::abort();\n}\n#endif\n\n// operational functions\n\n_LIBCPP_FUNC_VIS\npath __absolute(const path&, error_code* __ec = nullptr);\n_LIBCPP_FUNC_VIS\npath __canonical(const path&, error_code* __ec = nullptr);\n_LIBCPP_FUNC_VIS\nvoid __copy(const path& __from, const path& __to, copy_options __opt,\n            error_code* __ec = nullptr);\n_LIBCPP_FUNC_VIS\nbool __copy_file(const path& __from, const path& __to, copy_options __opt,\n                 error_code* __ec = nullptr);\n_LIBCPP_FUNC_VIS\nvoid __copy_symlink(const path& __existing_symlink, const path& __new_symlink,\n                    error_code* __ec = nullptr);\n_LIBCPP_FUNC_VIS\nbool __create_directories(const path& p, error_code* ec = nullptr);\n_LIBCPP_FUNC_VIS\nbool __create_directory(const path& p, error_code* ec = nullptr);\n_LIBCPP_FUNC_VIS\nbool __create_directory(const path& p, const path& attributes,\n                        error_code* ec = nullptr);\n_LIBCPP_FUNC_VIS\nvoid __create_directory_symlink(const path& __to, const path& __new_symlink,\n                                error_code* __ec = nullptr);\n_LIBCPP_FUNC_VIS\nvoid __create_hard_link(const path& __to, const path& __new_hard_link,\n                        error_code* __ec = nullptr);\n_LIBCPP_FUNC_VIS\nvoid __create_symlink(const path& __to, const path& __new_symlink,\n                      error_code* __ec = nullptr);\n_LIBCPP_FUNC_VIS\npath __current_path(error_code* __ec = nullptr);\n_LIBCPP_FUNC_VIS\nvoid __current_path(const path&, error_code* __ec = nullptr);\n_LIBCPP_FUNC_VIS\nbool __equivalent(const path&, const path&, error_code* __ec = nullptr);\n_LIBCPP_FUNC_VIS\nuintmax_t __file_size(const path&, error_code* __ec = nullptr);\n_LIBCPP_FUNC_VIS\nuintmax_t __hard_link_count(const path&, error_code* __ec = nullptr);\n_LIBCPP_FUNC_VIS\nbool __fs_is_empty(const path& p, error_code* ec = nullptr);\n_LIBCPP_FUNC_VIS\nfile_time_type __last_write_time(const path& p, error_code* ec = nullptr);\n_LIBCPP_FUNC_VIS\nvoid __last_write_time(const path& p, file_time_type new_time,\n                       error_code* ec = nullptr);\n_LIBCPP_FUNC_VIS\nvoid __permissions(const path&, perms, perm_options, error_code* = nullptr);\n_LIBCPP_FUNC_VIS\npath __read_symlink(const path& p, error_code* ec = nullptr);\n_LIBCPP_FUNC_VIS\nbool __remove(const path& p, error_code* ec = nullptr);\n_LIBCPP_FUNC_VIS\nuintmax_t __remove_all(const path& p, error_code* ec = nullptr);\n_LIBCPP_FUNC_VIS\nvoid __rename(const path& from, const path& to, error_code* ec = nullptr);\n_LIBCPP_FUNC_VIS\nvoid __resize_file(const path& p, uintmax_t size, error_code* ec = nullptr);\n_LIBCPP_FUNC_VIS\nspace_info __space(const path&, error_code* __ec = nullptr);\n_LIBCPP_FUNC_VIS\nfile_status __status(const path&, error_code* __ec = nullptr);\n_LIBCPP_FUNC_VIS\nfile_status __symlink_status(const path&, error_code* __ec = nullptr);\n_LIBCPP_FUNC_VIS\npath __system_complete(const path&, error_code* __ec = nullptr);\n_LIBCPP_FUNC_VIS\npath __temp_directory_path(error_code* __ec = nullptr);\n_LIBCPP_FUNC_VIS\npath __weakly_canonical(path const& __p, error_code* __ec = nullptr);\n\ninline _LIBCPP_INLINE_VISIBILITY path current_path() {\n  return __current_path();\n}\n\ninline _LIBCPP_INLINE_VISIBILITY path current_path(error_code& __ec) {\n  return __current_path(&__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void current_path(const path& __p) {\n  __current_path(__p);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void current_path(const path& __p,\n                                                   error_code& __ec) noexcept {\n  __current_path(__p, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY path absolute(const path& __p) {\n  return __absolute(__p);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY path absolute(const path& __p,\n                                               error_code& __ec) {\n  return __absolute(__p, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY path canonical(const path& __p) {\n  return __canonical(__p);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY path canonical(const path& __p,\n                                                error_code& __ec) {\n  return __canonical(__p, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void copy(const path& __from,\n                                           const path& __to) {\n  __copy(__from, __to, copy_options::none);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void copy(const path& __from, const path& __to,\n                                           error_code& __ec) {\n  __copy(__from, __to, copy_options::none, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void copy(const path& __from, const path& __to,\n                                           copy_options __opt) {\n  __copy(__from, __to, __opt);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void copy(const path& __from, const path& __to,\n                                           copy_options __opt,\n                                           error_code& __ec) {\n  __copy(__from, __to, __opt, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool copy_file(const path& __from,\n                                                const path& __to) {\n  return __copy_file(__from, __to, copy_options::none);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool\ncopy_file(const path& __from, const path& __to, error_code& __ec) {\n  return __copy_file(__from, __to, copy_options::none, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool\ncopy_file(const path& __from, const path& __to, copy_options __opt) {\n  return __copy_file(__from, __to, __opt);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool copy_file(const path& __from,\n                                                const path& __to,\n                                                copy_options __opt,\n                                                error_code& __ec) {\n  return __copy_file(__from, __to, __opt, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void copy_symlink(const path& __existing,\n                                                   const path& __new) {\n  __copy_symlink(__existing, __new);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void\ncopy_symlink(const path& __ext, const path& __new, error_code& __ec) noexcept {\n  __copy_symlink(__ext, __new, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool create_directories(const path& __p) {\n  return __create_directories(__p);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool create_directories(const path& __p,\n                                                         error_code& __ec) {\n  return __create_directories(__p, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool create_directory(const path& __p) {\n  return __create_directory(__p);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool\ncreate_directory(const path& __p, error_code& __ec) noexcept {\n  return __create_directory(__p, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool create_directory(const path& __p,\n                                                       const path& __attrs) {\n  return __create_directory(__p, __attrs);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool\ncreate_directory(const path& __p, const path& __attrs,\n                 error_code& __ec) noexcept {\n  return __create_directory(__p, __attrs, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void\ncreate_directory_symlink(const path& __to, const path& __new) {\n  __create_directory_symlink(__to, __new);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void\ncreate_directory_symlink(const path& __to, const path& __new,\n                         error_code& __ec) noexcept {\n  __create_directory_symlink(__to, __new, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void create_hard_link(const path& __to,\n                                                       const path& __new) {\n  __create_hard_link(__to, __new);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void\ncreate_hard_link(const path& __to, const path& __new,\n                 error_code& __ec) noexcept {\n  __create_hard_link(__to, __new, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void create_symlink(const path& __to,\n                                                     const path& __new) {\n  __create_symlink(__to, __new);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void\ncreate_symlink(const path& __to, const path& __new, error_code& __ec) noexcept {\n  return __create_symlink(__to, __new, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool status_known(file_status __s) noexcept {\n  return __s.type() != file_type::none;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool exists(file_status __s) noexcept {\n  return status_known(__s) && __s.type() != file_type::not_found;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool exists(const path& __p) {\n  return exists(__status(__p));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool exists(const path& __p,\n                                             error_code& __ec) noexcept {\n  auto __s = __status(__p, &__ec);\n  if (status_known(__s))\n    __ec.clear();\n  return exists(__s);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool equivalent(const path& __p1,\n                                                 const path& __p2) {\n  return __equivalent(__p1, __p2);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool\nequivalent(const path& __p1, const path& __p2, error_code& __ec) noexcept {\n  return __equivalent(__p1, __p2, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY uintmax_t file_size(const path& __p) {\n  return __file_size(__p);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY uintmax_t\nfile_size(const path& __p, error_code& __ec) noexcept {\n  return __file_size(__p, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY uintmax_t hard_link_count(const path& __p) {\n  return __hard_link_count(__p);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY uintmax_t\nhard_link_count(const path& __p, error_code& __ec) noexcept {\n  return __hard_link_count(__p, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_block_file(file_status __s) noexcept {\n  return __s.type() == file_type::block;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_block_file(const path& __p) {\n  return is_block_file(__status(__p));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_block_file(const path& __p,\n                                                    error_code& __ec) noexcept {\n  return is_block_file(__status(__p, &__ec));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool\nis_character_file(file_status __s) noexcept {\n  return __s.type() == file_type::character;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_character_file(const path& __p) {\n  return is_character_file(__status(__p));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool\nis_character_file(const path& __p, error_code& __ec) noexcept {\n  return is_character_file(__status(__p, &__ec));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_directory(file_status __s) noexcept {\n  return __s.type() == file_type::directory;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_directory(const path& __p) {\n  return is_directory(__status(__p));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_directory(const path& __p,\n                                                   error_code& __ec) noexcept {\n  return is_directory(__status(__p, &__ec));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_empty(const path& __p) {\n  return __fs_is_empty(__p);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_empty(const path& __p,\n                                               error_code& __ec) {\n  return __fs_is_empty(__p, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_fifo(file_status __s) noexcept {\n  return __s.type() == file_type::fifo;\n}\ninline _LIBCPP_INLINE_VISIBILITY bool is_fifo(const path& __p) {\n  return is_fifo(__status(__p));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_fifo(const path& __p,\n                                              error_code& __ec) noexcept {\n  return is_fifo(__status(__p, &__ec));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool\nis_regular_file(file_status __s) noexcept {\n  return __s.type() == file_type::regular;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_regular_file(const path& __p) {\n  return is_regular_file(__status(__p));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool\nis_regular_file(const path& __p, error_code& __ec) noexcept {\n  return is_regular_file(__status(__p, &__ec));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_socket(file_status __s) noexcept {\n  return __s.type() == file_type::socket;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_socket(const path& __p) {\n  return is_socket(__status(__p));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_socket(const path& __p,\n                                                error_code& __ec) noexcept {\n  return is_socket(__status(__p, &__ec));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_symlink(file_status __s) noexcept {\n  return __s.type() == file_type::symlink;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_symlink(const path& __p) {\n  return is_symlink(__symlink_status(__p));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_symlink(const path& __p,\n                                                 error_code& __ec) noexcept {\n  return is_symlink(__symlink_status(__p, &__ec));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_other(file_status __s) noexcept {\n  return exists(__s) && !is_regular_file(__s) && !is_directory(__s) &&\n         !is_symlink(__s);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_other(const path& __p) {\n  return is_other(__status(__p));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool is_other(const path& __p,\n                                               error_code& __ec) noexcept {\n  return is_other(__status(__p, &__ec));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY file_time_type\nlast_write_time(const path& __p) {\n  return __last_write_time(__p);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY file_time_type\nlast_write_time(const path& __p, error_code& __ec) noexcept {\n  return __last_write_time(__p, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void last_write_time(const path& __p,\n                                                      file_time_type __t) {\n  __last_write_time(__p, __t);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void\nlast_write_time(const path& __p, file_time_type __t,\n                error_code& __ec) noexcept {\n  __last_write_time(__p, __t, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void\npermissions(const path& __p, perms __prms,\n            perm_options __opts = perm_options::replace) {\n  __permissions(__p, __prms, __opts);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void permissions(const path& __p, perms __prms,\n                                                  error_code& __ec) noexcept {\n  __permissions(__p, __prms, perm_options::replace, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void permissions(const path& __p, perms __prms,\n                                                  perm_options __opts,\n                                                  error_code& __ec) {\n  __permissions(__p, __prms, __opts, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY path proximate(const path& __p,\n                                                const path& __base,\n                                                error_code& __ec) {\n  path __tmp = __weakly_canonical(__p, &__ec);\n  if (__ec)\n    return {};\n  path __tmp_base = __weakly_canonical(__base, &__ec);\n  if (__ec)\n    return {};\n  return __tmp.lexically_proximate(__tmp_base);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY path proximate(const path& __p,\n                                                error_code& __ec) {\n  return proximate(__p, current_path(), __ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY path\nproximate(const path& __p, const path& __base = current_path()) {\n  return __weakly_canonical(__p).lexically_proximate(\n      __weakly_canonical(__base));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY path read_symlink(const path& __p) {\n  return __read_symlink(__p);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY path read_symlink(const path& __p,\n                                                   error_code& __ec) {\n  return __read_symlink(__p, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY path relative(const path& __p,\n                                               const path& __base,\n                                               error_code& __ec) {\n  path __tmp = __weakly_canonical(__p, &__ec);\n  if (__ec)\n    return path();\n  path __tmpbase = __weakly_canonical(__base, &__ec);\n  if (__ec)\n    return path();\n  return __tmp.lexically_relative(__tmpbase);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY path relative(const path& __p,\n                                               error_code& __ec) {\n  return relative(__p, current_path(), __ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY path\nrelative(const path& __p, const path& __base = current_path()) {\n  return __weakly_canonical(__p).lexically_relative(__weakly_canonical(__base));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool remove(const path& __p) {\n  return __remove(__p);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool remove(const path& __p,\n                                             error_code& __ec) noexcept {\n  return __remove(__p, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY uintmax_t remove_all(const path& __p) {\n  return __remove_all(__p);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY uintmax_t remove_all(const path& __p,\n                                                      error_code& __ec) {\n  return __remove_all(__p, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void rename(const path& __from,\n                                             const path& __to) {\n  return __rename(__from, __to);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void\nrename(const path& __from, const path& __to, error_code& __ec) noexcept {\n  return __rename(__from, __to, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void resize_file(const path& __p,\n                                                  uintmax_t __ns) {\n  return __resize_file(__p, __ns);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void\nresize_file(const path& __p, uintmax_t __ns, error_code& __ec) noexcept {\n  return __resize_file(__p, __ns, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY space_info space(const path& __p) {\n  return __space(__p);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY space_info space(const path& __p,\n                                                  error_code& __ec) noexcept {\n  return __space(__p, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY file_status status(const path& __p) {\n  return __status(__p);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY file_status status(const path& __p,\n                                                    error_code& __ec) noexcept {\n  return __status(__p, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY file_status symlink_status(const path& __p) {\n  return __symlink_status(__p);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY file_status\nsymlink_status(const path& __p, error_code& __ec) noexcept {\n  return __symlink_status(__p, &__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY path temp_directory_path() {\n  return __temp_directory_path();\n}\n\ninline _LIBCPP_INLINE_VISIBILITY path temp_directory_path(error_code& __ec) {\n  return __temp_directory_path(&__ec);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY path weakly_canonical(path const& __p) {\n  return __weakly_canonical(__p);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY path weakly_canonical(path const& __p,\n                                                       error_code& __ec) {\n  return __weakly_canonical(__p, &__ec);\n}\n\nclass directory_iterator;\nclass recursive_directory_iterator;\nclass __dir_stream;\n\nclass directory_entry {\n  typedef _VSTD_FS::path _Path;\n\npublic:\n  // constructors and destructors\n  directory_entry() noexcept = default;\n  directory_entry(directory_entry const&) = default;\n  directory_entry(directory_entry&&) noexcept = default;\n\n  _LIBCPP_INLINE_VISIBILITY\n  explicit directory_entry(_Path const& __p) : __p_(__p) {\n    error_code __ec;\n    __refresh(&__ec);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  directory_entry(_Path const& __p, error_code& __ec) : __p_(__p) {\n    __refresh(&__ec);\n  }\n\n  ~directory_entry() {}\n\n  directory_entry& operator=(directory_entry const&) = default;\n  directory_entry& operator=(directory_entry&&) noexcept = default;\n\n  _LIBCPP_INLINE_VISIBILITY\n  void assign(_Path const& __p) {\n    __p_ = __p;\n    error_code __ec;\n    __refresh(&__ec);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void assign(_Path const& __p, error_code& __ec) {\n    __p_ = __p;\n    __refresh(&__ec);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void replace_filename(_Path const& __p) {\n    __p_.replace_filename(__p);\n    error_code __ec;\n    __refresh(&__ec);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void replace_filename(_Path const& __p, error_code& __ec) {\n    __p_ = __p_.parent_path() / __p;\n    __refresh(&__ec);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void refresh() { __refresh(); }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void refresh(error_code& __ec) noexcept { __refresh(&__ec); }\n\n  _LIBCPP_INLINE_VISIBILITY\n  _Path const& path() const noexcept { return __p_; }\n\n  _LIBCPP_INLINE_VISIBILITY\n  operator const _Path&() const noexcept { return __p_; }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool exists() const { return _VSTD_FS::exists(file_status{__get_ft()}); }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool exists(error_code& __ec) const noexcept {\n    return _VSTD_FS::exists(file_status{__get_ft(&__ec)});\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool is_block_file() const { return __get_ft() == file_type::block; }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool is_block_file(error_code& __ec) const noexcept {\n    return __get_ft(&__ec) == file_type::block;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool is_character_file() const { return __get_ft() == file_type::character; }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool is_character_file(error_code& __ec) const noexcept {\n    return __get_ft(&__ec) == file_type::character;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool is_directory() const { return __get_ft() == file_type::directory; }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool is_directory(error_code& __ec) const noexcept {\n    return __get_ft(&__ec) == file_type::directory;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool is_fifo() const { return __get_ft() == file_type::fifo; }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool is_fifo(error_code& __ec) const noexcept {\n    return __get_ft(&__ec) == file_type::fifo;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool is_other() const { return _VSTD_FS::is_other(file_status{__get_ft()}); }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool is_other(error_code& __ec) const noexcept {\n    return _VSTD_FS::is_other(file_status{__get_ft(&__ec)});\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool is_regular_file() const { return __get_ft() == file_type::regular; }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool is_regular_file(error_code& __ec) const noexcept {\n    return __get_ft(&__ec) == file_type::regular;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool is_socket() const { return __get_ft() == file_type::socket; }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool is_socket(error_code& __ec) const noexcept {\n    return __get_ft(&__ec) == file_type::socket;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool is_symlink() const { return __get_sym_ft() == file_type::symlink; }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool is_symlink(error_code& __ec) const noexcept {\n    return __get_sym_ft(&__ec) == file_type::symlink;\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  uintmax_t file_size() const { return __get_size(); }\n\n  _LIBCPP_INLINE_VISIBILITY\n  uintmax_t file_size(error_code& __ec) const noexcept {\n    return __get_size(&__ec);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  uintmax_t hard_link_count() const { return __get_nlink(); }\n\n  _LIBCPP_INLINE_VISIBILITY\n  uintmax_t hard_link_count(error_code& __ec) const noexcept {\n    return __get_nlink(&__ec);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  file_time_type last_write_time() const { return __get_write_time(); }\n\n  _LIBCPP_INLINE_VISIBILITY\n  file_time_type last_write_time(error_code& __ec) const noexcept {\n    return __get_write_time(&__ec);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  file_status status() const { return __get_status(); }\n\n  _LIBCPP_INLINE_VISIBILITY\n  file_status status(error_code& __ec) const noexcept {\n    return __get_status(&__ec);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  file_status symlink_status() const { return __get_symlink_status(); }\n\n  _LIBCPP_INLINE_VISIBILITY\n  file_status symlink_status(error_code& __ec) const noexcept {\n    return __get_symlink_status(&__ec);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool operator<(directory_entry const& __rhs) const noexcept {\n    return __p_ < __rhs.__p_;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool operator==(directory_entry const& __rhs) const noexcept {\n    return __p_ == __rhs.__p_;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool operator!=(directory_entry const& __rhs) const noexcept {\n    return __p_ != __rhs.__p_;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool operator<=(directory_entry const& __rhs) const noexcept {\n    return __p_ <= __rhs.__p_;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool operator>(directory_entry const& __rhs) const noexcept {\n    return __p_ > __rhs.__p_;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool operator>=(directory_entry const& __rhs) const noexcept {\n    return __p_ >= __rhs.__p_;\n  }\n\nprivate:\n  friend class directory_iterator;\n  friend class recursive_directory_iterator;\n  friend class __dir_stream;\n\n  enum _CacheType : unsigned char {\n    _Empty,\n    _IterSymlink,\n    _IterNonSymlink,\n    _RefreshSymlink,\n    _RefreshSymlinkUnresolved,\n    _RefreshNonSymlink\n  };\n\n  struct __cached_data {\n    uintmax_t __size_;\n    uintmax_t __nlink_;\n    file_time_type __write_time_;\n    perms __sym_perms_;\n    perms __non_sym_perms_;\n    file_type __type_;\n    _CacheType __cache_type_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __cached_data() noexcept { __reset(); }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __reset() {\n      __cache_type_ = _Empty;\n      __type_ = file_type::none;\n      __sym_perms_ = __non_sym_perms_ = perms::unknown;\n      __size_ = __nlink_ = uintmax_t(-1);\n      __write_time_ = file_time_type::min();\n    }\n  };\n\n  _LIBCPP_INLINE_VISIBILITY\n  static __cached_data __create_iter_result(file_type __ft) {\n    __cached_data __data;\n    __data.__type_ = __ft;\n    __data.__cache_type_ = [&]() {\n      switch (__ft) {\n      case file_type::none:\n        return _Empty;\n      case file_type::symlink:\n        return _IterSymlink;\n      default:\n        return _IterNonSymlink;\n      }\n    }();\n    return __data;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void __assign_iter_entry(_Path&& __p, __cached_data __dt) {\n    __p_ = std::move(__p);\n    __data_ = __dt;\n  }\n\n  _LIBCPP_FUNC_VIS\n  error_code __do_refresh() noexcept;\n\n  _LIBCPP_INLINE_VISIBILITY\n  static bool __is_dne_error(error_code const& __ec) {\n    if (!__ec)\n      return true;\n    switch (static_cast<errc>(__ec.value())) {\n    case errc::no_such_file_or_directory:\n    case errc::not_a_directory:\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void __handle_error(const char* __msg, error_code* __dest_ec,\n                      error_code const& __ec, bool __allow_dne = false) const {\n    if (__dest_ec) {\n      *__dest_ec = __ec;\n      return;\n    }\n    if (__ec && (!__allow_dne || !__is_dne_error(__ec)))\n      __throw_filesystem_error(__msg, __p_, __ec);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void __refresh(error_code* __ec = nullptr) {\n    __handle_error(\"in directory_entry::refresh\", __ec, __do_refresh(),\n                   /*allow_dne*/ true);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  file_type __get_sym_ft(error_code* __ec = nullptr) const {\n    switch (__data_.__cache_type_) {\n    case _Empty:\n      return __symlink_status(__p_, __ec).type();\n    case _IterSymlink:\n    case _RefreshSymlink:\n    case _RefreshSymlinkUnresolved:\n      if (__ec)\n        __ec->clear();\n      return file_type::symlink;\n    case _IterNonSymlink:\n    case _RefreshNonSymlink:\n      file_status __st(__data_.__type_);\n      if (__ec && !_VSTD_FS::exists(__st))\n        *__ec = make_error_code(errc::no_such_file_or_directory);\n      else if (__ec)\n        __ec->clear();\n      return __data_.__type_;\n    }\n    _LIBCPP_UNREACHABLE();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  file_type __get_ft(error_code* __ec = nullptr) const {\n    switch (__data_.__cache_type_) {\n    case _Empty:\n    case _IterSymlink:\n    case _RefreshSymlinkUnresolved:\n      return __status(__p_, __ec).type();\n    case _IterNonSymlink:\n    case _RefreshNonSymlink:\n    case _RefreshSymlink: {\n      file_status __st(__data_.__type_);\n      if (__ec && !_VSTD_FS::exists(__st))\n        *__ec = make_error_code(errc::no_such_file_or_directory);\n      else if (__ec)\n        __ec->clear();\n      return __data_.__type_;\n    }\n    }\n    _LIBCPP_UNREACHABLE();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  file_status __get_status(error_code* __ec = nullptr) const {\n    switch (__data_.__cache_type_) {\n    case _Empty:\n    case _IterNonSymlink:\n    case _IterSymlink:\n    case _RefreshSymlinkUnresolved:\n      return __status(__p_, __ec);\n    case _RefreshNonSymlink:\n    case _RefreshSymlink:\n      return file_status(__get_ft(__ec), __data_.__non_sym_perms_);\n    }\n    _LIBCPP_UNREACHABLE();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  file_status __get_symlink_status(error_code* __ec = nullptr) const {\n    switch (__data_.__cache_type_) {\n    case _Empty:\n    case _IterNonSymlink:\n    case _IterSymlink:\n      return __symlink_status(__p_, __ec);\n    case _RefreshNonSymlink:\n      return file_status(__get_sym_ft(__ec), __data_.__non_sym_perms_);\n    case _RefreshSymlink:\n    case _RefreshSymlinkUnresolved:\n      return file_status(__get_sym_ft(__ec), __data_.__sym_perms_);\n    }\n    _LIBCPP_UNREACHABLE();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  uintmax_t __get_size(error_code* __ec = nullptr) const {\n    switch (__data_.__cache_type_) {\n    case _Empty:\n    case _IterNonSymlink:\n    case _IterSymlink:\n    case _RefreshSymlinkUnresolved:\n      return _VSTD_FS::__file_size(__p_, __ec);\n    case _RefreshSymlink:\n    case _RefreshNonSymlink: {\n      error_code __m_ec;\n      file_status __st(__get_ft(&__m_ec));\n      __handle_error(\"in directory_entry::file_size\", __ec, __m_ec);\n      if (_VSTD_FS::exists(__st) && !_VSTD_FS::is_regular_file(__st)) {\n        errc __err_kind = _VSTD_FS::is_directory(__st) ? errc::is_a_directory\n                                                       : errc::not_supported;\n        __handle_error(\"in directory_entry::file_size\", __ec,\n                       make_error_code(__err_kind));\n      }\n      return __data_.__size_;\n    }\n    }\n    _LIBCPP_UNREACHABLE();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  uintmax_t __get_nlink(error_code* __ec = nullptr) const {\n    switch (__data_.__cache_type_) {\n    case _Empty:\n    case _IterNonSymlink:\n    case _IterSymlink:\n    case _RefreshSymlinkUnresolved:\n      return _VSTD_FS::__hard_link_count(__p_, __ec);\n    case _RefreshSymlink:\n    case _RefreshNonSymlink: {\n      error_code __m_ec;\n      (void)__get_ft(&__m_ec);\n      __handle_error(\"in directory_entry::hard_link_count\", __ec, __m_ec);\n      return __data_.__nlink_;\n    }\n    }\n    _LIBCPP_UNREACHABLE();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  file_time_type __get_write_time(error_code* __ec = nullptr) const {\n    switch (__data_.__cache_type_) {\n    case _Empty:\n    case _IterNonSymlink:\n    case _IterSymlink:\n    case _RefreshSymlinkUnresolved:\n      return _VSTD_FS::__last_write_time(__p_, __ec);\n    case _RefreshSymlink:\n    case _RefreshNonSymlink: {\n      error_code __m_ec;\n      file_status __st(__get_ft(&__m_ec));\n      __handle_error(\"in directory_entry::last_write_time\", __ec, __m_ec);\n      if (_VSTD_FS::exists(__st) &&\n          __data_.__write_time_ == file_time_type::min())\n        __handle_error(\"in directory_entry::last_write_time\", __ec,\n                       make_error_code(errc::value_too_large));\n      return __data_.__write_time_;\n    }\n    }\n    _LIBCPP_UNREACHABLE();\n  }\n\nprivate:\n  _Path __p_;\n  __cached_data __data_;\n};\n\nclass __dir_element_proxy {\npublic:\n  inline _LIBCPP_INLINE_VISIBILITY directory_entry operator*() {\n    return _VSTD::move(__elem_);\n  }\n\nprivate:\n  friend class directory_iterator;\n  friend class recursive_directory_iterator;\n  explicit __dir_element_proxy(directory_entry const& __e) : __elem_(__e) {}\n  __dir_element_proxy(__dir_element_proxy&& __o)\n      : __elem_(_VSTD::move(__o.__elem_)) {}\n  directory_entry __elem_;\n};\n\nclass directory_iterator {\npublic:\n  typedef directory_entry value_type;\n  typedef ptrdiff_t difference_type;\n  typedef value_type const* pointer;\n  typedef value_type const& reference;\n  typedef input_iterator_tag iterator_category;\n\npublic:\n  //ctor & dtor\n  directory_iterator() noexcept {}\n\n  explicit directory_iterator(const path& __p)\n      : directory_iterator(__p, nullptr) {}\n\n  directory_iterator(const path& __p, directory_options __opts)\n      : directory_iterator(__p, nullptr, __opts) {}\n\n  directory_iterator(const path& __p, error_code& __ec)\n      : directory_iterator(__p, &__ec) {}\n\n  directory_iterator(const path& __p, directory_options __opts,\n                     error_code& __ec)\n      : directory_iterator(__p, &__ec, __opts) {}\n\n  directory_iterator(const directory_iterator&) = default;\n  directory_iterator(directory_iterator&&) = default;\n  directory_iterator& operator=(const directory_iterator&) = default;\n\n  directory_iterator& operator=(directory_iterator&& __o) noexcept {\n    // non-default implementation provided to support self-move assign.\n    if (this != &__o) {\n      __imp_ = _VSTD::move(__o.__imp_);\n    }\n    return *this;\n  }\n\n  ~directory_iterator() = default;\n\n  const directory_entry& operator*() const {\n    _LIBCPP_ASSERT(__imp_, \"The end iterator cannot be dereferenced\");\n    return __dereference();\n  }\n\n  const directory_entry* operator->() const { return &**this; }\n\n  directory_iterator& operator++() { return __increment(); }\n\n  __dir_element_proxy operator++(int) {\n    __dir_element_proxy __p(**this);\n    __increment();\n    return __p;\n  }\n\n  directory_iterator& increment(error_code& __ec) { return __increment(&__ec); }\n\nprivate:\n  inline _LIBCPP_INLINE_VISIBILITY friend bool\n  operator==(const directory_iterator& __lhs,\n             const directory_iterator& __rhs) noexcept;\n\n  // construct the dir_stream\n  _LIBCPP_FUNC_VIS\n  directory_iterator(const path&, error_code*,\n                     directory_options = directory_options::none);\n\n  _LIBCPP_FUNC_VIS\n  directory_iterator& __increment(error_code* __ec = nullptr);\n\n  _LIBCPP_FUNC_VIS\n  const directory_entry& __dereference() const;\n\nprivate:\n  shared_ptr<__dir_stream> __imp_;\n};\n\ninline _LIBCPP_INLINE_VISIBILITY bool\noperator==(const directory_iterator& __lhs,\n           const directory_iterator& __rhs) noexcept {\n  return __lhs.__imp_ == __rhs.__imp_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY bool\noperator!=(const directory_iterator& __lhs,\n           const directory_iterator& __rhs) noexcept {\n  return !(__lhs == __rhs);\n}\n\n// enable directory_iterator range-based for statements\ninline _LIBCPP_INLINE_VISIBILITY directory_iterator\nbegin(directory_iterator __iter) noexcept {\n  return __iter;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY directory_iterator\nend(const directory_iterator&) noexcept {\n  return directory_iterator();\n}\n\nclass recursive_directory_iterator {\npublic:\n  using value_type = directory_entry;\n  using difference_type = std::ptrdiff_t;\n  using pointer = directory_entry const*;\n  using reference = directory_entry const&;\n  using iterator_category = std::input_iterator_tag;\n\npublic:\n  // constructors and destructor\n  _LIBCPP_INLINE_VISIBILITY\n  recursive_directory_iterator() noexcept : __rec_(false) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  explicit recursive_directory_iterator(\n      const path& __p, directory_options __xoptions = directory_options::none)\n      : recursive_directory_iterator(__p, __xoptions, nullptr) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  recursive_directory_iterator(const path& __p, directory_options __xoptions,\n                               error_code& __ec)\n      : recursive_directory_iterator(__p, __xoptions, &__ec) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  recursive_directory_iterator(const path& __p, error_code& __ec)\n      : recursive_directory_iterator(__p, directory_options::none, &__ec) {}\n\n  recursive_directory_iterator(const recursive_directory_iterator&) = default;\n  recursive_directory_iterator(recursive_directory_iterator&&) = default;\n\n  recursive_directory_iterator&\n  operator=(const recursive_directory_iterator&) = default;\n\n  _LIBCPP_INLINE_VISIBILITY\n  recursive_directory_iterator&\n  operator=(recursive_directory_iterator&& __o) noexcept {\n    // non-default implementation provided to support self-move assign.\n    if (this != &__o) {\n      __imp_ = _VSTD::move(__o.__imp_);\n      __rec_ = __o.__rec_;\n    }\n    return *this;\n  }\n\n  ~recursive_directory_iterator() = default;\n\n  _LIBCPP_INLINE_VISIBILITY\n  const directory_entry& operator*() const { return __dereference(); }\n\n  _LIBCPP_INLINE_VISIBILITY\n  const directory_entry* operator->() const { return &__dereference(); }\n\n  recursive_directory_iterator& operator++() { return __increment(); }\n\n  _LIBCPP_INLINE_VISIBILITY\n  __dir_element_proxy operator++(int) {\n    __dir_element_proxy __p(**this);\n    __increment();\n    return __p;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  recursive_directory_iterator& increment(error_code& __ec) {\n    return __increment(&__ec);\n  }\n\n  _LIBCPP_FUNC_VIS directory_options options() const;\n  _LIBCPP_FUNC_VIS int depth() const;\n\n  _LIBCPP_INLINE_VISIBILITY\n  void pop() { __pop(); }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void pop(error_code& __ec) { __pop(&__ec); }\n\n  _LIBCPP_INLINE_VISIBILITY\n  bool recursion_pending() const { return __rec_; }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void disable_recursion_pending() { __rec_ = false; }\n\nprivate:\n  recursive_directory_iterator(const path& __p, directory_options __opt,\n                               error_code* __ec);\n\n  _LIBCPP_FUNC_VIS\n  const directory_entry& __dereference() const;\n\n  _LIBCPP_FUNC_VIS\n  bool __try_recursion(error_code* __ec);\n\n  _LIBCPP_FUNC_VIS\n  void __advance(error_code* __ec = nullptr);\n\n  _LIBCPP_FUNC_VIS\n  recursive_directory_iterator& __increment(error_code* __ec = nullptr);\n\n  _LIBCPP_FUNC_VIS\n  void __pop(error_code* __ec = nullptr);\n\n  inline _LIBCPP_INLINE_VISIBILITY friend bool\n  operator==(const recursive_directory_iterator&,\n             const recursive_directory_iterator&) noexcept;\n\n  struct __shared_imp;\n  shared_ptr<__shared_imp> __imp_;\n  bool __rec_;\n}; // class recursive_directory_iterator\n\ninline _LIBCPP_INLINE_VISIBILITY bool\noperator==(const recursive_directory_iterator& __lhs,\n           const recursive_directory_iterator& __rhs) noexcept {\n  return __lhs.__imp_ == __rhs.__imp_;\n}\n\n_LIBCPP_INLINE_VISIBILITY\ninline bool operator!=(const recursive_directory_iterator& __lhs,\n                       const recursive_directory_iterator& __rhs) noexcept {\n  return !(__lhs == __rhs);\n}\n// enable recursive_directory_iterator range-based for statements\ninline _LIBCPP_INLINE_VISIBILITY recursive_directory_iterator\nbegin(recursive_directory_iterator __iter) noexcept {\n  return __iter;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY recursive_directory_iterator\nend(const recursive_directory_iterator&) noexcept {\n  return recursive_directory_iterator();\n}\n\n_LIBCPP_END_NAMESPACE_FILESYSTEM\n\n#endif // !_LIBCPP_CXX03_LANG\n\n_LIBCPP_POP_MACROS\n\n#endif // _LIBCPP_FILESYSTEM\n","#pragma once\n\n#include <filesystem>\n\n#include \"emp/config/ArgManager.hpp\"\n#include \"emp/prefab/ConfigPanel.hpp\"\n#include \"emp/web/UrlParams.hpp\"\n#include \"emp/web/web.hpp\"\n\n#include \"chemical-ecology/ExampleConfig.hpp\"\n\nvoid use_existing_config_file(chemical_ecology::Config & config, emp::ArgManager & am) {\n  if(std::filesystem::exists(\"chemical-ecology.cfg\")) {\n    std::cout << \"Configuration read from chemical-ecology.cfg\" << \"\\n\";\n    config.Read(\"chemical-ecology.cfg\");\n  }\n  am.UseCallbacks();\n  if (am.HasUnused())\n    std::exit(EXIT_FAILURE);\n}\n\nvoid setup_config_web(chemical_ecology::Config & config)  {\n  auto specs = emp::ArgManager::make_builtin_specs(&config);\n  emp::ArgManager am(emp::web::GetUrlParams(), specs);\n  use_existing_config_file(config, am);\n}\n\nvoid setup_config_native(chemical_ecology::Config & config, int argc, char* argv[]) {\n  auto specs = emp::ArgManager::make_builtin_specs(&config);\n  emp::ArgManager am(argc, argv, specs);\n  use_existing_config_file(config, am);\n}\n\n","// -*- C++ -*-\n//===-------------------------- unordered_map -----------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UNORDERED_MAP\n#define _LIBCPP_UNORDERED_MAP\n\n/*\n\n    unordered_map synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class Key, class T, class Hash = hash<Key>, class Pred = equal_to<Key>,\n          class Alloc = allocator<pair<const Key, T>>>\nclass unordered_map\n{\npublic:\n    // types\n    typedef Key                                                        key_type;\n    typedef T                                                          mapped_type;\n    typedef Hash                                                       hasher;\n    typedef Pred                                                       key_equal;\n    typedef Alloc                                                      allocator_type;\n    typedef pair<const key_type, mapped_type>                          value_type;\n    typedef value_type&                                                reference;\n    typedef const value_type&                                          const_reference;\n    typedef typename allocator_traits<allocator_type>::pointer         pointer;\n    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;\n    typedef typename allocator_traits<allocator_type>::size_type       size_type;\n    typedef typename allocator_traits<allocator_type>::difference_type difference_type;\n\n    typedef /unspecified/ iterator;\n    typedef /unspecified/ const_iterator;\n    typedef /unspecified/ local_iterator;\n    typedef /unspecified/ const_local_iterator;\n\n    typedef unspecified                             node_type;            // C++17\n    typedef INSERT_RETURN_TYPE<iterator, node_type> insert_return_type;   // C++17\n\n    unordered_map()\n        noexcept(\n            is_nothrow_default_constructible<hasher>::value &&\n            is_nothrow_default_constructible<key_equal>::value &&\n            is_nothrow_default_constructible<allocator_type>::value);\n    explicit unordered_map(size_type n, const hasher& hf = hasher(),\n                           const key_equal& eql = key_equal(),\n                           const allocator_type& a = allocator_type());\n    template <class InputIterator>\n        unordered_map(InputIterator f, InputIterator l,\n                      size_type n = 0, const hasher& hf = hasher(),\n                      const key_equal& eql = key_equal(),\n                      const allocator_type& a = allocator_type());\n    explicit unordered_map(const allocator_type&);\n    unordered_map(const unordered_map&);\n    unordered_map(const unordered_map&, const Allocator&);\n    unordered_map(unordered_map&&)\n        noexcept(\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value &&\n            is_nothrow_move_constructible<allocator_type>::value);\n    unordered_map(unordered_map&&, const Allocator&);\n    unordered_map(initializer_list<value_type>, size_type n = 0,\n                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),\n                  const allocator_type& a = allocator_type());\n    unordered_map(size_type n, const allocator_type& a)\n      : unordered_map(n, hasher(), key_equal(), a) {}  // C++14\n    unordered_map(size_type n, const hasher& hf, const allocator_type& a)\n      : unordered_map(n, hf, key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type& a)\n      : unordered_map(f, l, n, hasher(), key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher& hf, \n        const allocator_type& a)\n      : unordered_map(f, l, n, hf, key_equal(), a) {}  // C++14\n    unordered_map(initializer_list<value_type> il, size_type n, const allocator_type& a)\n      : unordered_map(il, n, hasher(), key_equal(), a) {}  // C++14\n    unordered_map(initializer_list<value_type> il, size_type n, const hasher& hf, \n      const allocator_type& a)\n      : unordered_map(il, n, hf, key_equal(), a) {}  // C++14\n    ~unordered_map();\n    unordered_map& operator=(const unordered_map&);\n    unordered_map& operator=(unordered_map&&)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n    unordered_map& operator=(initializer_list<value_type>);\n\n    allocator_type get_allocator() const noexcept;\n\n    bool      empty() const noexcept;\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n\n    iterator       begin() noexcept;\n    iterator       end() noexcept;\n    const_iterator begin()  const noexcept;\n    const_iterator end()    const noexcept;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend()   const noexcept;\n\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator, bool> insert(const value_type& obj);\n    template <class P>\n        pair<iterator, bool> insert(P&& obj);\n    iterator insert(const_iterator hint, const value_type& obj);\n    template <class P>\n        iterator insert(const_iterator hint, P&& obj);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type>);\n\n    node_type extract(const_iterator position);                                       // C++17\n    node_type extract(const key_type& x);                                             // C++17\n    insert_return_type insert(node_type&& nh);                                        // C++17\n    iterator           insert(const_iterator hint, node_type&& nh);                   // C++17\n\n    template <class... Args>\n        pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);          // C++17\n    template <class... Args>\n        pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);               // C++17\n    template <class... Args>\n        iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args); // C++17\n    template <class... Args>\n        iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);      // C++17\n    template <class M>\n        pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);            // C++17\n    template <class M>\n        pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);                 // C++17\n    template <class M>\n        iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);   // C++17\n    template <class M>\n        iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);        // C++17\n\n    iterator erase(const_iterator position);\n    iterator erase(iterator position);  // C++14\n    size_type erase(const key_type& k);\n    iterator erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    template<class H2, class P2>\n      void merge(unordered_map<Key, T, H2, P2, Allocator>& source);         // C++17\n    template<class H2, class P2>\n      void merge(unordered_map<Key, T, H2, P2, Allocator>&& source);        // C++17\n    template<class H2, class P2>\n      void merge(unordered_multimap<Key, T, H2, P2, Allocator>& source);    // C++17\n    template<class H2, class P2>\n      void merge(unordered_multimap<Key, T, H2, P2, Allocator>&& source);   // C++17\n\n    void swap(unordered_map&)\n        noexcept(\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value) &&\n            __is_nothrow_swappable<hasher>::value &&\n            __is_nothrow_swappable<key_equal>::value);\n\n    hasher hash_function() const;\n    key_equal key_eq() const;\n\n    iterator       find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    size_type count(const key_type& k) const;\n    pair<iterator, iterator>             equal_range(const key_type& k);\n    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;\n\n    mapped_type& operator[](const key_type& k);\n    mapped_type& operator[](key_type&& k);\n\n    mapped_type&       at(const key_type& k);\n    const mapped_type& at(const key_type& k) const;\n\n    size_type bucket_count() const noexcept;\n    size_type max_bucket_count() const noexcept;\n\n    size_type bucket_size(size_type n) const;\n    size_type bucket(const key_type& k) const;\n\n    local_iterator       begin(size_type n);\n    local_iterator       end(size_type n);\n    const_local_iterator begin(size_type n) const;\n    const_local_iterator end(size_type n) const;\n    const_local_iterator cbegin(size_type n) const;\n    const_local_iterator cend(size_type n) const;\n\n    float load_factor() const noexcept;\n    float max_load_factor() const noexcept;\n    void max_load_factor(float z);\n    void rehash(size_type n);\n    void reserve(size_type n);\n};\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,\n              unordered_map<Key, T, Hash, Pred, Alloc>& y)\n              noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator==(const unordered_map<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_map<Key, T, Hash, Pred, Alloc>& y);\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator!=(const unordered_map<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_map<Key, T, Hash, Pred, Alloc>& y);\n\ntemplate <class Key, class T, class Hash = hash<Key>, class Pred = equal_to<Key>,\n          class Alloc = allocator<pair<const Key, T>>>\nclass unordered_multimap\n{\npublic:\n    // types\n    typedef Key                                                        key_type;\n    typedef T                                                          mapped_type;\n    typedef Hash                                                       hasher;\n    typedef Pred                                                       key_equal;\n    typedef Alloc                                                      allocator_type;\n    typedef pair<const key_type, mapped_type>                          value_type;\n    typedef value_type&                                                reference;\n    typedef const value_type&                                          const_reference;\n    typedef typename allocator_traits<allocator_type>::pointer         pointer;\n    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;\n    typedef typename allocator_traits<allocator_type>::size_type       size_type;\n    typedef typename allocator_traits<allocator_type>::difference_type difference_type;\n\n    typedef /unspecified/ iterator;\n    typedef /unspecified/ const_iterator;\n    typedef /unspecified/ local_iterator;\n    typedef /unspecified/ const_local_iterator;\n\n    typedef unspecified node_type;    // C++17\n\n    unordered_multimap()\n        noexcept(\n            is_nothrow_default_constructible<hasher>::value &&\n            is_nothrow_default_constructible<key_equal>::value &&\n            is_nothrow_default_constructible<allocator_type>::value);\n    explicit unordered_multimap(size_type n, const hasher& hf = hasher(),\n                           const key_equal& eql = key_equal(),\n                           const allocator_type& a = allocator_type());\n    template <class InputIterator>\n        unordered_multimap(InputIterator f, InputIterator l,\n                      size_type n = 0, const hasher& hf = hasher(),\n                      const key_equal& eql = key_equal(),\n                      const allocator_type& a = allocator_type());\n    explicit unordered_multimap(const allocator_type&);\n    unordered_multimap(const unordered_multimap&);\n    unordered_multimap(const unordered_multimap&, const Allocator&);\n    unordered_multimap(unordered_multimap&&)\n        noexcept(\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value &&\n            is_nothrow_move_constructible<allocator_type>::value);\n    unordered_multimap(unordered_multimap&&, const Allocator&);\n    unordered_multimap(initializer_list<value_type>, size_type n = 0,\n                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),\n                  const allocator_type& a = allocator_type());\n    unordered_multimap(size_type n, const allocator_type& a)\n      : unordered_multimap(n, hasher(), key_equal(), a) {}  // C++14\n    unordered_multimap(size_type n, const hasher& hf, const allocator_type& a)\n      : unordered_multimap(n, hf, key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type& a)\n      : unordered_multimap(f, l, n, hasher(), key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher& hf, \n        const allocator_type& a)\n      : unordered_multimap(f, l, n, hf, key_equal(), a) {}  // C++14\n    unordered_multimap(initializer_list<value_type> il, size_type n, const allocator_type& a)\n      : unordered_multimap(il, n, hasher(), key_equal(), a) {}  // C++14\n    unordered_multimap(initializer_list<value_type> il, size_type n, const hasher& hf, \n      const allocator_type& a)\n      : unordered_multimap(il, n, hf, key_equal(), a) {}  // C++14\n    ~unordered_multimap();\n    unordered_multimap& operator=(const unordered_multimap&);\n    unordered_multimap& operator=(unordered_multimap&&)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n    unordered_multimap& operator=(initializer_list<value_type>);\n\n    allocator_type get_allocator() const noexcept;\n\n    bool      empty() const noexcept;\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n\n    iterator       begin() noexcept;\n    iterator       end() noexcept;\n    const_iterator begin()  const noexcept;\n    const_iterator end()    const noexcept;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend()   const noexcept;\n\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& obj);\n    template <class P>\n        iterator insert(P&& obj);\n    iterator insert(const_iterator hint, const value_type& obj);\n    template <class P>\n        iterator insert(const_iterator hint, P&& obj);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type>);\n\n    node_type extract(const_iterator position);                // C++17\n    node_type extract(const key_type& x);                      // C++17\n    iterator insert(node_type&& nh);                           // C++17\n    iterator insert(const_iterator hint, node_type&& nh);      // C++17\n\n    iterator erase(const_iterator position);\n    iterator erase(iterator position);  // C++14\n    size_type erase(const key_type& k);\n    iterator erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    template<class H2, class P2>\n      void merge(unordered_multimap<Key, T, H2, P2, Allocator>& source);    // C++17\n    template<class H2, class P2>\n      void merge(unordered_multimap<Key, T, H2, P2, Allocator>&& source);   // C++17\n    template<class H2, class P2>\n      void merge(unordered_map<Key, T, H2, P2, Allocator>& source);         // C++17\n    template<class H2, class P2>\n      void merge(unordered_map<Key, T, H2, P2, Allocator>&& source);        // C++17\n\n    void swap(unordered_multimap&)\n        noexcept(\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value) &&\n            __is_nothrow_swappable<hasher>::value &&\n            __is_nothrow_swappable<key_equal>::value);\n\n    hasher hash_function() const;\n    key_equal key_eq() const;\n\n    iterator       find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    size_type count(const key_type& k) const;\n    pair<iterator, iterator>             equal_range(const key_type& k);\n    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;\n\n    size_type bucket_count() const noexcept;\n    size_type max_bucket_count() const noexcept;\n\n    size_type bucket_size(size_type n) const;\n    size_type bucket(const key_type& k) const;\n\n    local_iterator       begin(size_type n);\n    local_iterator       end(size_type n);\n    const_local_iterator begin(size_type n) const;\n    const_local_iterator end(size_type n) const;\n    const_local_iterator cbegin(size_type n) const;\n    const_local_iterator cend(size_type n) const;\n\n    float load_factor() const noexcept;\n    float max_load_factor() const noexcept;\n    void max_load_factor(float z);\n    void rehash(size_type n);\n    void reserve(size_type n);\n};\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,\n              unordered_multimap<Key, T, Hash, Pred, Alloc>& y)\n              noexcept(noexcept(x.swap(y)));\n\ntemplate <class K, class T, class H, class P, class A, class Predicate>\n    void erase_if(unordered_set<K, T, H, P, A>& c, Predicate pred);       // C++20\n\ntemplate <class K, class T, class H, class P, class A, class Predicate>\n    void erase_if(unordered_multiset<K, T, H, P, A>& c, Predicate pred);  // C++20\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator==(const unordered_multimap<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_multimap<Key, T, Hash, Pred, Alloc>& y);\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator!=(const unordered_multimap<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_multimap<Key, T, Hash, Pred, Alloc>& y);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__hash_table>\n#include <__node_handle>\n#include <functional>\n#include <stdexcept>\n#include <tuple>\n#include <version>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _Cp, class _Hash,\n          bool = is_empty<_Hash>::value && !__libcpp_is_final<_Hash>::value>\nclass __unordered_map_hasher\n    : private _Hash\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Hash>::value)\n        : _Hash() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher(const _Hash& __h)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Hash>::value)\n        : _Hash(__h) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Hash& hash_function() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Cp& __x) const\n        {return static_cast<const _Hash&>(*this)(__x.__get_value().first);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Key& __x) const\n        {return static_cast<const _Hash&>(*this)(__x);}\n    void swap(__unordered_map_hasher&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Hash>::value)\n    {\n        using _VSTD::swap;\n        swap(static_cast<_Hash&>(*this), static_cast<_Hash&>(__y));\n    }\n};\n\ntemplate <class _Key, class _Cp, class _Hash>\nclass __unordered_map_hasher<_Key, _Cp, _Hash, false>\n{\n    _Hash __hash_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Hash>::value)\n        : __hash_() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher(const _Hash& __h)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Hash>::value)\n        : __hash_(__h) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Hash& hash_function() const _NOEXCEPT {return __hash_;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Cp& __x) const\n        {return __hash_(__x.__get_value().first);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Key& __x) const\n        {return __hash_(__x);}\n    void swap(__unordered_map_hasher&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Hash>::value)\n    {\n        using _VSTD::swap;\n        swap(__hash_, __y.__hash_);\n    }\n};\n\ntemplate <class _Key, class _Cp, class _Hash, bool __b>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__unordered_map_hasher<_Key, _Cp, _Hash, __b>& __x,\n     __unordered_map_hasher<_Key, _Cp, _Hash, __b>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Cp, class _Pred,\n          bool = is_empty<_Pred>::value && !__libcpp_is_final<_Pred>::value>\nclass __unordered_map_equal\n    : private _Pred\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Pred>::value)\n        : _Pred() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal(const _Pred& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Pred>::value)\n        : _Pred(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Pred& key_eq() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Cp& __y) const\n        {return static_cast<const _Pred&>(*this)(__x.__get_value().first, __y.__get_value().first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Key& __y) const\n        {return static_cast<const _Pred&>(*this)(__x.__get_value().first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _Cp& __y) const\n        {return static_cast<const _Pred&>(*this)(__x, __y.__get_value().first);}\n    void swap(__unordered_map_equal&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Pred>::value)\n    {\n        using _VSTD::swap;\n        swap(static_cast<_Pred&>(*this), static_cast<_Pred&>(__y));\n    }\n};\n\ntemplate <class _Key, class _Cp, class _Pred>\nclass __unordered_map_equal<_Key, _Cp, _Pred, false>\n{\n    _Pred __pred_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Pred>::value)\n        : __pred_() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal(const _Pred& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Pred>::value)\n        : __pred_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Pred& key_eq() const _NOEXCEPT {return __pred_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Cp& __y) const\n        {return __pred_(__x.__get_value().first, __y.__get_value().first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Key& __y) const\n        {return __pred_(__x.__get_value().first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _Cp& __y) const\n        {return __pred_(__x, __y.__get_value().first);}\n    void swap(__unordered_map_equal&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Pred>::value)\n    {\n        using _VSTD::swap;\n        swap(__pred_, __y.__pred_);\n    }\n};\n\ntemplate <class _Key, class _Cp, class _Pred, bool __b>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__unordered_map_equal<_Key, _Cp, _Pred, __b>& __x,\n     __unordered_map_equal<_Key, _Cp, _Pred, __b>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Alloc>\nclass __hash_map_node_destructor\n{\n    typedef _Alloc                              allocator_type;\n    typedef allocator_traits<allocator_type>    __alloc_traits;\n\npublic:\n\n    typedef typename __alloc_traits::pointer       pointer;\nprivate:\n\n    allocator_type& __na_;\n\n    __hash_map_node_destructor& operator=(const __hash_map_node_destructor&);\n\npublic:\n    bool __first_constructed;\n    bool __second_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __hash_map_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __first_constructed(false),\n          __second_constructed(false)\n        {}\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_node_destructor(__hash_node_destructor<allocator_type>&& __x)\n        _NOEXCEPT\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            __x.__value_constructed = false;\n        }\n#else  // _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_node_destructor(const __hash_node_destructor<allocator_type>& __x)\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            const_cast<bool&>(__x.__value_constructed) = false;\n        }\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__second_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__get_value().second));\n        if (__first_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__get_value().first));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n};\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Tp>\nstruct __hash_value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type&, mapped_type&>            __nc_ref_pair_type;\n    typedef pair<key_type&&, mapped_type&&>          __nc_rref_pair_type;\n\nprivate:\n    value_type __cc;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    value_type& __get_value()\n    {\n#if _LIBCPP_STD_VER > 14\n        return *_VSTD::launder(_VSTD::addressof(__cc));\n#else\n        return __cc;\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type& __get_value() const\n    {\n#if _LIBCPP_STD_VER > 14\n        return *_VSTD::launder(_VSTD::addressof(__cc));\n#else\n        return __cc;\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __nc_ref_pair_type __ref()\n    {\n        value_type& __v = __get_value();\n        return __nc_ref_pair_type(const_cast<key_type&>(__v.first), __v.second);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __nc_rref_pair_type __move()\n    {\n        value_type& __v = __get_value();\n        return __nc_rref_pair_type(\n            _VSTD::move(const_cast<key_type&>(__v.first)),\n            _VSTD::move(__v.second));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type& operator=(const __hash_value_type& __v)\n    {\n        __ref() = __v.__get_value();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type& operator=(__hash_value_type&& __v)\n    {\n        __ref() = __v.__move();\n        return *this;\n    }\n\n    template <class _ValueTp,\n              class = typename enable_if<\n                    __is_same_uncvref<_ValueTp, value_type>::value\n                 >::type\n             >\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type& operator=(_ValueTp&& __v)\n    {\n        __ref() = _VSTD::forward<_ValueTp>(__v);\n        return *this;\n    }\n\nprivate:\n    __hash_value_type(const __hash_value_type& __v) = delete;\n    __hash_value_type(__hash_value_type&& __v) = delete;\n    template <class ..._Args>\n    explicit __hash_value_type(_Args&& ...__args) = delete;\n\n    ~__hash_value_type() = delete;\n};\n\n#else\n\ntemplate <class _Key, class _Tp>\nstruct __hash_value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n\nprivate:\n    value_type __cc;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    value_type& __get_value() { return __cc; }\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type& __get_value() const { return __cc; }\n\nprivate:\n   ~__hash_value_type();\n};\n\n#endif\n\ntemplate <class _HashIterator>\nclass _LIBCPP_TEMPLATE_VIS __hash_map_iterator\n{\n    _HashIterator __i_;\n\n    typedef  __hash_node_types_from_iterator<_HashIterator> _NodeTypes;\n\npublic:\n    typedef forward_iterator_tag                                 iterator_category;\n    typedef typename _NodeTypes::__map_value_type                value_type;\n    typedef typename _NodeTypes::difference_type                 difference_type;\n    typedef value_type&                                          reference;\n    typedef typename _NodeTypes::__map_value_type_pointer       pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator(_HashIterator __i) _NOEXCEPT : __i_(__i) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__get_value();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__get_value());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator operator++(int)\n    {\n        __hash_map_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __hash_map_iterator& __x, const __hash_map_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __hash_map_iterator& __x, const __hash_map_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_iterator;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator;\n};\n\ntemplate <class _HashIterator>\nclass _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator\n{\n    _HashIterator __i_;\n\n    typedef  __hash_node_types_from_iterator<_HashIterator> _NodeTypes;\n\npublic:\n    typedef forward_iterator_tag                                 iterator_category;\n    typedef typename _NodeTypes::__map_value_type                value_type;\n    typedef typename _NodeTypes::difference_type                 difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename _NodeTypes::__const_map_value_type_pointer  pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator(_HashIterator __i) _NOEXCEPT : __i_(__i) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator(\n            __hash_map_iterator<typename _HashIterator::__non_const_iterator> __i)\n                 _NOEXCEPT\n                : __i_(__i.__i_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__get_value();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__get_value());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator operator++(int)\n    {\n        __hash_map_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_iterator;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator;\n};\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nclass unordered_multimap;\n\ntemplate <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,\n          class _Alloc = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TEMPLATE_VIS unordered_map\n{\npublic:\n    // types\n    typedef _Key                                           key_type;\n    typedef _Tp                                            mapped_type;\n    typedef _Hash                                          hasher;\n    typedef _Pred                                          key_equal;\n    typedef _Alloc                                         allocator_type;\n    typedef pair<const key_type, mapped_type>              value_type;\n    typedef value_type&                                    reference;\n    typedef const value_type&                              const_reference;\n    static_assert((is_same<value_type, typename allocator_type::value_type>::value),\n                  \"Invalid allocator::value_type\");\n    static_assert(sizeof(__diagnose_unordered_container_requirements<_Key, _Hash, _Pred>(0)), \"\");\n\nprivate:\n    typedef __hash_value_type<key_type, mapped_type>                 __value_type;\n    typedef __unordered_map_hasher<key_type, __value_type, hasher>   __hasher;\n    typedef __unordered_map_equal<key_type, __value_type, key_equal> __key_equal;\n    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,\n                                                 __value_type>::type __allocator_type;\n\n    typedef __hash_table<__value_type, __hasher,\n                         __key_equal,  __allocator_type>   __table;\n\n    __table __table_;\n\n    typedef typename __table::_NodeTypes                   _NodeTypes;\n    typedef typename __table::__node_pointer               __node_pointer;\n    typedef typename __table::__node_const_pointer         __node_const_pointer;\n    typedef typename __table::__node_traits                __node_traits;\n    typedef typename __table::__node_allocator             __node_allocator;\n    typedef typename __table::__node                       __node;\n    typedef __hash_map_node_destructor<__node_allocator>   _Dp;\n    typedef unique_ptr<__node, _Dp>                         __node_holder;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\n\n    static_assert((is_same<typename __table::__container_value_type, value_type>::value), \"\");\n    static_assert((is_same<typename __table::__node_value_type, __value_type>::value), \"\");\npublic:\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __table::size_type              size_type;\n    typedef typename __table::difference_type        difference_type;\n\n    typedef __hash_map_iterator<typename __table::iterator>       iterator;\n    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;\n    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;\n    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;\n\n#if _LIBCPP_STD_VER > 14\n    typedef __map_node_handle<__node, allocator_type> node_type;\n    typedef __insert_return_type<iterator, node_type> insert_return_type;\n#endif\n\n    template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>\n        friend class _LIBCPP_TEMPLATE_VIS unordered_map;\n    template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>\n        friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;\n\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map()\n        _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    explicit unordered_map(size_type __n, const hasher& __hf = hasher(),\n                           const key_equal& __eql = key_equal());\n    unordered_map(size_type __n, const hasher& __hf,\n                  const key_equal& __eql,\n                  const allocator_type& __a);\n    template <class _InputIterator>\n        unordered_map(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        unordered_map(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf = hasher(),\n                      const key_equal& __eql = key_equal());\n    template <class _InputIterator>\n        unordered_map(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf,\n                      const key_equal& __eql,\n                      const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit unordered_map(const allocator_type& __a);\n    unordered_map(const unordered_map& __u);\n    unordered_map(const unordered_map& __u, const allocator_type& __a);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(unordered_map&& __u)\n        _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);\n    unordered_map(unordered_map&& __u, const allocator_type& __a);\n    unordered_map(initializer_list<value_type> __il);\n    unordered_map(initializer_list<value_type> __il, size_type __n,\n                  const hasher& __hf = hasher(), const key_equal& __eql = key_equal());\n    unordered_map(initializer_list<value_type> __il, size_type __n,\n                  const hasher& __hf, const key_equal& __eql,\n                  const allocator_type& __a);\n#endif  // _LIBCPP_CXX03_LANG\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(size_type __n, const allocator_type& __a)\n      : unordered_map(__n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(size_type __n, const hasher& __hf, const allocator_type& __a)\n      : unordered_map(__n, __hf, key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_map(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)\n      : unordered_map(__first, __last, __n, hasher(), key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_map(_InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, \n        const allocator_type& __a)\n      : unordered_map(__first, __last, __n, __hf, key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)\n      : unordered_map(__il, __n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(initializer_list<value_type> __il, size_type __n, const hasher& __hf, \n      const allocator_type& __a)\n      : unordered_map(__il, __n, __hf, key_equal(), __a) {}\n#endif\n    // ~unordered_map() = default;\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map& operator=(const unordered_map& __u)\n    {\n#ifndef _LIBCPP_CXX03_LANG\n        __table_ = __u.__table_;\n#else\n        if (this != &__u) {\n            __table_.clear();\n            __table_.hash_function() = __u.__table_.hash_function();\n            __table_.key_eq() = __u.__table_.key_eq();\n            __table_.max_load_factor() = __u.__table_.max_load_factor();\n            __table_.__copy_assign_alloc(__u.__table_);\n            insert(__u.begin(), __u.end());\n        }\n#endif\n        return *this;\n    }\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map& operator=(unordered_map&& __u)\n        _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map& operator=(initializer_list<value_type> __il);\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(__table_.__node_alloc());}\n\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __table_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT  {return __table_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __table_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       begin() _NOEXCEPT        {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       end() _NOEXCEPT          {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT {return __table_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> insert(const value_type& __x)\n        {return __table_.__insert_unique(__x);}\n\n    iterator insert(const_iterator __p, const value_type& __x) {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n            \"unordered_map::insert(const_iterator, const value_type&) called with an iterator not\"\n            \" referring to this unordered_map\");\n#else\n        ((void)__p);\n#endif\n        return insert(__x).first;\n    }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __first, _InputIterator __last);\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> insert(value_type&& __x)\n        {return __table_.__insert_unique(_VSTD::move(__x));}\n\n    iterator insert(const_iterator __p, value_type&& __x) {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n            \"unordered_map::insert(const_iterator, const value_type&) called with an iterator not\"\n            \" referring to this unordered_map\");\n#else\n        ((void)__p);\n#endif\n        return __table_.__insert_unique(_VSTD::move(__x)).first;\n    }\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert(_Pp&& __x)\n            {return __table_.__insert_unique(_VSTD::forward<_Pp>(__x));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __p, _Pp&& __x)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n                \"unordered_map::insert(const_iterator, value_type&&) called with an iterator not\"\n                \" referring to this unordered_map\");\n#else\n          ((void)__p);\n#endif\n            return insert(_VSTD::forward<_Pp>(__x)).first;\n        }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> emplace(_Args&&... __args) {\n        return __table_.__emplace_unique(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator emplace_hint(const_iterator __p, _Args&&... __args) {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n            \"unordered_map::emplace_hint(const_iterator, args...) called with an iterator not\"\n            \" referring to this unordered_map\");\n#else\n          ((void)__p);\n#endif\n        return __table_.__emplace_unique(_VSTD::forward<_Args>(__args)...).first;\n    }\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 14\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> try_emplace(const key_type& __k, _Args&&... __args)\n    {\n        return __table_.__emplace_unique_key_args(__k, _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(__k),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> try_emplace(key_type&& __k, _Args&&... __args)\n    {\n        return __table_.__emplace_unique_key_args(__k, _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(_VSTD::move(__k)),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator try_emplace(const_iterator __h, const key_type& __k, _Args&&... __args)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__h) == this,\n            \"unordered_map::try_emplace(const_iterator, key, args...) called with an iterator not\"\n            \" referring to this unordered_map\");\n#else\n        ((void)__h);\n#endif\n        return try_emplace(__k, _VSTD::forward<_Args>(__args)...).first;\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator try_emplace(const_iterator __h, key_type&& __k, _Args&&... __args)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__h) == this,\n            \"unordered_map::try_emplace(const_iterator, key, args...) called with an iterator not\"\n            \" referring to this unordered_map\");\n#else\n        ((void)__h);\n#endif\n        return try_emplace(_VSTD::move(__k), _VSTD::forward<_Args>(__args)...).first;\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert_or_assign(const key_type& __k, _Vp&& __v)\n    {\n        pair<iterator, bool> __res = __table_.__emplace_unique_key_args(__k,\n            __k, _VSTD::forward<_Vp>(__v));\n        if (!__res.second) {\n            __res.first->second = _VSTD::forward<_Vp>(__v);\n        }\n        return __res;\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert_or_assign(key_type&& __k, _Vp&& __v)\n    {\n        pair<iterator, bool> __res = __table_.__emplace_unique_key_args(__k,\n            _VSTD::move(__k), _VSTD::forward<_Vp>(__v));\n        if (!__res.second) {\n            __res.first->second = _VSTD::forward<_Vp>(__v);\n        }\n        return __res;\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert_or_assign(const_iterator, const key_type& __k, _Vp&& __v)\n     {\n          // FIXME: Add debug mode checking for the iterator input\n          return insert_or_assign(__k, _VSTD::forward<_Vp>(__v)).first;\n     }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert_or_assign(const_iterator, key_type&& __k, _Vp&& __v)\n     {\n        // FIXME: Add debug mode checking for the iterator input\n        return insert_or_assign(_VSTD::move(__k), _VSTD::forward<_Vp>(__v)).first;\n     }\n#endif // _LIBCPP_STD_VER > 14\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(iterator __p)       {return __table_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __table_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __first, const_iterator __last)\n        {return __table_.erase(__first.__i_, __last.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n        void clear() _NOEXCEPT {__table_.clear();}\n\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    insert_return_type insert(node_type&& __nh)\n    {\n        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),\n            \"node_type with incompatible allocator passed to unordered_map::insert()\");\n        return __table_.template __node_handle_insert_unique<\n            node_type, insert_return_type>(_VSTD::move(__nh));\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __hint, node_type&& __nh)\n    {\n        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),\n            \"node_type with incompatible allocator passed to unordered_map::insert()\");\n        return __table_.template __node_handle_insert_unique<node_type>(\n            __hint.__i_, _VSTD::move(__nh));\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    node_type extract(key_type const& __key)\n    {\n        return __table_.template __node_handle_extract<node_type>(__key);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    node_type extract(const_iterator __it)\n    {\n        return __table_.template __node_handle_extract<node_type>(\n            __it.__i_);\n    }\n\n    template <class _H2, class _P2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(unordered_map<key_type, mapped_type, _H2, _P2, allocator_type>& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        return __table_.__node_handle_merge_unique(__source.__table_);\n    }\n    template <class _H2, class _P2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(unordered_map<key_type, mapped_type, _H2, _P2, allocator_type>&& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        return __table_.__node_handle_merge_unique(__source.__table_);\n    }\n    template <class _H2, class _P2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(unordered_multimap<key_type, mapped_type, _H2, _P2, allocator_type>& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        return __table_.__node_handle_merge_unique(__source.__table_);\n    }\n    template <class _H2, class _P2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(unordered_multimap<key_type, mapped_type, _H2, _P2, allocator_type>&& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        return __table_.__node_handle_merge_unique(__source.__table_);\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(unordered_map& __u)\n        _NOEXCEPT_(__is_nothrow_swappable<__table>::value)\n        { __table_.swap(__u.__table_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    hasher hash_function() const\n        {return __table_.hash_function().hash_function();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_equal key_eq() const\n        {return __table_.key_eq().key_eq();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       find(const key_type& __k)       {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type count(const key_type& __k) const {return __table_.__count_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, iterator>             equal_range(const key_type& __k)\n        {return __table_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const\n        {return __table_.__equal_range_unique(__k);}\n\n    mapped_type& operator[](const key_type& __k);\n#ifndef _LIBCPP_CXX03_LANG\n    mapped_type& operator[](key_type&& __k);\n#endif\n\n    mapped_type&       at(const key_type& __k);\n    const mapped_type& at(const key_type& __k) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_count() const _NOEXCEPT {return __table_.bucket_count();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_bucket_count() const _NOEXCEPT {return __table_.max_bucket_count();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_size(size_type __n) const\n        {return __table_.bucket_size(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       begin(size_type __n)        {return __table_.begin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       end(size_type __n)          {return __table_.end(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator begin(size_type __n) const  {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator end(size_type __n) const    {return __table_.cend(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cend(size_type __n) const   {return __table_.cend(__n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    float load_factor() const _NOEXCEPT {return __table_.load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    float max_load_factor() const _NOEXCEPT {return __table_.max_load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}\n    _LIBCPP_INLINE_VISIBILITY\n    void rehash(size_type __n) {__table_.rehash(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    void reserve(size_type __n) {__table_.reserve(__n);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const\n        {return __table_.__dereferenceable(&__i->__i_);}\n    bool __decrementable(const const_iterator* __i) const\n        {return __table_.__decrementable(&__i->__i_);}\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n\n#ifdef _LIBCPP_CXX03_LANG\n    __node_holder __construct_node_with_key(const key_type& __k);\n#endif\n};\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        size_type __n, const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        size_type __n, const hasher& __hf, const key_equal& __eql,\n        const allocator_type& __a)\n    : __table_(__hf, __eql, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        const allocator_type& __a)\n    : __table_(typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        const unordered_map& __u)\n    : __table_(__u.__table_)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        const unordered_map& __u, const allocator_type& __a)\n    : __table_(__u.__table_, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        unordered_map&& __u)\n    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)\n    : __table_(_VSTD::move(__u.__table_))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        unordered_map&& __u, const allocator_type& __a)\n    : __table_(_VSTD::move(__u.__table_), typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a != __u.get_allocator())\n    {\n        iterator __i = __u.begin();\n        while (__u.size() != 0) {\n            __table_.__emplace_unique(\n                __u.__table_.remove((__i++).__i_)->__value_.__move());\n        }\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    else\n        __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_map&& __u)\n    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value)\n{\n    __table_ = _VSTD::move(__u.__table_);\n    return *this;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(\n        initializer_list<value_type> __il)\n{\n    __table_.__assign_unique(__il.begin(), __il.end());\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\ninline\nvoid\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,\n                                                       _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        __table_.__insert_unique(*__first);\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n_Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type& __k)\n{\n    return __table_.__emplace_unique_key_args(__k,\n        std::piecewise_construct, std::forward_as_tuple(__k),\n                                  std::forward_as_tuple()).first->__get_value().second;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n_Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](key_type&& __k)\n{\n    return __table_.__emplace_unique_key_args(__k,\n        std::piecewise_construct, std::forward_as_tuple(std::move(__k)),\n                                  std::forward_as_tuple()).first->__get_value().second;\n}\n#else // _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntypename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node_with_key(const key_type& __k)\n{\n    __node_allocator& __na = __table_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__get_value().first), __k);\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__get_value().second));\n    __h.get_deleter().__second_constructed = true;\n    return _LIBCPP_EXPLICIT_MOVE(__h);  // explicitly moved for C++03\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n_Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type& __k)\n{\n    iterator __i = find(__k);\n    if (__i != end())\n        return __i->second;\n    __node_holder __h = __construct_node_with_key(__k);\n    pair<iterator, bool> __r = __table_.__node_insert_unique(__h.get());\n    __h.release();\n    return __r.first->second;\n}\n\n#endif  // _LIBCPP_CXX03_MODE\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n_Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k)\n{\n    iterator __i = find(__k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__i == end())\n        throw out_of_range(\"unordered_map::at: key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __i->second;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nconst _Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k) const\n{\n    const_iterator __i = find(__k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__i == end())\n        throw out_of_range(\"unordered_map::at: key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __i->second;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n     unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n#if _LIBCPP_STD_VER > 17\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid erase_if(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __c, _Predicate __pred)\n{ __libcpp_erase_if_container(__c, __pred); }\n#endif\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nbool\noperator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    if (__x.size() != __y.size())\n        return false;\n    typedef typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator\n                                                                 const_iterator;\n    for (const_iterator __i = __x.begin(), __ex = __x.end(), __ey = __y.end();\n            __i != __ex; ++__i)\n    {\n        const_iterator __j = __y.find(__i->first);\n        if (__j == __ey || !(*__i == *__j))\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,\n          class _Alloc = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TEMPLATE_VIS unordered_multimap\n{\npublic:\n    // types\n    typedef _Key                                           key_type;\n    typedef _Tp                                            mapped_type;\n    typedef _Hash                                          hasher;\n    typedef _Pred                                          key_equal;\n    typedef _Alloc                                         allocator_type;\n    typedef pair<const key_type, mapped_type>              value_type;\n    typedef value_type&                                    reference;\n    typedef const value_type&                              const_reference;\n    static_assert((is_same<value_type, typename allocator_type::value_type>::value),\n                  \"Invalid allocator::value_type\");\n    static_assert(sizeof(__diagnose_unordered_container_requirements<_Key, _Hash, _Pred>(0)), \"\");\n\nprivate:\n    typedef __hash_value_type<key_type, mapped_type>                 __value_type;\n    typedef __unordered_map_hasher<key_type, __value_type, hasher>   __hasher;\n    typedef __unordered_map_equal<key_type, __value_type, key_equal> __key_equal;\n    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,\n                                                 __value_type>::type __allocator_type;\n\n    typedef __hash_table<__value_type, __hasher,\n                         __key_equal,  __allocator_type>   __table;\n\n    __table __table_;\n\n    typedef typename __table::_NodeTypes                   _NodeTypes;\n    typedef typename __table::__node_traits                __node_traits;\n    typedef typename __table::__node_allocator             __node_allocator;\n    typedef typename __table::__node                       __node;\n    typedef __hash_map_node_destructor<__node_allocator>   _Dp;\n    typedef unique_ptr<__node, _Dp>                         __node_holder;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\n    static_assert((is_same<typename __node_traits::size_type,\n                          typename __alloc_traits::size_type>::value),\n                 \"Allocator uses different size_type for different types\");\npublic:\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __table::size_type              size_type;\n    typedef typename __table::difference_type        difference_type;\n\n    typedef __hash_map_iterator<typename __table::iterator>       iterator;\n    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;\n    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;\n    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;\n\n#if _LIBCPP_STD_VER > 14\n    typedef __map_node_handle<__node, allocator_type> node_type;\n#endif\n\n    template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>\n        friend class _LIBCPP_TEMPLATE_VIS unordered_map;\n    template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>\n        friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;\n\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap()\n        _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    explicit unordered_multimap(size_type __n, const hasher& __hf = hasher(),\n                                const key_equal& __eql = key_equal());\n    unordered_multimap(size_type __n, const hasher& __hf,\n                                const key_equal& __eql,\n                                const allocator_type& __a);\n    template <class _InputIterator>\n        unordered_multimap(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        unordered_multimap(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf = hasher(),\n                      const key_equal& __eql = key_equal());\n    template <class _InputIterator>\n        unordered_multimap(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf,\n                      const key_equal& __eql,\n                      const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit unordered_multimap(const allocator_type& __a);\n    unordered_multimap(const unordered_multimap& __u);\n    unordered_multimap(const unordered_multimap& __u, const allocator_type& __a);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(unordered_multimap&& __u)\n        _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);\n    unordered_multimap(unordered_multimap&& __u, const allocator_type& __a);\n    unordered_multimap(initializer_list<value_type> __il);\n    unordered_multimap(initializer_list<value_type> __il, size_type __n,\n                       const hasher& __hf = hasher(),\n                       const key_equal& __eql = key_equal());\n    unordered_multimap(initializer_list<value_type> __il, size_type __n,\n                       const hasher& __hf, const key_equal& __eql,\n                       const allocator_type& __a);\n#endif  // _LIBCPP_CXX03_LANG\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(size_type __n, const allocator_type& __a)\n      : unordered_multimap(__n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(size_type __n, const hasher& __hf, const allocator_type& __a)\n      : unordered_multimap(__n, __hf, key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_multimap(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)\n      : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_multimap(_InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, \n        const allocator_type& __a)\n      : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)\n      : unordered_multimap(__il, __n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(initializer_list<value_type> __il, size_type __n, const hasher& __hf, \n      const allocator_type& __a)\n      : unordered_multimap(__il, __n, __hf, key_equal(), __a) {}\n#endif\n    // ~unordered_multimap() = default;\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap& operator=(const unordered_multimap& __u)\n    {\n#ifndef _LIBCPP_CXX03_LANG\n        __table_ = __u.__table_;\n#else\n        if (this != &__u) {\n            __table_.clear();\n            __table_.hash_function() = __u.__table_.hash_function();\n            __table_.key_eq() = __u.__table_.key_eq();\n            __table_.max_load_factor() = __u.__table_.max_load_factor();\n            __table_.__copy_assign_alloc(__u.__table_);\n            insert(__u.begin(), __u.end());\n        }\n#endif\n        return *this;\n    }\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap& operator=(unordered_multimap&& __u)\n        _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap& operator=(initializer_list<value_type> __il);\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(__table_.__node_alloc());}\n\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __table_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT  {return __table_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __table_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       begin() _NOEXCEPT        {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       end() _NOEXCEPT          {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT {return __table_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __x) {return __table_.__insert_multi(__x);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __x)\n        {return __table_.__insert_multi(__p.__i_, __x);}\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(_InputIterator __first, _InputIterator __last);\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(value_type&& __x) {return __table_.__insert_multi(_VSTD::move(__x));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __x)\n        {return __table_.__insert_multi(__p.__i_, _VSTD::move(__x));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(_Pp&& __x)\n        {return __table_.__insert_multi(_VSTD::forward<_Pp>(__x));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, _Pp&& __x)\n        {return __table_.__insert_multi(__p.__i_, _VSTD::forward<_Pp>(__x));}\n\n    template <class... _Args>\n    iterator emplace(_Args&&... __args) {\n        return __table_.__emplace_multi(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class... _Args>\n    iterator emplace_hint(const_iterator __p, _Args&&... __args) {\n        return __table_.__emplace_hint_multi(__p.__i_, _VSTD::forward<_Args>(__args)...);\n    }\n#endif  // _LIBCPP_CXX03_LANG\n\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(iterator __p)       {return __table_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __table_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __first, const_iterator __last)\n        {return __table_.erase(__first.__i_, __last.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__table_.clear();}\n\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(node_type&& __nh)\n    {\n        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),\n            \"node_type with incompatible allocator passed to unordered_multimap::insert()\");\n        return __table_.template __node_handle_insert_multi<node_type>(\n            _VSTD::move(__nh));\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __hint, node_type&& __nh)\n    {\n        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),\n            \"node_type with incompatible allocator passed to unordered_multimap::insert()\");\n        return __table_.template __node_handle_insert_multi<node_type>(\n            __hint.__i_, _VSTD::move(__nh));\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    node_type extract(key_type const& __key)\n    {\n        return __table_.template __node_handle_extract<node_type>(__key);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    node_type extract(const_iterator __it)\n    {\n        return __table_.template __node_handle_extract<node_type>(\n            __it.__i_);\n    }\n\n    template <class _H2, class _P2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(unordered_multimap<key_type, mapped_type, _H2, _P2, allocator_type>& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        return __table_.__node_handle_merge_multi(__source.__table_);\n    }\n    template <class _H2, class _P2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(unordered_multimap<key_type, mapped_type, _H2, _P2, allocator_type>&& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        return __table_.__node_handle_merge_multi(__source.__table_);\n    }\n    template <class _H2, class _P2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(unordered_map<key_type, mapped_type, _H2, _P2, allocator_type>& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        return __table_.__node_handle_merge_multi(__source.__table_);\n    }\n    template <class _H2, class _P2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(unordered_map<key_type, mapped_type, _H2, _P2, allocator_type>&& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        return __table_.__node_handle_merge_multi(__source.__table_);\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(unordered_multimap& __u)\n        _NOEXCEPT_(__is_nothrow_swappable<__table>::value)\n        {__table_.swap(__u.__table_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    hasher hash_function() const\n        {return __table_.hash_function().hash_function();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_equal key_eq() const\n        {return __table_.key_eq().key_eq();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       find(const key_type& __k)       {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type count(const key_type& __k) const {return __table_.__count_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, iterator>             equal_range(const key_type& __k)\n        {return __table_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const\n        {return __table_.__equal_range_multi(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_count() const _NOEXCEPT {return __table_.bucket_count();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_bucket_count() const _NOEXCEPT\n        {return __table_.max_bucket_count();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_size(size_type __n) const\n        {return __table_.bucket_size(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       begin(size_type __n)        {return __table_.begin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       end(size_type __n)          {return __table_.end(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator begin(size_type __n) const  {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator end(size_type __n) const    {return __table_.cend(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cend(size_type __n) const   {return __table_.cend(__n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    float load_factor() const _NOEXCEPT {return __table_.load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    float max_load_factor() const _NOEXCEPT {return __table_.max_load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}\n    _LIBCPP_INLINE_VISIBILITY\n    void rehash(size_type __n) {__table_.rehash(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    void reserve(size_type __n) {__table_.reserve(__n);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const\n        {return __table_.__dereferenceable(&__i->__i_);}\n    bool __decrementable(const const_iterator* __i) const\n        {return __table_.__decrementable(&__i->__i_);}\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n\n};\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        size_type __n, const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        size_type __n, const hasher& __hf, const key_equal& __eql,\n        const allocator_type& __a)\n    : __table_(__hf, __eql, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        const allocator_type& __a)\n    : __table_(typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        const unordered_multimap& __u)\n    : __table_(__u.__table_)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        const unordered_multimap& __u, const allocator_type& __a)\n    : __table_(__u.__table_, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        unordered_multimap&& __u)\n    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)\n    : __table_(_VSTD::move(__u.__table_))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        unordered_multimap&& __u, const allocator_type& __a)\n    : __table_(_VSTD::move(__u.__table_), typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a != __u.get_allocator())\n    {\n        iterator __i = __u.begin();\n        while (__u.size() != 0)\n        {\n            __table_.__insert_multi(\n                __u.__table_.remove((__i++).__i_)->__value_.__move());\n        }\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    else\n        __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_multimap&& __u)\n    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value)\n{\n    __table_ = _VSTD::move(__u.__table_);\n    return *this;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(\n        initializer_list<value_type> __il)\n{\n    __table_.__assign_multi(__il.begin(), __il.end());\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\ninline\nvoid\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,\n                                                            _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        __table_.__insert_multi(*__first);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n     unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n#if _LIBCPP_STD_VER > 17\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid erase_if(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __c, _Predicate __pred)\n{ __libcpp_erase_if_container(__c, __pred); }\n#endif\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nbool\noperator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    if (__x.size() != __y.size())\n        return false;\n    typedef typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator\n                                                                 const_iterator;\n    typedef pair<const_iterator, const_iterator> _EqRng;\n    for (const_iterator __i = __x.begin(), __ex = __x.end(); __i != __ex;)\n    {\n        _EqRng __xeq = __x.equal_range(__i->first);\n        _EqRng __yeq = __y.equal_range(__i->first);\n        if (_VSTD::distance(__xeq.first, __xeq.second) !=\n            _VSTD::distance(__yeq.first, __yeq.second) ||\n                  !_VSTD::is_permutation(__xeq.first, __xeq.second, __yeq.first))\n            return false;\n        __i = __xeq.second;\n    }\n    return true;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    return !(__x == __y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UNORDERED_MAP\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2019\n *\n *  @file ArgManager.hpp\n *  @brief A tool for sythesizing command-line arguments, URL query params, and config files.\n *  @note Status: BETA\n */\n\n#ifndef EMP_CONFIG_ARGMANAGER_HPP_INCLUDE\n#define EMP_CONFIG_ARGMANAGER_HPP_INCLUDE\n\n#include <algorithm>\n#include <cstdlib>\n#include <iterator>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <set>\n#include <string>\n#include <vector>\n\n#include \"../base/optional.hpp\"\n#include \"../base/Ptr.hpp\"\n#include \"../base/vector.hpp\"\n\n#include \"command_line.hpp\"\n#include \"config.hpp\"\n\nnamespace emp {\n\n  /// A helper struct for ArgManager that specifies a single argument type.\n  /// Note that the primary argument name is specified as the keys of the specs\n  /// map constructor argument for ArgManager.\n\n  struct ArgSpec {\n\n    /// Max words after flag to be used (enforced during parsing and on UseArg request)\n    size_t most_quota;\n\n    /// Minimum words after flag required (enforced during parsing and on UseArg request)\n    size_t least_quota;\n\n    /// User-level description of this flag.\n    std::string description;\n\n    /// Set of alternate flag names that will trigger this flag\n    std::unordered_set<std::string> aliases;\n\n    /// Function that can process this flag and its arguments.\n    std::function<void(emp::optional<emp::vector<std::string>>)> callback;\n\n    /// Should this flag collect subsequent flags (that begin with -) as arguments?\n    bool gobble_flags;\n\n    /// If this flag is used multiple times, should we combine all argument packs?\n    ///   (e.g., a single list of words instead of a list of lists of words).\n    bool flatten;\n\n    ArgSpec(\n      const size_t quota_=0,\n      const std::string description_=\"No description provided.\",\n      const std::unordered_set<std::string> aliases_=std::unordered_set<std::string>(),\n      const std::function<void(emp::optional<emp::vector<std::string>>)> callback_=nullptr,\n      const bool gobble_flags_=false,\n      const bool flatten_=false\n    ) : ArgSpec(\n          quota_,\n          quota_,\n          description_,\n          aliases_,\n          callback_,\n          gobble_flags_,\n          flatten_\n        )\n    { ; }\n\n    ArgSpec(\n      const size_t most_quota_,\n      const size_t least_quota_,\n      const std::string description_=\"No description provided.\",\n      const std::unordered_set<std::string> aliases_=std::unordered_set<std::string>(),\n      const std::function<void(emp::optional<emp::vector<std::string>>)> callback_=nullptr,\n      const bool gobble_flags_=false,\n      const bool flatten_=false\n    ) : most_quota(most_quota_),\n        least_quota(least_quota_),\n        description(description_),\n        aliases(aliases_),\n        callback(callback_),\n        gobble_flags(gobble_flags_),\n        flatten(flatten_)\n    { ; }\n\n  };\n\n  // compares member variables of lhs and rhs, ignoring callback functions\n  // useful for tests\n  bool operator==(const ArgSpec& lhs, const ArgSpec& rhs) {\n    return std::tuple{\n      lhs.most_quota,\n      lhs.least_quota,\n      lhs.description,\n      lhs.aliases,\n      lhs.gobble_flags,\n      lhs.flatten\n    } == std::tuple{\n      rhs.most_quota,\n      rhs.least_quota,\n      rhs.description,\n      rhs.aliases,\n      rhs.gobble_flags,\n      rhs.flatten\n    };\n  }\n\n  /// Manager for command line arguments and URL query params.\n  class ArgManager {\n\n  public:\n    using pack_t = emp::vector<std::string>;\n    using pack_map_t = std::multimap<std::string, pack_t>;\n    using spec_map_t = std::unordered_map<std::string, ArgSpec>;\n\n  private:\n    // the actual data collected\n    pack_map_t packs;\n\n    // the specification for how to collect and dispense the data\n    const spec_map_t specs;\n\n  public:\n    /// Convert input arguments to a vector of strings for easier processing.\n    static pack_t args_to_strings(int argc, char* argv[]) {\n      pack_t args;\n      for (size_t i = 0; i < (size_t) argc; i++) {\n        args.push_back(argv[i]);\n      }\n      return args;\n    }\n\n    /// Use argument specifications to convert command line arguments\n    /// to argument packs.\n    static pack_map_t parse(\n      pack_t args,\n      const spec_map_t & specs = spec_map_t()\n    ) {\n\n      auto res = pack_map_t();\n\n      const auto alias_map = std::accumulate(\n        std::begin(specs),\n        std::end(specs),\n        std::unordered_map<std::string, std::string>(),\n        [](\n          std::unordered_map<std::string, std::string> l,\n          const std::pair<std::string, ArgSpec> & r\n        ){\n          l.insert({r.first, r.first});\n          for(const auto & p : r.second.aliases) l.insert({p, r.first});\n          return l;\n        }\n      );\n\n      // check for duplicate aliases\n      emp_assert(alias_map.size() == std::accumulate(\n        std::begin(specs),\n        std::end(specs),\n        specs.size(),\n        [](const size_t l, const std::pair<std::string, ArgSpec> & r){\n          return l + r.second.aliases.size();\n        }\n      ), \"duplicate aliases detected\");\n\n      // lookup table with leading dashes stripped\n      // this is an immediately-invoked lambda\n      const pack_t deflagged = [&args](){\n        auto res = args;\n        for (size_t i = 0; i < args.size(); ++i) {\n\n          const size_t dash_stop = args[i].find_first_not_of('-');\n          if (dash_stop == 0) {\n            // nop\n          } else if (dash_stop < args[i].size()) {\n            res[i].erase(0, dash_stop); // remove initial dash\n          } else if (args[i].size() == 2) {\n            // in POSIX, -- means treat subsequent words as literals\n            // so we remove the -- and stop deflagging subsequent words\n            res.erase(std::next(std::begin(res),i));\n            args.erase(std::next(std::begin(args),i));\n            break;\n          }\n          // \" \", -, ---, ----, etc. left in place and treated as non-flags\n\n        }\n        return res;\n      }();\n\n      // If word is a valid command or alias for a command,\n      // return the deflagged, dealiased command...\n      // otherwise, it's a positional command.\n      // In this context, positional commands are options that take\n      // option-arguments\n      auto parse_alias = [deflagged, args, alias_map, specs](const size_t i) {\n        const std::string deflag = deflagged[i];\n\n        // the whole deflagged version is an alias\n        // and there were leading hyphens that WERE removed then, return that\n        if ( alias_map.count(deflag) && args[i] != deflag ) {\n          return pack_t{alias_map.find(deflag)->second};\n        }\n\n        pack_t commands;\n        // since it might be a concatenation of single-letter commands,\n        // we must go through it letter by letter\n        // try looking at each of the characters\n        for (const char ch : deflag) {\n          if (alias_map.count( std::string{ch} )) {\n\n            // check that the command does not take arguments\n            if (\n              specs.find(\n                alias_map.find(std::string{ch})->second\n              )->second.most_quota != 0\n            ) {\n              // put strung-together commands that take arguments\n              // into _invalid\n              return pack_t{\"_invalid\"};\n            };\n\n            commands.push_back(alias_map.find(\n              std::string{ch}\n            )->second);\n\n          } else {\n            // found a bad letter! abort and return positional or unknown\n            if (\n              alias_map.count(\"_positional\") && (\n                deflag == args[i]\n                || specs.find(\"_positional\")->second.gobble_flags\n              )\n            ){\n              return pack_t{\"_positional\"};\n            } else {\n              return pack_t{\"_unknown\"};\n            }\n          }\n        }\n\n        // found all good letters\n        return commands;\n      };\n\n      if (!args.size()) return res;\n      res.insert({\"_command\", {args[0]}});\n\n      for(size_t i = 1; i < args.size(); ++i) {\n\n        // there *could* be multiple commands contained\n        // if the user passed something a la tar -czvf\n        // so we loop through them one-by-one\n        const pack_t & commands = parse_alias(i);\n\n        for (const auto & command : commands) {\n\n          // if command is unknown\n          // and user hasn't provided an ArgSpec for unknown commands\n          if (command == \"_unknown\" && !specs.count(\"_unknown\")) {\n            res.insert({\n                \"_unknown\",\n                { args[i] }\n            });\n            continue;\n          }\n          // if command is unknown\n          // and user hasn't provided an ArgSpec for invalid commands\n          if (command == \"_invalid\" && !specs.count(\"_invalid\")) {\n            res.insert({\n                \"_invalid\",\n                { args[i] }\n            });\n            continue;\n          }\n\n          const ArgSpec & spec = specs.find(command)->second;\n\n          // fast forward to grab all the words for this argument pack\n          size_t j;\n          for (\n            j = i;\n            j < args.size()\n              && j - i < spec.most_quota\n              && (\n                spec.gobble_flags\n                || !( j+1 < args.size() )\n                || deflagged[j+1] == args[j+1]\n            );\n            ++j\n          );\n\n          // store the argument pack\n          res.insert({\n              command,\n              pack_t(\n                std::next(\n                  std::begin(args),\n                  command == \"_positional\"\n                    || command == \"_unknown\"\n                    || command == \"_invalid\"\n                  ? i : i+1\n                ),\n                j+1 < args.size() ? std::next(std::begin(args), j+1) : std::end(args)\n              )\n          });\n          i = j;\n\n        }\n\n      }\n\n      return res;\n\n    }\n\n    /// Make specs for builtin commands, including any config adjustment args.\n    static spec_map_t make_builtin_specs(\n      const emp::Ptr<Config> config=nullptr\n    ) {\n\n      spec_map_t res({\n        {\"_positional\", ArgSpec(\n          std::numeric_limits<size_t>::max(),\n          1,\n          \"Positional arguments.\",\n          {},\n          nullptr,\n          false,\n          true\n        )},\n        {\"_unknown\", ArgSpec(\n          std::numeric_limits<size_t>::max(),\n          1,\n          \"Unknown arguments.\",\n          {},\n          [](emp::optional<pack_t> res){\n            if (res) {\n              std::cerr << \"UNKNOWN | _unknown:\";\n              for(const auto & v : *res) std::cerr << \" \" << v;\n              std::cerr << std::endl;\n              std::exit(EXIT_FAILURE);\n            }\n          }\n        )},\n        {\"_command\", ArgSpec(\n          1,\n          1,\n          \"Command name.\",\n          {},\n          [](emp::optional<emp::vector<std::string>> /* res */ ){ /*no-op*/ }\n        )},\n        {\"help\", ArgSpec(0, \"Print help information.\", {\"h\"})},\n        {\"gen\", ArgSpec(\n          1,\n          \"Generate configuration file.\",\n          {},\n          [config](emp::optional<pack_t> res){\n            if (res && config) {\n              const std::string cfg_file = res->front();\n              std::cout << \"Generating new config file: \" << cfg_file << std::endl;\n              config->Write(cfg_file);\n            }\n          }\n        )}\n        // @CAO: Removing \"make-const\" as a default until we have it working properly.\n        //,\n        // {\"make-const\", ArgSpec(\n        //   1,\n        //   \"Generate const version of macros file.\",\n        //   {},\n        //   [config](emp::optional<pack_t> res){\n        //     if (res && config) {\n        //       const std::string macro_file = res->front();\n        //       std::cout << \"Generating new macros file: \" << macro_file << std::endl;\n        //       config->WriteMacros(macro_file, true);\n        //     }\n        //   }\n        // )}\n      });\n\n      if (config) {\n        for (const auto & e : *config) {\n          const auto & entry = e.second;\n          res.insert({\n            entry->GetName(),\n            ArgSpec(\n              1,\n              emp::to_string(\n                entry->GetDescription(),\n                \" (type=\", entry->GetType(),\n                \"; default=\", entry->GetDefault(), ')'\n              ),\n              {},\n              [config, entry](emp::optional<pack_t> res){\n                if (res && config) {\n                  config->Set(entry->GetName(), res->front());\n                }\n              }\n            )\n          });\n        }\n      }\n\n      return res;\n\n    }\n\n    /// Constructor for raw command line arguments.\n    /// This constructor is first in the constructor daisy chain.\n    ArgManager(\n      int argc,\n      char* argv[],\n      const spec_map_t & specs_ = make_builtin_specs()\n    ) : ArgManager(\n      ArgManager::args_to_strings(argc, argv),\n      specs_\n    ) { ; }\n\n    // Constructor for command line arguments converted to vector of string.\n    /// This constructor is second in the constructor daisy chain.\n    ArgManager(\n      const pack_t args,\n      const spec_map_t & specs_ = make_builtin_specs()\n    ) : ArgManager(\n      ArgManager::parse(args, DealiasSpecs(specs_)),\n      specs_\n    ) { ; }\n\n    /// Constructor that bypasses command line argument parsing where argument\n    /// packs are provided directly, e.g., for use with URL query params.\n    /// This constructor is last in the constructor daisy chain.\n    ArgManager(\n      const pack_map_t & packs_,\n      const spec_map_t & specs_ = make_builtin_specs()\n    ) : packs(packs_), specs(DealiasSpecs(specs_)) {\n\n      // Flatten any argument packs with `flatten` specified; move into packs.\n      for (auto & [n, s] : specs) {\n        if (s.flatten && packs.count(n)) {\n          pack_t flat = std::accumulate(\n            packs.equal_range(n).first,\n            packs.equal_range(n).second,\n            pack_t(),\n            [](\n              pack_t l,\n              const std::pair<std::string, pack_t> & r\n            ){\n              l.insert(std::end(l), std::begin(r.second), std::end(r.second));\n              return l;\n            }\n          );\n          packs.erase(packs.equal_range(n).first, packs.equal_range(n).second);\n          packs.insert({n, flat});\n        }\n      }\n    }\n\n    ~ArgManager() { ; }\n\n    /// Trigger the callback (if specified) for an argument,\n    /// consuming an argument pack if available and callback present.\n    /// If no argpack is available, the callback is triggered with nullopt.\n    /// Return true if an argument pack was consumed, otherwise false.\n    bool CallbackArg(const std::string & name) {\n\n      if (specs.count(name) && specs.find(name)->second.callback) {\n        const auto res = UseArg(name);\n        specs.find(name)->second.callback(res);\n        return (bool) res;\n      }\n\n      return false;\n\n    }\n\n    /// Trigger all arguments with callbacks until all pertinent argument\n    /// packs are consumed.\n    void UseCallbacks() {\n\n      for (const auto &[name, spec]: specs) {\n        while (CallbackArg(name));\n      }\n\n    }\n\n    /// UseArg consumes an argument pack accessed by a certain name.\n    emp::optional<pack_t> UseArg(const std::string & name) {\n\n      const auto res = [this, name]()\n        -> emp::optional<pack_t> {\n\n        if (!packs.count(name)) return std::nullopt;\n\n        const auto & pack = packs.lower_bound(name)->second;\n\n        if (specs.count(name)) {\n          const auto & spec = specs.find(name)->second;\n          return (\n            spec.least_quota <= pack.size() && pack.size() <= spec.most_quota\n          ) ? emp::make_optional(pack) : std::nullopt;\n        } else {\n          return emp::make_optional(pack);\n        }\n\n      }();\n\n      if (res) packs.erase(packs.lower_bound(name));\n\n      return res;\n\n    }\n\n    /// ViewArg provides, but doesn't comsume,\n    /// all argument packs under a certain name.\n    emp::vector<pack_t> ViewArg(const std::string & name) const {\n\n      emp::vector<pack_t> res;\n\n      const auto range = packs.equal_range(name);\n      for (auto it = range.first; it != range.second; ++it) {\n        res.push_back(it->second);\n      }\n\n      return res;\n\n    }\n\n    /// Process builtin commands.\n    /// Return bool for \"should program proceed\" (i.e., true=continue, false=exit).\n    bool ProcessBuiltin(\n      const emp::Ptr<Config> config=nullptr,\n      std::ostream & os=std::cout\n    ) {\n\n      UseArg(\"_command\");\n\n      if (UseArg(\"help\")) {\n        PrintHelp(os);\n        return false;\n      }\n\n      if (const auto res = ViewArg(\"_unknown\"); res.size()) {\n        PrintDiagnostic(os);\n        PrintHelp(os);\n        return false;\n      }\n\n      bool proceed = true;\n\n      // Apply config arguments to Config object.\n      if (config) {\n        for (auto e : *config) {\n          const auto entry = e.second;\n          if (const auto res = UseArg(entry->GetName()); res) {\n            config->Set(entry->GetName(), res->front());\n          }\n        }\n      }\n\n      if (const auto res = UseArg(\"gen\"); res && config) {\n        const std::string cfg_file = res->front();\n        os << \"Generating new config file: \" << cfg_file << std::endl;\n        config->Write(cfg_file);\n        proceed = false;\n      }\n\n      if (const auto res = UseArg(\"make-const\"); res && config)  {\n        const std::string macro_file = res->front();\n        os << \"Generating new macros file: \" << macro_file << std::endl;\n        config->WriteMacros(macro_file, true);\n        proceed = false;\n      }\n\n      return proceed;\n\n    }\n\n    /// Print the current state of the ArgManager;\n    /// provide diagnostic hints about argument packs remaining.\n    void PrintDiagnostic(std::ostream & os=std::cout) const {\n\n      for (const auto & [name, pack] : packs) {\n        if (name == \"_unknown\") {\n          os << \"UNKNOWN | \";\n        } else if (\n          specs.count(name)\n          && specs.find(name)->second.least_quota <= pack.size()\n          && specs.find(name)->second.most_quota >= pack.size()\n        ) {\n          os << \"UNMET QUOTA | \";\n        } else {\n          os << \"UNUSED | \";\n        }\n        os << name << \":\";\n        for (const auto & v : pack) {\n          os << \" \" << v;\n        }\n        os << std::endl;\n      }\n\n    }\n\n    /// Print information about all known argument types and what they're for;\n    /// make pretty.\n    void PrintHelp(std::ostream & os=std::cerr) const {\n\n      os << \"Usage:\" << std::endl;\n      // print arguments in alphabetical order\n      for (\n        const auto & [name, spec]\n        : std::map<std::string,ArgSpec>(std::begin(specs), std::end(specs))\n      ) {\n        if (name != \"_unknown\" && name != \"_positional\") os << \"-\";\n\n        os << name;\n\n        for (const auto & alias : spec.aliases) os << \" -\" << alias;\n\n        if (spec.least_quota == spec.most_quota) {\n          os << \" [ quota = \" << spec.most_quota << \" ]\";\n        } else {\n          os << \" [ \" << spec.least_quota << \" <= quota <= \"\n            << spec.most_quota << \" ]\";\n        }\n\n        os << std::endl\n          << \"   | \"\n          << spec.description\n          << std::endl;\n\n      }\n\n    }\n\n    // Argspecs with a string including flags separated by '|' are turned\n    // into one argspec with a list of aliases\n    // example input: specs[help|-h] = ArgSpec a with a.aliases = {}\n    // example output: specs[help] = ArgSpecs b with b.aliases = {-h}\n    static spec_map_t DealiasSpecs(spec_map_t inSpecsMap) {\n      spec_map_t outSpecs;\n\n      //convert each Argspec\n      for (auto iSpec : inSpecsMap) {\n        std::string flags = iSpec.first;\n        std::vector <std::string> aliases = slice(flags, '|');\n        std::string mainFlag = aliases[0];\n        aliases.erase(aliases.begin());\n\n        //set aliases\n        ArgSpec oSpec = iSpec.second;\n        for(auto iAlias : aliases) {\n          oSpec.aliases.insert(iAlias);\n        }\n\n        outSpecs.emplace(mainFlag, oSpec);\n      }\n\n      return outSpecs;\n    }\n\n\n    /// Test if there are any unused argument packs,\n    /// and if so, output an error message.\n    /// Returns true if there are any unused argument packs, false otherwise.\n    bool HasUnused(std::ostream & os=std::cerr) const {\n      if (packs.size()) {\n        PrintDiagnostic(os);\n        PrintHelp(os);\n        return true;\n      }\n      return false;\n    }\n\n  };\n\n  namespace cl {\n\n    /// A simple class to manage command-line arguments that were passed in.\n    /// Derived from emp::vector<std::string>, but with added functionality for argument handling.\n    class ArgManager : public emp::vector<std::string> {\n    private:\n      using parent_t = emp::vector<std::string>;\n      emp::vector<std::string> arg_names;\n      emp::vector<std::string> arg_descs;\n\n    public:\n      ArgManager() : parent_t(), arg_names(), arg_descs() { ; }\n      ArgManager(int argc, char* argv[])\n       : parent_t(args_to_strings(argc, argv)), arg_names(), arg_descs() { ; }\n      ~ArgManager() { ; }\n\n      /// UseArg takes a name, a variable and an optional description.  If the name exists,\n      /// it uses the next argument to change the value of the variable.\n      /// Return 1 if found, 0 if not found, and -1 if error (no value provided)\n      template <typename T>\n      int UseArg(const std::string & name, T & var, const std::string & desc=\"\") {\n        arg_names.push_back(name);\n        arg_descs.push_back(desc);\n        return use_arg_value(*this, name, var);\n      }\n\n      /// UseArg can also take a config object and a name, and use the argument to set the\n      /// config object.\n      int UseArg(const std::string & name, Config & config, const std::string & cfg_name,\n                 const std::string & desc=\"\") {\n        arg_names.push_back(name);\n        arg_descs.push_back(desc);\n        std::string var;\n        bool rv = use_arg_value(*this, name, var);\n        if (rv==1) config.Set(cfg_name, var);\n        return rv;\n      }\n\n      /// UseFlag takes a name and an optional description.  If the name exists, return true,\n      /// otherwise return false.\n      bool UseFlag(const std::string & name, const std::string & desc=\"\") {\n        arg_names.push_back(name);\n        arg_descs.push_back(desc);\n        return use_arg(*this, name);\n      }\n\n      /// Print information about all known argument types and what they're for; make pretty.\n      void PrintHelp(std::ostream & os) const {\n        size_t max_name_size = 0;\n        for (const auto & name : arg_names) {\n          if (max_name_size < name.size()) max_name_size = name.size();\n        }\n        for (size_t i = 0; i < arg_names.size(); i++) {\n          os << arg_names[i]\n             << std::string(max_name_size + 1 - arg_names[i].size(), ' ')\n             << arg_descs[i]\n             << std::endl;\n        }\n      }\n\n      /// Test if there are any unprocessed arguments, and if so, output an error.\n      bool HasUnknown(std::ostream & os=std::cerr) const {\n        if (size() > 1) {\n          os << \"Unknown args:\";\n          for (size_t i = 1; i < size(); i++) os << \" \" << (*this)[i];\n          os << std::endl;\n          PrintHelp(os);\n          return true;\n        }\n        return false;\n      }\n\n      /// Leaving TestUnknown for backward compatability; returns opposite of HasUnknown().\n      bool TestUnknown(std::ostream & os=std::cerr) const { return !HasUnknown(os); }\n\n      /// Convert settings from a configure object to command-line arguments.\n      /// Return bool for \"should program proceed\" (i.e., true=continue, false=exit).\n      bool ProcessConfigOptions(Config & config, std::ostream & os,\n                                const std::string & cfg_file=\"\",\n                                const std::string & macro_file=\"\")\n      {\n        // Scan through the config object to generate command line flags for each setting.\n        for (auto e : config) {\n          auto entry = e.second;\n          std::string desc = emp::to_string( entry->GetDescription(),\n                                             \" (type=\", entry->GetType(),\n                                             \"; default=\", entry->GetDefault(), ')' );\n          UseArg(to_string('-', entry->GetName()), config, entry->GetName(), desc);\n        }\n\n        // Determine if we're using any special options for comman line flags.\n        bool print_help    = UseFlag(\"--help\", \"Print help information.\");\n        bool create_config = cfg_file.size() && UseFlag(\"--gen\", \"Generate configuration file.\");\n        bool const_macros  = macro_file.size() && UseFlag(\"--make-const\", \"Generate const version of macros file.\");\n\n        if (print_help)    { PrintHelp(os); return false; }\n        if (create_config) {\n          os << \"Generating new config file: \" << cfg_file << std::endl;\n          config.Write(cfg_file);\n          return false;\n        }\n        if (const_macros)  {\n          os << \"Generating new macros file: \" << macro_file << std::endl;\n          config.WriteMacros(macro_file, true);\n          return false;\n        }\n\n        return true;\n      }\n\n    };\n\n\n  }\n}\n\n#endif // #ifndef EMP_CONFIG_ARGMANAGER_HPP_INCLUDE\n","// -*- C++ -*-\n//===------------------------ functional ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL\n#define _LIBCPP_FUNCTIONAL\n\n/*\n    functional synopsis\n\nnamespace std\n{\n\ntemplate <class Arg, class Result>\nstruct unary_function\n{\n    typedef Arg    argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\nstruct binary_function\n{\n    typedef Arg1   first_argument_type;\n    typedef Arg2   second_argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class T>\nclass reference_wrapper\n    : public unary_function<T1, R> // if wrapping a unary functor\n    : public binary_function<T1, T2, R> // if wraping a binary functor\n{\npublic:\n    // types\n    typedef T type;\n    typedef see below result_type; // Not always defined\n\n    // construct/copy/destroy\n    reference_wrapper(T&) noexcept;\n    reference_wrapper(T&&) = delete; // do not bind to temps\n    reference_wrapper(const reference_wrapper<T>& x) noexcept;\n\n    // assignment\n    reference_wrapper& operator=(const reference_wrapper<T>& x) noexcept;\n\n    // access\n    operator T& () const noexcept;\n    T& get() const noexcept;\n\n    // invoke\n    template <class... ArgTypes>\n      typename result_of<T&(ArgTypes&&...)>::type\n          operator() (ArgTypes&&...) const;\n};\n\ntemplate <class T> reference_wrapper<T> ref(T& t) noexcept;\ntemplate <class T> void ref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<T> ref(reference_wrapper<T>t) noexcept;\n\ntemplate <class T> reference_wrapper<const T> cref(const T& t) noexcept;\ntemplate <class T> void cref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;\n\ntemplate <class T> struct unwrap_reference;                                       // since C++20\ntemplate <class T> struct unwrap_ref_decay : unwrap_reference<decay_t<T>> { };    // since C++20\ntemplate <class T> using unwrap_reference_t = typename unwrap_reference<T>::type; // since C++20\ntemplate <class T> using unwrap_ref_decay_t = typename unwrap_ref_decay<T>::type; // since C++20\n\ntemplate <class T> // <class T=void> in C++14\nstruct plus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct minus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct multiplies : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct divides : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct modulus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct negate : unary_function<T, T>\n{\n    T operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct not_equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_and : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_or : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_not : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_and : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_or : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T=void> // C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class Predicate>\nclass unary_negate // deprecated in C++17\n    : public unary_function<typename Predicate::argument_type, bool>\n{\npublic:\n    explicit unary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::argument_type& x) const;\n};\n\ntemplate <class Predicate> // deprecated in C++17\nunary_negate<Predicate> not1(const Predicate& pred);\n\ntemplate <class Predicate>\nclass binary_negate // deprecated in C++17\n    : public binary_function<typename Predicate::first_argument_type,\n                             typename Predicate::second_argument_type,\n                             bool>\n{\npublic:\n    explicit binary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::first_argument_type& x,\n                    const typename Predicate::second_argument_type& y) const;\n};\n\ntemplate <class Predicate> // deprecated in C++17\nbinary_negate<Predicate> not2(const Predicate& pred);\n\ntemplate <class F> unspecified not_fn(F&& f); // C++17\n\ntemplate<class T> struct is_bind_expression;\ntemplate<class T> struct is_placeholder;\n\n    // See C++14 20.9.9, Function object binders\ntemplate <class T> inline constexpr bool is_bind_expression_v\n  = is_bind_expression<T>::value; // C++17\ntemplate <class T> inline constexpr int is_placeholder_v\n  = is_placeholder<T>::value; // C++17\n\n\ntemplate<class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\ntemplate<class R, class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\n\nnamespace placeholders {\n  // M is the implementation-defined number of placeholders\n  extern unspecified _1;\n  extern unspecified _2;\n  .\n  .\n  .\n  extern unspecified _Mp;\n}\n\ntemplate <class Operation>\nclass binder1st     // deprecated in C++11, removed in C++17\n    : public unary_function<typename Operation::second_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                               op;\n    typename Operation::first_argument_type value;\npublic:\n    binder1st(const Operation& x, const typename Operation::first_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::second_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::second_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder1st<Operation> bind1st(const Operation& op, const T& x);  // deprecated in C++11, removed in C++17\n\ntemplate <class Operation>\nclass binder2nd     // deprecated in C++11, removed in C++17\n    : public unary_function<typename Operation::first_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                                op;\n    typename Operation::second_argument_type value;\npublic:\n    binder2nd(const Operation& x, const typename Operation::second_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::first_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::first_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder2nd<Operation> bind2nd(const Operation& op, const T& x);  // deprecated in C++11, removed in C++17\n\ntemplate <class Arg, class Result>      // deprecated in C++11, removed in C++17\nclass pointer_to_unary_function : public unary_function<Arg, Result>\n{\npublic:\n    explicit pointer_to_unary_function(Result (*f)(Arg));\n    Result operator()(Arg x) const;\n};\n\ntemplate <class Arg, class Result>\npointer_to_unary_function<Arg,Result> ptr_fun(Result (*f)(Arg));      // deprecated in C++11, removed in C++17\n\ntemplate <class Arg1, class Arg2, class Result>      // deprecated in C++11, removed in C++17\nclass pointer_to_binary_function : public binary_function<Arg1, Arg2, Result>\n{\npublic:\n    explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));\n    Result operator()(Arg1 x, Arg2 y) const;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\npointer_to_binary_function<Arg1,Arg2,Result> ptr_fun(Result (*f)(Arg1,Arg2));      // deprecated in C++11, removed in C++17\n\ntemplate<class S, class T>      // deprecated in C++11, removed in C++17\nclass mem_fun_t : public unary_function<T*, S>\n{\npublic:\n    explicit mem_fun_t(S (T::*p)());\n    S operator()(T* p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_t : public binary_function<T*, A, S>      // deprecated in C++11, removed in C++17\n{\npublic:\n    explicit mem_fun1_t(S (T::*p)(A));\n    S operator()(T* p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_t<S,T>    mem_fun(S (T::*f)());      // deprecated in C++11, removed in C++17\ntemplate<class S, class T, class A> mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));     // deprecated in C++11, removed in C++17\n\ntemplate<class S, class T>\nclass mem_fun_ref_t : public unary_function<T, S>      // deprecated in C++11, removed in C++17\n{\npublic:\n    explicit mem_fun_ref_t(S (T::*p)());\n    S operator()(T& p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_ref_t : public binary_function<T, A, S>      // deprecated in C++11, removed in C++17\n{\npublic:\n    explicit mem_fun1_ref_t(S (T::*p)(A));\n    S operator()(T& p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)());      // deprecated in C++11, removed in C++17\ntemplate<class S, class T, class A> mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));     // deprecated in C++11, removed in C++17\n\ntemplate <class S, class T>\nclass const_mem_fun_t : public unary_function<const T*, S>      // deprecated in C++11, removed in C++17\n{\npublic:\n    explicit const_mem_fun_t(S (T::*p)() const);\n    S operator()(const T* p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_t : public binary_function<const T*, A, S>      // deprecated in C++11, removed in C++17\n{\npublic:\n    explicit const_mem_fun1_t(S (T::*p)(A) const);\n    S operator()(const T* p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_t<S,T>    mem_fun(S (T::*f)() const);      // deprecated in C++11, removed in C++17\ntemplate <class S, class T, class A> const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);     // deprecated in C++11, removed in C++17\n\ntemplate <class S, class T>\nclass const_mem_fun_ref_t : public unary_function<T, S>      // deprecated in C++11, removed in C++17\n{\npublic:\n    explicit const_mem_fun_ref_t(S (T::*p)() const);\n    S operator()(const T& p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_ref_t : public binary_function<T, A, S>      // deprecated in C++11, removed in C++17\n{\npublic:\n    explicit const_mem_fun1_ref_t(S (T::*p)(A) const);\n    S operator()(const T& p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)() const);   // deprecated in C++11, removed in C++17\ntemplate <class S, class T, class A> const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);  // deprecated in C++11, removed in C++17\n\ntemplate<class R, class T> unspecified mem_fn(R T::*);\n\nclass bad_function_call\n    : public exception\n{\n};\n\ntemplate<class> class function; // undefined\n\ntemplate<class R, class... ArgTypes>\nclass function<R(ArgTypes...)>\n  : public unary_function<T1, R>      // iff sizeof...(ArgTypes) == 1 and\n                                      // ArgTypes contains T1\n  : public binary_function<T1, T2, R> // iff sizeof...(ArgTypes) == 2 and\n                                      // ArgTypes contains T1 and T2\n{\npublic:\n    typedef R result_type;\n\n    // construct/copy/destroy:\n    function() noexcept;\n    function(nullptr_t) noexcept;\n    function(const function&);\n    function(function&&) noexcept;\n    template<class F>\n      function(F);\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&) noexcept;            // removed in C++17\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, nullptr_t) noexcept; // removed in C++17\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, const function&);    // removed in C++17\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, function&&);         // removed in C++17\n    template<class F, Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, F);                  // removed in C++17\n\n    function& operator=(const function&);\n    function& operator=(function&&) noexcept;\n    function& operator=(nullptr_t) noexcept;\n    template<class F>\n      function& operator=(F&&);\n    template<class F>\n      function& operator=(reference_wrapper<F>) noexcept;\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) noexcept;\n    template<class F, class Alloc>\n      void assign(F&&, const Alloc&);                 // Removed in C++17\n\n    // function capacity:\n    explicit operator bool() const noexcept;\n\n    // function invocation:\n    R operator()(ArgTypes...) const;\n\n    // function target access:\n    const std::type_info& target_type() const noexcept;\n    template <typename T>       T* target() noexcept;\n    template <typename T> const T* target() const noexcept;\n};\n\n// Null pointer comparisons:\ntemplate <class R, class ... ArgTypes>\n  bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class  R, class ... ArgTypes>\n  bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\n// specialized algorithms:\ntemplate <class  R, class ... ArgTypes>\n  void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class T> struct hash;\n\ntemplate <> struct hash<bool>;\ntemplate <> struct hash<char>;\ntemplate <> struct hash<signed char>;\ntemplate <> struct hash<unsigned char>;\ntemplate <> struct hash<char16_t>;\ntemplate <> struct hash<char32_t>;\ntemplate <> struct hash<wchar_t>;\ntemplate <> struct hash<short>;\ntemplate <> struct hash<unsigned short>;\ntemplate <> struct hash<int>;\ntemplate <> struct hash<unsigned int>;\ntemplate <> struct hash<long>;\ntemplate <> struct hash<long long>;\ntemplate <> struct hash<unsigned long>;\ntemplate <> struct hash<unsigned long long>;\n\ntemplate <> struct hash<float>;\ntemplate <> struct hash<double>;\ntemplate <> struct hash<long double>;\n\ntemplate<class T> struct hash<T*>;\ntemplate <> struct hash<nullptr_t>;  // C++17\n\n}  // std\n\nPOLICY:  For non-variadic implementations, the number of arguments is limited\n         to 3.  It is hoped that the need for non-variadic implementations\n         will be minimal.\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <memory>\n#include <tuple>\n#include <utility>\n#include <version>\n\n#include <__functional_base>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS plus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x + __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS plus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS minus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x - __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS minus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS multiplies : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x * __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS multiplies<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS divides : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x / __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS divides<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS modulus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x % __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS modulus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS negate : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return -__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS negate<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n    _NOEXCEPT_(noexcept(- _VSTD::forward<_Tp>(__x)))\n    -> decltype        (- _VSTD::forward<_Tp>(__x))\n        { return        - _VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x == __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS not_equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x != __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS not_equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS greater : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x > __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS greater<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n// less in <__functional_base>\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS greater_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x >= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS greater_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS less_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x <= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS less_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS logical_and : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x && __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS logical_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS logical_or : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x || __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS logical_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS logical_not : unary_function<_Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x) const\n        {return !__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS logical_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n    _NOEXCEPT_(noexcept(!_VSTD::forward<_Tp>(__x)))\n    -> decltype        (!_VSTD::forward<_Tp>(__x))\n        { return        !_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS bit_and : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x & __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS bit_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS bit_or : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x | __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS bit_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS bit_xor : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x ^ __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS bit_xor<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\nstruct _LIBCPP_TEMPLATE_VIS bit_not : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return ~__x;}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS bit_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n    _NOEXCEPT_(noexcept(~_VSTD::forward<_Tp>(__x)))\n    -> decltype        (~_VSTD::forward<_Tp>(__x))\n        { return        ~_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\ntemplate <class _Predicate>\nclass _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX17 unary_negate\n    : public unary_function<typename _Predicate::argument_type, bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    explicit unary_negate(const _Predicate& __pred)\n        : __pred_(__pred) {}\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::argument_type& __x) const\n        {return !__pred_(__x);}\n};\n\ntemplate <class _Predicate>\n_LIBCPP_DEPRECATED_IN_CXX17 inline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nunary_negate<_Predicate>\nnot1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}\n\ntemplate <class _Predicate>\nclass _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX17 binary_negate\n    : public binary_function<typename _Predicate::first_argument_type,\n                             typename _Predicate::second_argument_type,\n                             bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit _LIBCPP_CONSTEXPR_AFTER_CXX11\n    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::first_argument_type& __x,\n                    const typename _Predicate::second_argument_type& __y) const\n        {return !__pred_(__x, __y);}\n};\n\ntemplate <class _Predicate>\n_LIBCPP_DEPRECATED_IN_CXX17 inline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbinary_negate<_Predicate>\nnot2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_BINDERS)\ntemplate <class __Operation>\nclass _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 binder1st\n    : public unary_function<typename __Operation::second_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                               op;\n    typename __Operation::first_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY binder1st(const __Operation& __x,\n                               const typename __Operation::first_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n};\n\ntemplate <class __Operation, class _Tp>\n_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY\nbinder1st<__Operation>\nbind1st(const __Operation& __op, const _Tp& __x)\n    {return binder1st<__Operation>(__op, __x);}\n\ntemplate <class __Operation>\nclass _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 binder2nd\n    : public unary_function<typename __Operation::first_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                                op;\n    typename __Operation::second_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (      typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n};\n\ntemplate <class __Operation, class _Tp>\n_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY\nbinder2nd<__Operation>\nbind2nd(const __Operation& __op, const _Tp& __x)\n    {return binder2nd<__Operation>(__op, __x);}\n\ntemplate <class _Arg, class _Result>\nclass _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 pointer_to_unary_function\n    : public unary_function<_Arg, _Result>\n{\n    _Result (*__f_)(_Arg);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_unary_function(_Result (*__f)(_Arg))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg __x) const\n        {return __f_(__x);}\n};\n\ntemplate <class _Arg, class _Result>\n_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY\npointer_to_unary_function<_Arg,_Result>\nptr_fun(_Result (*__f)(_Arg))\n    {return pointer_to_unary_function<_Arg,_Result>(__f);}\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nclass _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 pointer_to_binary_function\n    : public binary_function<_Arg1, _Arg2, _Result>\n{\n    _Result (*__f_)(_Arg1, _Arg2);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg1 __x, _Arg2 __y) const\n        {return __f_(__x, __y);}\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\n_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY\npointer_to_binary_function<_Arg1,_Arg2,_Result>\nptr_fun(_Result (*__f)(_Arg1,_Arg2))\n    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 mem_fun_t\n    : public unary_function<_Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 mem_fun1_t\n    : public binary_function<_Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\n_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY\nmem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)())\n    {return mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\n_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 mem_fun_ref_t\n    : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_ref_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 mem_fun1_ref_t\n    : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\n_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY\nmem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)())\n    {return mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\n_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 const_mem_fun_t\n    : public unary_function<const _Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 const_mem_fun1_t\n    : public binary_function<const _Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\n_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\n_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 const_mem_fun_ref_t\n    : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 const_mem_fun1_ref_t\n    : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\n_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\n_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n#endif\n\n////////////////////////////////////////////////////////////////////////////////\n//                                MEMFUN\n//==============================================================================\n\ntemplate <class _Tp>\nclass __mem_fn\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type __f_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY __mem_fn(type __f) _NOEXCEPT : __f_(__f) {}\n\n#ifndef _LIBCPP_CXX03_LANG\n    // invoke\n    template <class... _ArgTypes>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return<type, _ArgTypes...>::type\n    operator() (_ArgTypes&&... __args) const {\n        return __invoke(__f_, _VSTD::forward<_ArgTypes>(__args)...);\n    }\n#else\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0>::type\n    operator() (_A0& __a0) const {\n        return __invoke(__f_, __a0);\n    }\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0 const>::type\n    operator() (_A0 const& __a0) const {\n        return __invoke(__f_, __a0);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1>::type\n    operator() (_A0& __a0, _A1& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1>::type\n    operator() (_A0 const& __a0, _A1& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1 const>::type\n    operator() (_A0& __a0, _A1 const& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2>::type\n    operator() (_A0& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2 const>::type\n    operator() (_A0& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2 const>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2 const>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n#endif\n};\n\ntemplate<class _Rp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__mem_fn<_Rp _Tp::*>\nmem_fn(_Rp _Tp::* __pm) _NOEXCEPT\n{\n    return __mem_fn<_Rp _Tp::*>(__pm);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//                                FUNCTION\n//==============================================================================\n\n// bad_function_call\n\nclass _LIBCPP_EXCEPTION_ABI bad_function_call\n    : public exception\n{\n#ifdef _LIBCPP_ABI_BAD_FUNCTION_CALL_KEY_FUNCTION\npublic:\n    virtual ~bad_function_call() _NOEXCEPT;\n\n    virtual const char* what() const _NOEXCEPT;\n#endif\n};\n\n_LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY\nvoid __throw_bad_function_call()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_function_call();\n#else\n    _VSTD::abort();\n#endif\n}\n\ntemplate<class _Fp> class _LIBCPP_TEMPLATE_VIS function; // undefined\n\nnamespace __function\n{\n\ntemplate<class _Rp>\nstruct __maybe_derive_from_unary_function\n{\n};\n\ntemplate<class _Rp, class _A1>\nstruct __maybe_derive_from_unary_function<_Rp(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate<class _Rp>\nstruct __maybe_derive_from_binary_function\n{\n};\n\ntemplate<class _Rp, class _A1, class _A2>\nstruct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Fp>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(_Fp const&) { return true; }\n\ntemplate <class _Fp>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(_Fp* __ptr) { return __ptr; }\n\ntemplate <class _Ret, class _Class>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(_Ret _Class::*__ptr) { return __ptr; }\n\ntemplate <class _Fp>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(function<_Fp> const& __f) { return !!__f; }\n\n} // namespace __function\n\n#ifndef _LIBCPP_CXX03_LANG\n\nnamespace __function {\n\n// __alloc_func holds a functor and an allocator.\n\ntemplate <class _Fp, class _Ap, class _FB> class __alloc_func;\n\ntemplate <class _Fp, class _Ap, class _Rp, class... _ArgTypes>\nclass __alloc_func<_Fp, _Ap, _Rp(_ArgTypes...)>\n{\n    __compressed_pair<_Fp, _Ap> __f_;\n\n  public:\n    typedef _Fp _Target;\n    typedef _Ap _Alloc;\n\n    _LIBCPP_INLINE_VISIBILITY\n    const _Target& __target() const { return __f_.first(); }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const _Alloc& __allocator() const { return __f_.second(); }\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __alloc_func(_Target&& __f)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n               _VSTD::forward_as_tuple())\n    {\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __alloc_func(const _Target& __f, const _Alloc& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n               _VSTD::forward_as_tuple(__a))\n    {\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __alloc_func(const _Target& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n               _VSTD::forward_as_tuple(_VSTD::move(__a)))\n    {\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __alloc_func(_Target&& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n               _VSTD::forward_as_tuple(_VSTD::move(__a)))\n    {\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    _Rp operator()(_ArgTypes&&... __arg)\n    {\n        typedef __invoke_void_return_wrapper<_Rp> _Invoker;\n        return _Invoker::__call(__f_.first(),\n                                _VSTD::forward<_ArgTypes>(__arg)...);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __alloc_func* __clone() const\n    {\n        typedef allocator_traits<_Alloc> __alloc_traits;\n        typedef\n            typename __rebind_alloc_helper<__alloc_traits, __alloc_func>::type\n                _AA;\n        _AA __a(__f_.second());\n        typedef __allocator_destructor<_AA> _Dp;\n        unique_ptr<__alloc_func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n        ::new ((void*)__hold.get()) __alloc_func(__f_.first(), _Alloc(__a));\n        return __hold.release();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void destroy() _NOEXCEPT { __f_.~__compressed_pair<_Target, _Alloc>(); }\n};\n\n// __base provides an abstract interface for copyable functors.\n\ntemplate<class _Fp> class __base;\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass __base<_Rp(_ArgTypes...)>\n{\n    __base(const __base&);\n    __base& operator=(const __base&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY __base() {}\n    _LIBCPP_INLINE_VISIBILITY virtual ~__base() {}\n    virtual __base* __clone() const = 0;\n    virtual void __clone(__base*) const = 0;\n    virtual void destroy() _NOEXCEPT = 0;\n    virtual void destroy_deallocate() _NOEXCEPT = 0;\n    virtual _Rp operator()(_ArgTypes&& ...) = 0;\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT = 0;\n    virtual const std::type_info& target_type() const _NOEXCEPT = 0;\n#endif  // _LIBCPP_NO_RTTI\n};\n\n// __func implements __base for a given functor type.\n\ntemplate<class _FD, class _Alloc, class _FB> class __func;\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nclass __func<_Fp, _Alloc, _Rp(_ArgTypes...)>\n    : public  __base<_Rp(_ArgTypes...)>\n{\n    __alloc_func<_Fp, _Alloc, _Rp(_ArgTypes...)> __f_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f)\n        : __f_(_VSTD::move(__f)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, const _Alloc& __a)\n        : __f_(__f, __a) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, _Alloc&& __a)\n        : __f_(__f, _VSTD::move(__a)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f, _Alloc&& __a)\n        : __f_(_VSTD::move(__f), _VSTD::move(__a)) {}\n\n    virtual __base<_Rp(_ArgTypes...)>* __clone() const;\n    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;\n    virtual void destroy() _NOEXCEPT;\n    virtual void destroy_deallocate() _NOEXCEPT;\n    virtual _Rp operator()(_ArgTypes&&... __arg);\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT;\n    virtual const std::type_info& target_type() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n__base<_Rp(_ArgTypes...)>*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\n    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;\n    _Ap __a(__f_.__allocator());\n    typedef __allocator_destructor<_Ap> _Dp;\n    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n    ::new ((void*)__hold.get()) __func(__f_.__target(), _Alloc(__a));\n    return __hold.release();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p) const\n{\n    ::new (__p) __func(__f_.__target(), __f_.__allocator());\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() _NOEXCEPT\n{\n    __f_.destroy();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() _NOEXCEPT\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\n    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;\n    _Ap __a(__f_.__allocator());\n    __f_.destroy();\n    __a.deallocate(this, 1);\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n_Rp\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)\n{\n    return __f_(_VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst void*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target(const type_info& __ti) const _NOEXCEPT\n{\n    if (__ti == typeid(_Fp))\n        return &__f_.__target();\n    return (const void*)0;\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst std::type_info&\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    return typeid(_Fp);\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\n// __value_func creates a value-type from a __func.\n\ntemplate <class _Fp> class __value_func;\n\ntemplate <class _Rp, class... _ArgTypes> class __value_func<_Rp(_ArgTypes...)>\n{\n    typename aligned_storage<3 * sizeof(void*)>::type __buf_;\n\n    typedef __base<_Rp(_ArgTypes...)> __func;\n    __func* __f_;\n\n    _LIBCPP_NO_CFI static __func* __as_base(void* p)\n    {\n        return reinterpret_cast<__func*>(p);\n    }\n\n  public:\n    _LIBCPP_INLINE_VISIBILITY\n    __value_func() _NOEXCEPT : __f_(0) {}\n\n    template <class _Fp, class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY __value_func(_Fp&& __f, const _Alloc __a)\n        : __f_(0)\n    {\n        typedef allocator_traits<_Alloc> __alloc_traits;\n        typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _Fun;\n        typedef typename __rebind_alloc_helper<__alloc_traits, _Fun>::type\n            _FunAlloc;\n\n        if (__function::__not_null(__f))\n        {\n            _FunAlloc __af(__a);\n            if (sizeof(_Fun) <= sizeof(__buf_) &&\n                is_nothrow_copy_constructible<_Fp>::value &&\n                is_nothrow_copy_constructible<_FunAlloc>::value)\n            {\n                __f_ =\n                    ::new ((void*)&__buf_) _Fun(_VSTD::move(__f), _Alloc(__af));\n            }\n            else\n            {\n                typedef __allocator_destructor<_FunAlloc> _Dp;\n                unique_ptr<__func, _Dp> __hold(__af.allocate(1), _Dp(__af, 1));\n                ::new ((void*)__hold.get()) _Fun(_VSTD::move(__f), _Alloc(__a));\n                __f_ = __hold.release();\n            }\n        }\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_func(const __value_func& __f)\n    {\n        if (__f.__f_ == 0)\n            __f_ = 0;\n        else if ((void*)__f.__f_ == &__f.__buf_)\n        {\n            __f_ = __as_base(&__buf_);\n            __f.__f_->__clone(__f_);\n        }\n        else\n            __f_ = __f.__f_->__clone();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_func(__value_func&& __f) _NOEXCEPT\n    {\n        if (__f.__f_ == 0)\n            __f_ = 0;\n        else if ((void*)__f.__f_ == &__f.__buf_)\n        {\n            __f_ = __as_base(&__buf_);\n            __f.__f_->__clone(__f_);\n        }\n        else\n        {\n            __f_ = __f.__f_;\n            __f.__f_ = 0;\n        }\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__value_func()\n    {\n        if ((void*)__f_ == &__buf_)\n            __f_->destroy();\n        else if (__f_)\n            __f_->destroy_deallocate();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_func& operator=(__value_func&& __f)\n    {\n        *this = nullptr;\n        if (__f.__f_ == 0)\n            __f_ = 0;\n        else if ((void*)__f.__f_ == &__f.__buf_)\n        {\n            __f_ = __as_base(&__buf_);\n            __f.__f_->__clone(__f_);\n        }\n        else\n        {\n            __f_ = __f.__f_;\n            __f.__f_ = 0;\n        }\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_func& operator=(nullptr_t)\n    {\n        __func* __f = __f_;\n        __f_ = 0;\n        if ((void*)__f == &__buf_)\n            __f->destroy();\n        else if (__f)\n            __f->destroy_deallocate();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    _Rp operator()(_ArgTypes&&... __args) const\n    {\n        if (__f_ == 0)\n            __throw_bad_function_call();\n        return (*__f_)(_VSTD::forward<_ArgTypes>(__args)...);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(__value_func& __f) _NOEXCEPT\n    {\n        if (&__f == this)\n            return;\n        if ((void*)__f_ == &__buf_ && (void*)__f.__f_ == &__f.__buf_)\n        {\n            typename aligned_storage<sizeof(__buf_)>::type __tempbuf;\n            __func* __t = __as_base(&__tempbuf);\n            __f_->__clone(__t);\n            __f_->destroy();\n            __f_ = 0;\n            __f.__f_->__clone(__as_base(&__buf_));\n            __f.__f_->destroy();\n            __f.__f_ = 0;\n            __f_ = __as_base(&__buf_);\n            __t->__clone(__as_base(&__f.__buf_));\n            __t->destroy();\n            __f.__f_ = __as_base(&__f.__buf_);\n        }\n        else if ((void*)__f_ == &__buf_)\n        {\n            __f_->__clone(__as_base(&__f.__buf_));\n            __f_->destroy();\n            __f_ = __f.__f_;\n            __f.__f_ = __as_base(&__f.__buf_);\n        }\n        else if ((void*)__f.__f_ == &__f.__buf_)\n        {\n            __f.__f_->__clone(__as_base(&__buf_));\n            __f.__f_->destroy();\n            __f.__f_ = __f_;\n            __f_ = __as_base(&__buf_);\n        }\n        else\n            _VSTD::swap(__f_, __f.__f_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT { return __f_ != 0; }\n\n#ifndef _LIBCPP_NO_RTTI\n    _LIBCPP_INLINE_VISIBILITY\n    const std::type_info& target_type() const _NOEXCEPT\n    {\n        if (__f_ == 0)\n            return typeid(void);\n        return __f_->target_type();\n    }\n\n    template <typename _Tp>\n    _LIBCPP_INLINE_VISIBILITY const _Tp* target() const _NOEXCEPT\n    {\n        if (__f_ == 0)\n            return 0;\n        return (const _Tp*)__f_->target(typeid(_Tp));\n    }\n#endif // _LIBCPP_NO_RTTI\n};\n\n// Storage for a functor object, to be used with __policy to manage copy and\n// destruction.\nunion __policy_storage\n{\n    mutable char __small[sizeof(void*) * 2];\n    void* __large;\n};\n\n// True if _Fun can safely be held in __policy_storage.__small.\ntemplate <typename _Fun>\nstruct __use_small_storage\n    : public _VSTD::integral_constant<\n          bool, sizeof(_Fun) <= sizeof(__policy_storage) &&\n                    _LIBCPP_ALIGNOF(_Fun) <= _LIBCPP_ALIGNOF(__policy_storage) &&\n                    _VSTD::is_trivially_copy_constructible<_Fun>::value &&\n                    _VSTD::is_trivially_destructible<_Fun>::value> {};\n\n// Policy contains information about how to copy, destroy, and move the\n// underlying functor. You can think of it as a vtable of sorts.\nstruct __policy\n{\n    // Used to copy or destroy __large values. null for trivial objects.\n    void* (*const __clone)(const void*);\n    void (*const __destroy)(void*);\n\n    // True if this is the null policy (no value).\n    const bool __is_null;\n\n    // The target type. May be null if RTTI is disabled.\n    const std::type_info* const __type_info;\n\n    // Returns a pointer to a static policy object suitable for the functor\n    // type.\n    template <typename _Fun>\n    _LIBCPP_INLINE_VISIBILITY static const __policy* __create()\n    {\n        return __choose_policy<_Fun>(__use_small_storage<_Fun>());\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static const __policy* __create_empty()\n    {\n        static const _LIBCPP_CONSTEXPR __policy __policy_ = {nullptr, nullptr,\n                                                             true,\n#ifndef _LIBCPP_NO_RTTI\n                                                             &typeid(void)\n#else\n                                                             nullptr\n#endif\n        };\n        return &__policy_;\n    }\n\n  private:\n    template <typename _Fun> static void* __large_clone(const void* __s)\n    {\n        const _Fun* __f = static_cast<const _Fun*>(__s);\n        return __f->__clone();\n    }\n\n    template <typename _Fun> static void __large_destroy(void* __s)\n    {\n        typedef allocator_traits<typename _Fun::_Alloc> __alloc_traits;\n        typedef typename __rebind_alloc_helper<__alloc_traits, _Fun>::type\n            _FunAlloc;\n        _Fun* __f = static_cast<_Fun*>(__s);\n        _FunAlloc __a(__f->__allocator());\n        __f->destroy();\n        __a.deallocate(__f, 1);\n    }\n\n    template <typename _Fun>\n    _LIBCPP_INLINE_VISIBILITY static const __policy*\n        __choose_policy(/* is_small = */ false_type)\n    {\n        static const _LIBCPP_CONSTEXPR __policy __policy_ = {\n            &__large_clone<_Fun>, &__large_destroy<_Fun>, false,\n#ifndef _LIBCPP_NO_RTTI\n            &typeid(typename _Fun::_Target)\n#else\n            nullptr\n#endif\n        };\n        return &__policy_;\n    }\n\n    template <typename _Fun>\n    _LIBCPP_INLINE_VISIBILITY static const __policy*\n        __choose_policy(/* is_small = */ true_type)\n    {\n        static const _LIBCPP_CONSTEXPR __policy __policy_ = {\n            nullptr, nullptr, false,\n#ifndef _LIBCPP_NO_RTTI\n            &typeid(typename _Fun::_Target)\n#else\n            nullptr\n#endif\n        };\n        return &__policy_;\n    }\n};\n\n// Used to choose between perfect forwarding or pass-by-value. Pass-by-value is\n// faster for types that can be passed in registers.\ntemplate <typename _Tp>\nusing __fast_forward =\n    typename _VSTD::conditional<_VSTD::is_scalar<_Tp>::value, _Tp, _Tp&&>::type;\n\n// __policy_invoker calls an instance of __alloc_func held in __policy_storage.\n\ntemplate <class _Fp> struct __policy_invoker;\n\ntemplate <class _Rp, class... _ArgTypes>\nstruct __policy_invoker<_Rp(_ArgTypes...)>\n{\n    typedef _Rp (*__Call)(const __policy_storage*,\n                          __fast_forward<_ArgTypes>...);\n\n    __Call __call_;\n\n    // Creates an invoker that throws bad_function_call.\n    _LIBCPP_INLINE_VISIBILITY\n    __policy_invoker() : __call_(&__call_empty) {}\n\n    // Creates an invoker that calls the given instance of __func.\n    template <typename _Fun>\n    _LIBCPP_INLINE_VISIBILITY static __policy_invoker __create()\n    {\n        return __policy_invoker(&__call_impl<_Fun>);\n    }\n\n  private:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __policy_invoker(__Call __c) : __call_(__c) {}\n\n    static _Rp __call_empty(const __policy_storage*,\n                            __fast_forward<_ArgTypes>...)\n    {\n        __throw_bad_function_call();\n    }\n\n    template <typename _Fun>\n    static _Rp __call_impl(const __policy_storage* __buf,\n                           __fast_forward<_ArgTypes>... __args)\n    {\n        _Fun* __f = reinterpret_cast<_Fun*>(__use_small_storage<_Fun>::value\n                                                ? &__buf->__small\n                                                : __buf->__large);\n        return (*__f)(_VSTD::forward<_ArgTypes>(__args)...);\n    }\n};\n\n// __policy_func uses a __policy and __policy_invoker to create a type-erased,\n// copyable functor.\n\ntemplate <class _Fp> class __policy_func;\n\ntemplate <class _Rp, class... _ArgTypes> class __policy_func<_Rp(_ArgTypes...)>\n{\n    // Inline storage for small objects.\n    __policy_storage __buf_;\n\n    // Calls the value stored in __buf_. This could technically be part of\n    // policy, but storing it here eliminates a level of indirection inside\n    // operator().\n    typedef __function::__policy_invoker<_Rp(_ArgTypes...)> __invoker;\n    __invoker __invoker_;\n\n    // The policy that describes how to move / copy / destroy __buf_. Never\n    // null, even if the function is empty.\n    const __policy* __policy_;\n\n  public:\n    _LIBCPP_INLINE_VISIBILITY\n    __policy_func() : __policy_(__policy::__create_empty()) {}\n\n    template <class _Fp, class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY __policy_func(_Fp&& __f, const _Alloc& __a)\n        : __policy_(__policy::__create_empty())\n    {\n        typedef __alloc_func<_Fp, _Alloc, _Rp(_ArgTypes...)> _Fun;\n        typedef allocator_traits<_Alloc> __alloc_traits;\n        typedef typename __rebind_alloc_helper<__alloc_traits, _Fun>::type\n            _FunAlloc;\n\n        if (__function::__not_null(__f))\n        {\n            __invoker_ = __invoker::template __create<_Fun>();\n            __policy_ = __policy::__create<_Fun>();\n\n            _FunAlloc __af(__a);\n            if (__use_small_storage<_Fun>())\n            {\n                ::new ((void*)&__buf_.__small)\n                    _Fun(_VSTD::move(__f), _Alloc(__af));\n            }\n            else\n            {\n                typedef __allocator_destructor<_FunAlloc> _Dp;\n                unique_ptr<_Fun, _Dp> __hold(__af.allocate(1), _Dp(__af, 1));\n                ::new ((void*)__hold.get())\n                    _Fun(_VSTD::move(__f), _Alloc(__af));\n                __buf_.__large = __hold.release();\n            }\n        }\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __policy_func(const __policy_func& __f)\n        : __buf_(__f.__buf_), __invoker_(__f.__invoker_),\n          __policy_(__f.__policy_)\n    {\n        if (__policy_->__clone)\n            __buf_.__large = __policy_->__clone(__f.__buf_.__large);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __policy_func(__policy_func&& __f)\n        : __buf_(__f.__buf_), __invoker_(__f.__invoker_),\n          __policy_(__f.__policy_)\n    {\n        if (__policy_->__destroy)\n        {\n            __f.__policy_ = __policy::__create_empty();\n            __f.__invoker_ = __invoker();\n        }\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__policy_func()\n    {\n        if (__policy_->__destroy)\n            __policy_->__destroy(__buf_.__large);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __policy_func& operator=(__policy_func&& __f)\n    {\n        *this = nullptr;\n        __buf_ = __f.__buf_;\n        __invoker_ = __f.__invoker_;\n        __policy_ = __f.__policy_;\n        __f.__policy_ = __policy::__create_empty();\n        __f.__invoker_ = __invoker();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __policy_func& operator=(nullptr_t)\n    {\n        const __policy* __p = __policy_;\n        __policy_ = __policy::__create_empty();\n        __invoker_ = __invoker();\n        if (__p->__destroy)\n            __p->__destroy(__buf_.__large);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    _Rp operator()(_ArgTypes&&... __args) const\n    {\n        return __invoker_.__call_(_VSTD::addressof(__buf_),\n                                  _VSTD::forward<_ArgTypes>(__args)...);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(__policy_func& __f)\n    {\n        _VSTD::swap(__invoker_, __f.__invoker_);\n        _VSTD::swap(__policy_, __f.__policy_);\n        _VSTD::swap(__buf_, __f.__buf_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit operator bool() const _NOEXCEPT\n    {\n        return !__policy_->__is_null;\n    }\n\n#ifndef _LIBCPP_NO_RTTI\n    _LIBCPP_INLINE_VISIBILITY\n    const std::type_info& target_type() const _NOEXCEPT\n    {\n        return *__policy_->__type_info;\n    }\n\n    template <typename _Tp>\n    _LIBCPP_INLINE_VISIBILITY const _Tp* target() const _NOEXCEPT\n    {\n        if (__policy_->__is_null || typeid(_Tp) != *__policy_->__type_info)\n            return nullptr;\n        if (__policy_->__clone) // Out of line storage.\n            return reinterpret_cast<const _Tp*>(__buf_.__large);\n        else\n            return reinterpret_cast<const _Tp*>(&__buf_.__small);\n    }\n#endif // _LIBCPP_NO_RTTI\n};\n\n}  // __function\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass _LIBCPP_TEMPLATE_VIS function<_Rp(_ArgTypes...)>\n    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,\n      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>\n{\n#ifndef _LIBCPP_ABI_OPTIMIZED_FUNCTION\n    typedef __function::__value_func<_Rp(_ArgTypes...)> __func;\n#else\n    typedef __function::__policy_func<_Rp(_ArgTypes...)> __func;\n#endif\n\n    __func __f_;\n\n    template <class _Fp, bool = __lazy_and<\n        integral_constant<bool, !is_same<__uncvref_t<_Fp>, function>::value>,\n        __invokable<_Fp&, _ArgTypes...>\n    >::value>\n    struct __callable;\n    template <class _Fp>\n        struct __callable<_Fp, true>\n        {\n            static const bool value = is_same<void, _Rp>::value ||\n                is_convertible<typename __invoke_of<_Fp&, _ArgTypes...>::type,\n                               _Rp>::value;\n        };\n    template <class _Fp>\n        struct __callable<_Fp, false>\n        {\n            static const bool value = false;\n        };\n\n  template <class _Fp>\n  using _EnableIfCallable = typename enable_if<__callable<_Fp>::value>::type;\npublic:\n    typedef _Rp result_type;\n\n    // construct/copy/destroy:\n    _LIBCPP_INLINE_VISIBILITY\n    function() _NOEXCEPT { }\n    _LIBCPP_INLINE_VISIBILITY\n    function(nullptr_t) _NOEXCEPT {}\n    function(const function&);\n    function(function&&) _NOEXCEPT;\n    template<class _Fp, class = _EnableIfCallable<_Fp>>\n    function(_Fp);\n\n#if _LIBCPP_STD_VER <= 14\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&) _NOEXCEPT {}\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&, nullptr_t) _NOEXCEPT {}\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, const function&);\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, function&&);\n    template<class _Fp, class _Alloc, class = _EnableIfCallable<_Fp>>\n      function(allocator_arg_t, const _Alloc& __a, _Fp __f);\n#endif\n\n    function& operator=(const function&);\n    function& operator=(function&&) _NOEXCEPT;\n    function& operator=(nullptr_t) _NOEXCEPT;\n    template<class _Fp, class = _EnableIfCallable<_Fp>>\n    function& operator=(_Fp&&);\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) _NOEXCEPT;\n\n#if _LIBCPP_STD_VER <= 14\n    template<class _Fp, class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      void assign(_Fp&& __f, const _Alloc& __a)\n        {function(allocator_arg, __a, _VSTD::forward<_Fp>(__f)).swap(*this);}\n#endif\n\n    // function capacity:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {\n      return static_cast<bool>(__f_);\n    }\n\n    // deleted overloads close possible hole in the type system\n    template<class _R2, class... _ArgTypes2>\n      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;\n    template<class _R2, class... _ArgTypes2>\n      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;\npublic:\n    // function invocation:\n    _Rp operator()(_ArgTypes...) const;\n\n#ifndef _LIBCPP_NO_RTTI\n    // function target access:\n    const std::type_info& target_type() const _NOEXCEPT;\n    template <typename _Tp> _Tp* target() _NOEXCEPT;\n    template <typename _Tp> const _Tp* target() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(const function& __f) : __f_(__f.__f_) {}\n\n#if _LIBCPP_STD_VER <= 14\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                     const function& __f) : __f_(__f.__f_) {}\n#endif\n\ntemplate <class _Rp, class... _ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(function&& __f) _NOEXCEPT\n    : __f_(_VSTD::move(__f.__f_)) {}\n\n#if _LIBCPP_STD_VER <= 14\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                      function&& __f)\n    : __f_(_VSTD::move(__f.__f_)) {}\n#endif\n\ntemplate <class _Rp, class... _ArgTypes>\ntemplate <class _Fp, class>\nfunction<_Rp(_ArgTypes...)>::function(_Fp __f)\n    : __f_(_VSTD::move(__f), allocator<_Fp>()) {}\n\n#if _LIBCPP_STD_VER <= 14\ntemplate <class _Rp, class... _ArgTypes>\ntemplate <class _Fp, class _Alloc, class>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc& __a,\n                                      _Fp __f)\n    : __f_(_VSTD::move(__f), __a) {}\n#endif\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(const function& __f)\n{\n    function(__f).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(function&& __f) _NOEXCEPT\n{\n    __f_ = std::move(__f.__f_);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(nullptr_t) _NOEXCEPT\n{\n    __f_ = nullptr;\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp, class>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)\n{\n    function(_VSTD::forward<_Fp>(__f)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::~function() {}\n\ntemplate<class _Rp, class ..._ArgTypes>\nvoid\nfunction<_Rp(_ArgTypes...)>::swap(function& __f) _NOEXCEPT\n{\n    __f_.swap(__f.__f_);\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\n_Rp\nfunction<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const\n{\n    return __f_(_VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Rp, class ..._ArgTypes>\nconst std::type_info&\nfunction<_Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    return __f_.target_type();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\n_Tp*\nfunction<_Rp(_ArgTypes...)>::target() _NOEXCEPT\n{\n    return (_Tp*)(__f_.template target<_Tp>());\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\nconst _Tp*\nfunction<_Rp(_ArgTypes...)>::target() const _NOEXCEPT\n{\n    return __f_.template target<_Tp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) _NOEXCEPT\n{return __x.swap(__y);}\n\n#else // _LIBCPP_CXX03_LANG\n\n#include <__functional_03>\n\n#endif\n\n////////////////////////////////////////////////////////////////////////////////\n//                                  BIND\n//==============================================================================\n\ntemplate<class _Tp> struct __is_bind_expression : public false_type {};\ntemplate<class _Tp> struct _LIBCPP_TEMPLATE_VIS is_bind_expression\n    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR constexpr size_t is_bind_expression_v = is_bind_expression<_Tp>::value;\n#endif\n\ntemplate<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};\ntemplate<class _Tp> struct _LIBCPP_TEMPLATE_VIS is_placeholder\n    : public __is_placeholder<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR constexpr size_t is_placeholder_v = is_placeholder<_Tp>::value;\n#endif\n\nnamespace placeholders\n{\n\ntemplate <int _Np> struct __ph {};\n\n#if defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_LIBRARY)\n_LIBCPP_FUNC_VIS extern const __ph<1>   _1;\n_LIBCPP_FUNC_VIS extern const __ph<2>   _2;\n_LIBCPP_FUNC_VIS extern const __ph<3>   _3;\n_LIBCPP_FUNC_VIS extern const __ph<4>   _4;\n_LIBCPP_FUNC_VIS extern const __ph<5>   _5;\n_LIBCPP_FUNC_VIS extern const __ph<6>   _6;\n_LIBCPP_FUNC_VIS extern const __ph<7>   _7;\n_LIBCPP_FUNC_VIS extern const __ph<8>   _8;\n_LIBCPP_FUNC_VIS extern const __ph<9>   _9;\n_LIBCPP_FUNC_VIS extern const __ph<10> _10;\n#else\n/* _LIBCPP_INLINE_VAR */ constexpr __ph<1>   _1{};\n/* _LIBCPP_INLINE_VAR */ constexpr __ph<2>   _2{};\n/* _LIBCPP_INLINE_VAR */ constexpr __ph<3>   _3{};\n/* _LIBCPP_INLINE_VAR */ constexpr __ph<4>   _4{};\n/* _LIBCPP_INLINE_VAR */ constexpr __ph<5>   _5{};\n/* _LIBCPP_INLINE_VAR */ constexpr __ph<6>   _6{};\n/* _LIBCPP_INLINE_VAR */ constexpr __ph<7>   _7{};\n/* _LIBCPP_INLINE_VAR */ constexpr __ph<8>   _8{};\n/* _LIBCPP_INLINE_VAR */ constexpr __ph<9>   _9{};\n/* _LIBCPP_INLINE_VAR */ constexpr __ph<10> _10{};\n#endif // defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_LIBRARY)\n\n}  // placeholders\n\ntemplate<int _Np>\nstruct __is_placeholder<placeholders::__ph<_Np> >\n    : public integral_constant<int, _Np> {};\n\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\n__mu(reference_wrapper<_Tp> __t, _Uj&)\n{\n    return __t.get();\n}\n\ntemplate <class _Ti, class ..._Uj, size_t ..._Indx>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __invoke_of<_Ti&, _Uj...>::type\n__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)\n{\n    return __ti(_VSTD::forward<_Uj>(_VSTD::get<_Indx>(__uj))...);\n}\n\ntemplate <class _Ti, class ..._Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __lazy_enable_if\n<\n    is_bind_expression<_Ti>::value,\n    __invoke_of<_Ti&, _Uj...>\n>::type\n__mu(_Ti& __ti, tuple<_Uj...>& __uj)\n{\n    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;\n    return  __mu_expand(__ti, __uj, __indices());\n}\n\ntemplate <bool IsPh, class _Ti, class _Uj>\nstruct __mu_return2 {};\n\ntemplate <class _Ti, class _Uj>\nstruct __mu_return2<true, _Ti, _Uj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;\n};\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    0 < is_placeholder<_Ti>::value,\n    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type\n>::type\n__mu(_Ti&, _Uj& __uj)\n{\n    const size_t _Indx = is_placeholder<_Ti>::value - 1;\n    return _VSTD::forward<typename tuple_element<_Indx, _Uj>::type>(_VSTD::get<_Indx>(__uj));\n}\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_bind_expression<_Ti>::value &&\n    is_placeholder<_Ti>::value == 0 &&\n    !__is_reference_wrapper<_Ti>::value,\n    _Ti&\n>::type\n__mu(_Ti& __ti, _Uj&)\n{\n    return __ti;\n}\n\ntemplate <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,\n          class _TupleUj>\nstruct __mu_return_impl;\n\ntemplate <bool _Invokable, class _Ti, class ..._Uj>\nstruct __mu_return_invokable  // false\n{\n    typedef __nat type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct __mu_return_invokable<true, _Ti, _Uj...>\n{\n    typedef typename __invoke_of<_Ti&, _Uj...>::type type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct __mu_return_impl<_Ti, false, true, false, tuple<_Uj...> >\n    : public __mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>\n{\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct __mu_return_impl<_Ti, false, false, true, _TupleUj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,\n                                   _TupleUj>::type&& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct __mu_return_impl<_Ti, true, false, false, _TupleUj>\n{\n    typedef typename _Ti::type& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct __mu_return_impl<_Ti, false, false, false, _TupleUj>\n{\n    typedef _Ti& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct __mu_return\n    : public __mu_return_impl<_Ti,\n                              __is_reference_wrapper<_Ti>::value,\n                              is_bind_expression<_Ti>::value,\n                              0 < is_placeholder<_Ti>::value &&\n                              is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,\n                              _TupleUj>\n{\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj>\nstruct __is_valid_bind_return\n{\n    static const bool value = false;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj,\n          bool = __is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>\nstruct __bind_return;\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            const _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __bind_return<_Fp, _BoundArgs, _Args>::type\n__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,\n                _Args&& __args)\n{\n    return _VSTD::__invoke(__f, _VSTD::__mu(_VSTD::get<_Indx>(__bound_args), __args)...);\n}\n\ntemplate<class _Fp, class ..._BoundArgs>\nclass __bind\n    : public __weak_result_type<typename decay<_Fp>::type>\n{\nprotected:\n    typedef typename decay<_Fp>::type _Fd;\n    typedef tuple<typename decay<_BoundArgs>::type...> _Td;\nprivate:\n    _Fd __f_;\n    _Td __bound_args_;\n\n    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;\npublic:\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)\n        : __f_(_VSTD::forward<_Gp>(__f)),\n          __bound_args_(_VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args)\n        {\n            return _VSTD::__apply_functor(__f_, __bound_args_, __indices(),\n                                  tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args) const\n        {\n            return _VSTD::__apply_functor(__f_, __bound_args_, __indices(),\n                                   tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n};\n\ntemplate<class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nclass __bind_r\n    : public __bind<_Fp, _BoundArgs...>\n{\n    typedef __bind<_Fp, _BoundArgs...> base;\n    typedef typename base::_Fd _Fd;\n    typedef typename base::_Td _Td;\npublic:\n    typedef _Rp result_type;\n\n\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind_r>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)\n        : base(_VSTD::forward<_Gp>(__f),\n               _VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,\n                           result_type>::value || is_void<_Rp>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args)\n        {\n            typedef __invoke_void_return_wrapper<_Rp> _Invoker;\n            return _Invoker::__call(static_cast<base&>(*this), _VSTD::forward<_Args>(__args)...);\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,\n                           result_type>::value || is_void<_Rp>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args) const\n        {\n            typedef __invoke_void_return_wrapper<_Rp> _Invoker;\n            return _Invoker::__call(static_cast<base const&>(*this), _VSTD::forward<_Args>(__args)...);\n        }\n};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind<_Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind<_Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind_r<_Rp, _Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Fn, class ..._Args>\nresult_of_t<_Fn&&(_Args&&...)>\ninvoke(_Fn&& __f, _Args&&... __args)\n    noexcept(noexcept(_VSTD::__invoke(_VSTD::forward<_Fn>(__f), _VSTD::forward<_Args>(__args)...)))\n{\n    return _VSTD::__invoke(_VSTD::forward<_Fn>(__f), _VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _DecayFunc>\nclass _LIBCPP_TEMPLATE_VIS __not_fn_imp {\n  _DecayFunc __fd;\n\npublic:\n    __not_fn_imp() = delete;\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Args&& ...__args) &\n            noexcept(noexcept(!_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...)))\n        -> decltype(          !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...))\n        { return              !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...); }\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Args&& ...__args) &&\n            noexcept(noexcept(!_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...)))\n        -> decltype(          !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...))\n        { return              !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...); }\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Args&& ...__args) const&\n            noexcept(noexcept(!_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...)))\n        -> decltype(          !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...))\n        { return              !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...); }\n\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Args&& ...__args) const&&\n            noexcept(noexcept(!_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...)))\n        -> decltype(          !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...))\n        { return              !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...); }\n\nprivate:\n    template <class _RawFunc,\n              class = enable_if_t<!is_same<decay_t<_RawFunc>, __not_fn_imp>::value>>\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __not_fn_imp(_RawFunc&& __rf)\n        : __fd(_VSTD::forward<_RawFunc>(__rf)) {}\n\n    template <class _RawFunc>\n    friend inline _LIBCPP_INLINE_VISIBILITY\n    __not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&&);\n};\n\ntemplate <class _RawFunc>\ninline _LIBCPP_INLINE_VISIBILITY\n__not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&& __fn) {\n    return __not_fn_imp<decay_t<_RawFunc>>(_VSTD::forward<_RawFunc>(__fn));\n}\n\n#endif\n\n// struct hash<T*> in <memory>\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\npair<_ForwardIterator1, _ForwardIterator1> _LIBCPP_CONSTEXPR_AFTER_CXX11\n__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n         forward_iterator_tag, forward_iterator_tag)\n{\n    if (__first2 == __last2)\n        return make_pair(__first1, __first1);  // Everything matches an empty sequence\n    while (true)\n    {\n        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __last1)  // return __last1 if no element matches *__first2\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)\n                return make_pair(__first1, __m1);\n            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found\n                return make_pair(__last1, __last1);\n            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_RandomAccessIterator1, _RandomAccessIterator1>\n__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n         _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;\n    typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    const _D2 __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return make_pair(__first1, __first1);\n    const _D1 __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return make_pair(__last1, __last1);\n    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here\n\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __s)\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n\n        _RandomAccessIterator1 __m1 = __first1;\n        _RandomAccessIterator2 __m2 = __first2;\n         while (true)\n         {\n             if (++__m2 == __last2)\n                 return make_pair(__first1, __first1 + __len2);\n             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source\n             if (!__pred(*__m1, *__m2))\n             {\n                 ++__first1;\n                 break;\n             }\n         }\n    }\n}\n\n#if _LIBCPP_STD_VER > 14\n\n// default searcher\ntemplate<class _ForwardIterator, class _BinaryPredicate = equal_to<>>\nclass _LIBCPP_TYPE_VIS default_searcher {\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    default_searcher(_ForwardIterator __f, _ForwardIterator __l,\n                       _BinaryPredicate __p = _BinaryPredicate())\n        : __first_(__f), __last_(__l), __pred_(__p) {}\n\n    template <typename _ForwardIterator2>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<_ForwardIterator2, _ForwardIterator2>\n    operator () (_ForwardIterator2 __f, _ForwardIterator2 __l) const\n    {\n        return _VSTD::__search(__f, __l, __first_, __last_, __pred_,\n            typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category(),\n            typename _VSTD::iterator_traits<_ForwardIterator2>::iterator_category());\n    }\n\nprivate:\n    _ForwardIterator __first_;\n    _ForwardIterator __last_;\n    _BinaryPredicate __pred_;\n    };\n\n#endif // _LIBCPP_STD_VER > 14\n\n#if _LIBCPP_STD_VER > 17\ntemplate <class _Tp>\nusing unwrap_reference_t = typename unwrap_reference<_Tp>::type;\n\ntemplate <class _Tp>\nusing unwrap_ref_decay_t = typename unwrap_ref_decay<_Tp>::type;\n#endif // > C++17\n\ntemplate <class _Container, class _Predicate>\ninline void __libcpp_erase_if_container( _Container& __c, _Predicate __pred)\n{\n\tfor (typename _Container::iterator __iter = __c.begin(), __last = __c.end(); __iter != __last;)\n\t{\n\t\tif (__pred(*__iter))\n\t\t\t__iter = __c.erase(__iter);\n\t\telse\n\t\t\t++__iter;\n\t}\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2016-2017\n *\n *  @file DynamicString.hpp\n *  @brief A string handler where sections update dynamically based on functions.\n *  @note Status: BETA\n */\n\n#ifndef EMP_DATASTRUCTS_DYNAMICSTRING_HPP_INCLUDE\n#define EMP_DATASTRUCTS_DYNAMICSTRING_HPP_INCLUDE\n\n\n#include <functional>\n#include <string>\n\n#include \"../base/vector.hpp\"\n\nnamespace emp {\n\n  /// A string handler where some sections can be fixed strings, while others update\n  /// dynamically based on functions.\n  class DynamicString {\n  public:\n    using value_t = std::function<std::string()>;\n  private:\n    emp::vector<value_t> fun_set;  // Functions to update strings.\n\n  public:\n    DynamicString() { ; }\n    DynamicString(const DynamicString &) = default;\n\n    /// How many string components (funcations or continuous substrings) are in this DynamicString?\n    size_t GetSize() const { return fun_set.size(); }\n\n    /// Index in to a specific component (not a specific character, since size is variable)\n    /// and return it's associated string.\n    std::string operator[](size_t id) const { return fun_set[id](); }\n\n    /// Index in to a specific component (not a specific character, since size is variable)\n    /// and return it's associated function.\n    const value_t & GetFunction(size_t id) const { return fun_set[id]; }\n\n    /// Remove all contents on this DynamicString\n    DynamicString & Clear() { fun_set.clear(); return *this; }\n\n    /// Convert to an std::string.\n    std::string str() {\n      std::stringstream ss;\n      for (auto & cur_fun : fun_set) ss << cur_fun();\n      return ss.str();\n    }\n\n    /// Set the value of a specified component to the provided function.\n    DynamicString & Set(size_t id, const value_t & in_fun) {\n      fun_set[id] = in_fun;\n      return *this;\n    }\n\n    /// Set the value of a specified component to the provided std::string text.\n    DynamicString & Set(size_t id, const std::string & in_text) {\n      return Set( id, [in_text](){ return in_text; } );\n    }\n\n    /// Add a new function to the end of the DynamicString.\n    DynamicString & Append(const value_t & in_fun) {\n      fun_set.push_back(in_fun);\n      return *this;\n    }\n\n    /// Add new std::string text to the end of the DynamicString.\n    // (automatically create a function that just returns that string.)\n    DynamicString & Append(const std::string & in_text) {\n      return Append( [in_text](){ return in_text; } );\n    }\n\n    /// Allow operator<< to append to the back of a DynamicString.\n    template <typename IN_TYPE>\n    DynamicString & operator<<(IN_TYPE && _in) { return Append(_in); }\n\n  };\n\n}\n\nnamespace std {\n  /// Make sure that DynamicString works with with std::ostream.\n  std::ostream & operator<<( std::ostream & os, const emp::DynamicString & strings )\n  {\n    for (size_t i = 0; i < strings.GetSize(); ++i) {\n      os << strings[i];\n    }\n    return os;\n  }\n}\n\n#endif // #ifndef EMP_DATASTRUCTS_DYNAMICSTRING_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2018\n *\n *  @file Text.hpp\n *  @brief Specs for the Text widget.\n *\n *  A representation of text on a web page.  Text Widgets can be included inside of Divs or\n *  Tables to cordon off a section of text (and will be automatically created when text is\n *  streamed into these other widgets).  The primary benefit of explicitly creating your\n *  own text widget is to control the text style.\n */\n\n#ifndef EMP_WEB_TEXT_HPP_INCLUDE\n#define EMP_WEB_TEXT_HPP_INCLUDE\n\n#include \"../datastructs/DynamicString.hpp\"\n\n#include \"Widget.hpp\"\n\nnamespace emp {\nnamespace web {\n\n  /// A Text widget handles putting text on a web page that can be controlled and modified.\n\n  class Text : public internal::WidgetFacet<Text> {\n    friend class TextInfo;\n  protected:\n\n    class TextInfo : public internal::WidgetInfo {\n      friend Text;\n    protected:\n      DynamicString strings;    ///< All string (and functions returning strings) in Text widget.\n      bool append_ok;           ///< Can this Text widget be extended?\n\n      TextInfo(const std::string & in_id=\"\") : internal::WidgetInfo(in_id), append_ok(true) { ; }\n      TextInfo(const TextInfo &) = delete;               // No copies of INFO allowed\n      TextInfo & operator=(const TextInfo &) = delete;   // No copies of INFO allowed\n      virtual ~TextInfo() { ; }\n\n      std::string GetTypeName() const override { return \"TextInfo\"; }\n\n      bool AppendOK() const override { return append_ok; }\n      void PreventAppend() override { append_ok = false; }\n\n      Widget Append(const std::string & in_text) override;\n      Widget Append(const std::function<std::string()> & in_fun) override;\n\n      // All derived widgets must suply a mechanism for providing associated HTML code.\n      virtual void GetHTML(std::stringstream & HTML) override {\n        HTML.str(\"\");                         // Clear the current text.\n        HTML << \"<span id=\\'\" << id << \"'>\"   // Initial span tag to keep id.\n             << strings                       // Save the current value of all of the strings.\n             << \"</span>\";                    // Close span tag.\n      }\n\n    public:\n      virtual std::string GetType() override { return \"web::TextInfo\"; }\n    };  // End of TextInfo\n\n\n    // Get a properly cast version of indo.\n    TextInfo * Info() { return (TextInfo *) info; }\n    const TextInfo * Info() const { return (TextInfo *) info; }\n\n    Text(TextInfo * in_info) : WidgetFacet(in_info) { ; }\n  public:\n    Text(const std::string & in_id=\"\") : WidgetFacet(in_id) {\n      // When a name is provided, create an associated Widget info.\n      info = new TextInfo(in_id);\n    }\n    Text(const Text & in) : WidgetFacet(in) { ; }\n    Text(const Widget & in) : WidgetFacet(in) { emp_assert(in.IsText()); }\n    ~Text() { ; }\n\n    using INFO_TYPE = TextInfo;\n\n    /// How many text items are contained?\n    size_t GetSize() const { return Info()->strings.GetSize(); }\n\n    /// Erase current text.\n    Text & Clear() { Info()->strings.Clear(); return *this; }\n  };\n\n  /// Add new text to this string.\n  Widget Text::TextInfo::Append(const std::string & text) {\n    if (!append_ok) return ForwardAppend(text);  // If text widget cannot append, forward to parent.\n    strings.Append(text);                        // Record the new string being added.\n    if (state == Widget::ACTIVE) ReplaceHTML();  // If node is active, immediately redraw!\n    return web::Text(this);\n  }\n\n  /// Add a function that produces text to this widget.  Every time the widget is re-drawn, the\n  /// function will be re-run to get the latest version of the text.  When a Live() function\n  /// wraps a variable it simply makes sure that this version of Append is called so that the\n  /// value of the variable is kept live.\n  Widget Text::TextInfo::Append(const std::function<std::string()> & fun) {\n    if (!append_ok) return ForwardAppend(fun);   // If text widget cannot append, forward to parent.\n    strings.Append(fun);                         // Record the new function being added.\n    if (state == Widget::ACTIVE) ReplaceHTML();  // If node is active, immediately redraw!\n    return web::Text(this);\n  }\n\n}\n}\n\n#endif // #ifndef EMP_WEB_TEXT_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2018\n *\n *  @file Style.hpp\n *  @brief A CSS class for tracking font style, etc.\n */\n\n#ifndef EMP_WEB_STYLE_HPP_INCLUDE\n#define EMP_WEB_STYLE_HPP_INCLUDE\n\n\n\n#ifdef __EMSCRIPTEN__\n#include <emscripten.h>\n#endif\n\n#include \"../tools/string_utils.hpp\"\n\n#include <map>\n#include <set>\n#include <string>\n\nnamespace emp {\nnamespace web {\n\n  ///  Class to maintain a map of setting names to values that can be easily ported\n  ///  over to JavaScript.  A companial class, Attributes, also exists.\n  class Style {\n  private:\n    std::map<std::string, std::string> settings;  ///< CSS Setting values being tracked.\n    std::set<std::string> classes;  ///< CSS classes\n\n  public:\n    Style() { ; }\n    Style(const Style &) = default;\n    Style(Style &&) = default;\n    Style & operator=(const Style &) = default;\n    Style & operator=(Style &&) = default;\n\n    /// Return a count of the number of settings that have been set.\n    size_t GetSize() const { return settings.size(); }\n    /// Return a count of the number of classes that have been added.\n    size_t GetNClasses() const { return classes.size(); }\n\n   Style & AddClass(const std::string & in_clss) {\n      classes.insert(in_clss);\n      return *this;\n    }\n\n\n    Style & DoSet(const std::string & in_set, const std::string & in_val) {\n      settings[in_set] = in_val;\n      return *this;\n    }\n\n    /// Record that setting \"s\" is set to value \"v\" (converted to string) and return this object.\n    template <typename SET_TYPE>\n    Style & Set(const std::string & s, SET_TYPE v) {\n      return DoSet(s, emp::to_string(v));\n    }\n\n    /// Set all values from in_css here as well.  Return this object.\n    Style & Insert(const Style & in_css) {\n      settings.insert(in_css.settings.begin(), in_css.settings.end());\n      return *this;\n    }\n\n    /// Return true/false based on whether \"setting\" has been given a value in this Style.\n    bool Has(const std::string & setting) const {\n      return settings.find(setting) != settings.end();\n    }\n\n    /// Return the (string) value of \"setting\" that has been recorded in this Style.\n    const std::string & Get(const std::string & setting) const {\n      auto it = settings.find(setting);\n      return (it == settings.end()) ? emp::empty_string() : it->second;\n    }\n\n    const std::map<std::string, std::string> & GetMap() const {\n      return settings;\n    }\n\n    const std::set<std::string> & GetClasses() const {\n      return classes;\n    }\n\n\n    /// Remove all setting values and all classes.\n    void Clear() { settings.clear(); classes.clear(); }\n\n    /// Remove a specific setting value.\n    void Remove(const std::string & setting) {\n      settings.erase(setting);\n    }\n\n    /// Remove a specific class\n    void RemoveClass(const std::string & clss) {\n      classes.erase(clss);\n    }\n\n    /// Apply ALL of the style settings to a specified widget.\n    void Apply(const std::string & widget_id) {\n\n      // Stop immediately if nothing to set.\n      if (settings.size() == 0 && classes.size() == 0) return;\n\n      // Find the current object only once.\n#ifdef __EMSCRIPTEN__\n      MAIN_THREAD_EM_ASM({\n          var id = UTF8ToString($0);\n          emp_i.cur_obj = $( '#' + id );\n        }, widget_id.c_str());\n#endif\n\n      for (auto css_pair : settings) {\n        if (css_pair.second == \"\") continue; // Ignore empty entries.\n#ifdef __EMSCRIPTEN__\n        MAIN_THREAD_EM_ASM({\n            var name = UTF8ToString($0);\n            var value = UTF8ToString($1);\n            emp_i.cur_obj.css( name, value);\n          }, css_pair.first.c_str(), css_pair.second.c_str());\n#else\n        std::cout << \"Setting '\" << widget_id << \"' attribute '\" << css_pair.first\n                  << \"' to '\" << css_pair.second << \"'.\";\n#endif\n      }\n\n      for (std::string class_ : classes) {\n\n#ifdef EMSCRIPTEN\n        EM_ASM_ARGS({\n            var name = UTF8ToString($0);\n            emp_i.cur_obj.addClass( name );\n          }, class_.c_str());\n#else\n        std::cout << \"Adding class to '\" << widget_id << \"': '\" << class_;\n#endif\n\n      }\n\n    }\n\n    /// Apply only a SPECIFIC style setting from the setting library.\n    void Apply(const std::string & widget_id, const std::string & setting) {\n      emp_assert(Has(setting));\n\n#ifdef __EMSCRIPTEN__\n      MAIN_THREAD_EM_ASM({\n          var id = UTF8ToString($0);\n          var setting = UTF8ToString($1);\n          var value = UTF8ToString($2);\n          $( '#' + id ).css( setting, value);\n        }, widget_id.c_str(), setting.c_str(), settings[setting].c_str());\n#else\n      std::cout << \"Setting '\" << widget_id << \"' attribute '\" << setting\n                << \"' to '\" << settings[setting] << \"'.\";\n#endif\n    }\n\n    /// Apply onlay a SPECIFIC style setting with a specifid value!\n    static void Apply(const std::string & widget_id, const std::string & setting,\n                      const std::string & value) {\n#ifdef __EMSCRIPTEN__\n      MAIN_THREAD_EM_ASM({\n          var id = UTF8ToString($0);\n          var setting = UTF8ToString($1);\n          var value = UTF8ToString($2);\n          $( '#' + id ).css( setting, value);\n        }, widget_id.c_str(), setting.c_str(), value.c_str());\n#else\n      std::cout << \"Setting '\" << widget_id << \"' attribute '\" << setting\n                << \"' to '\" << value << \"'.\";\n#endif\n    }\n\n    static void ApplyClass(const std::string & widget_id, const std::string & clss){\n\n#ifdef EMSCRIPTEN\n      EM_ASM_ARGS({\n          var id = UTF8ToString($0);\n          var name = UTF8ToString($1);\n          $( '#' + id ).addClass( name);\n        }, widget_id.c_str(), clss.c_str());\n#else\n      std::cout << \"Adding class to '\" << widget_id << \"': '\" << clss;\n#endif\n    }\n\n    static void ApplyRemoveClass(const std::string & widget_id, const std::string & clss){\n#ifdef EMSCRIPTEN\n      EM_ASM_ARGS({\n          var id = UTF8ToString($0);\n          var name = UTF8ToString($1);\n          $( '#' + id ).removeClass( name);\n        }, widget_id.c_str(), clss.c_str());\n#else\n      std::cout << \"Adding class to '\" << widget_id << \"': '\" << clss;\n#endif\n    }\n\n    /// Have any settings be set?\n    operator bool() const { return (bool) settings.size(); }\n  };\n\n\n}\n}\n\n\n#endif // #ifndef EMP_WEB_STYLE_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2018\n *\n *  @file JSWrap.hpp\n *  @brief Wrap a C++ function and convert it to an integer that can be called from Javascript\n *\n *  To wrap a function, call:\n *\n *     `uint32_t fun_id = emp::JSWrap(FunctionToBeWrapped, \"JS_Function_Name\");``\n *\n *  To manually callback a function from Javascript, first set `emp_i.cb_args` to an array of\n *  function arguments, then call `empCppCallback( fun_id );`   This all happens automatically\n *  if you use the `emp.Callback(fun_id, args...)` function from Javascript.\n *\n *  The JS_Function_Name string is optional, but if you use it, the appropriate function will\n *  be automatically generated in Javascript by JSWrap, in the emp class.\n *\n *  For example, if you have:\n *\n *     `int AddPair(int x, int y) { return x + y; }``\n *\n *  You can wrap it with:\n *\n *     `size_t fun_id = emp::JSWrap(AddPair, \"AddPair\");`\n *\n *  And then in Javascript, you can simply call it as:\n *\n *     `emp.AddPair(4, 5); // will return 9.`\n *\n *\n *  @todo Add a JSWrap that takes an object and method and does the bind automatically.\n *  @todo Build a non-enscripten version; it should still be callable from the C++ side, but\n *        mostly to be able to test programs without Emscripten.\n *\n */\n\n#ifndef EMP_WEB_JSWRAP_HPP_INCLUDE\n#define EMP_WEB_JSWRAP_HPP_INCLUDE\n\n#include <array>\n#include <functional>\n#include <tuple>\n#include <type_traits>\n\n#include \"../base/assert.hpp\"\n#include \"../base/vector.hpp\"\n#include \"../datastructs/tuple_struct.hpp\"\n#include \"../datastructs/tuple_utils.hpp\"\n#include \"../debug/mem_track.hpp\"\n#include \"../meta/meta.hpp\"\n\n#include \"init.hpp\"\n#include \"js_utils.hpp\"\n\n#ifndef DOXYGEN_SHOULD_SKIP_THIS\n#ifdef __EMSCRIPTEN__\nextern \"C\" {\n  extern int EMP_GetCBArgCount();  // Get the number of arguments associated with a callback.\n}\n#else\n// When NOT in Emscripten, need a stub for this function.\nint EMP_GetCBArgCount() { return -1; }\n#endif // EMSCRIPTEN\n#endif // DOXYGEN_SHOULD_SKIP_THIS\n\nnamespace emp {\n\n  #ifndef DOXYGEN_SHOULD_SKIP_THIS\n\n  template <typename JSON_TYPE, int ARG_ID, int FIELD>\n  struct LoadTuple;\n\n  /// This needs to go before LoadTuple is defined, in case there are nested tuple structs\n  template <int ARG_ID, typename T> static\n  void LoadArg(T & arg_var) {\n    if constexpr ( is_introspective_tuple<T>() ) {\n      using JSON_TYPE = T;\n      //std::cout << \"Loading ARGNID: \" << ARG_ID << std::endl;\n      MAIN_THREAD_EM_ASM({\n        emp_i.object_queue = [];\n        emp_i.curr_obj = emp_i.cb_args[$0];\n      }, ARG_ID);\n      LoadTuple<JSON_TYPE, ARG_ID, JSON_TYPE::n_fields> load_tuple = LoadTuple<JSON_TYPE, ARG_ID, JSON_TYPE::n_fields>();\n      load_tuple.LoadJSDataArg(arg_var);\n    }\n    else {\n      arg_var = (T) MAIN_THREAD_EM_ASM_DOUBLE({ return emp_i.cb_args[$0]; }, ARG_ID);\n    }\n  }\n\n  template <int ARG_ID> static void LoadArg(std::string & arg_var) {\n    char * tmp_var = (char *) MAIN_THREAD_EM_ASM_INT({\n        return allocate(intArrayFromString(emp_i.cb_args[$0]), 'i8', ALLOC_STACK);\n      }, ARG_ID);\n    arg_var = tmp_var;   // @CAO Do we need to free the memory in tmp_var?\n  }\n\n  template <int ARG_ID, size_t SIZE, typename T> static void LoadArg(emp::array<T, SIZE> & arg_var){\n    MAIN_THREAD_EM_ASM({emp_i.__outgoing_array = emp_i.cb_args[$0];}, ARG_ID);\n    pass_array_to_cpp(arg_var);\n  }\n\n  template <int ARG_ID, typename T> static void LoadArg(emp::vector<T> & arg_var){\n    MAIN_THREAD_EM_ASM({emp_i.__outgoing_array = emp_i.cb_args[$0];}, ARG_ID);\n    pass_vector_to_cpp(arg_var);\n  }\n\n  //Helper functions to load arguments from inside Javascript objects by name.\n  template <int ARG_ID> static void LoadArg(int16_t & arg_var, std::string var) {\n    arg_var = (int16_t) MAIN_THREAD_EM_ASM_INT({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(int32_t & arg_var, std::string var) {\n    arg_var = (int32_t) MAIN_THREAD_EM_ASM_INT({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(int64_t & arg_var, std::string var) {\n    arg_var = (int64_t) MAIN_THREAD_EM_ASM_DOUBLE({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(uint16_t & arg_var, std::string var) {\n    arg_var = (uint16_t) MAIN_THREAD_EM_ASM_INT({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(uint32_t & arg_var, std::string var) {\n    arg_var = (uint32_t) MAIN_THREAD_EM_ASM_INT({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(uint64_t & arg_var, std::string var) {\n    arg_var = (uint64_t) MAIN_THREAD_EM_ASM_DOUBLE({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(bool & arg_var, std::string var) {\n    arg_var = (bool) MAIN_THREAD_EM_ASM_INT({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(char & arg_var, std::string var) {\n    arg_var = (char) MAIN_THREAD_EM_ASM_INT({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(double & arg_var, std::string var) {\n    arg_var = MAIN_THREAD_EM_ASM_DOUBLE({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(float & arg_var, std::string var) {\n    arg_var = (float) MAIN_THREAD_EM_ASM_DOUBLE({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(std::string & arg_var, std::string var) {\n    char * tmp_var = (char *) MAIN_THREAD_EM_ASM_INT({\n      if (emp_i.curr_obj[UTF8ToString($0)] == null){\n        emp_i.curr_obj[UTF8ToString($0)] = \"undefined\";\n      }\n      return allocate(intArrayFromString(emp_i.curr_obj[UTF8ToString($0)]),\n                   'i8', ALLOC_STACK);\n    }, var.c_str());\n    arg_var = tmp_var;   // Free memory here?\n  }\n\n  template <int ARG_ID, typename JSON_TYPE> static\n  typename std::enable_if<JSON_TYPE::n_fields != -1, void>::type\n  LoadArg(JSON_TYPE & arg_var, std::string var) {\n    //std::cout << \"Loading \" << var << \" ARGNID: \" << ARG_ID << std::endl;\n    //LoadArg<ARG_ID>(std::get<ARG_ID>(arg_var.emp__tuple_body));\n    MAIN_THREAD_EM_ASM({\n      emp_i.object_queue.push(emp_i.curr_obj);\n      emp_i.curr_obj = emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n    LoadTuple<JSON_TYPE, ARG_ID, JSON_TYPE::n_fields> load_tuple = LoadTuple<JSON_TYPE, ARG_ID, JSON_TYPE::n_fields>();\n    load_tuple.LoadJSDataArg(arg_var);\n  }\n\n  template <typename JSON_TYPE, int ARG_ID, int FIELD>\n  struct LoadTuple {\n    static void LoadJSDataArg(JSON_TYPE & arg_var) {\n    //std::cout << \"LoadingJS \" << arg_var.var_names[FIELD-1] << \" FIeLd: \" << FIELD-1 << std::endl;\n      LoadArg<ARG_ID>(std::get<FIELD-1>(arg_var.emp__tuple_body), arg_var.var_names[FIELD-1]);\n      LoadTuple<JSON_TYPE, ARG_ID, FIELD-1> load_tuple = LoadTuple<JSON_TYPE, ARG_ID, FIELD-1>();\n      load_tuple.LoadJSDataArg(arg_var);\n    }\n  };\n\n  template <typename JSON_TYPE, int ARG_ID>\n  struct LoadTuple<JSON_TYPE, ARG_ID, 0> {\n    static void LoadJSDataArg(JSON_TYPE & arg_var) {\n        MAIN_THREAD_EM_ASM({emp_i.curr_obj = emp_i.object_queue.pop();});\n    }\n  };\n\n\n  // ----- StoreReturn -----\n  // Helper functions to individually store return values to JS\n\n  // static void StoreReturn(const bool & ret_var) {\n  //   MAIN_THREAD_EM_ASM({ emp_i.cb_return = $0; }, ret_var);\n  // }\n\n  static void StoreReturn(const int & ret_var) {\n    MAIN_THREAD_EM_ASM({ emp_i.cb_return = $0; }, ret_var);\n  }\n\n  static void StoreReturn(const double & ret_var) {\n    MAIN_THREAD_EM_ASM({ emp_i.cb_return = $0; }, ret_var);\n  }\n\n  static void StoreReturn(const std::string & ret_var) {\n    MAIN_THREAD_EM_ASM({ emp_i.cb_return = UTF8ToString($0); }, ret_var.c_str());\n  }\n\n  template <typename T, size_t N>\n  static void StoreReturn(const emp::array<T, N> & ret_var) {\n    pass_array_to_javascript(ret_var);\n    MAIN_THREAD_EM_ASM({ emp_i.cb_return = emp_i.__incoming_array; });\n  }\n\n  /// If the return type has a personalized function to handle the return, use it!\n  template <typename RETURN_TYPE>\n  static emp::sfinae_decoy<void, decltype(&RETURN_TYPE::StoreAsReturn)>\n  StoreReturn(const RETURN_TYPE & ret_var) {\n    ret_var.template StoreAsReturn();\n  }\n\n  /// Helper functions to store values inside JSON objects\n  static void StoreReturn(const int & ret_var, std::string var) {\n    MAIN_THREAD_EM_ASM({ emp_i.curr_obj[UTF8ToString($1)] = $0; }, ret_var, var.c_str());\n  }\n\n  static void StoreReturn(const double & ret_var, std::string var) {\n    MAIN_THREAD_EM_ASM({ emp_i.curr_obj[UTF8ToString($1)] = $0; }, ret_var, var.c_str());\n  }\n\n  static void StoreReturn(const std::string & ret_var, std::string var) {\n    MAIN_THREAD_EM_ASM({ emp_i.curr_obj[UTF8ToString($1)] = UTF8ToString($0); }\n                                                    , ret_var.c_str(), var.c_str());\n  }\n\n  template <typename T, size_t N>\n  static void StoreReturn(const emp::array<T, N> & ret_var, std::string var) {\n    pass_array_to_javascript(ret_var);\n    MAIN_THREAD_EM_ASM({ emp_i.curr_obj[UTF8ToString($0)] = emp_i.__incoming_array;}, var.c_str());\n  }\n\n  template <typename JSON_TYPE, int FIELD>\n  struct StoreTuple;\n\n  // Tuple struct\n  template <typename RETURN_TYPE>\n  static typename std::enable_if<RETURN_TYPE::n_fields != -1, void>::type\n  StoreReturn(const RETURN_TYPE & ret_var) {\n    MAIN_THREAD_EM_ASM({\n      emp_i.cb_return = {};\n      emp_i.object_queue = [];\n      emp_i.curr_obj = emp_i.cb_return;\n    });\n\n    StoreTuple<RETURN_TYPE, RETURN_TYPE::n_fields> store_tuple = StoreTuple<RETURN_TYPE, RETURN_TYPE::n_fields>();\n    store_tuple.StoreJSDataArg(ret_var);\n  }\n\n  // Nested tuple struct\n  template <typename RETURN_TYPE>\n  static emp::sfinae_decoy<void, decltype(RETURN_TYPE::n_fields)>\n  StoreReturn(const RETURN_TYPE & ret_var, std::string var) {\n    MAIN_THREAD_EM_ASM({\n      emp_i.curr_obj[UTF8ToString($0)] = {};\n      emp_i.object_queue.push(emp_i.curr_obj);\n      emp_i.curr_obj = emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n\n    StoreTuple<RETURN_TYPE, RETURN_TYPE::n_fields> store_tuple = StoreTuple<RETURN_TYPE, RETURN_TYPE::n_fields>();\n    store_tuple.StoreJSDataArg(ret_var);\n  }\n\n  template <typename JSON_TYPE, int FIELD>\n  struct StoreTuple {\n    static void StoreJSDataArg(const JSON_TYPE & ret_var) {\n      StoreReturn(std::get<FIELD-1>(ret_var.emp__tuple_body), ret_var.var_names[FIELD-1]);\n      StoreTuple<JSON_TYPE, FIELD-1> store_tuple = StoreTuple<JSON_TYPE, FIELD-1>();\n      store_tuple.StoreJSDataArg(ret_var);\n    }\n  };\n\n  template <typename JSON_TYPE>\n  struct StoreTuple<JSON_TYPE, 0> {\n    static void StoreJSDataArg(const JSON_TYPE & ret_var) {\n      MAIN_THREAD_EM_ASM({emp_i.curr_obj = emp_i.object_queue.pop();});\n    }\n  };\n\n  // The following code is in the \"internal\" namespace since it's used only to implement the\n  // details of the JSWrap function.\n\n  namespace internal {\n\n    template <typename T, int ARG_ID>\n    void LoadArg_impl(emp::sfinae_decoy<bool, decltype(&T::template LoadFromArg<ARG_ID>)>,\n                      T & target) {\n      target.template LoadFromArg<ARG_ID>();\n    }\n    template <typename T, int ARG_ID>\n    void LoadArg_impl(int, T & target) {\n      LoadArg<ARG_ID>(target);\n    }\n\n    // JSWrap_Callback_Base provides a base class for the wrappers around functions.\n    // Specifically, it creates a virtual DoCallback() member function that can be called\n    // to trigger a specific wrapped function.\n\n    class JSWrap_Callback_Base {\n    protected:\n      bool is_disposable;  // Should this callback be deleted automatically after first use?\n\n    public:\n      JSWrap_Callback_Base(bool in_disposable=false) : is_disposable(in_disposable) { ; }\n      virtual ~JSWrap_Callback_Base() { ; }\n\n      bool IsDisposable() const { return is_disposable; }\n      void SetDisposable() { is_disposable = true; }\n\n      // Base class to be called from Javascript (after storing args) to do a callback.\n      virtual void DoCallback() = 0;\n\n\n      // A pair of helper functions that systematically load ALL arguments from JS.\n      template <typename TUPLE_TYPE, int ARGS_LEFT>\n      struct Collect_impl {\n        static void CollectArgs(TUPLE_TYPE & tuple) {\n          LoadArg_impl<typename std::tuple_element<ARGS_LEFT-1,TUPLE_TYPE>::type, ARGS_LEFT-1>( true, std::get<ARGS_LEFT-1>(tuple) );  // Load an arg\n          Collect_impl<TUPLE_TYPE, ARGS_LEFT-1>::CollectArgs(tuple);        // Recurse to next arg\n        }\n      };\n\n      template <typename TUPLE_TYPE>\n      struct Collect_impl<TUPLE_TYPE, 0> {\n        static void CollectArgs(TUPLE_TYPE & tuple) { (void) tuple; } // End load recursion.\n      };\n\n    };\n\n\n    // The derived form of JSWrap_Callback knows the specific argument types of the function\n    // needed, keeps track of the function poninter, and has a tuple in which the arguments\n    // can be loaded before a call is made.\n\n    template <typename RET_TYPE, typename... ARG_TYPES>\n    class JSWrap_Callback : public JSWrap_Callback_Base {\n    private:\n      std::function<RET_TYPE(ARG_TYPES...)> fun;   // Function to be wrapped\n\n    public:\n      JSWrap_Callback(const std::function<RET_TYPE(ARG_TYPES...)> & in_fun, bool disposable=false)\n        : JSWrap_Callback_Base(disposable), fun(in_fun)\n      {\n        EMP_TRACK_CONSTRUCT(JSWrap_Callback);\n      }\n      ~JSWrap_Callback() { EMP_TRACK_DESTRUCT(JSWrap_Callback); }\n\n      // This function is called from Javascript.  Arguments should be collected and then used\n      // to call the target function.\n      void DoCallback() {\n        const int num_args = sizeof...(ARG_TYPES);\n\n        // Make sure that we are returning the correct number of arguments.  If this\n        // assert fails, it means that we've failed to set the correct number of arguments\n        // in emp.cb_args, and need to realign.\n        emp_assert(EMP_GetCBArgCount() < 0 || EMP_GetCBArgCount() >= num_args, EMP_GetCBArgCount(), num_args);\n\n        // Collect the values of the arguments in a tuple\n        using args_t = std::tuple< typename std::decay<ARG_TYPES>::type... >;\n        args_t args;\n        Collect_impl<args_t, num_args>::CollectArgs(args);\n\n        // And finally, do the actual callback.\n\n        RET_TYPE return_val;\n        std::apply(\n          [&return_val, this](ARG_TYPES... in_args){ return_val = fun(in_args...); },\n          args\n        );\n\n        // And save the return value for JS.\n        StoreReturn(return_val);\n      }\n    };\n\n    // A specialized version of the class that handles functions with void returns.\n\n    template <typename... ARG_TYPES>\n    class JSWrap_Callback<void, ARG_TYPES...> : public JSWrap_Callback_Base {\n    private:\n      std::function<void(ARG_TYPES...)> fun;   // Function to be wrapped\n\n    public:\n      JSWrap_Callback(const std::function<void(ARG_TYPES...)> & in_fun, bool disposable=false)\n        : JSWrap_Callback_Base(disposable), fun(in_fun)\n      { EMP_TRACK_CONSTRUCT(JSWrap_Callback_VOID); }\n      ~JSWrap_Callback() { EMP_TRACK_DESTRUCT(JSWrap_Callback_VOID); }\n\n\n      // This function is called from Javascript.  Arguments should be collected and then used\n      // to call the target function.\n      void DoCallback() {\n        const int num_args = sizeof...(ARG_TYPES);\n\n        // Make sure that we are returning the correct number of arguments.  If this\n        // assert fails, it means that we've failed to set the correct number of arguments\n        // in emp.cb_args, and need to realign.\n        emp_assert(EMP_GetCBArgCount() < 0 || EMP_GetCBArgCount() >= num_args, EMP_GetCBArgCount(), num_args);\n\n        // Collect the values of the arguments in a tuple\n        using args_t = std::tuple< typename std::decay<ARG_TYPES>::type... >;\n        args_t args;\n        Collect_impl<args_t, num_args>::CollectArgs(args);\n\n        // And finally, do the actual callback.\n        std::apply(fun, args);\n\n        // And save a return value for JS.\n        StoreReturn(0);\n      }\n    };\n\n\n    // The following function returns a static callback array; callback ID's all index into\n    // this array.\n    static emp::vector<JSWrap_Callback_Base *> & CallbackArray() {\n      #ifdef __EMSCRIPTEN_PTHREADS__\n      thread_local emp::vector<JSWrap_Callback_Base *> callback_array{nullptr};\n      #else\n      static emp::vector<JSWrap_Callback_Base *> callback_array(1, nullptr);\n      #endif\n      return callback_array;\n    }\n\n  } // End internal namespace\n\n  // The following JSWrap functions take a target function and return an integer id that\n  // indexes into a callback array.\n\n  // The first version assumes that we already have it enclosed in an std::function, while\n  // the second version assumes we have a raw function pointer and wraps it for us.\n\n  template <typename RET_TYPE, typename... ARG_TYPES>\n  size_t JSWrap(const std::function<RET_TYPE(ARG_TYPES...)> & in_fun,\n                const std::string & fun_name=\"\",\n                bool dispose_on_use=false)\n  {\n    // We should never create disposible functions with names!\n    emp_assert(fun_name == \"\" || dispose_on_use == false);\n\n    auto * new_cb =\n      new emp::internal::JSWrap_Callback<RET_TYPE, ARG_TYPES...>(in_fun, dispose_on_use);\n    auto & callback_array = internal::CallbackArray();\n    size_t out_id = callback_array.size();\n    callback_array.push_back(new_cb);\n\n    if (fun_name != \"\") {\n      MAIN_THREAD_EM_ASM({\n          var fun_name = UTF8ToString($1);\n          emp[fun_name] = function() {\n            emp_i.cb_args = [];\n            for (var i = 0; i < arguments.length; i++) {\n              emp_i.cb_args[i] = arguments[i];\n            }\n\n            // Callback to the original function.\n            empCppCallback($0);\n\n            // Return the resulting value\n            return emp_i.cb_return;\n          };\n        }, out_id, fun_name.c_str());\n    }\n\n    return out_id;\n  }\n\n  template <typename RETURN_TYPE, typename... ARG_TYPES>\n  size_t JSWrap( RETURN_TYPE (*in_fun) (ARG_TYPES...),\n                 const std::string & fun_name=\"\", bool dispose_on_use=false )\n  {\n    std::function<RETURN_TYPE(ARG_TYPES...)> fun_ptr(in_fun);\n    return JSWrap(fun_ptr, fun_name, dispose_on_use);\n  }\n\n  #endif // end DOXYGEN_SHOULD_SKIP_THIS\n\n  /// JSWrap takes a C++ function and wraps it in Javascript for easy calling in web code\n  /// @param in_fun a C++ function to wrap\n  /// @param fun_name optionally, a name to call the function on the Javascript size\n  /// @param dispose_on_use should we delete this function after using it?\n  /// @returns the id of the function on the Javascript side\n  template <typename FUN_TYPE>\n  size_t JSWrap(const FUN_TYPE & in_fun, const std::string & fun_name=\"\", bool dispose_on_use=false)\n  {\n    return JSWrap(to_function(in_fun), fun_name, dispose_on_use);\n  }\n\n\n  /// If we want a quick, unnammed, disposable function, use JSWrapOnce\n  template <typename FUN_TYPE>\n  size_t JSWrapOnce(FUN_TYPE && in_fun) { return JSWrap(std::forward<FUN_TYPE>(in_fun), \"\", true); }\n\n\n  /// Cleanup a function pointer when finished with it.\n  void JSDelete( size_t fun_id ) {\n    emp_assert(fun_id > 0);  // Make sure this isn't a null pointer!\n    // @CAO -- Should make sure to clean up named functions on JS side if they exist.\n    auto & callback_array = internal::CallbackArray();\n    delete callback_array[fun_id];\n    callback_array[fun_id] = nullptr;\n  }\n}\n\nextern \"C\" {\n\n/// This function is dispatched by empCppCallback. It should be dispatched on\n/// the thread hosting the main Empirical runtime.\n/// If running with Emscripten pthreads, that would be the worker thread hosting\n/// the main Empirical runtime. If not running with Emscripten pthreads, that\n/// would be the main browser thread.\n/// (In a few limited cases when running with Emscripten pthreads, this function\n/// is called on the main browser thread.)\nvoid empDoCppCallback(const size_t cb_id) {\n\n  // Convert the uint passed in from 32 bits to 64 and THEN convert it to a pointer.\n  auto * cb_obj = emp::internal::CallbackArray()[cb_id];\n\n  // Run DoCallback() on the generic base class type, which is virtual and will call\n  // the correct template automatically.\n  cb_obj->DoCallback();\n\n  // dispatch all pending offscreen canvas updates to the browser thread\n  #ifdef __EMSCRIPTEN_PTHREADS__\n  EM_ASM({\n    emp_i.pending_offscreen_canvas_ids\n      = emp_i.pending_offscreen_canvas_ids || new Set();\n    emp_i.pending_offscreen_canvas_ids.forEach( function( key, val, set ){\n\n      bitmap = emp_i.offscreen_canvases[key].transferToImageBitmap();\n      postMessage(\n        {\n          // this cmd corresponds to a 'nop' on emscripten's part\n          // see https://github.com/emscripten-core/emscripten/blob/bec6d1c1c1c982ecba787b8d51907d2ba51e6555/src/library_pthread.js#L366\n          // and also https://github.com/emscripten-core/emscripten/blob/be50706a38240e2f0679b60d58945f0e296ee9ee/system/lib/pthread/library_pthread_stub.c#L28\n          cmd: 'processQueuedMainThreadWork',\n          emp_canvas_id : key,\n          emp_bitmap : bitmap,\n        },\n        [ bitmap ] // transfer ownership of the bitmap\n      );\n    });\n\n    emp_i.pending_offscreen_canvas_ids.clear();\n\n  });\n  #endif\n\n  // If we have indicated that this callback is single use, delete it now.\n  if (cb_obj->IsDisposable()) {\n    delete cb_obj;\n    emp::internal::CallbackArray()[cb_id] = nullptr;\n  }\n\n}\n\n/// Once you use JSWrap to create an ID, you can call the wrapped function from\n/// Javascript by supplying CPPCallback with the id and all args.\n/// If running with Emscripten pthreads, this method is to be called from the\n/// DOM and it will forward the call to empDoCppCallback on the web worker\n/// hosting Empirical runtime.\n/// If not running with Emscripten pthreads, this method simply calls\n/// empDoCppCallback (on the main browser thread).\nvoid empCppCallback(const size_t cb_id) {\n\n  #ifndef __EMSCRIPTEN_PTHREADS__\n\n    empDoCppCallback( cb_id );\n\n  #else\n\n  // dispatch the callback to the worker thread main was proxied to\n\n    const pthread_t proxy_pthread_id = EM_ASM_INT({\n\n      if ( Object.keys( PThread.pthreads ).length !== 0 ) {\n        console.assert( Object.keys( PThread.pthreads ).length === 1 );\n        return Object.keys(PThread.pthreads)[0];\n      } else return 0;\n\n    });\n\n    emscripten_async_queue_on_thread(\n      proxy_pthread_id,\n      EM_FUNC_SIG_VI, // VI = no return value, one argument\n      (void*) &empDoCppCallback,\n      NULL,\n      cb_id\n    );\n\n  #endif // __EMSCRIPTEN_PTHREADS__\n\n}\n\n} // extern \"C\"\n\n\n\n#endif // #ifndef EMP_WEB_JSWRAP_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2018\n *\n *  @file JSWrap.hpp\n *  @brief Wrap a C++ function and convert it to an integer that can be called from Javascript\n *\n *  To wrap a function, call:\n *\n *     `uint32_t fun_id = emp::JSWrap(FunctionToBeWrapped, \"JS_Function_Name\");``\n *\n *  To manually callback a function from Javascript, first set `emp_i.cb_args` to an array of\n *  function arguments, then call `empCppCallback( fun_id );`   This all happens automatically\n *  if you use the `emp.Callback(fun_id, args...)` function from Javascript.\n *\n *  The JS_Function_Name string is optional, but if you use it, the appropriate function will\n *  be automatically generated in Javascript by JSWrap, in the emp class.\n *\n *  For example, if you have:\n *\n *     `int AddPair(int x, int y) { return x + y; }``\n *\n *  You can wrap it with:\n *\n *     `size_t fun_id = emp::JSWrap(AddPair, \"AddPair\");`\n *\n *  And then in Javascript, you can simply call it as:\n *\n *     `emp.AddPair(4, 5); // will return 9.`\n *\n *\n *  @todo Add a JSWrap that takes an object and method and does the bind automatically.\n *  @todo Build a non-enscripten version; it should still be callable from the C++ side, but\n *        mostly to be able to test programs without Emscripten.\n *\n */\n\n#ifndef EMP_WEB_JSWRAP_HPP_INCLUDE\n#define EMP_WEB_JSWRAP_HPP_INCLUDE\n\n#include <array>\n#include <functional>\n#include <tuple>\n#include <type_traits>\n\n#include \"../base/assert.hpp\"\n#include \"../base/vector.hpp\"\n#include \"../datastructs/tuple_struct.hpp\"\n#include \"../datastructs/tuple_utils.hpp\"\n#include \"../debug/mem_track.hpp\"\n#include \"../meta/meta.hpp\"\n\n#include \"init.hpp\"\n#include \"js_utils.hpp\"\n\n#ifndef DOXYGEN_SHOULD_SKIP_THIS\n#ifdef __EMSCRIPTEN__\nextern \"C\" {\n  extern int EMP_GetCBArgCount();  // Get the number of arguments associated with a callback.\n}\n#else\n// When NOT in Emscripten, need a stub for this function.\nint EMP_GetCBArgCount() { return -1; }\n#endif // EMSCRIPTEN\n#endif // DOXYGEN_SHOULD_SKIP_THIS\n\nnamespace emp {\n\n  #ifndef DOXYGEN_SHOULD_SKIP_THIS\n\n  template <typename JSON_TYPE, int ARG_ID, int FIELD>\n  struct LoadTuple;\n\n  /// This needs to go before LoadTuple is defined, in case there are nested tuple structs\n  template <int ARG_ID, typename T> static\n  void LoadArg(T & arg_var) {\n    if constexpr ( is_introspective_tuple<T>() ) {\n      using JSON_TYPE = T;\n      //std::cout << \"Loading ARGNID: \" << ARG_ID << std::endl;\n      MAIN_THREAD_EM_ASM({\n        emp_i.object_queue = [];\n        emp_i.curr_obj = emp_i.cb_args[$0];\n      }, ARG_ID);\n      LoadTuple<JSON_TYPE, ARG_ID, JSON_TYPE::n_fields> load_tuple = LoadTuple<JSON_TYPE, ARG_ID, JSON_TYPE::n_fields>();\n      load_tuple.LoadJSDataArg(arg_var);\n    }\n    else {\n      arg_var = (T) MAIN_THREAD_EM_ASM_DOUBLE({ return emp_i.cb_args[$0]; }, ARG_ID);\n    }\n  }\n\n  template <int ARG_ID> static void LoadArg(std::string & arg_var) {\n    char * tmp_var = (char *) MAIN_THREAD_EM_ASM_INT({\n        return allocate(intArrayFromString(emp_i.cb_args[$0]), 'i8', ALLOC_STACK);\n      }, ARG_ID);\n    arg_var = tmp_var;   // @CAO Do we need to free the memory in tmp_var?\n  }\n\n  template <int ARG_ID, size_t SIZE, typename T> static void LoadArg(emp::array<T, SIZE> & arg_var){\n    MAIN_THREAD_EM_ASM({emp_i.__outgoing_array = emp_i.cb_args[$0];}, ARG_ID);\n    pass_array_to_cpp(arg_var);\n  }\n\n  template <int ARG_ID, typename T> static void LoadArg(emp::vector<T> & arg_var){\n    MAIN_THREAD_EM_ASM({emp_i.__outgoing_array = emp_i.cb_args[$0];}, ARG_ID);\n    pass_vector_to_cpp(arg_var);\n  }\n\n  //Helper functions to load arguments from inside Javascript objects by name.\n  template <int ARG_ID> static void LoadArg(int16_t & arg_var, std::string var) {\n    arg_var = (int16_t) MAIN_THREAD_EM_ASM_INT({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(int32_t & arg_var, std::string var) {\n    arg_var = (int32_t) MAIN_THREAD_EM_ASM_INT({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(int64_t & arg_var, std::string var) {\n    arg_var = (int64_t) MAIN_THREAD_EM_ASM_DOUBLE({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(uint16_t & arg_var, std::string var) {\n    arg_var = (uint16_t) MAIN_THREAD_EM_ASM_INT({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(uint32_t & arg_var, std::string var) {\n    arg_var = (uint32_t) MAIN_THREAD_EM_ASM_INT({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(uint64_t & arg_var, std::string var) {\n    arg_var = (uint64_t) MAIN_THREAD_EM_ASM_DOUBLE({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(bool & arg_var, std::string var) {\n    arg_var = (bool) MAIN_THREAD_EM_ASM_INT({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(char & arg_var, std::string var) {\n    arg_var = (char) MAIN_THREAD_EM_ASM_INT({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(double & arg_var, std::string var) {\n    arg_var = MAIN_THREAD_EM_ASM_DOUBLE({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(float & arg_var, std::string var) {\n    arg_var = (float) MAIN_THREAD_EM_ASM_DOUBLE({\n      return emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n  }\n\n  template <int ARG_ID> static void LoadArg(std::string & arg_var, std::string var) {\n    char * tmp_var = (char *) MAIN_THREAD_EM_ASM_INT({\n      if (emp_i.curr_obj[UTF8ToString($0)] == null){\n        emp_i.curr_obj[UTF8ToString($0)] = \"undefined\";\n      }\n      return allocate(intArrayFromString(emp_i.curr_obj[UTF8ToString($0)]),\n                   'i8', ALLOC_STACK);\n    }, var.c_str());\n    arg_var = tmp_var;   // Free memory here?\n  }\n\n  template <int ARG_ID, typename JSON_TYPE> static\n  typename std::enable_if<JSON_TYPE::n_fields != -1, void>::type\n  LoadArg(JSON_TYPE & arg_var, std::string var) {\n    //std::cout << \"Loading \" << var << \" ARGNID: \" << ARG_ID << std::endl;\n    //LoadArg<ARG_ID>(std::get<ARG_ID>(arg_var.emp__tuple_body));\n    MAIN_THREAD_EM_ASM({\n      emp_i.object_queue.push(emp_i.curr_obj);\n      emp_i.curr_obj = emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n    LoadTuple<JSON_TYPE, ARG_ID, JSON_TYPE::n_fields> load_tuple = LoadTuple<JSON_TYPE, ARG_ID, JSON_TYPE::n_fields>();\n    load_tuple.LoadJSDataArg(arg_var);\n  }\n\n  template <typename JSON_TYPE, int ARG_ID, int FIELD>\n  struct LoadTuple {\n    static void LoadJSDataArg(JSON_TYPE & arg_var) {\n    //std::cout << \"LoadingJS \" << arg_var.var_names[FIELD-1] << \" FIeLd: \" << FIELD-1 << std::endl;\n      LoadArg<ARG_ID>(std::get<FIELD-1>(arg_var.emp__tuple_body), arg_var.var_names[FIELD-1]);\n      LoadTuple<JSON_TYPE, ARG_ID, FIELD-1> load_tuple = LoadTuple<JSON_TYPE, ARG_ID, FIELD-1>();\n      load_tuple.LoadJSDataArg(arg_var);\n    }\n  };\n\n  template <typename JSON_TYPE, int ARG_ID>\n  struct LoadTuple<JSON_TYPE, ARG_ID, 0> {\n    static void LoadJSDataArg(JSON_TYPE & arg_var) {\n        MAIN_THREAD_EM_ASM({emp_i.curr_obj = emp_i.object_queue.pop();});\n    }\n  };\n\n\n  // ----- StoreReturn -----\n  // Helper functions to individually store return values to JS\n\n  // static void StoreReturn(const bool & ret_var) {\n  //   MAIN_THREAD_EM_ASM({ emp_i.cb_return = $0; }, ret_var);\n  // }\n\n  static void StoreReturn(const int & ret_var) {\n    MAIN_THREAD_EM_ASM({ emp_i.cb_return = $0; }, ret_var);\n  }\n\n  static void StoreReturn(const double & ret_var) {\n    MAIN_THREAD_EM_ASM({ emp_i.cb_return = $0; }, ret_var);\n  }\n\n  static void StoreReturn(const std::string & ret_var) {\n    MAIN_THREAD_EM_ASM({ emp_i.cb_return = UTF8ToString($0); }, ret_var.c_str());\n  }\n\n  template <typename T, size_t N>\n  static void StoreReturn(const emp::array<T, N> & ret_var) {\n    pass_array_to_javascript(ret_var);\n    MAIN_THREAD_EM_ASM({ emp_i.cb_return = emp_i.__incoming_array; });\n  }\n\n  /// If the return type has a personalized function to handle the return, use it!\n  template <typename RETURN_TYPE>\n  static emp::sfinae_decoy<void, decltype(&RETURN_TYPE::StoreAsReturn)>\n  StoreReturn(const RETURN_TYPE & ret_var) {\n    ret_var.template StoreAsReturn();\n  }\n\n  /// Helper functions to store values inside JSON objects\n  static void StoreReturn(const int & ret_var, std::string var) {\n    MAIN_THREAD_EM_ASM({ emp_i.curr_obj[UTF8ToString($1)] = $0; }, ret_var, var.c_str());\n  }\n\n  static void StoreReturn(const double & ret_var, std::string var) {\n    MAIN_THREAD_EM_ASM({ emp_i.curr_obj[UTF8ToString($1)] = $0; }, ret_var, var.c_str());\n  }\n\n  static void StoreReturn(const std::string & ret_var, std::string var) {\n    MAIN_THREAD_EM_ASM({ emp_i.curr_obj[UTF8ToString($1)] = UTF8ToString($0); }\n                                                    , ret_var.c_str(), var.c_str());\n  }\n\n  template <typename T, size_t N>\n  static void StoreReturn(const emp::array<T, N> & ret_var, std::string var) {\n    pass_array_to_javascript(ret_var);\n    MAIN_THREAD_EM_ASM({ emp_i.curr_obj[UTF8ToString($0)] = emp_i.__incoming_array;}, var.c_str());\n  }\n\n  template <typename JSON_TYPE, int FIELD>\n  struct StoreTuple;\n\n  // Tuple struct\n  template <typename RETURN_TYPE>\n  static typename std::enable_if<RETURN_TYPE::n_fields != -1, void>::type\n  StoreReturn(const RETURN_TYPE & ret_var) {\n    MAIN_THREAD_EM_ASM({\n      emp_i.cb_return = {};\n      emp_i.object_queue = [];\n      emp_i.curr_obj = emp_i.cb_return;\n    });\n\n    StoreTuple<RETURN_TYPE, RETURN_TYPE::n_fields> store_tuple = StoreTuple<RETURN_TYPE, RETURN_TYPE::n_fields>();\n    store_tuple.StoreJSDataArg(ret_var);\n  }\n\n  // Nested tuple struct\n  template <typename RETURN_TYPE>\n  static emp::sfinae_decoy<void, decltype(RETURN_TYPE::n_fields)>\n  StoreReturn(const RETURN_TYPE & ret_var, std::string var) {\n    MAIN_THREAD_EM_ASM({\n      emp_i.curr_obj[UTF8ToString($0)] = {};\n      emp_i.object_queue.push(emp_i.curr_obj);\n      emp_i.curr_obj = emp_i.curr_obj[UTF8ToString($0)];\n    }, var.c_str());\n\n    StoreTuple<RETURN_TYPE, RETURN_TYPE::n_fields> store_tuple = StoreTuple<RETURN_TYPE, RETURN_TYPE::n_fields>();\n    store_tuple.StoreJSDataArg(ret_var);\n  }\n\n  template <typename JSON_TYPE, int FIELD>\n  struct StoreTuple {\n    static void StoreJSDataArg(const JSON_TYPE & ret_var) {\n      StoreReturn(std::get<FIELD-1>(ret_var.emp__tuple_body), ret_var.var_names[FIELD-1]);\n      StoreTuple<JSON_TYPE, FIELD-1> store_tuple = StoreTuple<JSON_TYPE, FIELD-1>();\n      store_tuple.StoreJSDataArg(ret_var);\n    }\n  };\n\n  template <typename JSON_TYPE>\n  struct StoreTuple<JSON_TYPE, 0> {\n    static void StoreJSDataArg(const JSON_TYPE & ret_var) {\n      MAIN_THREAD_EM_ASM({emp_i.curr_obj = emp_i.object_queue.pop();});\n    }\n  };\n\n  // The following code is in the \"internal\" namespace since it's used only to implement the\n  // details of the JSWrap function.\n\n  namespace internal {\n\n    template <typename T, int ARG_ID>\n    void LoadArg_impl(emp::sfinae_decoy<bool, decltype(&T::template LoadFromArg<ARG_ID>)>,\n                      T & target) {\n      target.template LoadFromArg<ARG_ID>();\n    }\n    template <typename T, int ARG_ID>\n    void LoadArg_impl(int, T & target) {\n      LoadArg<ARG_ID>(target);\n    }\n\n    // JSWrap_Callback_Base provides a base class for the wrappers around functions.\n    // Specifically, it creates a virtual DoCallback() member function that can be called\n    // to trigger a specific wrapped function.\n\n    class JSWrap_Callback_Base {\n    protected:\n      bool is_disposable;  // Should this callback be deleted automatically after first use?\n\n    public:\n      JSWrap_Callback_Base(bool in_disposable=false) : is_disposable(in_disposable) { ; }\n      virtual ~JSWrap_Callback_Base() { ; }\n\n      bool IsDisposable() const { return is_disposable; }\n      void SetDisposable() { is_disposable = true; }\n\n      // Base class to be called from Javascript (after storing args) to do a callback.\n      virtual void DoCallback() = 0;\n\n\n      // A pair of helper functions that systematically load ALL arguments from JS.\n      template <typename TUPLE_TYPE, int ARGS_LEFT>\n      struct Collect_impl {\n        static void CollectArgs(TUPLE_TYPE & tuple) {\n          LoadArg_impl<typename std::tuple_element<ARGS_LEFT-1,TUPLE_TYPE>::type, ARGS_LEFT-1>( true, std::get<ARGS_LEFT-1>(tuple) );  // Load an arg\n          Collect_impl<TUPLE_TYPE, ARGS_LEFT-1>::CollectArgs(tuple);        // Recurse to next arg\n        }\n      };\n\n      template <typename TUPLE_TYPE>\n      struct Collect_impl<TUPLE_TYPE, 0> {\n        static void CollectArgs(TUPLE_TYPE & tuple) { (void) tuple; } // End load recursion.\n      };\n\n    };\n\n\n    // The derived form of JSWrap_Callback knows the specific argument types of the function\n    // needed, keeps track of the function poninter, and has a tuple in which the arguments\n    // can be loaded before a call is made.\n\n    template <typename RET_TYPE, typename... ARG_TYPES>\n    class JSWrap_Callback : public JSWrap_Callback_Base {\n    private:\n      std::function<RET_TYPE(ARG_TYPES...)> fun;   // Function to be wrapped\n\n    public:\n      JSWrap_Callback(const std::function<RET_TYPE(ARG_TYPES...)> & in_fun, bool disposable=false)\n        : JSWrap_Callback_Base(disposable), fun(in_fun)\n      {\n        EMP_TRACK_CONSTRUCT(JSWrap_Callback);\n      }\n      ~JSWrap_Callback() { EMP_TRACK_DESTRUCT(JSWrap_Callback); }\n\n      // This function is called from Javascript.  Arguments should be collected and then used\n      // to call the target function.\n      void DoCallback() {\n        const int num_args = sizeof...(ARG_TYPES);\n\n        // Make sure that we are returning the correct number of arguments.  If this\n        // assert fails, it means that we've failed to set the correct number of arguments\n        // in emp.cb_args, and need to realign.\n        emp_assert(EMP_GetCBArgCount() < 0 || EMP_GetCBArgCount() >= num_args, EMP_GetCBArgCount(), num_args);\n\n        // Collect the values of the arguments in a tuple\n        using args_t = std::tuple< typename std::decay<ARG_TYPES>::type... >;\n        args_t args;\n        Collect_impl<args_t, num_args>::CollectArgs(args);\n\n        // And finally, do the actual callback.\n\n        RET_TYPE return_val;\n        std::apply(\n          [&return_val, this](ARG_TYPES... in_args){ return_val = fun(in_args...); },\n          args\n        );\n\n        // And save the return value for JS.\n        StoreReturn(return_val);\n      }\n    };\n\n    // A specialized version of the class that handles functions with void returns.\n\n    template <typename... ARG_TYPES>\n    class JSWrap_Callback<void, ARG_TYPES...> : public JSWrap_Callback_Base {\n    private:\n      std::function<void(ARG_TYPES...)> fun;   // Function to be wrapped\n\n    public:\n      JSWrap_Callback(const std::function<void(ARG_TYPES...)> & in_fun, bool disposable=false)\n        : JSWrap_Callback_Base(disposable), fun(in_fun)\n      { EMP_TRACK_CONSTRUCT(JSWrap_Callback_VOID); }\n      ~JSWrap_Callback() { EMP_TRACK_DESTRUCT(JSWrap_Callback_VOID); }\n\n\n      // This function is called from Javascript.  Arguments should be collected and then used\n      // to call the target function.\n      void DoCallback() {\n        const int num_args = sizeof...(ARG_TYPES);\n\n        // Make sure that we are returning the correct number of arguments.  If this\n        // assert fails, it means that we've failed to set the correct number of arguments\n        // in emp.cb_args, and need to realign.\n        emp_assert(EMP_GetCBArgCount() < 0 || EMP_GetCBArgCount() >= num_args, EMP_GetCBArgCount(), num_args);\n\n        // Collect the values of the arguments in a tuple\n        using args_t = std::tuple< typename std::decay<ARG_TYPES>::type... >;\n        args_t args;\n        Collect_impl<args_t, num_args>::CollectArgs(args);\n\n        // And finally, do the actual callback.\n        std::apply(fun, args);\n\n        // And save a return value for JS.\n        StoreReturn(0);\n      }\n    };\n\n\n    // The following function returns a static callback array; callback ID's all index into\n    // this array.\n    static emp::vector<JSWrap_Callback_Base *> & CallbackArray() {\n      #ifdef __EMSCRIPTEN_PTHREADS__\n      thread_local emp::vector<JSWrap_Callback_Base *> callback_array{nullptr};\n      #else\n      static emp::vector<JSWrap_Callback_Base *> callback_array(1, nullptr);\n      #endif\n      return callback_array;\n    }\n\n  } // End internal namespace\n\n  // The following JSWrap functions take a target function and return an integer id that\n  // indexes into a callback array.\n\n  // The first version assumes that we already have it enclosed in an std::function, while\n  // the second version assumes we have a raw function pointer and wraps it for us.\n\n  template <typename RET_TYPE, typename... ARG_TYPES>\n  size_t JSWrap(const std::function<RET_TYPE(ARG_TYPES...)> & in_fun,\n                const std::string & fun_name=\"\",\n                bool dispose_on_use=false)\n  {\n    // We should never create disposible functions with names!\n    emp_assert(fun_name == \"\" || dispose_on_use == false);\n\n    auto * new_cb =\n      new emp::internal::JSWrap_Callback<RET_TYPE, ARG_TYPES...>(in_fun, dispose_on_use);\n    auto & callback_array = internal::CallbackArray();\n    size_t out_id = callback_array.size();\n    callback_array.push_back(new_cb);\n\n    if (fun_name != \"\") {\n      MAIN_THREAD_EM_ASM({\n          var fun_name = UTF8ToString($1);\n          emp[fun_name] = function() {\n            emp_i.cb_args = [];\n            for (var i = 0; i < arguments.length; i++) {\n              emp_i.cb_args[i] = arguments[i];\n            }\n\n            // Callback to the original function.\n            empCppCallback($0);\n\n            // Return the resulting value\n            return emp_i.cb_return;\n          };\n        }, out_id, fun_name.c_str());\n    }\n\n    return out_id;\n  }\n\n  template <typename RETURN_TYPE, typename... ARG_TYPES>\n  size_t JSWrap( RETURN_TYPE (*in_fun) (ARG_TYPES...),\n                 const std::string & fun_name=\"\", bool dispose_on_use=false )\n  {\n    std::function<RETURN_TYPE(ARG_TYPES...)> fun_ptr(in_fun);\n    return JSWrap(fun_ptr, fun_name, dispose_on_use);\n  }\n\n  #endif // end DOXYGEN_SHOULD_SKIP_THIS\n\n  /// JSWrap takes a C++ function and wraps it in Javascript for easy calling in web code\n  /// @param in_fun a C++ function to wrap\n  /// @param fun_name optionally, a name to call the function on the Javascript size\n  /// @param dispose_on_use should we delete this function after using it?\n  /// @returns the id of the function on the Javascript side\n  template <typename FUN_TYPE>\n  size_t JSWrap(const FUN_TYPE & in_fun, const std::string & fun_name=\"\", bool dispose_on_use=false)\n  {\n    return JSWrap(to_function(in_fun), fun_name, dispose_on_use);\n  }\n\n\n  /// If we want a quick, unnammed, disposable function, use JSWrapOnce\n  template <typename FUN_TYPE>\n  size_t JSWrapOnce(FUN_TYPE && in_fun) { return JSWrap(std::forward<FUN_TYPE>(in_fun), \"\", true); }\n\n\n  /// Cleanup a function pointer when finished with it.\n  void JSDelete( size_t fun_id ) {\n    emp_assert(fun_id > 0);  // Make sure this isn't a null pointer!\n    // @CAO -- Should make sure to clean up named functions on JS side if they exist.\n    auto & callback_array = internal::CallbackArray();\n    delete callback_array[fun_id];\n    callback_array[fun_id] = nullptr;\n  }\n}\n\nextern \"C\" {\n\n/// This function is dispatched by empCppCallback. It should be dispatched on\n/// the thread hosting the main Empirical runtime.\n/// If running with Emscripten pthreads, that would be the worker thread hosting\n/// the main Empirical runtime. If not running with Emscripten pthreads, that\n/// would be the main browser thread.\n/// (In a few limited cases when running with Emscripten pthreads, this function\n/// is called on the main browser thread.)\nvoid empDoCppCallback(const size_t cb_id) {\n\n  // Convert the uint passed in from 32 bits to 64 and THEN convert it to a pointer.\n  auto * cb_obj = emp::internal::CallbackArray()[cb_id];\n\n  // Run DoCallback() on the generic base class type, which is virtual and will call\n  // the correct template automatically.\n  cb_obj->DoCallback();\n\n  // dispatch all pending offscreen canvas updates to the browser thread\n  #ifdef __EMSCRIPTEN_PTHREADS__\n  EM_ASM({\n    emp_i.pending_offscreen_canvas_ids\n      = emp_i.pending_offscreen_canvas_ids || new Set();\n    emp_i.pending_offscreen_canvas_ids.forEach( function( key, val, set ){\n\n      bitmap = emp_i.offscreen_canvases[key].transferToImageBitmap();\n      postMessage(\n        {\n          // this cmd corresponds to a 'nop' on emscripten's part\n          // see https://github.com/emscripten-core/emscripten/blob/bec6d1c1c1c982ecba787b8d51907d2ba51e6555/src/library_pthread.js#L366\n          // and also https://github.com/emscripten-core/emscripten/blob/be50706a38240e2f0679b60d58945f0e296ee9ee/system/lib/pthread/library_pthread_stub.c#L28\n          cmd: 'processQueuedMainThreadWork',\n          emp_canvas_id : key,\n          emp_bitmap : bitmap,\n        },\n        [ bitmap ] // transfer ownership of the bitmap\n      );\n    });\n\n    emp_i.pending_offscreen_canvas_ids.clear();\n\n  });\n  #endif\n\n  // If we have indicated that this callback is single use, delete it now.\n  if (cb_obj->IsDisposable()) {\n    delete cb_obj;\n    emp::internal::CallbackArray()[cb_id] = nullptr;\n  }\n\n}\n\n/// Once you use JSWrap to create an ID, you can call the wrapped function from\n/// Javascript by supplying CPPCallback with the id and all args.\n/// If running with Emscripten pthreads, this method is to be called from the\n/// DOM and it will forward the call to empDoCppCallback on the web worker\n/// hosting Empirical runtime.\n/// If not running with Emscripten pthreads, this method simply calls\n/// empDoCppCallback (on the main browser thread).\nvoid empCppCallback(const size_t cb_id) {\n\n  #ifndef __EMSCRIPTEN_PTHREADS__\n\n    empDoCppCallback( cb_id );\n\n  #else\n\n  // dispatch the callback to the worker thread main was proxied to\n\n    const pthread_t proxy_pthread_id = EM_ASM_INT({\n\n      if ( Object.keys( PThread.pthreads ).length !== 0 ) {\n        console.assert( Object.keys( PThread.pthreads ).length === 1 );\n        return Object.keys(PThread.pthreads)[0];\n      } else return 0;\n\n    });\n\n    emscripten_async_queue_on_thread(\n      proxy_pthread_id,\n      EM_FUNC_SIG_VI, // VI = no return value, one argument\n      (void*) &empDoCppCallback,\n      NULL,\n      cb_id\n    );\n\n  #endif // __EMSCRIPTEN_PTHREADS__\n\n}\n\n} // extern \"C\"\n\n\n\n#endif // #ifndef EMP_WEB_JSWRAP_HPP_INCLUDE\n","// -*- C++ -*-\n//===--------------------------- iosfwd -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOSFWD\n#define _LIBCPP_IOSFWD\n\n/*\n    iosfwd synopsis\n\nnamespace std\n{\n\ntemplate<class charT> struct char_traits;\ntemplate<>            struct char_traits<char>;\ntemplate<>            struct char_traits<char8_t>;  // C++20\ntemplate<>            struct char_traits<char16_t>;\ntemplate<>            struct char_traits<char32_t>;\ntemplate<>            struct char_traits<wchar_t>;\n\ntemplate<class T>     class allocator;\n\nclass ios_base;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ios;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_streambuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_istream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ostream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_iostream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringbuf;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_istringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_ostringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_filebuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ifstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ofstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_fstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class istreambuf_iterator;\ntemplate <class charT, class traits = char_traits<charT> > class ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class state> class fpos;\ntypedef fpos<char_traits<char>::state_type>    streampos;\ntypedef fpos<char_traits<wchar_t>::state_type> wstreampos;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <wchar.h>  // for mbstate_t\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS ios_base;\n\ntemplate<class _CharT>  struct _LIBCPP_TEMPLATE_VIS char_traits;\ntemplate<> struct char_traits<char>;\n#ifndef _LIBCPP_NO_HAS_CHAR8_T\ntemplate<> struct char_traits<char8_t>;\n#endif\ntemplate<> struct char_traits<char16_t>;\ntemplate<> struct char_traits<char32_t>;\ntemplate<> struct char_traits<wchar_t>;\n\ntemplate<class _Tp>     class _LIBCPP_TEMPLATE_VIS allocator;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_ios;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_streambuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_istream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_ostream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_iostream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_stringbuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_istringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_ostringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_stringstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_filebuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_ifstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_ofstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_fstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS istreambuf_iterator;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class _State>             class _LIBCPP_TEMPLATE_VIS fpos;\ntypedef fpos<mbstate_t>    streampos;\ntypedef fpos<mbstate_t>    wstreampos;\n#ifndef _LIBCPP_NO_HAS_CHAR8_T\ntypedef fpos<mbstate_t>    u8streampos;\n#endif\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntypedef fpos<mbstate_t>    u16streampos;\ntypedef fpos<mbstate_t>    u32streampos;\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n#if defined(_NEWLIB_VERSION)\n// On newlib, off_t is 'long int'\ntypedef long int streamoff;         // for char_traits in <string>\n#else\ntypedef long long streamoff;        // for char_traits in <string>\n#endif\n\ntemplate <class _CharT,             // for <stdexcept>\n          class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_string;\ntypedef basic_string<char, char_traits<char>, allocator<char> > string;\ntypedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;\n\n\n// Include other forward declarations here\ntemplate <class _Tp, class _Alloc = allocator<_Tp> >\nclass _LIBCPP_TEMPLATE_VIS vector;\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOSFWD\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2019.\n *\n *  @file Widget.hpp\n *  @brief Widgets maintain individual components on a web page and link to Elements\n *\n *  Each HTML Widget has all of its details stored in a WidgetInfo object; Multiple Widgets can\n *  be attached to the same WidgetInfo, simplifying the usage.  All the library user needs to\n *  worry about is the Widget object itself; the WidgetInfo will be managed behind the scenes.\n *\n *  WidgetInfo contains the basic information for all Widgets\n *  Widget is a generic base class, with a shared pointer to WidgetInfo\n *  WidgetFacet is a template that allows Set* methods to return derived return-type.\n *\n *  In other files, Widgets will be used to define specific elements.\n *  ELEMENTInfo maintains information about the specific widget (derived from WidgetInfo)\n *  ELEMENT interfaces to ELEMENTInfo so multiple elements use same core; derived from WidgetFacet\n *\n *  Library users should not need to access Widgets directly, only specific derived types.\n *\n *  Tips for using widgets:\n *\n *  1. If you are about to make a lot of changes at once, run Freeze(), make the changes, and\n *     then run Activate() again.  Freeze prevents widgets from being updated immediately.\n *\n *  2. Trust the Widget to handle all of the manipulation behind the scenes\n *\n */\n\n#ifndef EMP_WEB_WIDGET_HPP_INCLUDE\n#define EMP_WEB_WIDGET_HPP_INCLUDE\n\n\n#include <string>\n\n#include \"../base/errors.hpp\"\n#include \"../base/vector.hpp\"\n#include \"../control/Signal.hpp\"\n#include \"../debug/mem_track.hpp\"\n#include \"../meta/meta.hpp\"\n\n#include \"events.hpp\"\n#include \"Font.hpp\"\n#include \"init.hpp\"\n#include \"WidgetExtras.hpp\"\n\nnamespace emp {\nnamespace web {\n\n    #ifndef DOXYGEN_SHOULD_SKIP_THIS\n  // Setup some types we will need later\n  namespace internal {\n    // Pre-declare WidgetInfo so classes can inter-operate.\n    class WidgetInfo;\n    class DivInfo;\n    class TableInfo;\n\n    /// Quick method for generating unique Widget ID numbers when not otherwise specified.\n    static size_t NextWidgetNum(bool inc_num=true) {\n      static size_t next_id = 0;\n      if (!inc_num) return next_id;\n      return next_id++;\n    }\n\n    /// Quick method for generating unique string IDs for Widgets.\n    static std::string NextWidgetID() {\n      return emp::to_string(\"emp__\", NextWidgetNum());\n    }\n\n    /// Base class for command-objects that can be fed into widgets.\n    class WidgetCommand {\n    public:\n      virtual ~WidgetCommand() { ; }\n      virtual bool Trigger(WidgetInfo &) const = 0;\n    };\n  }\n  #endif // DOXYGEN_SHOULD_SKIP_THIS\n\n  /// Widget is effectively a smart pointer to a WidgetInfo object, plus some basic accessors.\n  class Widget {\n    friend internal::WidgetInfo; friend internal::DivInfo; friend internal::TableInfo;\n  protected:\n    using WidgetInfo = internal::WidgetInfo;\n    WidgetInfo * info;                        ///< Information associated with this widget.\n\n    /// If an Append doesn't work with current class, forward it to the parent and try there.\n    template <typename FWD_TYPE> Widget & ForwardAppend(FWD_TYPE && arg);\n\n    /// Set the information associated with this widget.\n    Widget & SetInfo(WidgetInfo * in_info);\n\n    /// Internally, we can treat a Widget as a pointer to its WidgetInfo.\n    WidgetInfo * operator->() { return info; }\n\n    /// Give derived classes the ability to access widget info.\n    static WidgetInfo * Info(const Widget & w) { return w.info; }\n\n    /// Four activity states for any widget:\n    ///   INACTIVE - Not be in DOM at all.\n    ///   WAITING  - Will become active once the page finishes loading.\n    ///   FROZEN   - Part of DOM, but not updating on the screen.\n    ///   ACTIVE   - Fully active; changes are reflected as they happen.\n\n    enum ActivityState { INACTIVE, WAITING, FROZEN, ACTIVE };\n\n    /// Default name for un-initialized widgets.\n    static const std::string no_name;\n\n  public:\n    /// When Widgets are first created, they should be provided with an ID.\n    Widget(const std::string & id);\n    Widget(WidgetInfo * in_info=nullptr);\n    Widget(const Widget & in) : Widget(in.info) { ; }\n    Widget & operator=(const Widget & in) { return SetInfo(in.info); }\n\n    virtual ~Widget();\n\n    /// Test if this widget is valid.\n    bool IsNull() const { return info == nullptr; }\n\n    /// Some debugging helpers...\n    std::string GetInfoTypeName() const;\n\n    bool IsInactive() const;  ///< Test if the activity state of this widget is currently INACTIVE\n    bool IsWaiting() const;   ///< Test if the activity state of this widget is currently WAITING\n    bool IsFrozen() const;    ///< Test if the activity state of this widget is currently FROZEN\n    bool IsActive() const;    ///< Test if the activity state of this widget is currently ACTIVE\n\n    bool AppendOK() const;    ///< Is it okay to add more internal Widgets into this one?\n    void PreventAppend();     ///< Disallow further appending to this Widget.\n\n    bool IsButton()   const { return GetInfoTypeName() == \"ButtonInfo\"; }\n    bool IsCanvas()   const { return GetInfoTypeName() == \"CanvasInfo\"; }\n    bool IsDiv()      const { return GetInfoTypeName() == \"DivInfo\"; }\n    bool IsImage()    const { return GetInfoTypeName() == \"ImageInfo\"; }\n    bool IsInput()    const { return GetInfoTypeName() == \"InputInfo\"; }\n    bool IsSelector() const { return GetInfoTypeName() == \"SelectorInfo\"; }\n    bool IsTable()    const { return GetInfoTypeName() == \"TableInfo\"; }\n    bool IsText()     const { return GetInfoTypeName() == \"TextInfo\"; }\n    bool IsTextArea() const { return GetInfoTypeName() == \"TextAreaInfo\"; }\n    bool IsTextFeed() const { return GetInfoTypeName() == \"TextFeedInfo\"; }\n\n    bool IsD3Visualization() const { return GetInfoTypeName() == \"D3VisualizationInfo\"; }\n\n    const std::string & GetID() const;  ///< What is the HTML string ID for this Widget?\n\n    /// Retrieve a specific CSS trait associated with this Widget.\n    /// Note: CSS-related options may be overridden in derived classes that have multiple styles.\n    virtual const std::string & GetCSS(const std::string & setting) const;\n\n    /// Determine is a CSS trait has been set on this Widget.\n    virtual bool HasCSS(const std::string & setting);\n\n    /// Retrieve a specific attribute associated with this Widget.\n    virtual const std::string & GetAttr(const std::string & setting) const;\n\n    /// Determine is an attribute has been set on this Widget.\n    virtual bool HasAttr(const std::string & setting);\n\n    /// Are two Widgets refering to the same HTML object?\n    bool operator==(const Widget & in) const { return info == in.info; }\n\n    /// Are two Widgets refering to different HTML objects?\n    bool operator!=(const Widget & in) const { return info != in.info; }\n\n    /// Conver Widget to bool (I.e., is this Widget active?)\n    operator bool() const { return info != nullptr; }\n\n    const std::string & GetTitle() const { return GetAttr(\"title\"); }  /// Get current tooltip on this widget.\n\n    double GetXPos();          ///< Get the X-position of this Widget within its parent.\n    double GetYPos();          ///< Get the Y-position of this Widget within its parent.\n    double GetWidth();         ///< Get the width of this Widget on screen.\n    double GetHeight();        ///< Get the height of this Widget on screen.\n    double GetInnerWidth();    ///< Get the width of this Widget not including padding.\n    double GetInnerHeight();   ///< Get the height of this Widget not including padding.\n    double GetOuterWidth();    ///< Get the width of this Widget including all padding.\n    double GetOuterHeight();   ///< Get the height of this Widget including all padding.\n\n    /// Make this widget live, so changes occur immediately (once document is ready)\n    void Activate();\n\n    /// Record changes internally, but keep static screen until Activate() is called.\n    void Freeze();\n\n    /// Record changes internally and REMOVE from screen until Activate is called.\n    /// (Argument is for recursive, internal use only.)\n    virtual void Deactivate(bool top_level=true);\n\n    /// Toggle between Active and Deactivated.\n    bool ToggleActive();\n\n    /// Clear and redraw the current widget on the screen.\n    void Redraw();\n\n    /// Look up previously created elements, by type.\n    Widget & Find(const std::string & test_name);\n\n    /// Add a dependant to this Widget that should be redrawn when it is.\n    Widget & AddDependant(const Widget & w);\n\n    /// Setup << operator to redirect to Append; option preparation can be overridden.\n    virtual void PrepareAppend() { ; }\n    template <typename IN_TYPE> Widget operator<<(IN_TYPE && in_val);\n\n    /// Debug...\n    std::string GetInfoType() const;\n  };\n\n  #ifndef DOXYGEN_SHOULD_SKIP_THIS\n  namespace internal {\n\n    // WidgetInfo is a base class containing information needed by all GUI widget classes\n    // (Buttons, Images, etc...).  It take in a return type to be cast to for accessors.\n\n    class WidgetInfo {\n    public:\n      // Smart-pointer info\n      int ptr_count;                  ///< How many widgets are pointing to this info?\n\n      // Basic info about a widget\n      std::string id;                 ///< ID used for associated DOM element.\n      WidgetExtras extras;            ///< HTML attributes, CSS style, and listeners for web events.\n\n      // Track hierarchy\n      WidgetInfo * parent;            ///< Which WidgetInfo is this one contained within?\n      emp::vector<Widget> dependants; ///< Widgets to be refreshed if this one is triggered\n      Widget::ActivityState state;    ///< Is this element active in DOM?\n\n      emp::Signal<void()> on_update_js_signal; /// Signal for JavaScript functions to be called with TriggerJS()\n\n      /// WidgetInfo cannot be built unless within derived class, so constructor is protected\n      WidgetInfo(const std::string & in_id=\"\")\n        : ptr_count(1), id(in_id), parent(nullptr), state(Widget::INACTIVE)\n      {\n        EMP_TRACK_CONSTRUCT(WebWidgetInfo);\n        if (id == \"\") id = NextWidgetID();\n      }\n\n      /// No copies of INFO allowed\n      WidgetInfo(const WidgetInfo &) = delete;\n      WidgetInfo & operator=(const WidgetInfo &) = delete;\n\n      virtual ~WidgetInfo() {\n        EMP_TRACK_DESTRUCT(WebWidgetInfo);\n      }\n\n      /// Debugging helpers...\n      virtual std::string GetTypeName() const { return \"WidgetInfo\"; }\n\n      // If not overloaded, pass along widget registration to parent.\n      virtual void Register_recurse(Widget & w) { if (parent) parent->Register_recurse(w); }\n      virtual void Register(Widget & w) { if (parent) parent->Register(w); }\n      virtual void Unregister_recurse(Widget & w) { if (parent) parent->Unregister_recurse(w); }\n      virtual void Unregister(Widget & w) { if (parent) parent->Unregister(w); }\n\n      // Some nodes can have children and need to be able to recursively register them.\n      virtual void RegisterChildren(DivInfo * registrar) { ; }   // No children by default.\n      virtual void UnregisterChildren(DivInfo * registrar) { ; } // No children by default.\n\n      virtual void AddChild(Widget in) { ; }\n      virtual void RemoveChild(Widget & child) { ; }\n\n      // Record dependants.  Dependants are only acted upon when this widget's action is\n      // triggered (e.g. a button is pressed)\n      void AddDependant(Widget in) {\n        dependants.emplace_back(in);\n      }\n\n      template <typename... T>\n      void AddDependants(Widget first, T... widgets) {\n        AddDependant(first);\n        AddDependants(widgets...);\n      }\n\n      void AddDependants() { ; }\n\n      void UpdateDependants() { for (auto & d : dependants) d->ReplaceHTML(); }\n\n\n      // Activate is delayed until the document is ready, when DoActivate will be called.\n      virtual void DoActivate(bool top_level=true) {\n\n        if ( state != Widget::ACTIVE ) {\n          state = Widget::ACTIVE;\n          if ( top_level ) ReplaceHTML();\n        }\n\n      }\n\n      virtual bool AppendOK() const { return false; } // Most widgets can't be appended to.\n      virtual void PreventAppend() { emp_assert(false, GetTypeName()); } // Only for appendable widgets.\n\n      // By default, elements should forward unknown appends to their parents.\n      virtual Widget Append(const std::string & text) { return ForwardAppend(text); }\n      virtual Widget Append(const std::function<std::string()> & fn) { return ForwardAppend(fn); }\n      virtual Widget Append(Widget info) { return ForwardAppend(info); }\n      virtual Widget Append(const Font & font) { return ForwardAppend(font); }\n\n      // Handle special commands\n      virtual Widget Append(const emp::web::internal::WidgetCommand & cmd) {\n        if (cmd.Trigger(*this)) return Widget(this);\n        return ForwardAppend(cmd);  // Otherwise pass the Close to parent!\n      }\n\n      // If overloaded versions of Append don't resolve properly, collect everything else\n      // with this generic version and try to collect more information about it.\n      template <typename T>\n      Widget Append(const T & val) {\n        // First, test if we are working with a Widget command.\n        if constexpr ( std::is_base_of<Widget,T>() ) {\n          const Widget widget = val;\n          return Append(widget);\n        }\n\n        // First, test if we are working with a Widget command.\n        if constexpr ( std::is_base_of<WidgetCommand,T>() ) {\n          const WidgetCommand & cmd = val;\n          return Append(cmd);\n        }\n\n        // Next, test if this if an invocable function\n        // @CAO: We should make sure it returns a string when called with no arguments.\n        else if constexpr ( std::is_invocable<T>() ) {\n          std::function<std::string()> fun_val( val );\n          return Append(fun_val);\n        }\n\n        // If we are given a vector, we should try and add each element individually.\n        // Allows one to stream ___.Children() to get similar behavior to display: contents\n        // which is unsupported on some browsers\n        else if constexpr ( is_emp_vector<T>::value ) {\n          Widget last(this);\n          for (auto & item : val) {\n            last = Append(item);\n          }\n          return last;\n        }\n\n        // Anything else we should just try to convert to a string, and used that.\n        else {\n          return Append(emp::to_string(val));\n        }\n      }\n\n      // If an Append doesn't work with current class, forward it to the parent.\n      template <typename FWD_TYPE>\n      Widget ForwardAppend(FWD_TYPE && arg) {\n        emp_assert(parent && \"Trying to forward append to parent, but no parent!\", id);\n        return parent->Append(std::forward<FWD_TYPE>(arg));\n      }\n\n      // All derived widgets must supply a mechanism for providing associated HTML code.\n      virtual void GetHTML(std::stringstream & ss) = 0;\n\n      // Derived widgets may also provide JavaScript code to be run on redraw.\n      virtual void TriggerJS() {\n        on_update_js_signal.Trigger();\n      }\n\n      // Add JS function to be executed when TriggerJS() is called\n      SignalKey RegisterUpdateJS(const std::function<void()> &fun){\n        return on_update_js_signal.AddAction(fun);\n      }\n\n      // Assume that the associated ID exists and replace it with the current HTML code.\n      virtual void ReplaceHTML() {\n        // If this node is frozen, don't change it!\n        if (state == Widget::FROZEN) return;\n\n        // If this node is active, put its contents in ss; otherwise make ss an empty span.\n        std::stringstream ss;\n        if (state == Widget::ACTIVE) GetHTML(ss);\n        else ss << \"<span id='\" << id << \"'></span>\";\n\n        // Now do the replacement.\n        MAIN_THREAD_EM_ASM({\n            var widget_id = UTF8ToString($0);\n            var out_html = UTF8ToString($1);\n            $('#' + widget_id).replaceWith(out_html);\n          }, id.c_str(), ss.str().c_str());\n\n        // If active update style, trigger JS, and recurse to children!\n        if (state == Widget::ACTIVE) {\n          extras.Apply(id); // Update the attributes, style, and listeners.\n          TriggerJS();      // Run associated Javascript code, if any (e.g., to fill out a canvas)\n        }\n      }\n\n    public:\n      virtual std::string GetType() { return \"web::WidgetInfo\"; }\n    };\n\n  }  // end namespaceinternal\n  #endif // DOXYGEN_SHOULD_SKIP_THIS\n\n  // Implementation of Widget methods...\n\n  Widget::Widget(const std::string & id) {\n    emp_assert(has_whitespace(id) == false);\n    // We are creating a new widget; in derived class, make sure:\n    // ... to assign info pointer to new object of proper *Info type\n    // ... NOT to increment info->ptr_count since it's initialized to 1.\n    EMP_TRACK_CONSTRUCT(WebWidget);\n  }\n\n  Widget::Widget(WidgetInfo * in_info) {\n    info = in_info;\n    if (info) info->ptr_count++;\n    EMP_TRACK_CONSTRUCT(WebWidget);\n  }\n\n  Widget::~Widget() {\n    // We are deleting a widget.\n    if (info) {\n      info->ptr_count--;\n      if (info->ptr_count == 0) delete info;\n    }\n    EMP_TRACK_DESTRUCT(WebWidget);\n  }\n\n  std::string Widget::GetInfoTypeName() const { if (IsNull()) return \"NULL\"; return info->GetTypeName(); }\n\n  Widget & Widget::SetInfo(WidgetInfo * in_info) {\n    // If the widget is already set correctly, stop here.\n    if (info == in_info) return *this;\n\n    // Clean up the old info that was previously pointed to.\n    if (info) {\n      info->ptr_count--;\n      if (info->ptr_count == 0) delete info;\n    }\n\n    // Setup new info.\n    info = in_info;\n    if (info) info->ptr_count++;\n\n    return *this;\n  }\n\n  bool Widget::IsInactive() const { if (!info) return false; return info->state == INACTIVE; }\n  bool Widget::IsWaiting() const { if (!info) return false; return info->state == WAITING; }\n  bool Widget::IsFrozen() const { if (!info) return false; return info->state == FROZEN; }\n  bool Widget::IsActive() const { if (!info) return false; return info->state == ACTIVE; }\n\n  bool Widget::AppendOK() const { if (!info) return false; return info->AppendOK(); }\n  void Widget::PreventAppend() { emp_assert(info); info->PreventAppend(); }\n\n  const std::string Widget::no_name = \"(none)\";\n  const std::string & Widget::GetID() const { return info ? info->id : no_name; }\n\n  const std::string & Widget::GetCSS(const std::string & setting) const {\n    return info ? info->extras.GetStyle(setting) : emp::empty_string();\n  }\n  bool Widget::HasCSS(const std::string & setting) {\n    return info ? info->extras.HasStyle(setting) : false;\n  }\n\n  const std::string & Widget::GetAttr(const std::string & setting) const {\n    return info ? info->extras.GetAttr(setting) : emp::empty_string();\n  }\n  bool Widget::HasAttr(const std::string & setting) {\n    return info ? info->extras.HasAttr(setting) : false;\n  }\n\n  double Widget::GetXPos() {\n    if (!info) return -1.0;\n    emp_assert(GetID() != \"\");  // Must have a name!\n    return MAIN_THREAD_EM_ASM_DOUBLE({\n      var id = UTF8ToString($0);\n      var rect = $('#' + id).position();\n      if (rect === undefined) return -1.0;\n      return rect.left;\n    }, GetID().c_str());\n  }\n\n  double Widget::GetYPos() {\n    if (!info) return -1.0;\n    emp_assert(GetID() != \"\");  // Must have a name!\n    return MAIN_THREAD_EM_ASM_DOUBLE({\n      var id = UTF8ToString($0);\n      var rect = $('#' + id).position();\n      if (rect === undefined) return -1.0;\n      return rect.top;\n    }, GetID().c_str());\n  }\n\n  double Widget::GetWidth(){\n    if (!info) return -1.0;\n    emp_assert(GetID() != \"\");  // Must have a name!\n    return MAIN_THREAD_EM_ASM_DOUBLE({\n      var id = UTF8ToString($0);\n      return $('#' + id).width();\n    }, GetID().c_str());\n  }\n  double Widget::GetHeight(){\n    if (!info) return -1.0;\n    emp_assert(GetID() != \"\");  // Must have a name!\n    return MAIN_THREAD_EM_ASM_DOUBLE({\n      var id = UTF8ToString($0);\n      return $('#' + id).height();\n    }, GetID().c_str());\n  }\n  double Widget::GetInnerWidth(){\n    if (!info) return -1.0;\n    emp_assert(GetID() != \"\");  // Must have a name!\n    return MAIN_THREAD_EM_ASM_DOUBLE({\n      var id = UTF8ToString($0);\n      return $('#' + id).innerWidth();\n    }, GetID().c_str());\n  }\n  double Widget::GetInnerHeight(){\n    if (!info) return -1.0;\n    emp_assert(GetID() != \"\");  // Must have a name!\n    return MAIN_THREAD_EM_ASM_DOUBLE({\n      var id = UTF8ToString($0);\n      return $('#' + id).innerHeight();\n    }, GetID().c_str());\n  }\n  double Widget::GetOuterWidth(){\n    if (!info) return -1.0;\n    emp_assert(GetID() != \"\");  // Must have a name!\n    return MAIN_THREAD_EM_ASM_DOUBLE({\n      var id = UTF8ToString($0);\n      return $('#' + id).outerWidth();\n    }, GetID().c_str());\n  }\n  double Widget::GetOuterHeight(){\n    if (!info) return -1.0;\n    emp_assert(GetID() != \"\");  // Must have a name!\n    return MAIN_THREAD_EM_ASM_DOUBLE({\n      var id = UTF8ToString($0);\n      return $('#' + id).outerHeight();\n    }, GetID().c_str());\n  }\n\n  void Widget::Activate() {\n    auto * cur_info = info;\n    info->state = WAITING;\n    OnDocumentReady( std::function<void(void)>([cur_info](){ cur_info->DoActivate(); }) );\n    OnDocumentLoad( std::function<void(void)>([cur_info](){ cur_info->DoActivate(); }) );\n  }\n\n  void Widget::Freeze() {\n    info->state = FROZEN;\n  }\n\n  void Widget::Deactivate(bool top_level) {\n    if (!info || info->state == INACTIVE) return;  // Skip if we are not active.\n    info->state = INACTIVE;\n    if (top_level) info->ReplaceHTML();            // If at top level, clear the contents\n  }\n\n  bool Widget::ToggleActive() {\n    emp_assert(info);\n    if (info->state != INACTIVE) Deactivate();\n    else Activate();\n    return info->state;\n  }\n\n  void Widget::Redraw() {\n    emp_assert(info);\n    info->ReplaceHTML();\n  }\n\n  Widget & Widget::AddDependant(const Widget & w) {\n    info->AddDependant(w);\n    return *this;\n  }\n\n  template <typename IN_TYPE>\n  Widget Widget::operator<<(IN_TYPE && in_val) {\n    PrepareAppend();\n    return info->Append(std::forward<IN_TYPE>(in_val));\n  }\n\n  std::string Widget::GetInfoType() const {\n    if (!info) return \"UNINITIALIZED\";\n    return info->GetType();\n  }\n\n  #ifndef DOXYGEN_SHOULD_SKIP_THIS\n  namespace internal {\n\n    /// WidgetFacet is a template that provides accessors into Widget with a derived return type.\n    template <typename RETURN_TYPE>\n    class WidgetFacet : public Widget {\n    protected:\n      /// WidgetFacet cannot be built unless within derived class, so constructors are protected\n      WidgetFacet(const std::string & in_id=\"\") : Widget(in_id) { ; }\n      WidgetFacet(const WidgetFacet & in) : Widget(in) { ; }\n      WidgetFacet(const Widget & in) : Widget(in) {\n        // Converting from a generic widget; make sure type is correct or non-existant!\n        emp_assert(!in || dynamic_cast<typename RETURN_TYPE::INFO_TYPE *>( Info(in) ) != NULL,\n                   in.GetID());\n      }\n      WidgetFacet(WidgetInfo * in_info) : Widget(in_info) { ; }\n      WidgetFacet & operator=(const WidgetFacet & in) { Widget::operator=(in); return *this; }\n      virtual ~WidgetFacet() { ; }\n\n      /// CSS-related options may be overridden in derived classes that have multiple styles.\n      /// By default DoCSS will track the new information and apply it (if active) to the widget.\n      virtual void DoCSS(const std::string & setting, const std::string & value) {\n        info->extras.style.DoSet(setting, value);\n        if (IsActive()) Style::Apply(info->id, setting, value);\n      }\n\n      virtual void DoCSS(const std::string & class_) {\n        info->extras.style.AddClass(class_);\n        if (IsActive()) Style::ApplyClass(info->id, class_);\n      }\n\n      /// Attr-related options may be overridden in derived classes that have multiple attributes.\n      /// By default DoAttr will track the new information and apply it (if active) to the widget.\n      virtual void DoAttr(const std::string & setting, const std::string & value) {\n        info->extras.attr.DoSet(setting, value);\n        if (IsActive()) Attributes::Apply(info->id, setting, value);\n      }\n\n      /// New attribute value will be appended to any existing values for this widget, not overridden.\n      virtual void DoAddAttr(const std::string attr, const std::string & value){\n        info->extras.attr.DoAddAttr(attr, value);\n        if (IsActive()) Attributes::Apply(info->id, attr, info->extras.attr.GetAttrValue(attr));\n      }\n\n      /// Listener options may be overridden in derived classes that have multiple listen targets.\n      /// By default DoListen will track new listens and set them up immediately, if active.\n      virtual void DoListen(const std::string & event_name, size_t fun_id) {\n        info->extras.listen.Set(event_name, fun_id);\n        if (IsActive()) Listeners::Apply(info->id, event_name, fun_id);\n      }\n\n    public:\n      using return_t = RETURN_TYPE;\n\n      std::string GetHTML(){\n        std::stringstream ss;\n        info->GetHTML(ss);\n        return ss.str();\n      }\n      /// Set a specific CSS value for this widget.\n      template <typename SETTING_TYPE>\n      return_t & SetCSS(const std::string & setting, SETTING_TYPE && value) {\n        emp_assert(info != nullptr);\n        DoCSS(setting, emp::to_string(value));\n        return (return_t &) *this;\n      }\n\n      /// Set a specific Attribute value for this widget.\n      template <typename SETTING_TYPE>\n      return_t & SetAttr(const std::string & setting, SETTING_TYPE && value) {\n        emp_assert(info != nullptr);\n        DoAttr(setting, emp::to_string(value));\n        return (return_t &) *this;\n      }\n\n      /// Multiple CSS settings can be provided simultaneously.\n      template <typename T1, typename T2, typename... OTHER_SETTINGS>\n      return_t & SetCSS(const std::string & setting1, T1 && val1,\n                        const std::string & setting2, T2 && val2,\n                        OTHER_SETTINGS... others) {\n        SetCSS(setting1, val1);                      // Set the first CSS value.\n        return SetCSS(setting2, val2, others...);    // Recurse to the others.\n      }\n\n      /// Add more than one value to an attribute.\n      template <typename T>\n      return_t & AddAttr(const std::string attr, T && value){\n        emp_assert(info != nullptr);\n        DoAddAttr(attr, emp::to_string(value));\n        return (return_t &) *this;\n      }\n\n      /// Multiple Attributes can be added to simultaneously.\n      template <typename T1, typename T2, typename... OTHER_SETTINGS>\n      return_t & AddAttr(const std::string & setting1, T1 && val1,\n                            const std::string & setting2, T2 && val2,\n                            OTHER_SETTINGS... others) {\n        AddAttr(setting1, val1);                      // Set the first CSS value.\n        return AddAttr(setting2, val2, others...);    // Recurse to the others.\n      }\n\n      /// Multiple Attributes can be provided simultaneously.\n      template <typename T1, typename T2, typename... OTHER_SETTINGS>\n      return_t & SetAttr(const std::string & setting1, T1 && val1,\n                            const std::string & setting2, T2 && val2,\n                            OTHER_SETTINGS... others) {\n        SetAttr(setting1, val1);                      // Set the first CSS value.\n        return SetAttr(setting2, val2, others...);    // Recurse to the others.\n      }\n\n      /// Allow multiple CSS settings to be provided as a single object.\n      /// (still go through DoCSS given need for virtual re-routing.)\n      return_t & SetCSS(const Style & in_style) {\n\n        emp_assert(info != nullptr);\n        for (const auto & s : in_style.GetMap()) {\n          DoCSS(s.first, s.second);\n        }\n        for (const auto & s : in_style.GetClasses()) {\n          DoCSS(s);\n        }\n        return (return_t &) *this;\n      }\n\n      /// Allow multiple Attr settings to be provided as a single object.\n      /// (still go through DoAttr given need for virtual re-routing.)\n      return_t & SetAttr(const Attributes & in_attr) {\n        emp_assert(info != nullptr);\n        for (const auto & a : in_attr.GetMap()) {\n          DoAttr(a.first, a.second);\n        }\n        return (return_t &) *this;\n      }\n\n      /// Provide an event and a function that will be called when that event is triggered.\n      /// In this case, the function as no arguments.\n      return_t & On(const std::string & event_name, const std::function<void()> & fun) {\n        emp_assert(info != nullptr);\n        size_t fun_id = JSWrap(fun);\n        DoListen(event_name, fun_id);\n        return (return_t &) *this;\n      }\n\n      /// Provide an event and a function that will be called when that event is triggered.\n      /// In this case, the function takes a keyboard event as an argument, with full info about keyboard.\n      return_t & On(const std::string & event_name,\n                    const std::function<void(KeyboardEvent evt)> & fun) {\n        emp_assert(info != nullptr);\n        size_t fun_id = JSWrap(fun);\n        DoListen(event_name, fun_id);\n        return (return_t &) *this;\n      }\n\n      /// Provide an event and a function that will be called when that event is triggered.\n      /// In this case, the function takes a mouse event as an argument, with full info about mouse.\n      return_t & On(const std::string & event_name,\n                    const std::function<void(MouseEvent evt)> & fun) {\n        emp_assert(info != nullptr);\n        size_t fun_id = JSWrap(fun);\n        DoListen(event_name, fun_id);\n        return (return_t &) *this;\n      }\n\n      /// Provide an event and a function that will be called when that event is triggered.\n      /// In this case, the function takes two doubles which will be filled in with mouse coordinates.\n      return_t & On(const std::string & event_name,\n                    const std::function<void(double,double)> & fun) {\n        emp_assert(info != nullptr);\n        auto fun_cb = [this, fun](MouseEvent evt){\n          double x = evt.clientX - GetXPos();\n          double y = evt.clientY - GetYPos();\n          fun(x,y);\n        };\n        size_t fun_id = JSWrap(fun_cb);\n        DoListen(event_name, fun_id);\n        return (return_t &) *this;\n      }\n\n      /// Provide a function to be called when the window is resized.\n      template <typename T> return_t & OnResize(T && arg) { return On(\"resize\", arg); }\n\n      /// Provide a function to be called when the mouse button is clicked in this Widget.\n      template <typename T> return_t & OnClick(T && arg) { return On(\"click\", arg); }\n\n      /// Provide a function to be called when the mouse button is double clicked in this Widget.\n      template <typename T> return_t & OnDoubleClick(T && arg) { return On(\"dblclick\", arg); }\n\n      /// Provide a function to be called when the mouse button is pushed down in this Widget.\n      template <typename T> return_t & OnMouseDown(T && arg) { return On(\"mousedown\", arg); }\n\n      /// Provide a function to be called when the mouse button is released in this Widget.\n      template <typename T> return_t & OnMouseUp(T && arg) { return On(\"mouseup\", arg); }\n\n      /// Provide a function to be called whenever the mouse moves in this Widget.\n      template <typename T> return_t & OnMouseMove(T && arg) { return On(\"mousemove\", arg); }\n\n      /// Provide a function to be called whenever the mouse leaves the Widget.\n      template <typename T> return_t & OnMouseOut(T && arg) { return On(\"mouseout\", arg); }\n\n      /// Provide a function to be called whenever the mouse moves over the Widget.\n      template <typename T> return_t & OnMouseOver(T && arg) { return On(\"mouseover\", arg); }\n\n      /// Provide a function to be called whenever the mouse wheel moves in this Widget.\n      template <typename T> return_t & OnMouseWheel(T && arg) { return On(\"mousewheel\", arg); }\n\n      /// Provide a function to be called whenever a key is pressed down in this Widget.\n      template <typename T> return_t & OnKeydown(T && arg) { return On(\"keydown\", arg); }\n\n      /// Provide a function to be called whenever a key is pressed down and released in this Widget.\n      template <typename T> return_t & OnKeypress(T && arg) { return On(\"keypress\", arg); }\n\n      /// Provide a function to be called whenever a key is pressed released in this Widget.\n      template <typename T> return_t & OnKeyup(T && arg) { return On(\"keyup\", arg); }\n\n      /// Provide a function to be called whenever text is copied in this Widget.\n      template <typename T> return_t & OnCopy(T && arg) { return On(\"copy\", arg); }\n\n      /// Provide a function to be called whenever text is cut in this Widget.\n      template <typename T> return_t & OnCut(T && arg) { return On(\"cut\", arg); }\n\n      /// Provide a function to be called whenever text is pasted in this Widget.\n      template <typename T> return_t & OnPaste(T && arg) { return On(\"paste\", arg); }\n\n      /// Create a tooltip for this Widget.\n      return_t & SetTitle(const std::string & _in) { return SetAttr(\"title\", _in); }\n\n      /// Update the width of this Widget.\n      /// @param w new width of the widget\n      /// @param unit defaults to pixels (\"px\"), but can also be a measured distance (e.g, \"inches\") or a percentage(\"%\")\n      return_t & SetWidth(double w, const std::string & unit=\"px\") {\n        return SetCSS(\"width\", emp::to_string(w, unit) );\n      }\n\n      /// Update the height of this Widget.\n      /// @param h new height for the widget\n      /// @param unit defaults to pixels (\"px\"), but can also be a measured distance (e.g, \"inches\") or a percentage(\"%\")\n      return_t & SetHeight(double h, const std::string & unit=\"px\") {\n        return SetCSS(\"height\", emp::to_string(h, unit) );\n      }\n\n      /// Update the size (width and height) of this widget.\n      /// @param w widget width\n      /// @param h widget height\n      /// @param unit defaults to pixels (\"px\"), but can also be a measured distance (e.g, \"inches\") or a percentage(\"%\")\n      return_t & SetSize(double w, double h, const std::string & unit=\"px\") {\n        SetWidth(w, unit); return SetHeight(h, unit);\n      }\n\n      /// Move this widget to the center of its container.\n      return_t & Center() { return SetCSS(\"margin\", \"auto\"); }\n\n      /// Set the x-y position of this widget within its container.\n      return_t & SetPosition(int x, int y, const std::string & unit=\"px\",\n                             const std::string & pos_type=\"absolute\",\n                             const std::string & x_anchor=\"left\",\n                             const std::string & y_anchor=\"top\") {\n        return SetCSS(\"position\", pos_type,\n                      x_anchor, emp::to_string(x, unit),\n                      y_anchor, emp::to_string(y, unit));\n      }\n\n      /// Set the x-y position of this Widget within its container, using the TOP-RIGHT as an anchor.\n      return_t & SetPositionRT(int x, int y, const std::string & unit=\"px\")\n        { return SetPosition(x, y, unit, \"absolute\", \"right\", \"top\"); }\n\n      /// Set the x-y position of this Widget within its container, using the BOTTOM-RIGHT as an anchor.\n      return_t & SetPositionRB(int x, int y, const std::string & unit=\"px\")\n        { return SetPosition(x, y, unit, \"absolute\", \"right\", \"bottom\"); }\n\n      /// Set the x-y position of this Widget within its container, using the BOTTOM-LEFT as an anchor.\n      return_t & SetPositionLB(int x, int y, const std::string & unit=\"px\")\n        { return SetPosition(x, y, unit, \"absolute\", \"left\", \"bottom\"); }\n\n      /// Set the x-y position of this Widget, fixed within the browser window.\n      return_t & SetPositionFixed(int x, int y, const std::string & unit=\"px\")\n        { return SetPosition(x, y, unit, \"fixed\", \"left\", \"top\"); }\n\n      /// Set the x-y position of the top-right corner this Widget, fixed within the browser window.\n      return_t & SetPositionFixedRT(int x, int y, const std::string & unit=\"px\")\n        { return SetPosition(x, y, unit, \"fixed\", \"right\", \"top\"); }\n\n      /// Set the x-y position of the bottom-right corner this Widget, fixed within the browser window.\n      return_t & SetPositionFixedRB(int x, int y, const std::string & unit=\"px\")\n        { return SetPosition(x, y, unit, \"fixed\", \"right\", \"bottom\"); }\n\n      /// Set the x-y position of the bottom-left corner this Widget, fixed within the browser window.\n      return_t & SetPositionFixedLB(int x, int y, const std::string & unit=\"px\")\n        { return SetPosition(x, y, unit, \"fixed\", \"left\", \"bottom\"); }\n\n\n      /// Set this Widget to float appropriately within its containter.\n      return_t & SetFloat(const std::string & f=\"left\") { return SetCSS(\"float\", f); }\n\n      /// Setup how this Widget should handle overflow.\n      return_t & SetOverflow(const std::string & o=\"auto\") { return SetCSS(\"overflow\", o); }\n\n      /// Setup how this Widget to always have scrollbars.\n      return_t & SetScroll() { return SetCSS(\"overflow\", \"scroll\"); }\n\n      /// Setup how this Widget to have scrollbars if needed for overflow.\n      return_t & SetScrollAuto() { return SetCSS(\"overflow\", \"auto\"); }\n\n      /// Setup how this Widget to be user-resizable.\n      return_t & SetResizable() { return SetCSS(\"resize\", \"both\"); }\n\n      /// Setup how this Widget for the x only to be user-resizable.\n      return_t & SetResizableX() { return SetCSS(\"resize\", \"horizontal\"); }\n\n      /// Setup how this Widget for the y only to be user-resizable.\n      return_t & SetResizableY() { return SetCSS(\"resize\", \"vertical\"); }\n\n      /// Setup how this Widget to NOT be resizable.\n      return_t & SetResizableOff() { return SetCSS(\"resize\", \"none\"); }\n\n      /// Provide a Font object to setup the font for this widget.\n      return_t & SetFont(const Font & font) {\n        font.ConfigStyle(info->extras.style);\n        return (return_t &) *this;\n      }\n\n      /// Setup the Font to be used in this Widget.\n      return_t & SetFont(const std::string & font) { return SetCSS(\"font-family\", font); }\n\n      /// Setup the size of the Font to be used in this Widget.\n      return_t & SetFontSize(int s) { return SetCSS(\"font-size\", emp::to_string(s, \"px\")); }\n\n      /// Setup the size of the Font to be used in this Widget in units of % of viewport width.\n      return_t & SetFontSizeVW(double s) { return SetCSS(\"font-size\", emp::to_string(s, \"vw\")); }\n\n      /// Align text to be centered.\n      return_t & SetCenterText() { return SetCSS(\"text-align\", \"center\"); }\n\n      /// Set the background color of this Widget.\n      return_t & SetBackground(const std::string & v) { return SetCSS(\"background-color\", v); }\n\n      /// Set the foreground color of this Widget.\n      return_t & SetColor(const std::string & v) { return SetCSS(\"color\", v); }\n\n      /// Set the opacity level of this Widget.\n      return_t & SetOpacity(double v) { return SetCSS(\"opacity\", v); }\n\n      /// Set information about the Widget board.\n      return_t & SetBorder(const std::string & border_info) {\n        return SetCSS(\"border\", border_info);\n      }\n\n      /// The the number of pixels (or alternate unit) for the padding around cells (used with Tables)\n      return_t & SetPadding(double p, const std::string & unit=\"px\") {\n        return SetCSS(\"padding\", emp::to_string(p, unit));\n      }\n\n      /// Wrap a wrapper around this Widget.\n      /// @param wrapper the wrapper that will be placed around this Widget\n      /// @return this Widget\n      return_t & WrapWith(Widget wrapper) {\n\n        // if this Widget is already nested within a parent\n        // we'll need to wedge the wrapper between this Widget and the parent\n        // e.g., parent->child will become parent->wrapper->child\n        if (Info(*this)->parent) {\n\n          // parent should be a DivInfo\n          emp_assert(dynamic_cast<internal::DivInfo*>(\n            Info(*this)->parent\n          ));\n\n          const auto parent_info = Info((return_t &) *this)->parent;\n\n          // switch out parent's existing child for wrapper\n          parent_info->RemoveChild((return_t &) *this);\n          parent_info->AddChild(wrapper);\n        }\n\n        // put this Widget inside of the wrapper\n        wrapper << (return_t &) *this;\n\n        return (return_t &) *this;\n      }\n\n      // Add JS function to on_update_js_sig\n      SignalKey RegisterUpdateJS(const std::function<void()> & fun){\n        return info->RegisterUpdateJS(fun);\n      }\n\n    };\n\n  }\n  #endif // DOXYGEN_SHOULD_SKIP_THIS\n\n}\n}\n\n\n#endif // #ifndef EMP_WEB_WIDGET_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2016-2021.\n *\n *  @file string_utils.hpp\n *  @brief Simple functions to manipulate strings.\n *  @note Status: RELEASE\n */\n\n#ifndef EMP_TOOLS_STRING_UTILS_HPP_INCLUDE\n#define EMP_TOOLS_STRING_UTILS_HPP_INCLUDE\n\n\n#include <algorithm>\n#include <cctype>\n#include <cstdio>\n#include <functional>\n#include <initializer_list>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <memory>\n#include <numeric>\n#include <regex>\n#include <sstream>\n#include <string>\n#include <string_view>\n#include <unordered_set>\n\n#include \"../base/array.hpp\"\n#include \"../base/assert.hpp\"\n#include \"../base/Ptr.hpp\"\n#include \"../base/vector.hpp\"\n#include \"../meta/reflection.hpp\"\n#include \"../meta/type_traits.hpp\"\n\nnamespace emp {\n\n  /// Return a const reference to an empty string.  This function is useful to implement other\n  /// functions that need to return a const reference for efficiency, but also need a null response.\n\n  static inline const std::string & empty_string() {\n    static std::string empty = \"\";\n    return empty;\n  }\n\n  /// Count the number of times a specific character appears in a string\n  /// (a clean shortcut to std::count)\n  static inline size_t count(const std::string & str, char c) {\n    return (size_t) std::count(str.begin(), str.end(), c);\n  }\n\n  /// Convert a single chararcter to one that uses a proper escape sequence (in a string) if needed.\n  static inline std::string to_escaped_string(char value) {\n    // Start by quickly returning a string if it's easy.\n    std::stringstream ss;\n    if ( (value >= 40 && value < 91) || (value > 96 && value < 127)) {\n      ss << value;\n      return ss.str();\n    }\n    switch (value) {\n    case '\\0': return \"\\\\0\";\n    case 1: return \"\\\\001\";\n    case 2: return \"\\\\002\";\n    case 3: return \"\\\\003\";\n    case 4: return \"\\\\004\";\n    case 5: return \"\\\\005\";\n    case 6: return \"\\\\006\";\n    case '\\a': return \"\\\\a\";  // case  7 (audible bell)\n    case '\\b': return \"\\\\b\";  // case  8 (backspace)\n    case '\\t': return \"\\\\t\";  // case  9 (tab)\n    case '\\n': return \"\\\\n\";  // case 10 (newline)\n    case '\\v': return \"\\\\v\";  // case 11 (vertical tab)\n    case '\\f': return \"\\\\f\";  // case 12 (form feed - new page)\n    case '\\r': return \"\\\\r\";  // case 13 (carriage return)\n    case 14: return \"\\\\016\";\n    case 15: return \"\\\\017\";\n    case 16: return \"\\\\020\";\n    case 17: return \"\\\\021\";\n    case 18: return \"\\\\022\";\n    case 19: return \"\\\\023\";\n    case 20: return \"\\\\024\";\n    case 21: return \"\\\\025\";\n    case 22: return \"\\\\026\";\n    case 23: return \"\\\\027\";\n    case 24: return \"\\\\030\";\n    case 25: return \"\\\\031\";\n    case 26: return \"\\\\032\";\n    case 27: return \"\\\\033\";  // case 27 (ESC), sometimes \\e\n    case 28: return \"\\\\034\";\n    case 29: return \"\\\\035\";\n    case 30: return \"\\\\036\";\n    case 31: return \"\\\\037\";\n\n    case '\\\"': return \"\\\\\\\"\";  // case 34\n    case '\\'': return \"\\\\\\'\";  // case 39\n    case '\\\\': return \"\\\\\\\\\";  // case 92\n    case 127: return \"\\\\177\";  // (delete)\n\n    // case '\\?': return \"\\\\\\?\";\n    default:\n      ss << value;\n      return ss.str();\n    };\n  }\n\n  /// Convert a full string to one that uses proper escape sequences, as needed.\n  static inline std::string to_escaped_string(const std::string & value) {\n    std::stringstream ss;\n    for (char c : value) { ss << to_escaped_string(c); }\n    return ss.str();\n  }\n\n  /// Take a string and replace reserved HTML characters with character entities\n  inline std::string to_web_safe_string(const std::string & value) {\n    std::string web_safe = value;\n    std::regex apm(\"[&]\");\n    std::regex open_brace(\"[<]\");\n    std::regex close_brace(\"[>]\");\n    std::regex single_quote(\"[']\");\n    std::regex double_quote(\"[\\\"]\");\n\n    web_safe = std::regex_replace(web_safe, apm, \"&amp\");\n    web_safe = std::regex_replace(web_safe, open_brace, \"&lt\");\n    web_safe = std::regex_replace(web_safe, close_brace, \"&gt\");\n    web_safe = std::regex_replace(web_safe, single_quote, \"&apos\");\n    web_safe = std::regex_replace(web_safe, double_quote, \"&quot\");\n\n    return web_safe;\n  }\n\n\n  /// Returns url encoding of value.\n  /// See https://en.wikipedia.org/wiki/Percent-encoding\n  // adapted from https://stackoverflow.com/a/17708801\n  template<bool encode_space=false>\n  std::string url_encode(const std::string &value) {\n    std::ostringstream escaped;\n    escaped.fill('0');\n    escaped << std::hex;\n\n    for (const auto c : value) {\n\n      // If encoding space, replace with +\n      if ( encode_space && c == ' ' ) escaped << '+';\n      // Keep alphanumeric and other accepted characters intact\n      else if (\n        std::isalnum(c) || c == '-' || c == '_' || c == '.' || c == '~'\n      ) escaped << c;\n      // Any other characters are percent-encoded\n      else {\n        escaped << std::uppercase;\n        escaped << '%' << std::setw(2) << (static_cast<int>(c) & 0x000000FF);\n        escaped << std::nouppercase;\n      }\n\n    }\n\n    return escaped.str();\n  }\n\n  /// Returns url decoding of string.\n  /// See https://en.wikipedia.org/wiki/Percent-encoding\n  // adapted from https://stackoverflow.com/a/29962178\n  template<bool decode_plus=false>\n  std::string url_decode(const std::string& str){\n    std::string res;\n\n    for (size_t i{}; i < str.size(); ++i) {\n      if (str[i] == '%') {\n        int hex_code;\n        std::sscanf(str.substr(i + 1, 2).c_str(), \"%x\", &hex_code);\n        res += static_cast<char>(hex_code);\n        i += 2;\n      } else {\n        res += ( decode_plus && str[i] == '+' ) ? ' ' : str[i];\n      }\n    }\n\n    return res;\n  }\n\n  /// Take a value and convert it to a C++-style literal.\n  template <typename T>\n  inline\n  typename std::enable_if<!emp::IsIterable<T>::value, std::string>::type to_literal(const T & value) {\n    return std::to_string(value);\n  }\n\n  /// Take a char and convert it to a C++-style literal.\n  static inline std::string to_literal(char value) {\n    std::stringstream ss;\n    ss << \"'\" << to_escaped_string(value) << \"'\";\n    return ss.str();\n  }\n\n  /// Take a string or iterable and convert it to a C++-style literal.\n  // This is the version for string. The version for an iterable is below.\n  static inline std::string to_literal(const std::string & value) {\n    // Add quotes to the ends and convert each character.\n    std::stringstream ss;\n    ss << \"\\\"\";\n    for (char c : value) {\n      ss << to_escaped_string(c);\n    }\n    ss << \"\\\"\";\n    return ss.str();\n  }\n\n  #ifndef DOXYGEN_SHOULD_SKIP_THIS\n\n  /// Take any iterable value and convert it to a C++-style literal.\n  template <typename T>\n  inline\n  typename std::enable_if<emp::IsIterable<T>::value, std::string>::type to_literal(const T & value) {\n    std::stringstream ss;\n    ss << \"{ \";\n    for (auto iter = std::begin( value ); iter != std::end( value ); ++iter) {\n      if (iter != std::begin( value )) ss << \" \";\n      ss << emp::to_literal< std::decay_t<decltype(*iter)> >( *iter );\n    }\n    ss << \" }\";\n\n    return ss.str();\n  }\n\n  #endif\n\n  /// Test if an input string is properly formated as a literal character.\n  static inline char is_literal_char(const std::string & value) {\n    // A literal char must beging with a single quote, contain a representation of a single\n    // character, and end with a single quote.\n    if (value.size() < 3) return false;\n    if (value[0] != '\\'' || value.back() != '\\'') return false;\n\n    // If there's only a single character in the quotes, it's USUALLY legal.\n    if (value.size() == 3) {\n      switch (value[1]) {\n        case '\\'':         // Can't be a single quote (must be escaped!)\n        case '\\\\':         // Can't be a backslash (must be followed by something!)\n          return false;\n        default:\n          return true;\n      }\n    }\n\n    // If there are more characters, must be an escape sequence.\n    if (value.size() == 4) {\n      if (value[1] != '\\\\') return false;\n\n      // Identify legal escape sequences.\n      // @CAO Need more here!\n      switch (value[2]) {\n        case 'n':   // Newline\n        case 'r':   // Return\n        case 't':   // Tab\n        case '0':   // Empty (character 0)\n        case '\\\\':  // Backslash\n        case '\\'':  // Single quote\n          return true;\n        default:\n          return false;\n      }\n    }\n\n    // @CAO: Need to add special types of numerical escapes here (e.g., ascii codes!)\n\n    // If we made it here without a problem, it must be correct!\n    return true;\n  }\n\n  /// Convert a literal character representation to an actual string.\n  /// (i.e., 'A', ';', or '\\n')\n  static inline char from_literal_char(const std::string & value) {\n    emp_assert(is_literal_char(value));\n    // Given the assert, we can assume the string DOES contain a literal representation,\n    // and we just need to convert it.\n\n    if (value.size() == 3) return value[1];\n    if (value.size() == 4) {\n      switch (value[2]) {\n        case 'n': return '\\n';   // Newline\n        case 'r': return '\\r';   // Return\n        case 't': return '\\t';   // Tab\n        case '0': return '\\0';   // Empty (character 0)\n        case '\\\\': return '\\\\';  // Backslash\n        case '\\'': return '\\'';  // Single quote\n      }\n    }\n\n    // @CAO: Need to add special types of numerical escapes here (e.g., ascii codes!)\n\n    // Problem!\n    return '0';\n  }\n\n  /// Test if an input string is properly formated as a literal string.\n  static inline char is_literal_string(const std::string & value) {\n    // A literal string must begin and end with a double quote and contain only valid characters.\n    if (value.size() < 2) return false;\n    if (value[0] != '\"' || value.back() != '\"') return false;\n\n    // Are all of the characters valid?\n    for (size_t pos = 1; pos < value.size() - 1; pos++) {\n      if (value[pos] == '\"') return false;  // Cannot have a raw double-quote in the middle.\n      if (value[pos] == '\\\\') {\n        if (pos == value.size()-2) return false;  // Backslash must have char to escape.\n\n        // Move to the next char and make sure it's legal to be escaped.\n        // @CAO Expand on options!\n        pos++;\n        switch (value[pos]) {\n          case 'n':   // Newline\n          case 'r':   // Return\n          case 't':   // Tab\n          case '0':   // Empty (character 0)\n          case '\\\\':  // Backslash\n          case '\\'':  // Single quote\n            continue;\n          default:\n            return false;\n        }\n      }\n    }\n\n    // @CAO: Need to check special types of numerical escapes (e.g., ascii codes!)\n\n    // If we made it here without a problem, it must be correct!\n    return true;\n  }\n\n  /// Concatenate n copies of a string.\n  inline std::string repeat( const std::string& value, const size_t n ) {\n    const emp::vector<std::string> repeated( n, value );\n    return std::accumulate(\n      std::begin(repeated), std::end(repeated), std::string{}\n    );\n  }\n\n\n  /// Convert a literal string representation to an actual string.\n  static inline std::string from_literal_string(const std::string & value) {\n    emp_assert(is_literal_string(value));\n    // Given the assert, we can assume the string DOES contain a literal representation,\n    // and we just need to convert it.\n\n    std::string out_string;\n    out_string.reserve(value.size()-2);  // Make a guess on final size.\n\n    for (size_t pos = 1; pos < value.size() - 1; pos++) {\n      // If we don't have an escaped character, just move it over.\n      if (value[pos] != '\\\\') {\n        out_string.push_back(value[pos]);\n        continue;\n      }\n\n      // If we do have an escape character, convert it.\n      pos++;\n\n      switch (value[pos]) {\n        case 'n': out_string.push_back('\\n'); break;   // Newline\n        case 'r': out_string.push_back('\\r'); break;   // Return\n        case 't': out_string.push_back('\\t'); break;   // Tab\n        case '0': out_string.push_back('\\0'); break;   // Empty (character 0)\n        case '\\\\': out_string.push_back('\\\\'); break;  // Backslash\n        case '\\'': out_string.push_back('\\''); break;  // Single quote\n        default:\n          emp_assert(false, \"unknown escape char used; probably need to update converter!\");\n      }\n    }\n\n    return out_string;\n  }\n\n\n  /// Convert a string to all uppercase.\n  static inline std::string to_upper(std::string value) {\n    constexpr int char_shift = 'a' - 'A';\n    for (auto & x : value) {\n      if (x >= 'a' && x <= 'z') x = (char) (x - char_shift);\n    }\n    return value;\n  }\n\n  /// Convert a string to all lowercase.\n  static inline std::string to_lower(std::string value) {\n    constexpr int char_shift = 'a' - 'A';\n    for (auto & x : value) {\n      if (x >= 'A' && x <= 'Z') x = (char) (x + char_shift);\n    }\n    return value;\n  }\n\n  /// Make first letter of each word upper case\n  static inline std::string to_titlecase(std::string value) {\n    constexpr int char_shift = 'a' - 'A';\n    bool next_upper = true;\n    for (size_t i = 0; i < value.size(); i++) {\n      if (next_upper && value[i] >= 'a' && value[i] <= 'z') {\n        value[i] = (char) (value[i] - char_shift);\n      } else if (!next_upper && value[i] >= 'A' && value[i] <= 'Z') {\n        value[i] = (char) (value[i] + char_shift);\n      }\n\n      next_upper = (value[i] == ' ');\n    }\n    return value;\n  }\n\n  /// Convert an integer to a roman numeral string.\n  static inline std::string to_roman_numeral(int val, const std::string & prefix=\"\") {\n    std::string ret_string(prefix);\n    if (val < 0) ret_string += to_roman_numeral(-val, \"-\");\n    else if (val > 3999) { ; } // Out of bounds; return a blank;\n    else if (val >= 1000) ret_string += to_roman_numeral(val - 1000, \"M\");\n    else if (val >= 900) ret_string += to_roman_numeral(val - 900, \"CM\");\n    else if (val >= 500) ret_string += to_roman_numeral(val - 500, \"D\");\n    else if (val >= 400) ret_string += to_roman_numeral(val - 400, \"CD\");\n    else if (val >= 100) ret_string += to_roman_numeral(val - 100, \"C\");\n    else if (val >= 90) ret_string += to_roman_numeral(val - 90, \"XC\");\n    else if (val >= 50) ret_string += to_roman_numeral(val - 50, \"L\");\n    else if (val >= 40) ret_string += to_roman_numeral(val - 40, \"XL\");\n    else if (val >= 10) ret_string += to_roman_numeral(val - 10, \"X\");\n    else if (val == 9) ret_string += \"IX\";\n    else if (val >= 5) ret_string += to_roman_numeral(val - 5, \"V\");\n    else if (val == 4) ret_string += \"IV\";\n    else if (val > 0) ret_string += to_roman_numeral(val - 1, \"I\");\n\n    // else we already have it exactly and don't need to return anything.\n    return ret_string;\n  }\n\n\n  /// Determine if a character is whitespace.\n  inline bool is_whitespace(char test_char) {\n    return (test_char == ' ' || test_char == '\\n' || test_char == '\\r' || test_char == '\\t');\n  }\n\n  /// Determine if a character is an uppercase letter.\n  inline bool is_upper_letter(char test_char) {\n    return (test_char >= 'A' && test_char <= 'Z');\n  }\n\n  /// Determine if a character is a lowercase letter.\n  inline bool is_lower_letter(char test_char) {\n    return (test_char >= 'a' && test_char <= 'z');\n  }\n\n  /// Determine if a character is a letter of any kind.\n  inline bool is_letter(char test_char) {\n    return is_upper_letter(test_char) || is_lower_letter(test_char);\n  }\n\n  /// Determine if a character is a digit.\n  inline bool is_digit(char test_char) {\n    return (test_char >= '0' && test_char <= '9');\n  }\n\n  /// Determine if a character is a letter or digit.\n  inline bool is_alphanumeric(char test_char) {\n    return is_letter(test_char) || is_digit(test_char);\n  }\n\n  /// Determine if a character is a letter, digit, or underscore.\n  inline bool is_idchar(char test_char) {\n    return is_alphanumeric(test_char) || test_char == '_';\n  }\n\n  /// Determine if a character is in a set of characters (represented as a string)\n  static inline bool is_one_of(char test_char, const std::string & char_set) {\n    for (char x : char_set) if (test_char == x) return true;\n    return false;\n  }\n\n  /// Determine if a string is composed only of a set of characters (represented as a string)\n  static inline bool is_composed_of(const std::string & test_str, const std::string & char_set) {\n    for (char x : test_str) if (!is_one_of(x, char_set)) return false;\n    return true;\n  }\n\n  /// Determine if there is whitespace anywhere in a string.\n  inline bool has_whitespace(const std::string & test_str) {\n    for (char c : test_str) if (is_whitespace(c)) return true;\n    return false;\n  }\n\n  /// Determine if there are any uppercase letters in a string.\n  inline bool has_upper_letter(const std::string & test_str) {\n    for (char c : test_str) if (is_upper_letter(c)) return true;\n    return false;\n  }\n\n  /// Determine if there are any lowercase letters in a string.\n  inline bool has_lower_letter(const std::string & test_str) {\n    for (char c : test_str) if (is_lower_letter(c)) return true;\n    return false;\n  }\n\n  /// Determine if there are any letters in a string.\n  inline bool has_letter(const std::string & test_str) {\n    for (char c : test_str) if (is_letter(c)) return true;\n    return false;\n  }\n\n  /// Determine if there are any digits in a string.\n  inline bool has_digit(const std::string & test_str) {\n    for (char c : test_str) if (is_digit(c)) return true;\n    return false;\n  }\n\n  /// Determine if there are only digits in a string.\n  inline bool is_digits(const std::string & test_str) {\n    // If string is empty, there are no digits.\n    if (test_str.size() == 0) return false;\n\n    // Otherwise return false if any character is not a digit.\n    for (char c : test_str) if (!is_digit(c)) return false;\n    return true;\n  }\n\n  /// Determine if there are any letters or digits anywhere in a string.\n  inline bool has_alphanumeric(const std::string & test_str) {\n    for (char c : test_str) if (is_alphanumeric(c)) return true;\n    return false;\n  }\n\n  /// Determine if there are any letters or digits anywhere in a string.\n  inline bool is_alphanumeric(const std::string & test_str) {\n    for (char c : test_str) if (!is_alphanumeric(c)) return false;\n    return true;\n  }\n\n  /// Determine if there are any letters, digit, or underscores anywhere in a string.\n  inline bool has_idchar(const std::string & test_str) {\n    for (char c : test_str) if (is_idchar(c)) return true;\n    return false;\n  }\n\n  /// Determine if a specified set of characters appears anywhere in a string.\n  static inline bool has_one_of(const std::string & test_str, const std::string & char_set) {\n    for (char c : test_str) if (is_one_of(c, char_set)) return true;\n    return false;\n  }\n\n\n  /// If no functions are provided to is_valid(), always return false as base case.\n  inline bool is_valid(char /* test_char */ ) { return false; }\n\n  /// Determine if a character passes any of the test functions provided.\n  template <typename... FUNS>\n  inline bool is_valid(char test_char, std::function<bool(char)> fun1, FUNS... funs) {\n    return fun1(test_char) || is_valid(test_char, funs...);\n  }\n\n  /// For a string to be valid, each character must pass at least one provided function.\n  template <typename... FUNS>\n  static inline bool is_valid(const std::string & test_str, FUNS... funs) {\n    for (char x : test_str) if ( !is_valid(x, funs...) ) return false;\n    return true;\n  }\n\n\n  /// Pop a segment from the beginning of a string as another string, shortening original.\n  static inline std::string string_pop_fixed(std::string & in_string, std::size_t end_pos, size_t delim_size=0)\n  {\n    std::string out_string = \"\";\n    if (end_pos == 0);                        // Not popping anything!\n    else if (end_pos == std::string::npos) {  // Popping whole string.\n      out_string = in_string;\n      in_string = \"\";\n    }\n    else {\n      out_string = in_string.substr(0, end_pos);  // Copy up to the deliminator for ouput\n      in_string.erase(0, end_pos + delim_size);   // Delete output string AND deliminator\n    }\n\n    return out_string;\n  }\n\n  /// Get a segment from the beginning of a string as another string, leaving original untouched.\n  static inline std::string string_get_range(const std::string & in_string, std::size_t start_pos,\n                                             std::size_t end_pos) {\n    emp_assert(start_pos <= in_string.size());\n    if (end_pos == std::string::npos) end_pos = in_string.size();\n    emp_assert(end_pos <= in_string.size());\n    return in_string.substr(start_pos, end_pos - start_pos);\n  }\n\n  /// Remove a prefix of the input string (up to a specified delimeter) and return it.  If the\n  /// delimeter is not found, return the entire input string and clear it.\n  inline std::string string_pop(std::string & in_string, const char delim=' ') {\n    return string_pop_fixed(in_string, in_string.find(delim), 1);\n  }\n\n  /// Return a prefix of the input string (up to a specified delimeter), but do not modify it.\n  /// If the delimeter is not found, return the entire input string.\n  inline std::string string_get(const std::string & in_string, const char delim=' ', size_t start_pos=0) {\n    return string_get_range(in_string, start_pos, in_string.find(delim, start_pos));\n  }\n\n  /// Remove a prefix of the input string (up to any of a specified set of delimeters) and\n  /// return it.  If the delimeter is not found, return the entire input string and clear it.\n  inline std::string string_pop(std::string & in_string, const std::string & delim_set) {\n    return string_pop_fixed(in_string, in_string.find_first_of(delim_set), 1);\n  }\n\n  /// Return a prefix of the input string (up to any of a specified set of delimeters), but do not\n  /// modify it. If the delimeter is not found, return the entire input string.\n  inline std::string string_get(const std::string & in_string, const std::string & delim_set, size_t start_pos=0) {\n    emp_assert(start_pos <= in_string.size());\n    return string_get_range(in_string, start_pos, in_string.find_first_of(delim_set, start_pos));\n  }\n\n  /// Remove a prefix of a string, up to the first whitespace, and return it.\n  inline std::string string_pop_word(std::string & in_string) {\n    // Whitespace = ' ' '\\n' '\\r' or '\\t'\n    return string_pop(in_string, \" \\n\\r\\t\");\n  }\n\n  /// Return a prefix of a string, up to the first whitespace (do not modify the original string)\n  inline std::string string_get_word(const std::string & in_string, size_t start_pos=0) {\n    // Whitespace = ' ' '\\n' '\\r' or '\\t'\n    return string_get(in_string, \" \\n\\r\\t\", start_pos);\n  }\n\n  /// Test if a string has a given prefix.\n  inline bool has_prefix(const std::string & in_string, const std::string & prefix) {\n    if (prefix.size() > in_string.size()) return false;\n    for (size_t i = 0; i < prefix.size(); ++i) {\n      if (in_string[i] != prefix[i]) return false;\n    }\n    return true;\n  }\n\n  /// Remove a prefix of a string, up to the first newline, and return it.\n  inline std::string string_pop_line(std::string & in_string) {\n    return string_pop(in_string, '\\n');\n  }\n\n  /// Return a prefix of a string, up to the first newline (do not modify the original string)\n  inline std::string string_get_line(const std::string & in_string, size_t start_pos=0) {\n    return string_get(in_string, '\\n', start_pos);\n  }\n\n  /// Remove all whitespace at the beginning of a string.  Return the whitespace removed.\n  inline std::string left_justify(std::string & in_string) {\n    return string_pop_fixed(in_string, in_string.find_first_not_of(\" \\n\\r\\t\"));\n  }\n\n  /// Remove all whitespace at the end of a string.\n  inline void right_justify(std::string & in_string) {\n    // @CAO *very* inefficient at the moment.\n    while (is_whitespace(in_string.back())) in_string.pop_back();\n  }\n\n  /// Remove all whitespace at both the beginning and the end of a string.\n  inline void justify(std::string & in_string) {\n    left_justify(in_string);\n    right_justify(in_string);\n  }\n\n  /// Remove instances of characters from file.\n  static inline void remove_chars(std::string & in_string, std::string chars) {\n    size_t cur_pos = 0;\n    for (size_t i = 0; i < in_string.size(); i++) {\n      if (is_one_of(in_string[i], chars)) continue;\n      in_string[cur_pos++] = in_string[i];\n    }\n    in_string.resize(cur_pos);\n  }\n\n  /// Every time one or more whitespace characters appear replace them with a single space.\n  static inline void compress_whitespace(std::string & in_string) {\n    const size_t strlen = in_string.size();\n    bool last_whitespace = true;          // Remove whitespace from beginning of line.\n    size_t pos = 0;\n\n    for (size_t i = 0; i < strlen; i++) {\n      if (is_whitespace(in_string[i])) {  // This char is whitespace\n        if (last_whitespace) continue;\n        in_string[pos++] = ' ';\n        last_whitespace = true;\n      }\n      else {  // Not whitespace\n        in_string[pos++] = in_string[i];\n        last_whitespace = false;\n      }\n    }\n\n    if (pos && last_whitespace) pos--;   // If the end of the line is whitespace, remove it.\n\n    in_string.resize(pos);\n  }\n\n  /// Remove all whitespace from anywhere within a string.\n  static inline void remove_whitespace(std::string & in_string) {\n    const size_t strlen = in_string.size();\n    size_t pos = 0;\n\n    for (size_t i = 0; i < strlen; i++) {\n      if (is_whitespace(in_string[i])) continue;\n      in_string[pos++] = in_string[i];\n    }\n\n    in_string.resize(pos);\n  }\n\n  /// Remove all characters from a string except letters, numbers, and whitespace.\n  static inline void remove_punctuation(std::string & in_string) {\n    const size_t strlen = in_string.size();\n    size_t pos = 0;\n\n    for (size_t i = 0; i < strlen; i++) {\n      const char cur_char = in_string[i];\n      if (is_alphanumeric(cur_char) || is_whitespace(cur_char)) {\n        in_string[pos++] = cur_char;\n      }\n    }\n\n    in_string.resize(pos);\n  }\n\n  /// Make a string safe(r)\n  static inline std::string slugify(const std::string & in_string) {\n    //TODO handle complicated unicode strings\n    std::string res = to_lower(in_string);\n    remove_punctuation(res);\n    compress_whitespace(res);\n    std::transform(res.begin(), res.end(), res.begin(), [](char ch) {\n      return (ch == ' ') ? '-' : ch;\n    });\n    return res;\n  }\n\n  /// Provide a string_view on a given string\n  static inline std::string_view view_string(const std::string_view & str) {\n    return std::string_view(str);\n  }\n\n  /// Provide a string_view on a string from a given starting point.\n  static inline std::string_view view_string(const std::string_view & str, size_t start) {\n    emp_assert(start <= str.size());\n    return str.substr(start, str.size() - start);\n  }\n\n  /// Provide a string_view on a string from a starting point with a given size.\n  static inline std::string_view view_string(const std::string_view & str,\n                                             size_t start,\n                                             size_t npos) {\n    emp_assert(start + npos <= str.size());\n    return str.substr(start, npos);\n  }\n\n  /// Provide a string_view on a string from the beginning to a given size.\n  static inline std::string_view view_string_front(const std::string_view & str,\n                                                   size_t npos) {\n    emp_assert(npos <= str.size());\n    return str.substr(0, npos);\n  }\n\n  /// Provide a string_view on a string from a starting point with a given size.\n  static inline std::string_view view_string_back(const std::string_view & str,\n                                                  size_t npos) {\n    emp_assert(npos <= str.size());\n    return str.substr(str.size() - npos, npos);\n  }\n\n  /// Provide a string_view on a string from a starting point to an ending point.\n  static inline std::string_view view_string_range(const std::string_view & str,\n                                                   size_t start,\n                                                   size_t end) {\n    emp_assert(start <= end);\n    emp_assert(end <= str.size());\n    return str.substr(start, end - start);\n  }\n\n  /// Return a view of the prefix of the input string up to a specified delimeter.\n  /// If the delimeter is not found, return the entire input string.\n  static inline std::string_view view_string_to(const std::string_view & in_string,\n                                                const char delim,\n                                                size_t start_pos=0) {\n    const size_t in_size = in_string.size();\n    size_t end_pos = start_pos;\n    while (end_pos < in_size && in_string[end_pos] != delim) end_pos++;\n    return view_string_range(in_string, start_pos, end_pos);\n  }\n\n  /// Cut up a string based on the provided delimiter; fill them in to the provided vector.\n  /// @param in_string operand\n  /// @param out_set destination\n  /// @param delim delimiter to split on\n  /// @param max_split defines the maximum number of splits\n  static inline void slice(\n    const std::string_view & in_string,\n    emp::vector<std::string> & out_set,\n    const char delim='\\n',\n    const size_t max_split=std::numeric_limits<size_t>::max()\n  ) {\n    const size_t test_size = in_string.size();\n\n    // Count produced strings\n    size_t out_count = 0;\n    size_t pos = 0;\n    while (pos < test_size && out_count <= max_split) {\n      while (pos < test_size && in_string[pos] != delim) pos++;\n      pos++; // Skip over deliminator\n      out_count++;  // Increment for each delim plus once at the end (so once if no delims).\n    }\n\n    // And copy over the strings\n    out_set.resize(out_count);\n    pos = 0;\n    size_t string_id = 0;\n    while (pos < test_size) {\n      out_set[string_id] = \"\";\n      while (\n        pos < test_size\n        && (in_string[pos] != delim || string_id == out_count - 1)\n      ) {\n        out_set[string_id] += in_string[pos];\n        pos++;\n      }\n      pos++;        // Skip over any final deliminator\n      string_id++;  // Move to the next sub-string.\n    }\n\n  }\n\n  /// Slice a string without passing in result vector (may be less efficient).\n  /// @param in_string operand\n  /// @param delim delimiter to split on\n  /// @param max_split defines the maximum number of splits\n  static inline emp::vector<std::string> slice(\n    const std::string_view & in_string,\n    const char delim='\\n',\n    const size_t max_split=std::numeric_limits<size_t>::max()\n  ) {\n    emp::vector<std::string> result;\n    slice(in_string, result, delim, max_split);\n    return result;\n  }\n\n  /// Create a set of string_views based on the provided delimiter; fill them in to the provided vector.\n  static inline void view_slices(const std::string_view & in_string,\n                                 emp::vector<std::string_view> & out_set,\n                                 char delim='\\n') {\n    const size_t in_size = in_string.size();\n    out_set.resize(0);\n\n    size_t pos = 0;\n    while (pos < in_size) {\n      out_set.push_back( view_string_to(in_string, delim, pos) );\n      pos += out_set.back().size() + 1;\n    }\n\n  }\n\n  /// Slice a string without passing in result vector (may be less efficient).\n  static inline emp::vector<std::string_view> view_slices(const std::string_view & in_string,\n                                                          char delim='\\n') {\n    emp::vector<std::string_view> result;\n    view_slices(in_string, result, delim);\n    return result;\n  }\n\n  #ifndef DOXYGEN_SHOULD_SKIP_THIS\n\n  // The next functions are not efficient, but they will take any number of inputs and\n  // dynamically convert them all into a single, concatanated string.\n\n  /// Setup emp::ToString declarations for built-in types.\n  template <typename T, size_t N> inline std::string ToString(const emp::array<T,N> & container);\n  template <typename T, typename... Ts>\n  inline std::string ToString(const emp::vector<T, Ts...> & container);\n\n  /// Join a container of strings with a delimiter.\n  /// Adapted fromhttps://stackoverflow.com/questions/5288396/c-ostream-out-manipulation/5289170#5289170\n  template <typename Range, typename Value = typename Range::value_type>\n  std::string join_on(\n    Range const& elements,\n    const char *const delimiter\n  ) {\n    std::ostringstream os;\n    auto b = std::begin(elements), e = std::end(elements);\n\n    if (b != e) {\n        std::copy(b, std::prev(e), std::ostream_iterator<Value>(os, delimiter));\n        b = std::prev(e);\n    }\n    if (b != e) {\n        os << *b;\n    }\n\n    return os.str();\n  }\n\n\n  namespace internal {\n    // If the item passed in has a ToString(), always use it.\n    template <typename T>\n    decltype(std::declval<T>().ToString()) to_stream_item(const T & in, bool) {\n      return in.ToString();\n    }\n\n    // Otherwise, if emp::ToString(x) is defined for x, use it.\n    template <typename T>\n    auto to_stream_item(const T & in, int) -> decltype(emp::ToString(in)) {\n      return emp::ToString(in);\n    }\n\n    // If neither works, just assume stream operator will handle things...\n    // @CAO: Technically we can detect this to give a more informative error...\n    template <typename T> const T & to_stream_item(const T & in, ...) { return in; }\n\n  }\n\n  #endif // DOXYGEN_SHOULD_SKIP_THIS\n\n\n  /// This function does its very best to convert anything it gets to a string. Takes any number\n  /// of arguments and returns a single string containing all of them concatenated.  Any objects\n  /// that can go through a stringstream, have a ToString() memember function, or are defined to\n  /// be passed into emp::ToString(x) will work correctly.\n  template <typename... Ts>\n  inline std::string to_string(const Ts &... values) {\n    std::stringstream ss;\n    (ss << ... << internal::to_stream_item(values, true));\n    return ss.str();\n  }\n\n  /// Setup emp::ToString to work on arrays.\n  template <typename T, size_t N>\n  inline std::string ToString(const emp::array<T,N> & container) {\n    std::stringstream ss;\n    ss << \"[ \";\n    for (const auto & el : container) {\n      ss << to_string(el);\n      ss << \" \";\n    }\n    ss << \"]\";\n    return ss.str();\n  }\n\n  /// Setup emp::ToString to work on vectors.\n  template <typename T, typename... Ts>\n  inline std::string ToString(const emp::vector<T, Ts...> & container) {\n    std::stringstream ss;\n    ss << \"[ \";\n    for (const auto & el : container) {\n      ss << to_string(el);\n      ss << \" \";\n    }\n    ss << \"]\";\n    return ss.str();\n  }\n\n  /// This function tries to convert a string into any type you're looking for...  You just\n  /// need to specify the out type as the template argument.\n  template <typename T>\n  inline T from_string(const std::string & str) {\n    std::stringstream ss;\n    ss << str;\n    T out_val;\n    ss >> out_val;\n    return out_val;\n  }\n\n  #ifndef DOXYGEN_SHOULD_SKIP_THIS\n  namespace internal {\n    static inline void _from_string(std::stringstream &) { ; }\n\n    template <typename T, typename... Ts>\n    void _from_string(std::stringstream & ss, T & arg1, Ts... extra_args) {\n      ss >> arg1;\n      _from_string(ss, extra_args...);\n    }\n  }\n  #endif // DOXYGEN_SHOULD_SKIP_THIS\n\n  /// The from_string() function can also take multiple args instead of a return.\n  template <typename... Ts>\n  inline void from_string(const std::string & str, Ts &... args) {\n    std::stringstream ss;\n    ss << str;\n    internal::_from_string(ss, args...);\n  }\n\n  /// The from_strings() function takes a vector of strings and convets them into a vector\n  /// of the appropriate type.\n  template <typename T>\n  inline emp::vector<T> from_strings(const emp::vector<std::string> & string_v) {\n    emp::vector<T> vals(string_v.size());\n    for (size_t i = 0; i < string_v.size(); i++) {\n      vals[i] = from_string<T>(string_v[i]);\n    }\n    return vals;\n  }\n\n  /// This function tries to convert a string_view into any other type...  You must\n  /// need to specify the out type as the template argument.\n  template <typename T>\n  inline T from_string(std::string_view str) {\n    std::stringstream ss;\n    ss << str;\n    T out_val;\n    ss >> out_val;\n    return out_val;\n  }\n\n  /**\n   * This function returns the values in a vector as a string separated\n   * by a given delimeter.\n   *\n   * @param v a vector\n   * @param join_str delimeter\n   * @return string of vector values\n   */\n  template <typename T>\n  inline std::string join(const emp::vector<T> & v, std::string join_str) {\n\n    if (v.size() == 0) {\n      return \"\";\n    } else if (v.size() == 1) {\n      return to_string(v[0]);\n    } else {\n      std::stringstream res;\n      res << v[0];\n      for (size_t i = 1; i < v.size(); i++) {\n        res << join_str;\n        res << to_string(v[i]);\n      }\n      return res.str();\n    }\n  }\n\n\n  // -------- Functions that operate on VECTORS of strings --------\n\n  using string_vec_t = emp::vector<std::string>;\n\n  /// Convert a vector of strings to an English list, such as \"one, two, three, and four.\"\n  static inline std::string to_english_list(const string_vec_t & strings) {\n    // If there are no input strings, return an empty string.\n    if (strings.size() == 0) { return \"\"; }\n\n    // If there is one string provided, return it by itself.\n    if (strings.size() == 1) { return strings[0]; }\n\n    // If two strings are provided, link them by an \"and\".\n    if (strings.size() == 2) { return to_string(strings[0], \" and \", strings[1]); }\n\n    // If MORE than two strings are provided, list the first n-1 followed by commas, ending\n    // with an \"and\" before the final one.\n    std::string out_str;\n    for (size_t i = 0; i < strings.size(); i++) {\n      if (i) {\n        out_str += \", \";\n        if (i == strings.size()-1) out_str += \"and \";\n      }\n      out_str += strings[i];\n    }\n\n    return out_str;\n  }\n\n\n  /// Transform all strings in a vector.\n  static inline string_vec_t transform_strings(const string_vec_t & in_strings,\n                                               std::function<std::string(const std::string &)> fun) {\n    string_vec_t out_strings(in_strings.size());\n    for (size_t i = 0; i < in_strings.size(); i++) {\n      out_strings[i] = fun(in_strings[i]);\n    }\n    return out_strings;\n  }\n\n  /// Put all strings provided in quotes (Like 'this'), pre- and post-fixing another string if\n  /// provided.\n  static inline string_vec_t quote_strings(const string_vec_t & in_strings,\n                                           const std::string quote=\"'\") {\n    return transform_strings(in_strings, [quote](const std::string & str) {\n      return to_string(quote, str, quote);\n    });\n  }\n\n  /// Pre-pend and post-pend specified sequences to all strings provided.\n  static inline string_vec_t quote_strings(const string_vec_t & in_strings,\n                                           const std::string open_quote,\n                                           const std::string close_quote) {\n    return transform_strings(in_strings, [open_quote, close_quote](const std::string & str) {\n      return to_string(open_quote, str, close_quote);\n    });\n  }\n\n  /// Take a vector of strings, put them in quotes, and then transform it into an English list.\n  static inline std::string to_quoted_list(const string_vec_t & in_strings,\n                                           const std::string quote=\"'\") {\n    return to_english_list(quote_strings(in_strings, quote));\n  }\n\n  // Some ANSI helper functions.\n  inline constexpr char ANSI_ESC() { return (char) 27; }\n  inline std::string ANSI_Reset() { return \"\\033[0m\"; }\n  inline std::string ANSI_Bold() { return \"\\033[1m\"; }\n  inline std::string ANSI_Faint() { return \"\\033[2m\"; }\n  inline std::string ANSI_Italic() { return \"\\033[3m\"; }\n  inline std::string ANSI_Underline() { return \"\\033[4m\"; }\n  inline std::string ANSI_SlowBlink() { return \"\\033[5m\"; }\n  inline std::string ANSI_Blink() { return \"\\033[6m\"; }\n  inline std::string ANSI_Reverse() { return \"\\033[7m\"; }\n  inline std::string ANSI_Strike() { return \"\\033[9m\"; }\n\n  inline std::string ANSI_NoBold() { return \"\\033[22m\"; }\n  inline std::string ANSI_NoItalic() { return \"\\033[23m\"; }\n  inline std::string ANSI_NoUnderline() { return \"\\033[24m\"; }\n  inline std::string ANSI_NoBlink() { return \"\\033[25m\"; }\n  inline std::string ANSI_NoReverse() { return \"\\033[27m\"; }\n\n  inline std::string ANSI_Black() { return \"\\033[30m\"; }\n  inline std::string ANSI_Red() { return \"\\033[31m\"; }\n  inline std::string ANSI_Green() { return \"\\033[32m\"; }\n  inline std::string ANSI_Yellow() { return \"\\033[33m\"; }\n  inline std::string ANSI_Blue() { return \"\\033[34m\"; }\n  inline std::string ANSI_Magenta() { return \"\\033[35m\"; }\n  inline std::string ANSI_Cyan() { return \"\\033[36m\"; }\n  inline std::string ANSI_White() { return \"\\033[37m\"; }\n  inline std::string ANSI_DefaultColor() { return \"\\033[39m\"; }\n\n  inline std::string ANSI_BlackBG() { return \"\\033[40m\"; }\n  inline std::string ANSI_RedBG() { return \"\\033[41m\"; }\n  inline std::string ANSI_GreenBG() { return \"\\033[42m\"; }\n  inline std::string ANSI_YellowBG() { return \"\\033[43m\"; }\n  inline std::string ANSI_BlueBG() { return \"\\033[44m\"; }\n  inline std::string ANSI_MagentaBG() { return \"\\033[45m\"; }\n  inline std::string ANSI_CyanBG() { return \"\\033[46m\"; }\n  inline std::string ANSI_WhiteBG() { return \"\\033[47m\"; }\n  inline std::string ANSI_DefaultBGColor() { return \"\\033[49m\"; }\n\n  inline std::string ANSI_BrightBlack() { return \"\\033[30m\"; }\n  inline std::string ANSI_BrightRed() { return \"\\033[31m\"; }\n  inline std::string ANSI_BrightGreen() { return \"\\033[32m\"; }\n  inline std::string ANSI_BrightYellow() { return \"\\033[33m\"; }\n  inline std::string ANSI_BrightBlue() { return \"\\033[34m\"; }\n  inline std::string ANSI_BrightMagenta() { return \"\\033[35m\"; }\n  inline std::string ANSI_BrightCyan() { return \"\\033[36m\"; }\n  inline std::string ANSI_BrightWhite() { return \"\\033[37m\"; }\n\n  inline std::string ANSI_BrightBlackBG() { return \"\\033[40m\"; }\n  inline std::string ANSI_BrightRedBG() { return \"\\033[41m\"; }\n  inline std::string ANSI_BrightGreenBG() { return \"\\033[42m\"; }\n  inline std::string ANSI_BrightYellowBG() { return \"\\033[43m\"; }\n  inline std::string ANSI_BrightBlueBG() { return \"\\033[44m\"; }\n  inline std::string ANSI_BrightMagentaBG() { return \"\\033[45m\"; }\n  inline std::string ANSI_BrightCyanBG() { return \"\\033[46m\"; }\n  inline std::string ANSI_BrightWhiteBG() { return \"\\033[47m\"; }\n\n  /// Make a string appear bold when printed to the command line.\n  inline std::string to_ansi_bold(const std::string & _in) {\n    return ANSI_Bold() + _in + ANSI_NoBold();\n  }\n\n  /// Make a string appear italics when printed to the command line.\n  inline std::string to_ansi_italic(const std::string & _in) {\n    return ANSI_Italic() + _in + ANSI_NoItalic();\n  }\n\n  /// Make a string appear underline when printed to the command line.\n  inline std::string to_ansi_underline(const std::string & _in) {\n    return ANSI_Underline() + _in + ANSI_NoUnderline();\n  }\n\n  /// Make a string appear blink when printed to the command line.\n  inline std::string to_ansi_blink(const std::string & _in) {\n    return ANSI_Blink() + _in + ANSI_NoBlink();\n  }\n\n  /// Make a string appear reverse when printed to the command line.\n  inline std::string to_ansi_reverse(const std::string & _in) {\n    return ANSI_Reverse() + _in + ANSI_NoReverse();\n  }\n\n\n  /// Apply sprintf-like formatting to a string.\n  /// See https://en.cppreference.com/w/cpp/io/c/fprintf.\n  /// Adapted from https://stackoverflow.com/a/26221725.\n  template<typename... Args>\n  std::string format_string( const std::string& format, Args... args ) {\n\n    #pragma GCC diagnostic push\n    #pragma GCC diagnostic ignored \"-Wformat-security\"\n\n    // Extra space for '\\0'\n    const size_t size = std::snprintf(nullptr, 0, format.c_str(), args...) + 1;\n    emp_assert( size >= 0 );\n\n    emp::vector<char> buf( size );\n    std::snprintf( buf.data(), size, format.c_str(), args... );\n\n     // We don't want the '\\0' inside\n    return std::string( buf.data(), buf.data() + size - 1 );\n\n    #pragma GCC diagnostic pop\n\n  }\n\n}\n\n#endif // #ifndef EMP_TOOLS_STRING_UTILS_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2019\n *\n *  @file mem_track.hpp\n *  @brief A set of macros to track how many instances of specific classes are made.\n *  @note Status: BETA\n *\n *  One way of tracking memory leaks is to simply count instances of classes.  The macros here\n *  simplify this process.\n *\n *  To setup, every constructor for a class must incude EMP_TRACK_CONSTRUCT(CLASS_NAME),\n *  and every destructor must have EMP_TRACK_DESTRUCT(CLASS_NAME).  Make sure to avoid\n *  implicit constructors/destructors or counts will be off.\n *\n *  To collect information, EMP_TRACK_COUNT(CLASS_NAME) will provide the current count\n *  for a specific class, and EMP_TRACK_STATUS will translate into a string providing\n *  information about all available classes.\n *\n *  Developer notes:\n *  @todo Currently having issues with the memory map corruption.  Perhaps it needs to use onload?\n *   Also, can try using JS maps instead?  (only when using Emscripten.)\n */\n\n#ifndef EMP_DEBUG_MEM_TRACK_HPP_INCLUDE\n#define EMP_DEBUG_MEM_TRACK_HPP_INCLUDE\n\n\n// If EMP_NDEBUG is turned on, turn off mem checks.\n#ifdef EMP_NDEBUG\n#define EMP_NO_MEM_CHECK\n#endif\n\n\n#include <sstream>\n#include <string>\n\n#include \"../base/map.hpp\"\n\n#include \"alert.hpp\"\n\n#ifdef EMP_NO_MEM_CHECK\n\n#define EMP_TRACK_CONSTRUCT(CLASS_NAME)\n#define EMP_TRACK_DESTRUCT(CLASS_NAME)\n#define EMP_TRACK_COUNT(CLASS_NAME) 0\n#define EMP_TRACK_STATUS std::string(\"(not in debug mode)\")\n\n#else  // DEBUG MODE!\n\n#define EMP_TRACK_CONSTRUCT(CLASS_NAME) emp::internal::TrackMem_Inc(#CLASS_NAME)\n#define EMP_TRACK_DESTRUCT(CLASS_NAME) emp::internal::TrackMem_Dec(#CLASS_NAME)\n#define EMP_TRACK_COUNT(CLASS_NAME) emp::internal::TrackMem_Count(#CLASS_NAME)\n#define EMP_TRACK_STATUS emp::internal::TrackMem_Status()\n\nnamespace emp {\n\n  #ifndef DOXYGEN_SHOULD_SKIP_THIS\n  namespace internal {\n\n    static emp::map<std::string,int> & TrackMem_GetMap() {\n      static emp::map<std::string,int> * track_mem_class_map = nullptr;\n      if (!track_mem_class_map) track_mem_class_map = new emp::map<std::string,int>;\n      return *track_mem_class_map;\n    }\n\n    static std::string TrackMem_Status() {\n      auto & mem_map = TrackMem_GetMap();\n\n      std::stringstream ss;\n      for (auto stat : mem_map) {\n        ss << \"[\" << stat.first << \"] : \" << stat.second << std::endl;\n      }\n      return ss.str();\n    }\n\n    static void TrackMem_Inc(const std::string & class_name) {\n      (void) class_name;\n      auto & mem_map = TrackMem_GetMap();\n      if (mem_map.find(class_name) == mem_map.end()) {\n        mem_map[class_name] = 0;\n      }\n      mem_map[class_name]++;\n    }\n\n    static void TrackMem_Dec(const std::string & class_name) {\n      (void) class_name;\n      auto & mem_map = TrackMem_GetMap();\n\n      // Make sure we are not trying to delete a class that was never registered!\n      if (mem_map.find(class_name) == mem_map.end()) {\n        emp::CappedAlert(3, \"Trying to delete unknown: [\", class_name,\n                         \"]; map size = \", mem_map.size());\n        abort();\n      }\n      mem_map[class_name]--;\n      if (mem_map[class_name] < 0) {\n        emp::CappedAlert(3, \"Trying to delete too many: \", class_name);\n        abort();\n      }\n    }\n\n    static int TrackMem_Count(const std::string & class_name) {\n      (void) class_name;\n      auto & mem_map = TrackMem_GetMap();\n\n      if (mem_map.find(class_name) == mem_map.end()) {\n        return 0;\n      }\n      return mem_map[class_name];\n    }\n\n  }\n  #endif // DOXYGEN_SHOULD_SKIP_THIS\n\n}\n#endif\n\n\n#endif // #ifndef EMP_DEBUG_MEM_TRACK_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2017\n *\n *  @file WidgetExtras.hpp\n *  @brief A collection of extra details about HTML Widgets (attributes, style, listerns)\n */\n\n#ifndef EMP_WEB_WIDGETEXTRAS_HPP_INCLUDE\n#define EMP_WEB_WIDGETEXTRAS_HPP_INCLUDE\n\n#include \"Attributes.hpp\"\n#include \"init.hpp\"\n#include \"Listeners.hpp\"\n#include \"Style.hpp\"\n\nnamespace emp {\nnamespace web {\n\n  struct WidgetExtras {\n    Style style;       ///< CSS Style\n    Attributes attr;   ///< HTML Attributes about a cell.\n    Listeners listen;  ///< Listen for web events\n\n    template <typename SET_TYPE>\n    void SetStyle(const std::string & s, SET_TYPE v) { style.Set(s, emp::to_string(v)); }\n    bool HasStyle(const std::string & setting) const { return style.Has(setting); }\n    const std::string & GetStyle(const std::string & setting) const { return style.Get(setting); }\n    void RemoveStyle(const std::string & setting) { style.Remove(setting); }\n\n    template <typename SET_TYPE>\n    void SetAttr(const std::string & s, SET_TYPE v) { attr.Set(s, emp::to_string(v)); }\n    bool HasAttr(const std::string & setting) const { return attr.Has(setting); }\n    const std::string & GetAttr(const std::string & setting) const { return attr.Get(setting); }\n    void RemoveAttr(const std::string & setting) { attr.Remove(setting); }\n\n    /// Apply all HTML details associated with this widget.\n    void Apply(const std::string & name) {\n      style.Apply(name);\n      attr.Apply(name);\n      listen.Apply(name);\n    }\n\n    /// Clear all of style, attributes, and listeners.\n    void Clear() {\n      style.Clear();\n      attr.Clear();\n      listen.Clear();\n    }\n\n    /// Have any details been set?\n    operator bool() const { return style || attr || listen; } // Return true if any extras are set.\n  };\n\n}\n}\n\n#endif // #ifndef EMP_WEB_WIDGETEXTRAS_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2017\n *\n *  @file events.hpp\n *  @brief Event handlers that use JQuery.\n *\n *  @todo Events can be further sub-divided and built up (similar to DataNode objects) so that we\n *    save only the information that we're planning to use.  This may be slightly faster (given\n *    how frequently some of these like mouse move might be used), but likely to be more compelx.\n *  @todo An alternative speed-up might be to save the current event somewhere in emp_i on the\n *    Javascript side, and then just request the information that we might need.  This approach\n *    should be easier to implement, but since everything would be copied anyway in such as case,\n *    it might not actually be a speedup.\n */\n\n#ifndef EMP_WEB_EVENTS_HPP_INCLUDE\n#define EMP_WEB_EVENTS_HPP_INCLUDE\n\n#include <utility>\n\n#include \"JSWrap.hpp\"\n\nnamespace emp {\nnamespace web {\n\n  /// Runs the specified function when the document is finished loading and being set up.\n  template <typename FUN_TYPE> void OnDocumentReady(FUN_TYPE && fun) {\n    // const size_t fun_id = JSWrapOnce(fun);\n    const size_t fun_id = JSWrap(std::forward<FUN_TYPE>(fun), \"\", true);\n    (void) fun_id;\n\n    MAIN_THREAD_EM_ASM({  $( document ).ready(function() { emp.Callback($0); });  }, fun_id);\n  }\n\n  /// Runs the specified function when the document is finished loading.\n  template <typename FUN_TYPE> void OnDocumentLoad(FUN_TYPE && fun) {\n    // const size_t fun_id = JSWrapOnce(fun);\n    const size_t fun_id = JSWrap(std::forward<FUN_TYPE>(fun), \"\", true);\n    (void) fun_id;\n\n    MAIN_THREAD_EM_ASM({\n        $( window ).on( \"load\", function() { emp.Callback($0); });\n      },\n      fun_id\n    );\n  }\n\n  /// Data common to all web events.\n  struct Event {\n    bool bubbles;           ///< Is this a bubbling event?\n    bool cancelable;        ///< Can the default action be prevented?\n    // bool defaultPrevented;  // Has the default action already been prevented?\n    // int currentTarget;   // Element whose event listeners triggered this event\n    // int eventPhase;      // 0=none, 1=capturing, 2=at target, 3=bubbling\n    // bool isTrusted;\n    // int target;          // Which element triggered this event?\n    // int timeStamp;       // When was event created?\n    // std::string type;    // E.g., \"mousedown\"\n    // int view;            // Which window did event occur in?\n\n    // void preventDefault() { ; }\n    // void stopImmediatePropagation() { ; }   // Prevents other listeners from being called.\n    // void stopPropagation() { ; }\n\n    template <int ARG_ID>\n    void LoadFromArg() {\n      bubbles = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].bubbles; }, ARG_ID);\n      cancelable = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].cancelable; }, ARG_ID);\n    }\n  };\n\n  /// Mouse-specific information about web events.\n  struct MouseEvent : public Event {\n    // All values reflect the state of devices when the event was triggered.\n    bool altKey;     ///< Was \"ALT\" key was pressed?\n    bool ctrlKey;    ///< Was \"CTRL\" key pressed?\n    bool metaKey;    ///< Was \"META\" key pressed?\n    bool shiftKey;   ///< Was \"SHIFT\" key pressed?\n\n    int button;      ///< Which mouse button was pressed?  -1=none  (0/1/2)\n    int detail;      ///< How many clicks happened in short succession?\n\n    int clientX;     ///< X-mouse postion, relative to current window\n    int clientY;     ///< Y-mouse postion, relative to current window\n    int screenX;     ///< X-mouse position, relative to the screen\n    int screenY;     ///< Y-mouse position, relative to the screen\n    // int buttons;     ///< Which mouse buttons were pressed? Sum: (1/4/2) (Special: 8,16)\n    // int relatedTarget    ///< Element related to the element that triggered the mouse event\n    // int which     ///< Which mouse button was pressed?  0=none  (1/2/3)\n\n    template <int ARG_ID>\n    void LoadFromArg() {\n      Event::LoadFromArg<ARG_ID>();\n\n      altKey = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].altKey; }, ARG_ID);\n      ctrlKey = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].ctrlKey; }, ARG_ID);\n      metaKey = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].metaKey; }, ARG_ID);\n      shiftKey = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].shiftKey; }, ARG_ID);\n      button = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].button; }, ARG_ID);\n      detail = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].detail; }, ARG_ID);\n      clientX = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].clientX; }, ARG_ID);\n      clientY = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].clientY; }, ARG_ID);\n      screenX = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].screenX; }, ARG_ID);\n      screenY = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].screenY; }, ARG_ID);\n    }\n  };\n\n\n  /// Keyboard-specific information about web events.\n  struct KeyboardEvent : public Event {\n    // All values reflect the state of devices when the event was triggered.\n    bool altKey;     ///< Was \"ALT\" key was pressed?\n    bool ctrlKey;    ///< Was \"CTRL\" key pressed?\n    bool metaKey;    ///< Was \"META\" key pressed?\n    bool shiftKey;   ///< Was \"SHIFT\" key pressed?\n\n    int charCode;    ///< Unicode character pressed\n    int keyCode;     ///< Which key was pressed on the keyboard (e.g., 'a' and 'A' are the same)\n\n    template <int ARG_ID>\n    void LoadFromArg() {\n      Event::LoadFromArg<ARG_ID>();\n\n      altKey = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].altKey; }, ARG_ID);\n      ctrlKey = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].ctrlKey; }, ARG_ID);\n      metaKey = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].metaKey; }, ARG_ID);\n      shiftKey = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].shiftKey; }, ARG_ID);\n      charCode = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].charCode; }, ARG_ID);\n      keyCode = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].keyCode; }, ARG_ID);\n    }\n  };\n\n\n  /// Mouse-wheel-specific information about web events.\n  struct WheelEvent : public Event {\n    // All values reflect the state of devices when the event was triggered.\n    int deltaX;      ///< Horizontal scroll amount.\n    int deltaY;      ///< Vertical scroll amount.\n    int deltaZ;      ///< Scroll amount of a mouse wheel for the z-axis\n    int deltaMode;   ///< The unit of measurements for delta values (pixels, lines or pages)\n\n    template <int ARG_ID>\n    void LoadFromArg() {\n      Event::LoadFromArg<ARG_ID>();\n\n      deltaX = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].deltaX; }, ARG_ID);\n      deltaY = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].deltaY; }, ARG_ID);\n      deltaZ = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].deltaZ; }, ARG_ID);\n      deltaMode = MAIN_THREAD_EM_ASM_INT({ return emp_i.cb_args[$0].deltaMode; }, ARG_ID);\n    }\n  };\n}\n}\n\n#endif // #ifndef EMP_WEB_EVENTS_HPP_INCLUDE\n","#pragma once\n\n#include \"emp/config/config.hpp\"\n\nnamespace chemical_ecology {\n\n  EMP_BUILD_CONFIG(Config,\n    GROUP(GLOBAL_SETTINGS, \"Global settings\"),\n    VALUE(SEED, int, -1, \"Seed for a simulation\"),\n    VALUE(N_TYPES, int, 100, \"Number of types\"),\n    VALUE(WORLD_SIZE, int, 100, \"Number of positions in world\"),\n    VALUE(UPDATES, int, 1000, \"Number of time steps to run for\"),\n    VALUE(MAX_POP, int, 10000, \"Maximum population size for one type in one cell\"),\n    VALUE(INTERACTION_MAGNITUDE, double, 1, \"Range of interaction intensities (from negative of this value to positive of this value\"),\n\n    // GROUP(OTHER_SETTINGS, \"Miscellaneous settings\"),\n    // VALUE(LUNCH_ORDER, std::string, \"ham on five\", \"What's for lunch today\"),\n    // VALUE(HOLD_MAYO, bool, true, \"Whether or not to hold the mayo\"),\n    // VALUE(SUPER_SECRET, bool, true, \"It's a hidden switch\"),\n  );\n}\n","// -*- C++ -*-\n//===---------------------------- numeric ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_NUMERIC\n#define _LIBCPP_NUMERIC\n\n/*\n    numeric synopsis\n\nnamespace std\n{\n\ntemplate <class InputIterator, class T>\n    T\n    accumulate(InputIterator first, InputIterator last, T init);\n\ntemplate <class InputIterator, class T, class BinaryOperation>\n    T\n    accumulate(InputIterator first, InputIterator last, T init, BinaryOperation binary_op);\n\ntemplate<class InputIterator>\n    typename iterator_traits<InputIterator>::value_type\n    reduce(InputIterator first, InputIterator last);  // C++17\n\ntemplate<class InputIterator, class T>\n    T\n    reduce(InputIterator first, InputIterator last, T init);  // C++17\n\ntemplate<class InputIterator, class T, class BinaryOperation>\n    T\n    reduce(InputIterator first, InputIterator last, T init, BinaryOperation binary_op);  // C++17\n\ntemplate <class InputIterator1, class InputIterator2, class T>\n    T\n    inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init);\n\ntemplate <class InputIterator1, class InputIterator2, class T, class BinaryOperation1, class BinaryOperation2>\n    T\n    inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,\n                  T init, BinaryOperation1 binary_op1, BinaryOperation2 binary_op2);\n\n\ntemplate<class InputIterator1, class InputIterator2, class T>\n    T\n    transform_reduce(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, T init);  // C++17\n\ntemplate<class InputIterator1, class InputIterator2, class T, class BinaryOperation1, class BinaryOperation2>\n    T\n    transform_reduce(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, T init,\n                     BinaryOperation1 binary_op1, BinaryOperation2 binary_op2);  // C++17\n\ntemplate<class InputIterator, class T, class BinaryOperation, class UnaryOperation>\n    T\n    transform_reduce(InputIterator first, InputIterator last, T init,\n                     BinaryOperation binary_op, UnaryOperation unary_op);  // C++17\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    partial_sum(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate <class InputIterator, class OutputIterator, class BinaryOperation>\n    OutputIterator\n    partial_sum(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op);\n\ntemplate<class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    exclusive_scan(InputIterator first, InputIterator last,\n                   OutputIterator result, T init); // C++17\n\ntemplate<class InputIterator, class OutputIterator, class T, class BinaryOperation>\n    OutputIterator\n    exclusive_scan(InputIterator first, InputIterator last,\n                   OutputIterator result, T init, BinaryOperation binary_op); // C++17\n\ntemplate<class InputIterator, class OutputIterator>\n    OutputIterator\n    inclusive_scan(InputIterator first, InputIterator last, OutputIterator result);  // C++17\n\ntemplate<class InputIterator, class OutputIterator, class BinaryOperation>\n    OutputIterator\n    inclusive_scan(InputIterator first, InputIterator last,\n                   OutputIterator result, BinaryOperation binary_op);  // C++17\n\ntemplate<class InputIterator, class OutputIterator, class BinaryOperation, class T>\n    OutputIterator\n    inclusive_scan(InputIterator first, InputIterator last,\n                   OutputIterator result, BinaryOperation binary_op, T init);  // C++17\n\ntemplate<class InputIterator, class OutputIterator, class T,\n         class BinaryOperation, class UnaryOperation>\n    OutputIterator\n    transform_exclusive_scan(InputIterator first, InputIterator last,\n                             OutputIterator result, T init,\n                             BinaryOperation binary_op, UnaryOperation unary_op);  // C++17\n\ntemplate<class InputIterator, class OutputIterator,\n         class BinaryOperation, class UnaryOperation>\n    OutputIterator\n    transform_inclusive_scan(InputIterator first, InputIterator last,\n                             OutputIterator result,\n                             BinaryOperation binary_op, UnaryOperation unary_op);  // C++17\n\ntemplate<class InputIterator, class OutputIterator,\n         class BinaryOperation, class UnaryOperation, class T>\n    OutputIterator\n    transform_inclusive_scan(InputIterator first, InputIterator last,\n                             OutputIterator result,\n                             BinaryOperation binary_op, UnaryOperation unary_op,\n                             T init);  // C++17\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    adjacent_difference(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate <class InputIterator, class OutputIterator, class BinaryOperation>\n    OutputIterator\n    adjacent_difference(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op);\n\ntemplate <class ForwardIterator, class T>\n    void iota(ForwardIterator first, ForwardIterator last, T value);\n\ntemplate <class M, class N>\n    constexpr common_type_t<M,N> gcd(M m, N n);    // C++17\n\ntemplate <class M, class N>\n    constexpr common_type_t<M,N> lcm(M m, N n);    // C++17\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iterator>\n#include <limits> // for numeric_limits\n#include <functional>\n#include <version>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\naccumulate(_InputIterator __first, _InputIterator __last, _Tp __init)\n{\n    for (; __first != __last; ++__first)\n        __init = __init + *__first;\n    return __init;\n}\n\ntemplate <class _InputIterator, class _Tp, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\naccumulate(_InputIterator __first, _InputIterator __last, _Tp __init, _BinaryOperation __binary_op)\n{\n    for (; __first != __last; ++__first)\n        __init = __binary_op(__init, *__first);\n    return __init;\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _InputIterator, class _Tp, class _BinaryOp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\nreduce(_InputIterator __first, _InputIterator __last, _Tp __init, _BinaryOp __b)\n{\n    for (; __first != __last; ++__first)\n        __init = __b(__init, *__first);\n    return __init;\n}\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\nreduce(_InputIterator __first, _InputIterator __last, _Tp __init)\n{\n    return _VSTD::reduce(__first, __last, __init, _VSTD::plus<>());\n}\n\ntemplate <class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::value_type\nreduce(_InputIterator __first, _InputIterator __last)\n{\n    return _VSTD::reduce(__first, __last,\n       typename iterator_traits<_InputIterator>::value_type{});\n}\n#endif\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\ninner_product(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _Tp __init)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        __init = __init + *__first1 * *__first2;\n    return __init;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Tp, class _BinaryOperation1, class _BinaryOperation2>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\ninner_product(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,\n              _Tp __init, _BinaryOperation1 __binary_op1, _BinaryOperation2 __binary_op2)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));\n    return __init;\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _InputIterator, class _Tp, class _BinaryOp, class _UnaryOp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\ntransform_reduce(_InputIterator __first, _InputIterator __last,\n           _Tp __init,  _BinaryOp __b, _UnaryOp __u)\n{\n    for (; __first != __last; ++__first)\n        __init = __b(__init, __u(*__first));\n    return __init;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2,\n          class _Tp, class _BinaryOp1, class _BinaryOp2>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\ntransform_reduce(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _Tp __init,  _BinaryOp1 __b1, _BinaryOp2 __b2)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        __init = __b1(__init, __b2(*__first1, *__first2));\n    return __init;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\ntransform_reduce(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _Tp __init)\n{\n    return _VSTD::transform_reduce(__first1, __last1, __first2, _VSTD::move(__init),\n                                   _VSTD::plus<>(), _VSTD::multiplies<>());\n}\n#endif\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\npartial_sum(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t(*__first);\n        *__result = __t;\n        for (++__first, (void) ++__result; __first != __last; ++__first, (void) ++__result)\n        {\n            __t = __t + *__first;\n            *__result = __t;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\npartial_sum(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n              _BinaryOperation __binary_op)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t(*__first);\n        *__result = __t;\n        for (++__first, (void) ++__result; __first != __last; ++__first, (void) ++__result)\n        {\n            __t = __binary_op(__t, *__first);\n            *__result = __t;\n        }\n    }\n    return __result;\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _InputIterator, class _OutputIterator, class _Tp, class _BinaryOp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nexclusive_scan(_InputIterator __first, _InputIterator __last,\n               _OutputIterator __result, _Tp __init, _BinaryOp __b)\n{\n    if (__first != __last)\n    {\n        _Tp __saved = __init;\n        do\n        {\n            __init = __b(__init, *__first);\n            *__result = __saved;\n            __saved = __init;\n            ++__result;\n        } while (++__first != __last);\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nexclusive_scan(_InputIterator __first, _InputIterator __last,\n               _OutputIterator __result, _Tp __init)\n{\n    return _VSTD::exclusive_scan(__first, __last, __result, __init, _VSTD::plus<>());\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp, class _BinaryOp>\n_OutputIterator inclusive_scan(_InputIterator __first, _InputIterator __last,\n                               _OutputIterator __result, _BinaryOp __b,  _Tp __init)\n{\n    for (; __first != __last; ++__first, (void) ++__result) {\n        __init = __b(__init, *__first);\n        *__result = __init;\n        }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryOp>\n_OutputIterator inclusive_scan(_InputIterator __first, _InputIterator __last,\n                               _OutputIterator __result, _BinaryOp __b)\n{\n    if (__first != __last) {\n        typename std::iterator_traits<_InputIterator>::value_type __init = *__first;\n        *__result++ = __init;\n        if (++__first != __last)\n            return _VSTD::inclusive_scan(__first, __last, __result, __b, __init);\n        }\n\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\n_OutputIterator inclusive_scan(_InputIterator __first, _InputIterator __last,\n                               _OutputIterator __result)\n{\n    return _VSTD::inclusive_scan(__first, __last, __result, std::plus<>());\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp,\n          class _BinaryOp, class _UnaryOp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform_exclusive_scan(_InputIterator __first, _InputIterator __last,\n                           _OutputIterator __result, _Tp __init,\n                           _BinaryOp __b, _UnaryOp __u)\n{\n    if (__first != __last)\n    {\n        _Tp __saved = __init;\n        do\n        {\n            __init = __b(__init, __u(*__first));\n            *__result = __saved;\n            __saved = __init;\n            ++__result;\n        } while (++__first != __last);\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp, class _BinaryOp, class _UnaryOp>\n_OutputIterator transform_inclusive_scan(_InputIterator __first, _InputIterator __last,\n                           _OutputIterator __result, _BinaryOp __b, _UnaryOp __u, _Tp __init)\n{\n    for (; __first != __last; ++__first, (void) ++__result) {\n        __init = __b(__init, __u(*__first));\n        *__result = __init;\n        }\n\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryOp, class _UnaryOp>\n_OutputIterator transform_inclusive_scan(_InputIterator __first, _InputIterator __last,\n                               _OutputIterator __result, _BinaryOp __b, _UnaryOp __u)\n{\n    if (__first != __last) {\n        typename std::iterator_traits<_InputIterator>::value_type __init = __u(*__first);\n        *__result++ = __init;\n        if (++__first != __last)\n            return _VSTD::transform_inclusive_scan(__first, __last, __result, __b, __u, __init);\n        }\n\n    return __result;\n}\n#endif\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nadjacent_difference(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t1(*__first);\n        *__result = __t1;\n        for (++__first, (void) ++__result; __first != __last; ++__first, (void) ++__result)\n        {\n            typename iterator_traits<_InputIterator>::value_type __t2(*__first);\n            *__result = __t2 - __t1;\n            __t1 = _VSTD::move(__t2);\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nadjacent_difference(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n                      _BinaryOperation __binary_op)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t1(*__first);\n        *__result = __t1;\n        for (++__first, (void) ++__result; __first != __last; ++__first, (void) ++__result)\n        {\n            typename iterator_traits<_InputIterator>::value_type __t2(*__first);\n            *__result = __binary_op(__t2, __t1);\n            __t1 = _VSTD::move(__t2);\n        }\n    }\n    return __result;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value_)\n{\n    for (; __first != __last; ++__first, (void) ++__value_)\n        *__first = __value_;\n}\n\n\n#if _LIBCPP_STD_VER > 14\ntemplate <typename _Result, typename _Source, bool _IsSigned = is_signed<_Source>::value> struct __abs;\n\ntemplate <typename _Result, typename _Source>\nstruct __abs<_Result, _Source, true> {\n    _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n    _Result operator()(_Source __t) const noexcept\n    {\n    if (__t >= 0) return __t;\n    if (__t == numeric_limits<_Source>::min()) return -static_cast<_Result>(__t);\n    return -__t;\n    }\n};\n\ntemplate <typename _Result, typename _Source>\nstruct __abs<_Result, _Source, false> {\n    _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n    _Result operator()(_Source __t) const noexcept { return __t; }\n};\n\n\ntemplate<class _Tp>\n_LIBCPP_CONSTEXPR _LIBCPP_HIDDEN\n_Tp __gcd(_Tp __m, _Tp __n)\n{\n    static_assert((!is_signed<_Tp>::value), \"\");\n    return __n == 0 ? __m : _VSTD::__gcd<_Tp>(__n, __m % __n);\n}\n\n\ntemplate<class _Tp, class _Up>\n_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\ncommon_type_t<_Tp,_Up>\ngcd(_Tp __m, _Up __n)\n{\n    static_assert((is_integral<_Tp>::value && is_integral<_Up>::value), \"Arguments to gcd must be integer types\");\n    static_assert((!is_same<typename remove_cv<_Tp>::type, bool>::value), \"First argument to gcd cannot be bool\" );\n    static_assert((!is_same<typename remove_cv<_Up>::type, bool>::value), \"Second argument to gcd cannot be bool\" );\n    using _Rp = common_type_t<_Tp,_Up>;\n    using _Wp = make_unsigned_t<_Rp>;\n    return static_cast<_Rp>(_VSTD::__gcd(\n        static_cast<_Wp>(__abs<_Rp, _Tp>()(__m)),\n        static_cast<_Wp>(__abs<_Rp, _Up>()(__n))));\n}\n\ntemplate<class _Tp, class _Up>\n_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\ncommon_type_t<_Tp,_Up>\nlcm(_Tp __m, _Up __n)\n{\n    static_assert((is_integral<_Tp>::value && is_integral<_Up>::value), \"Arguments to lcm must be integer types\");\n    static_assert((!is_same<typename remove_cv<_Tp>::type, bool>::value), \"First argument to lcm cannot be bool\" );\n    static_assert((!is_same<typename remove_cv<_Up>::type, bool>::value), \"Second argument to lcm cannot be bool\" );\n    if (__m == 0 || __n == 0)\n        return 0;\n\n    using _Rp = common_type_t<_Tp,_Up>;\n    _Rp __val1 = __abs<_Rp, _Tp>()(__m) / _VSTD::gcd(__m, __n);\n    _Rp __val2 = __abs<_Rp, _Up>()(__n);\n    _LIBCPP_ASSERT((numeric_limits<_Rp>::max() / __val1 > __val2), \"Overflow in lcm\");\n    return __val1 * __val2;\n}\n\n#endif /* _LIBCPP_STD_VER > 14 */\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_NUMERIC\n","//  This file is part of Artificial Ecology for Chemical Ecology Project\n//  Copyright (C) Emily Dolson, 2021.\n//  Released under MIT license; see LICENSE\n\n#include <iostream>\n\n#include \"emp/prefab/ConfigPanel.hpp\"\n#include \"emp/web/TextArea.hpp\"\n#include \"emp/web/web.hpp\"\n#include \"emp/web/d3/d3_init.hpp\"\n#include \"emp/web/d3/selection.hpp\"\n#include \"emp/web/d3/svg_shapes.hpp\"\n\n#include \"chemical-ecology/config_setup.hpp\"\n#include \"chemical-ecology/a-eco.hpp\"\n#include \"chemical-ecology/ExampleConfig.hpp\"\n\nnamespace UI = emp::web;\n\nUI::Document doc(\"emp_base\");\nUI::Canvas canvas;\n\nemp::vector<D3::LinearScale> square_colors;\nemp::vector<std::string> colors = {\"aqua\", \"crimson\", \"darkmagenta\", \"darkgreen\", \"deeppink\", \"darkorange\", \"yellow\", \"yellowgreen\"};\n\nchemical_ecology::Config cfg;\nAEcoWorld world;\n\n\nvoid ResetScales() {\n  square_colors.resize(cfg.N_TYPES());\n  for (int i=0; i < cfg.N_TYPES(); i++){\n    square_colors[i].SetDomain(emp::array<double, 2>({0, (double)cfg.MAX_POP()}));\n    square_colors[i].SetInterpolate(\"interpolateLab\");\n    square_colors[i].SetRange(emp::array<std::string, 2>({\"white\", colors[i]}));\n  }\n}\n\nvoid DrawWorldCanvas() {\n  // UI::Canvas canvas = doc.Canvas(\"world_canvas\");\n  canvas.Clear(\"gray\");\n\n  const size_t world_x = sqrt(cfg.WORLD_SIZE());\n  const size_t world_y = sqrt(cfg.WORLD_SIZE());\n  const double canvas_x = (double) canvas.GetWidth();\n  const double canvas_y = (double) canvas.GetHeight();\n  const double n_type_sqrt = sqrt(cfg.N_TYPES());\n  std::cout << \"x: \" << world_x << \" y: \" << world_y << std::endl;\n  const double org_x = canvas_x / (double) world_x;\n  const double org_y = canvas_y / (double) world_y;\n  const double org_r = emp::Min(org_x, org_y) / 2.0;\n  const double type_x = org_x/n_type_sqrt;\n  const double type_y = org_y/n_type_sqrt;\n\n  for (size_t y = 0; y < world_y; y++) {\n    for (size_t x = 0; x < world_x; x++) {\n      const size_t org_id = y * world_x + x;\n      if (org_id >= cfg.WORLD_SIZE()) {\n        break;\n      }\n      const size_t cur_x = org_x * (0.5 + (double) x);\n      const size_t cur_y = org_y * (0.5 + (double) y);\n      canvas.Rect(x*org_x, y*org_y, org_x, org_y, \"#444444\", \"black\");\n      \n      for (size_t type = 0; type < cfg.N_TYPES(); type++) {\n        int type_x_id = type % (int)n_type_sqrt;\n        int type_y_id = type / (int)n_type_sqrt;\n        double x_pos = x*org_x + type_x_id*type_x;\n        double y_pos = y*org_y + type_y_id*type_y;\n        int count = world.world[org_id][type];\n        canvas.Rect(x_pos, y_pos, type_x, type_y, square_colors[type].ApplyScaleString(count), \"black\");        \n      }\n     }\n  }\n\n  // Add a plus sign in the middle.\n  // const double mid_x = org_x * world_x / 2.0;\n  // const double mid_y = org_y * world_y / 2.0;\n  // const double plus_bar = org_r * world_x;\n  // canvas.Line(mid_x, mid_y-plus_bar, mid_x, mid_y+plus_bar, \"#8888FF\");\n  // canvas.Line(mid_x-plus_bar, mid_y, mid_x+plus_bar, mid_y, \"#8888FF\");\n\n  // doc.Text(\"ud_text\").Redraw();\n}\n\nint main()\n{\n  // doc << \"<h1>Hello, browser!</h1>\";\n  canvas = doc.AddCanvas(600, 600, \"world_canvas\");\n  canvas.SetHeight(600);\n  canvas.SetWidth(600);\n  // doc << canvas;\n\n  // Set up a configuration panel for web application\n  setup_config_web(cfg);\n  cfg.Write(std::cout);\n  emp::prefab::ConfigPanel example_config_panel(cfg);\n  // example_config_panel.ExcludeSetting(\"SEED\");\n  // example_config_panel.SetRange(\"SEED\", \"-1\", \"100\", \"1\");\n  doc << example_config_panel;\n\n  // An example to show how the Config Panel could be used\n  // to control the color of text in an HTML text area\n  // UI::TextArea example_area(\"example_area\");\n  // example_area.SetSize(cfg.SIZE(), cfg.SIZE());\n  // example_config_panel.SetOnChangeFun([](const std::string & setting, const std::string & value){\n\n  // });\n\n  world.Setup(cfg);\n  // world.Run();\n  ResetScales();\n  DrawWorldCanvas();\n\n}\n","#pragma once\n\n#include <iostream>\n#include \"emp/Evolve/World.hpp\"\n#include \"chemical-ecology/config_setup.hpp\"\n\nstruct Particle {\n  int type;\n  double r = 1;\n  int position;\n};\n\n\nclass AEcoWorld { //: public emp::World<Particle> {\n  private:\n    emp::vector<emp::vector<double> > interactions;\n    double r = 1;\n    emp::Random rnd;\n    chemical_ecology::Config * config = nullptr;\n    int N_TYPES;\n    int MAX_POP;\n\n  public:\n  AEcoWorld(){;}\n  emp::vector<emp::vector<int> > world;\n\n  void Setup(chemical_ecology::Config & cfg) {\n    config = &cfg;\n\n    N_TYPES = cfg.N_TYPES();\n    MAX_POP = cfg.MAX_POP();\n\n    rnd.ResetSeed(cfg.SEED());\n\n    world.resize(cfg.WORLD_SIZE());\n    for (emp::vector<int> & v : world) {\n      v.resize(N_TYPES);\n      for (int & count : v) {\n        count = rnd.GetInt(100);\n      }\n    }\n\n    interactions.resize(N_TYPES);\n    for (int i = 0; i < N_TYPES; i++) {\n      interactions[i].resize(N_TYPES);\n      for (int j = 0; j < N_TYPES; j++) {\n        if (i != j ){\n          interactions[i][j] = rnd.GetDouble(cfg.INTERACTION_MAGNITUDE() * -1, cfg.INTERACTION_MAGNITUDE());\n        }\n      }\n      std::cout << emp::to_string(interactions[i]) << std::endl;\n    }\n    std::cout << std::endl;\n  }\n\n  void Update() {\n    // for (emp::vector<Particle> pos : world) {\n    //   emp::vector<int> counts(interactions.size(), 0);\n    //   for (Particle p : pos) {\n    //     counts[p.type]++;\n    //   }      \n    // }\n\n    for (emp::vector<int> & pos : world) {\n      emp::vector<int> new_counts(N_TYPES);\n      for (int i = 0; i < N_TYPES; i++) {\n        double modifier = 0;\n        for (int j = 0; j < N_TYPES; j++) {\n          modifier += interactions[i][j] * pos[j];\n        }\n  \n        // Logistic growth\n        int new_pop = ceil((r+modifier)*pos[i]); // * ((double)(MAX_POP - pos[i])/MAX_POP));\n        // std::cout << pos[i] << \" \" << new_pop << \" \" << modifier << \" \" << ((double)(MAX_POP - pos[i])/MAX_POP) <<  std::endl;\n        new_counts[i] = std::max(pos[i] + new_pop, 0);\n        new_counts[i] = std::min(new_counts[i], MAX_POP);\n      }\n      // std::cout << emp::to_string(pos) << std::endl;\n      std::swap(pos, new_counts);\n      std::cout << emp::to_string(pos) << std::endl;\n    }\n\n  }\n\n  void Run() {\n    for (int i = 0; i < config->UPDATES(); i++) {\n      Update();\n      std::cout << std::endl;\n    }\n\n    for (auto & v : world) {\n      std::cout << emp::to_string(v) << std::endl;\n    }\n  }\n\n};","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2021\n *\n *  @file ConfigPanel.hpp\n *  @brief Interfaces with emp::config objects to provide UI configuration.\n */\n\n#ifndef EMP_PREFAB_CONFIGPANEL_HPP_INCLUDE\n#define EMP_PREFAB_CONFIGPANEL_HPP_INCLUDE\n\n#include <set>\n\n#include \"../datastructs/set_utils.hpp\"\n#include \"../tools/string_utils.hpp\"\n\n#include \"../config/config.hpp\"\n#include \"../web/Div.hpp\"\n#include \"../web/Element.hpp\"\n#include \"../web/Input.hpp\"\n\n// Prefab elements\n#include \"Card.hpp\"\n#include \"ValueBox.hpp\"\n\nnamespace emp {\nnamespace prefab {\n\n  namespace internal {\n      /**\n       * Shared pointer held by instances of ConfigPanel class representing\n       * the same conceptual ConfigPanel DOM object.\n       * Contains state that should persist while ConfigPanel DOM object\n       * persists.\n       */\n      class ConfigPanelInfo : public web::internal::DivInfo {\n\n      public:\n        using on_change_fun_t = std::function<void(const std::string &, const std::string &)>;\n\n      private:\n        on_change_fun_t on_change_fun{ [](const std::string & name, const std::string & val) { ; } };\n\n      public:\n        /**\n         * Construct a shared pointer to manage ConfigPanel state.\n         *\n         * @param in_id HTML ID of ConfigPanel div\n         */\n        ConfigPanelInfo( const std::string & in_id=\"\" )\n        : web::internal::DivInfo(in_id) { ; }\n\n        /**\n         * Get current on-update callback for a ConfigPanel.\n         *\n         * @return current callback function handle\n         */\n        on_change_fun_t & GetOnChangeFun() { return on_change_fun; }\n\n        /**\n         * Set on-update callback for a ConfigPanel.\n         *\n         * @param fun callback function handle\n         */\n        void SetOnChangeFun(const on_change_fun_t & fun) {\n          on_change_fun = fun;\n        }\n\n      };\n\n  }\n\n  /**\n   * Use the ConfigPanel class to easily add a dynamic configuration\n   * panel to your web app. Users can interact with the config panel\n   * by updating values.\n   *\n   * The ConfigPanel is constructed using subcomponents. Groups of\n   * settings are placed in Cards, and individual settings are represented\n   * by ValueControls.\n   */\n  class ConfigPanel : public web::Div {\n    public:\n      using on_change_fun_t = internal::ConfigPanelInfo::on_change_fun_t;\n\n    private:\n      /**\n       * Type of shared pointer shared among instances of ConfigPanel\n       * representing the same conceptual DOM element.\n       */\n      using INFO_TYPE = internal::ConfigPanelInfo;\n\n      /**\n       * Get shared info pointer, cast to ConfigPanel-specific type.\n       *\n       * @return cast pointer\n       */\n      INFO_TYPE * Info() {\n        return dynamic_cast<INFO_TYPE *>(info);\n      }\n\n      /**\n       * Get shared info pointer, cast to const ConfigPanel-specific type.\n       *\n       * @return cast pointer\n       */\n      const INFO_TYPE * Info() const {\n        return dynamic_cast<INFO_TYPE *>(info);\n      }\n\n      inline static std::set<std::string> numeric_types = {\"int\", \"double\", \"float\", \"uint32_t\", \"uint64_t\", \"size_t\"};\n      // Helper function to get prety names from config values\n      inline static std::function<std::string(const std::string &)> format_label = [](\n        const std::string & name\n      ) {\n        return to_titlecase(join(slice(name, '_'), \" \"));\n      };\n\n      /**\n       * Get current on-update callback.\n       *\n       * @return current callback function handle\n       */\n      on_change_fun_t& GetOnChangeFun() {\n          return Info()->GetOnChangeFun();\n      };\n\n    public:\n      /**\n       * @param config config object used to construct this panel\n       */\n      ConfigPanel(\n        Config & config,\n        bool open = true,\n        const std::string & div_name = \"\"\n      ) {\n        info = new internal::ConfigPanelInfo(div_name);\n        this->AddAttr(\"class\", \"config_main\");\n\n        // Reset button redirects to a URL with the current config settings\n        web::Element reload_button{\"a\", emp::to_string(GetID(), \"_\", \"reload\")};\n        reload_button.SetAttr(\"class\", \"btn btn-danger\");\n        std::stringstream query;\n        config.WriteUrlQueryString(query);\n        reload_button.SetAttr(\"href\", query.str());\n        reload_button << \"Reload with changes\";\n\n        on_change_fun_t & onChangeRef = GetOnChangeFun();\n\n        for (auto & group : config.GetGroupSet()) {\n          const std::string group_name(group->GetName());\n          const std::string group_desc(group->GetDesc());\n\n          // Setting groups have IDs generated by \"{main id}_{group name}_outer\"\n          const std::string group_base(emp::to_string(GetID(), \"_\", group_name, \"_outer\"));\n\n          Card group_card(open ? \"INIT_OPEN\" : \"INIT_CLOSED\", true, group_base);\n\n          group_card.AddHeaderContent(group_desc);\n          (*this) << group_card;\n          // A div within card helps make grid without messing up collapse properties\n          // and has ID \"{main id}_{group name}\" for ease of access\n          Div settings(emp::to_string(GetID(), \"_\", group_name));\n          settings.AddAttr(\"class\", \"settings_group\");\n          group_card << settings;\n\n          for (size_t i = 0; i < group->GetSize(); ++i) {\n            auto setting = group->GetEntry(i);\n            // Get loads of information from the config setting\n            const std::string name(setting->GetName());\n            const std::string pretty_name(format_label(name));\n            const std::string type(setting->GetType());\n            const std::string desc(setting->GetDescription());\n            const std::string value(setting->GetValue());\n\n            // Settings have IDs generated by can be accessed via \"{main id}_{setting name}\"\n            const std::string setting_base(emp::to_string(GetID(), \"_\", name));\n\n            const auto handleChange = [\n              name, reload=reload_button, &config, &handleChange = onChangeRef\n            ] (const std::string & val) {\n              config.Set(name, val);\n              // Run the handler function in case user wants to trigger something when the config values\n              // change (default does nothing)\n              handleChange(name, val);\n              // Update the reload button's href\n              std::stringstream ss;\n              config.WriteUrlQueryString(ss);\n              static_cast<web::Div>(reload).SetAttr(\"href\", ss.str());\n              // ^ TODO: need the cast a bug with SetAttr doesn't work for Element here, why?\n            };\n\n            // Add a different control depending on the config types\n            if (Has(numeric_types, type)) {\n              settings << NumericValueControl(\n                pretty_name, desc, value, type, handleChange, setting_base\n              );\n            } else if (type == \"std::string\") {\n              settings << TextValueControl(\n                pretty_name, desc, value, handleChange, setting_base\n              );\n            } else if (type == \"bool\") {\n              settings << BoolValueControl(\n                pretty_name, desc, emp::from_string<bool>(value), handleChange, setting_base\n              );\n            } else {\n              // If a setting type is unrecognized (e.g. a new type becomes supported in Config.hpp)\n              // just display its value (should we add a warning to the description?)\n              settings << ValueDisplay(pretty_name, desc, value, setting_base);\n            }\n          }\n        }\n\n        // A div at the end for controls\n        Div controls{emp::to_string(GetID(), \"_\", \"controls\")};\n        controls.AddAttr(\"class\", \"config_controls\");\n        (*this) << controls;\n\n        controls << reload_button;\n      }\n\n      /**\n       * Sets on-update callback for a ConfigPanel.\n       *\n       * @param fun callback function handle\n       */\n      void SetOnChangeFun(const on_change_fun_t& fun) {\n        Info()->SetOnChangeFun(fun);\n      }\n\n      /**\n       * Sets the range of a slider for a numeric setting.\n       *\n       * @param setting the numeric config value which will have its range slider updated\n       * @param min minimum value of the slider for this config value (use \"DEFAULT\"\n       * to leave unchanged)\n       * @param max maximum value of the slider for this config value (use \"DEFAULT\"\n       * to leave unchanged)\n       * @param step step size of the slider for this config value (use \"DEFAULT\"\n       * to leave unchanged)\n       */\n      void SetRange(\n        const std::string & setting,\n        const std::string & min,\n        const std::string & max = \"DEFAULT\",\n        const std::string & step = \"DEFAULT\"\n      ) {\n        const std::string target_id{emp::to_string(GetID(), \"_\", setting, \"_view\")};\n        if (this->HasChild(target_id)) {\n          Div target(this->Find(target_id));\n          if (target.Children()[0].IsInput()) {\n            web::Input slider{target.Children()[0]};\n            if (slider.GetType() == \"range\") {\n              if (min != \"DEFAULT\") {\n                slider.Min(min);\n              }\n              if (max != \"DEFAULT\") {\n                slider.Max(max);\n              }\n              if (step != \"DEFAULT\") {\n                slider.Step(step);\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * Excludes a setting or group of settings, recommend using ExcludeSetting\n       * or ExcludeGroup instead\n       *\n       * @param setting The name of a single setting that should not be\n       * displayed in the config panel\n       * @deprecated renamed to ExcludeSetting\n       */\n      [[deprecated(\"Use 'ExcludeSetting' to remove a single config parameter.\")]]\n      void ExcludeConfig(const std::string & setting) {\n        ExcludeSetting(setting);\n      }\n\n      /**\n       * Excludes a specific setting from the config panel\n       *\n       * @param setting name of the setting that should not be\n       * displayed in the config panel\n       */\n      void ExcludeSetting(const std::string & setting) {\n        const std::string target_id(emp::to_string(GetID(), \"_\", setting));\n        if (this->HasChild(target_id)) {\n          Div target(this->Find(target_id));\n          target.AddAttr(\"class\", \"excluded\");\n        }\n      }\n\n      /**\n       * Excludes an entire group of settings from the config panel\n       *\n       * @param setting_group name of the group that should not be\n       * displayed in the config panel\n       */\n      void ExcludeGroup(const std::string & setting_group) {\n        const std::string target_id(emp::to_string(GetID(), \"_\", setting_group, \"_outer\"));\n        if (this->HasChild(target_id)) {\n          Div target(this->Find(target_id));\n          target.AddAttr(\"class\", \"excluded\");\n        }\n      }\n\n      /**\n       * Arranges config panel based configuration pass to constructor\n       * @param config the config object used to create this panel\n       * @param id_prefix string appended to id for each setting (unusued)\n       * @deprecated No longer necessary for config panel to function.\n       * This function was a work around to fix a bug.\n       */\n      [[deprecated(\"Prefer construction of ConfigPanel after config values have been set.\")]]\n      void Setup(Config & config, bool open = true, const std::string & id_prefix = \"\") {\n        // Setup should no longer be used since it was a work-around to a bug,\n        // but if called will reinitialize the component by just making a new one\n        // to mimic earlier behavior\n        *this = ConfigPanel(config, open, id_prefix);\n      }\n\n      /** @return Div containing the entire config panel\n       *  @deprecated Can directly stream this component\n       */\n      [[deprecated(\"Can directly stream this component into another.\")]]\n      web::Div & GetConfigPanelDiv() { return (*this); }\n\n  };\n}\n}\n\n#endif // #ifndef EMP_PREFAB_CONFIGPANEL_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2016-2017\n *\n *  @file FunctionSet.hpp\n *  @brief Setup a collection of functions, all with the same signature, that can be run as a group.\n *  @note Status: BETA\n */\n\n#ifndef EMP_FUNCTIONAL_FUNCTIONSET_HPP_INCLUDE\n#define EMP_FUNCTIONAL_FUNCTIONSET_HPP_INCLUDE\n\n#include <functional>\n\n#include \"../base/vector.hpp\"\n\nnamespace emp {\n\n  template <typename T> class FunctionSet;\n\n  /// A vector of functions that can all be triggered at onece; results can either be returned\n  /// in a vector or post-processed in a function (such as max, min, etc.)\n  /// Derived from emp::vector, hence with all of the same methods as vector.\n  template <typename RETURN_T, typename... ARGS>\n  class FunctionSet<RETURN_T(ARGS...)> : public emp::vector<std::function<RETURN_T(ARGS...)>> {\n  protected:\n    mutable emp::vector<RETURN_T> return_vals;\n\n  public:\n    FunctionSet() : return_vals() { ; }\n    ~FunctionSet() { ; }\n\n    using base_t = emp::vector<std::function<RETURN_T(ARGS...)>>;\n    using value_type = typename base_t::value_type;\n    using return_t = RETURN_T;\n\n    /// How many functions are in this FunctionSet?\n    size_t GetSize() const { return base_t::size(); }\n\n    /// Add a new funtion to this FunctionSet\n    void Add(const value_type & in_fun) { base_t::push_back(in_fun); }\n\n    /// Remove the function at a specified position.\n    void Remove(size_t pos) { base_t::erase(base_t::begin()+pos); }\n\n    /// Run all functions and return a vector of all results.\n    const emp::vector<RETURN_T> & Run(ARGS... args) const {\n      const size_t num_tests = base_t::size();\n      return_vals.resize(num_tests);\n      for (size_t i = 0; i < num_tests; i++) {\n        return_vals[i] = (*this)[i](args...);\n      }\n      return return_vals;\n    }\n\n    /// If you want to provide a filter function, you can retrieve a specific return value.\n    /// The filter should take in two return values and indicate which is \"better\".\n    RETURN_T Run(ARGS... args, std::function<RETURN_T(RETURN_T, RETURN_T)> comp_fun,\n                 RETURN_T default_val=0) const {\n      if (base_t::size() == 0) return default_val;  // If we have no entries, return the default.\n\n      Run(args...);\n\n      RETURN_T best_found = return_vals[0];\n      for (size_t i = 1; i < return_vals.size(); i++) {\n        best_found = comp_fun(best_found, return_vals[i]);\n      }\n\n      return best_found;\n    }\n\n    /// Run all functions and return the highest value.\n    RETURN_T FindMax(ARGS... args, RETURN_T default_val=0) const {\n      return Run(args..., [](double i1, double i2){ return std::max(i1,i2); }, default_val);\n    }\n\n    /// Run all functions and return the lowest value.\n    RETURN_T FindMin(ARGS... args, RETURN_T default_val=0) const {\n      return Run(args..., [](double i1, double i2){ return std::min(i1,i2); }, default_val);\n    }\n\n    /// Run all functions and return the total value.\n    RETURN_T FindSum(ARGS... args, RETURN_T default_val=0) const {\n      return Run(args..., [](double i1, double i2){ return i1 + i2; }, default_val);\n    }\n\n    /// Run all functions and return a product of all values.\n    RETURN_T FindProduct(ARGS... args, RETURN_T default_val=1) const {\n      return Run(args..., [](double i1, double i2){ return i1 * i2; }, default_val);\n    }\n  };\n\n\n  /// A specialized version of FunctionSet for void functions.\n  template <typename... ARGS>\n  class FunctionSet<void(ARGS...)> : public emp::vector<std::function<void(ARGS...)>> {\n  public:\n    FunctionSet() { ; }\n    ~FunctionSet() { ; }\n\n    using base_t = emp::vector<std::function<void(ARGS...)>>;\n    using value_type = typename base_t::value_type;\n    using return_t = void;\n\n    /// How many functions are in this FunctionSet?\n    size_t GetSize() const { return base_t::size(); }\n\n    /// Add a new function to this FunctionSet.\n    void Add(const std::function<void(ARGS...)> & in_fun) { base_t::push_back(in_fun); }\n\n    /// Remove the function at the designated position from this FunctionSet.\n    void Remove(size_t pos) { base_t::erase(base_t::begin()+(int)pos); }\n\n    /// Run all functions in the FunctionSet\n    void Run(ARGS... args) const {\n      for (const std::function<void(ARGS...)> & cur_fun : *this) {\n        cur_fun(args...);\n      }\n    }\n  };\n\n}\n\n#endif // #ifndef EMP_FUNCTIONAL_FUNCTIONSET_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2016-2017\n *\n *  @file Action.hpp\n *  @brief A mechanism to abstract functions from their underlying type and provide run-time names.\n *  @note Status: Beta\n *\n *  @todo Create an ActionDefaults class that can take fewer args than expected and fill in rest.\n *  @todo Allow for named arguments to facilite intepreted functions.\n */\n\n#ifndef EMP_CONTROL_ACTION_HPP_INCLUDE\n#define EMP_CONTROL_ACTION_HPP_INCLUDE\n\n#include <functional>\n#include <string>\n\nnamespace emp {\n\n  /// BaseActions abstract functions and allow for signals to be setup at runtime; they can be\n  /// called with types specified in the call.\n  ///\n  /// Actions can be a bit heavyweight, but can easily be converted to more lightweight\n  /// std:function objects.\n\n  class ActionBase {\n  protected:\n    std::string name;  ///< A unique name for this action so it can be called at runtime.\n\n    ActionBase(const std::string & in_name) : name(in_name) { ; }\n\n    // Protected: ActionBase should not be copied directly, only through derived class.\n    ActionBase(const ActionBase &) = default;\n    ActionBase(ActionBase &&) = default;\n    ActionBase & operator=(const ActionBase &) = default;\n    ActionBase & operator=(ActionBase &&) = default;\n  public:\n    virtual ~ActionBase() { ; }\n\n    /// Get the name of this action.\n    const std::string & GetName() const { return name; }\n\n    /// Get number of arguments this action takes.\n    virtual size_t GetArgCount() const = 0;\n\n    /// Clone() will produce a pointer to a full copy of an Action, going through derived version.\n    virtual ActionBase * Clone() const = 0;\n  };\n\n  /// ActionSize is a second layer of abstract actions that know the number of arguments used at compile\n  /// time to facilitate easy type-checking.\n  template <size_t ARG_COUNT>\n  class ActionSize : public ActionBase {\n  protected:\n    ActionSize(const std::string & in_name) : ActionBase(in_name) { ; }\n  public:\n    size_t GetArgCount() const { return ARG_COUNT; }\n  };\n\n  /// The declaration for Action has any template types; the only definined specilizations require\n  /// a function type to be specified (with void and non-void return type variants.)\n  template <typename... ARGS> class Action;\n\n  /// This Action class specialization takes a function with a void return tyime and builds it off\n  /// of the action base classes.\n  template <typename... ARGS>\n  class Action<void(ARGS...)> : public ActionSize<sizeof...(ARGS)> {\n  protected:\n    std::function<void(ARGS...)> fun;  ///< The specific function associated with this action.\n  public:\n    using this_t = Action<void(ARGS...)>;\n    using parent_t = ActionSize<sizeof...(ARGS)>;\n\n    Action(const std::function<void(ARGS...)> & in_fun, const std::string & in_name=\"\")\n      : parent_t(in_name), fun(in_fun) { ; }\n    template <typename RETURN>\n    Action(const std::function<RETURN(ARGS...)> & in_fun, const std::string & in_name=\"\")\n      : parent_t(in_name)\n      , fun([in_fun](ARGS &&... args){in_fun(std::forward<ARGS>(args)...);}) { ; }\n    Action(const this_t &) = default;\n    Action(this_t &&) = default;\n\n    this_t & operator=(const this_t &) = default;\n    this_t & operator=(this_t &&) = default;\n\n    const std::function<void(ARGS...)> & GetFun() const { return fun; };\n\n    /// Call the function associated with this action.\n    void Call(ARGS &&... args) { return fun(std::forward<ARGS>(args)...); }\n\n    /// Build a copy of this Action.\n    this_t * Clone() const { return new this_t(*this); }\n  };\n\n\n  /// This Action class specialization takes a function with any non-void return tyime and builds it\n  /// off of the action base classes.\n  template <typename RETURN, typename... ARGS>\n  class Action<RETURN(ARGS...)> : public ActionSize<sizeof...(ARGS)> {\n  protected:\n    std::function<RETURN(ARGS...)> fun;  ///< The specific function associated with this action.\n  public:\n    using fun_t = RETURN(ARGS...);\n    using this_t = Action<fun_t>;\n    using parent_t = ActionSize<sizeof...(ARGS)>;\n\n    Action(const std::function<RETURN(ARGS...)> & in_fun, const std::string & in_name=\"\")\n      : parent_t(in_name), fun(in_fun) { ; }\n    Action(const this_t &) = default;\n    Action(this_t &&) = default;\n\n    this_t & operator=(const this_t &) = default;\n    this_t & operator=(this_t &&) = default;\n\n    const std::function<fun_t> & GetFun() const { return fun; };\n\n    /// Call the function associated with this action.\n    RETURN Call(ARGS &&... args) { return fun(std::forward<ARGS>(args)...); }\n\n    /// Build a copy of this Action.\n    this_t * Clone() const { return new this_t(*this); }\n  };\n\n  /// Build an action object using this function.\n  template <typename RETURN, typename... ARGS>\n  auto make_action(const std::function<RETURN(ARGS...)> & in_fun, const std::string & name=\"\") {\n    return Action<RETURN(ARGS...)>(in_fun, name);\n  }\n}\n\n#endif // #ifndef EMP_CONTROL_ACTION_HPP_INCLUDE\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL_BASE\n#define _LIBCPP_FUNCTIONAL_BASE\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <new>\n#include <utility>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nstruct _LIBCPP_TEMPLATE_VIS binary_function\n{\n    typedef _Arg1   first_argument_type;\n    typedef _Arg2   second_argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Tp>\nstruct __has_result_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::result_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS less : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x < __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS less<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n// __weak_result_type\n\ntemplate <class _Tp>\nstruct __derives_from_unary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _Ap, class _Rp>\n        static unary_function<_Ap, _Rp>\n        __test(const volatile unary_function<_Ap, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp>\nstruct __derives_from_binary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _A1, class _A2, class _Rp>\n        static binary_function<_A1, _A2, _Rp>\n        __test(const volatile binary_function<_A1, _A2, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp, bool = __derives_from_unary_function<_Tp>::value>\nstruct __maybe_derive_from_unary_function  // bool is true\n    : public __derives_from_unary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_unary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __derives_from_binary_function<_Tp>::value>\nstruct __maybe_derive_from_binary_function  // bool is true\n    : public __derives_from_binary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_binary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __has_result_type<_Tp>::value>\nstruct __weak_result_type_imp // bool is true\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n    typedef typename _Tp::result_type result_type;\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type_imp<_Tp, false>\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type\n    : public __weak_result_type_imp<_Tp>\n{\n};\n\n// 0 argument case\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp ()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (&)()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (*)()>\n{\n    typedef _Rp result_type;\n};\n\n// 1 argument case\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (&)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (*)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)()>\n    : public unary_function<_Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const>\n    : public unary_function<const _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() volatile>\n    : public unary_function<volatile _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const volatile>\n    : public unary_function<const volatile _Cp*, _Rp>\n{\n};\n\n// 2 argument case\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (*)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (&)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1)>\n    : public binary_function<_Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const>\n    : public binary_function<const _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>\n    : public binary_function<volatile _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>\n    : public binary_function<const volatile _Cp*, _A1, _Rp>\n{\n};\n\n\n#ifndef _LIBCPP_CXX03_LANG\n// 3 or more arguments\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Tp, class ..._Args>\nstruct __invoke_return\n{\n    typedef decltype(__invoke(_VSTD::declval<_Tp>(), _VSTD::declval<_Args>()...)) type;\n};\n\n#else // defined(_LIBCPP_CXX03_LANG)\n\n#include <__functional_base_03>\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\n\ntemplate <class _Ret>\nstruct __invoke_void_return_wrapper\n{\n#ifndef _LIBCPP_CXX03_LANG\n    template <class ..._Args>\n    static _Ret __call(_Args&&... __args) {\n        return __invoke(_VSTD::forward<_Args>(__args)...);\n    }\n#else\n    template <class _Fn>\n    static _Ret __call(_Fn __f) {\n        return __invoke(__f);\n    }\n\n    template <class _Fn, class _A0>\n    static _Ret __call(_Fn __f, _A0& __a0) {\n        return __invoke(__f, __a0);\n    }\n\n    template <class _Fn, class _A0, class _A1>\n    static _Ret __call(_Fn __f, _A0& __a0, _A1& __a1) {\n        return __invoke(__f, __a0, __a1);\n    }\n\n    template <class _Fn, class _A0, class _A1, class _A2>\n    static _Ret __call(_Fn __f, _A0& __a0, _A1& __a1, _A2& __a2){\n        return __invoke(__f, __a0, __a1, __a2);\n    }\n#endif\n};\n\ntemplate <>\nstruct __invoke_void_return_wrapper<void>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    template <class ..._Args>\n    static void __call(_Args&&... __args) {\n        __invoke(_VSTD::forward<_Args>(__args)...);\n    }\n#else\n    template <class _Fn>\n    static void __call(_Fn __f) {\n        __invoke(__f);\n    }\n\n    template <class _Fn, class _A0>\n    static void __call(_Fn __f, _A0& __a0) {\n        __invoke(__f, __a0);\n    }\n\n    template <class _Fn, class _A0, class _A1>\n    static void __call(_Fn __f, _A0& __a0, _A1& __a1) {\n        __invoke(__f, __a0, __a1);\n    }\n\n    template <class _Fn, class _A0, class _A1, class _A2>\n    static void __call(_Fn __f, _A0& __a0, _A1& __a1, _A2& __a2) {\n        __invoke(__f, __a0, __a1, __a2);\n    }\n#endif\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS reference_wrapper\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type* __f_;\n\npublic:\n    // construct/copy/destroy\n    _LIBCPP_INLINE_VISIBILITY reference_wrapper(type& __f) _NOEXCEPT\n        : __f_(_VSTD::addressof(__f)) {}\n#ifndef _LIBCPP_CXX03_LANG\n    private: reference_wrapper(type&&); public: // = delete; // do not bind to temps\n#endif\n\n    // access\n    _LIBCPP_INLINE_VISIBILITY operator type&    () const _NOEXCEPT {return *__f_;}\n    _LIBCPP_INLINE_VISIBILITY          type& get() const _NOEXCEPT {return *__f_;}\n\n#ifndef _LIBCPP_CXX03_LANG\n    // invoke\n    template <class... _ArgTypes>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_of<type&, _ArgTypes...>::type\n    operator() (_ArgTypes&&... __args) const {\n        return __invoke(get(), _VSTD::forward<_ArgTypes>(__args)...);\n    }\n#else\n\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return<type>::type\n    operator() () const {\n        return __invoke(get());\n    }\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0>::type\n    operator() (_A0& __a0) const {\n        return __invoke(get(), __a0);\n    }\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0 const>::type\n    operator() (_A0 const& __a0) const {\n        return __invoke(get(), __a0);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1>::type\n    operator() (_A0& __a0, _A1& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1>::type\n    operator() (_A0 const& __a0, _A1& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1 const>::type\n    operator() (_A0& __a0, _A1 const& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2>::type\n    operator() (_A0& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2 const>::type\n    operator() (_A0& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2 const>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2 const>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n#endif // _LIBCPP_CXX03_LANG\n};\n\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(_Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<_Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return ref(__t.get());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(const _Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<const _Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return cref(__t.get());\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp> void ref(const _Tp&&) = delete;\ntemplate <class _Tp> void cref(const _Tp&&) = delete;\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class, class = void>\nstruct __is_transparent : false_type {};\n\ntemplate <class _Tp, class _Up>\nstruct __is_transparent<_Tp, _Up,\n                        typename __void_t<typename _Tp::is_transparent>::type>\n   : true_type {};\n#endif\n\n// allocator_arg_t\n\nstruct _LIBCPP_TEMPLATE_VIS allocator_arg_t { };\n\n#if defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_LIBRARY)\nextern _LIBCPP_EXPORTED_FROM_ABI const allocator_arg_t allocator_arg;\n#else\n/* _LIBCPP_INLINE_VAR */ constexpr allocator_arg_t allocator_arg = allocator_arg_t();\n#endif\n\n// uses_allocator\n\ntemplate <class _Tp>\nstruct __has_allocator_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::allocator_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>\nstruct __uses_allocator\n    : public integral_constant<bool,\n        is_convertible<_Alloc, typename _Tp::allocator_type>::value>\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct __uses_allocator<_Tp, _Alloc, false>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct _LIBCPP_TEMPLATE_VIS uses_allocator\n    : public __uses_allocator<_Tp, _Alloc>\n{\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp, class _Alloc>\n_LIBCPP_INLINE_VAR constexpr size_t uses_allocator_v = uses_allocator<_Tp, _Alloc>::value;\n#endif\n\n#ifndef _LIBCPP_CXX03_LANG\n\n// allocator construction\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor_imp\n{\n    typedef typename __uncvref<_Alloc>::type _RawAlloc;\n    static const bool __ua = uses_allocator<_Tp, _RawAlloc>::value;\n    static const bool __ic =\n        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;\n    static const int value = __ua ? 2 - __ic : 0;\n};\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor\n    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>\n    {};\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)...);\n}\n\n// FIXME: This should have a version which takes a non-const alloc.\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (allocator_arg, __a, _VSTD::forward<_Args>(__args)...);\n}\n\n// FIXME: This should have a version which takes a non-const alloc.\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)..., __a);\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL_BASE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2021\n *\n *  @file ValueBox.hpp\n *  @brief UI subcomponent for ConfigPanel and ReadoutPanel.\n */\n\n#ifndef EMP_PREFAB_VALUEBOX_HPP_INCLUDE\n#define EMP_PREFAB_VALUEBOX_HPP_INCLUDE\n\n#include <cmath>\n\n#include \"../datastructs/set_utils.hpp\"\n#include \"../tools/string_utils.hpp\"\n\n#include \"../web/Div.hpp\"\n#include \"../web/Element.hpp\"\n#include \"../web/Input.hpp\"\n\n#include \"Collapse.hpp\"\n#include \"CommentBox.hpp\"\n#include \"FontAwesomeIcon.hpp\"\n#include \"ToggleSwitch.hpp\"\n\nnamespace emp::prefab {\n\n  /**\n   * ValueBox is the base class for a component to show information.\n   * At its core it has a label, a description, and a value to display.\n   *\n   * ValueBoxes and derived classes placed in component with the \"settings_group\"\n   * or \"display_group\" class will align to a grid.\n   */\n  class ValueBox : public web::Div {\n\n    protected:\n\n    CommentBox description{emp::to_string(GetID(), \"_descr\")};\n    Div view{emp::to_string(GetID(), \"_view\")};\n\n    public:\n    /**\n     * @param label name for this value\n     * @param desc a more detailed description of what the value means\n     * @param id user defined ID for ValueBox Div (default is emscripten generated)\n     */\n    ValueBox(\n      const std::string & label,\n      const std::string & desc,\n      const std::string & id=\"\"\n    ) : Div(id) {\n      web::Element drop_button(\"button\", emp::to_string(GetID(), \"_label\"));\n      drop_button.AddAttr(\"class\", \"btn btn-link\");\n\n      FontAwesomeIcon arrow_right(\"fa-angle-double-right\");\n      arrow_right.AddAttr(\"class\", \"toggle_icon_right_margin\");\n      FontAwesomeIcon arrow_up(\"fa-angle-double-up\");\n      arrow_up.AddAttr(\"class\", \"toggle_icon_right_margin\");\n      drop_button << arrow_right;\n      drop_button << arrow_up;\n      drop_button << label;\n\n      description.AddContent(desc);\n      CollapseCoupling(drop_button, description, false);\n      *this << drop_button;\n      *this << description;\n      *this << view;\n      this->AddAttr(\"class\", \"value_box\");\n      view.AddAttr(\"class\", \"value_view\");\n      description.AddAttr(\"class\", \"value_description\");\n    }\n\n    /**\n     * Returns the view div containing live values to animate\n     * (use this in an Animate instance).\n     *\n     * @return the view div\n     */\n    Div & GetView() {\n      return view;\n    }\n  };\n\n  /**\n   * Use a ValueDisplay component to display a labeled, static value with\n   * a nice description of what this value means.\n   *\n   * We suggest adding the \"display_group\" class to the enclosing tag around\n   * multiple ValueDisplays to align labels and values along a common grid.\n   */\n  class ValueDisplay : public ValueBox {\n\n    public:\n    /**\n     * @param label name for this value\n     * @param desc a more detailed description of what the value means\n     * @param value the piece of information or data being displayed\n     * @param id user defined ID for ValueDisplay div (default is emscripten generated)\n     */\n    ValueDisplay(\n      const std::string & label,\n      const std::string & desc,\n      const std::string & value,\n      const std::string & id=\"\"\n    ) : ValueBox(label, desc, id) {\n      view << value;\n    }\n  };\n\n  /**\n   * Use a LiveValueDisplay component to display a labeled value which will\n   * change over the course of a simulation with a nice description of what\n   * this value means. Internally, it manages an Animator to redraw the\n   * view at the fastest possible framerate unless independent=false.\n   *\n   * We suggest adding the \"display_group\" class to the enclosing tag around\n   * multiple LiveValueDisplays to align labels and values along a common grid.\n   */\n  class LiveValueDisplay : public ValueBox {\n\n    public:\n    /**\n     * @param label name for this value\n     * @param desc a more detailed description of what the value means\n     * @param value a value to display or function returning a string\n     * @param independent should this component be independently animated? Or will\n     * some other component manage its animation?\n     * @param id user defined ID for LiveValueDisplay div (default is emscripten generated)\n     */\n    template<typename T>\n    LiveValueDisplay(\n      const std::string & label,\n      const std::string & desc,\n      T && value,\n      const bool & independent=true,\n      const std::string & id=\"\"\n    ) : ValueBox(label, desc, id) {\n      view << web::Live(std::forward<T>(value));\n      if (independent) {\n        this->AddAnimation(GetID(), [](){;}, view);\n        this->Animate(GetID()).Start();\n      }\n    }\n  };\n\n  /**\n   * ValueControl is the base class for components the user should be\n   * able to interact with. The view will contain the Input object for\n   * controlling the value.\n   */\n  class ValueControl : public ValueBox {\n    protected:\n    web::Input mainCtrl;\n    public:\n    /**\n     * @param label name for this value\n     * @param desc a more detailed description of what the value means\n     * @param initial_value the initial value\n     * @param input Input component that user can interact with\n     * @param id user defined ID for ValueControl div (default is emscripten generated)\n     */\n    ValueControl(\n      const std::string & label,\n      const std::string & desc,\n      const std::string & inital_value,\n      web::Input input,\n      const std::string & id=\"\"\n    ) : ValueBox(label, desc, id), mainCtrl(input) {\n      view << mainCtrl;\n      mainCtrl.Value(inital_value);\n    }\n  };\n\n  /**\n   * Use a TextValueControl to display a boolean value with a label,\n   * description, and a text input to manipulate the value.\n   */\n  class TextValueControl : public ValueControl {\n    public:\n    /**\n     * @param label name for this value\n     * @param desc a more detailed description of what the value means\n     * @param value the initial value\n     * @param onChange function to be called when the user changes this value\n     * @param id user defined ID for TextValueControl div (default is emscripten generated)\n     */\n    TextValueControl(\n      const std::string & label,\n      const std::string & desc,\n      const std::string & value,\n      const std::function<void(const std::string &)> & onChange = [](const std::string &) { ; },\n      const std::string & id=\"\"\n    ) : ValueControl(label, desc, value, web::Input(onChange, \"text\", \"\"), id) {\n      mainCtrl.AddAttr(\"class\", \"form-control\");\n    }\n  };\n\n  /**\n   * Use a BoolValueControl to display a boolean value with a label,\n   * description, and a switch to toggle the value.\n   */\n  class BoolValueControl : public ValueBox {\n    public:\n    /**\n     * @param label name for this value\n     * @param desc a more detailed description of what the value means\n     * @param value the initial value\n     * @param onChange function to be called when the user changes this value\n     * @param id user defined ID for BoolValueControl div (default is emscripten generated)\n     */\n    BoolValueControl(\n      const std::string & label,\n      const std::string & desc,\n      const bool is_checked,\n      const std::function<void(const std::string &)> & onChange = [](const std::string &) { ; },\n      const std::string & id=\"\"\n    ) : ValueBox(label, desc, id) {\n      prefab::ToggleSwitch toggle(onChange, \"\", is_checked);\n      view << toggle;\n    }\n  };\n\n  /**\n   * Use a NumericValueControl to display a number with a label,\n   * description, synchronized slider and number box to change the\n   * value.\n   */\n  class NumericValueControl : public ValueControl {\n\n    using range_setter_t = std::function<void(\n      const std::string &, // value\n      const std::string &, // type\n      emp::web::Input &\n    )>;\n\n    // Determine the default range by finding the next highest order of magnitude (base 10)\n    inline static range_setter_t applyDefaultRange = [](\n      const std::string & value,\n      const std::string & type,\n      emp::web::Input & in\n    ) {\n      if(type == \"float\" || type == \"double\") {\n        const double val = emp::from_string<double>(value);\n        const int max = (abs(val) <= 1) ? 1 : static_cast<int>(pow(10, ceil(log10(abs(val)))));\n        const int min = (val >= 0) ? 0 : -max;\n        const double step = max/100.0;\n        in.Max(max);\n        in.Min(min);\n        in.Step(step);\n      } else {\n        const int val = emp::from_string<int>(value);\n        const int max = (abs(val) <= 10) ? 10 : static_cast<int>(pow(10, ceil(log10(abs(val)))));\n        const int min = (val >= 0) ? 0 : -max;\n        const int step = (int)fmax(max/100.0, 1);\n        in.Max(max);\n        in.Min(min);\n        in.Step(step);\n      }\n    };\n\n    public:\n    /**\n     * @param label name for this value\n     * @param desc a more detailed description of what the value means\n     * @param type the numeric type ('float', 'double' or 'int')\n     * @param value the initial value\n     * @param onChange function to be called when the user changes this value\n     * @param id user defined ID for NumericValueControl div (default is emscripten generated)\n     */\n    NumericValueControl(\n      const std::string & label,\n      const std::string & desc,\n      const std::string & value,\n      const std::string & type,\n      const std::function<void(const std::string & val)> & onChange = [](const std::string & val) { ; },\n      const std::string & id=\"\"\n    ) : ValueControl(label, desc, value, web::Input([](const std::string & val){ ; }, \"range\", \"\"), id) {\n      mainCtrl.AddAttr(\"class\", \"form-range\");\n      web::Input temp(mainCtrl);\n      web::Input number_box([slider=temp, onChange](const std::string & val) mutable {\n        // Lambdas must be marked mutable since .Value is not a const function\n        // Note: referenced components/functions must be captured by value at\n        // this lowest level or dangling references (and broken components) result!\n        slider.Value(val);\n      }, \"number\", \"\");\n      mainCtrl.Callback([number_box, onChange](const std::string & val) mutable {\n        onChange(val);\n        number_box.Value(val);\n      });\n      number_box.Value(value);\n      number_box.AddAttr(\"class\", \"form-control\");\n      view << number_box;\n      NumericValueControl::applyDefaultRange(value, type, mainCtrl);\n      NumericValueControl::applyDefaultRange(value, type, number_box);\n    }\n\n    /**\n     * @param det a function that based on the value and type provided sets\n     * a slider input's min, max and step values appropriately.\n     */\n    static void setDefaultRangeMaker(const range_setter_t & det) {\n      applyDefaultRange = det;\n    }\n  };\n}\n\n#endif // #ifndef EMP_PREFAB_VALUEBOX_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2018\n *\n *  @file Input.hpp\n *  @brief Create/control an HTML input and call a specified function when it receives input.\n *\n *  Use example:\n *\n *    emp::web::Input my_input(MyFun, \"input type\", \"input Name\", \"html_id\");\n *\n *  Where my_input is the C++ object linking to the input, MyFun is the\n *  function you want to call on changes, \"Input Name\" is the label on the\n *  input itself, and \"html_id\" is the optional id you want it to use in the\n *  HTML code (otherwise it will generate a unique name on its own.)\n *\n *  Member functions to set state:\n *    Input & Callback(const std::function<void()> & in_callback)\n *    Input & Label(const std::string & in_label)\n *    Input & Autofocus(bool in_af)\n *    Input & Disabled(bool in_dis)\n *\n *  Retriving current state:\n *    const std::string & GetLabel() const\n *    bool HasAutofocus() const\n *    bool IsDisabled() const\n */\n\n#ifndef EMP_WEB_INPUT_HPP_INCLUDE\n#define EMP_WEB_INPUT_HPP_INCLUDE\n\n\n#include \"Widget.hpp\"\n\nnamespace emp {\nnamespace web {\n\n  /// Create or control an HTML Input object that you can manipulate and update as needed.\n  class Input : public internal::WidgetFacet<Input> {\n    friend class InputInfo;\n  protected:\n    #ifndef DOXYGEN_SHOULD_SKIP_THIS\n    // Inputs associated with the same DOM element share a single InputInfo object.\n    class InputInfo : public internal::WidgetInfo {\n      friend Input;\n    protected:\n      std::string label;\n      std::string type;\n      std::string min = \"\";\n      std::string max = \"\";\n      std::string value = \"\";\n      std::string step = \"\";\n\n      std::string curr_val =\"\";\n      bool show_value = false;\n      bool autofocus;\n\n      std::function<void(std::string)> callback;\n      std::function<bool(std::string)> checker;\n      uint32_t callback_id;\n      std::string onchange_info;\n\n      InputInfo(const std::string & in_id=\"\")\n      : internal::WidgetInfo(in_id)\n      , checker([](std::string in){ return true; })\n      { ; }\n      InputInfo(const InputInfo &) = delete;               // No copies of INFO allowed\n      InputInfo & operator=(const InputInfo &) = delete;   // No copies of INFO allowed\n      virtual ~InputInfo() {\n        if (callback_id) emp::JSDelete(callback_id);         // Delete callback wrapper.\n      }\n\n      std::string GetTypeName() const override { return \"InputInfo\"; }\n\n      virtual void GetHTML(std::stringstream & HTML) override {\n\n        // CSS from https://stackoverflow.com/questions/46695616/align-range-slider-and-label\n\n        HTML.str(\"\");                                           // Clear the current text.\n        // HTML << \"<form style=\\\"display:flex; flex-flow:row; align-items:center;\\\">\";                                       // Needs to be part of form for label + output to work\n        if (label != \"\") {                                      // Add label, if one exists\n          HTML << \"<label for=\\\"\" << id << \"\\\"> \";\n          HTML << label <<  \"</label>\";\n        }\n        HTML << \"<input type=\\\"\" << type << \"\\\"\";               // Indicate input type.\n        if (min != \"\") HTML << \" min=\\\"\" << min << \"\\\"\";        // Add a min allowed value if there is one.\n        if (max != \"\") HTML << \" max=\\\"\" << max << \"\\\"\";        // Add a max allowed value if there is one.\n        if (value != \"\") HTML << \" value=\\\"\" << value << \"\\\"\";  // Add a current value if there is one.\n        if (step != \"\") HTML << \" step=\\\"\" << step << \"\\\"\";     // Add a step if there is one.\n        HTML << \" id=\\\"\" << id << \"\\\"\";                         // Indicate ID.\n        HTML << \" onchange=\\\"\" << onchange_info << \"\\\"\";        // Indicate action on change.\n        HTML << \">\" << \"</input>\";                              // Close the Input.\n        if (show_value) {\n          HTML << \"<output for=\" << id << \"onforminput=\\\"value = \" << id << \".valueAsNumber;\\\"></output>\";         // Add output to show value of slider\n        }\n        // HTML << \"</form>\";\n      }\n\n      virtual void TriggerJS() override {\n\n        if (show_value) {\n          // Inspired by https://codepen.io/chriscoyier/pen/imdrE\n          EM_ASM_ARGS({\n\n            function modifyOffset() {\n              var el;\n              var newPlace;\n              var offset;\n              var siblings;\n              var k;\n              var width    = this.offsetWidth;\n              var newPoint = (this.value - this.getAttribute(\"min\")) / (this.getAttribute(\"max\") - this.getAttribute(\"min\"));\n              offset   = -1;\n              if (newPoint < 0) { newPlace = 0;  }\n              else if (newPoint > 1) { newPlace = width; }\n              else { newPlace = width * newPoint + offset; offset -= newPoint;}\n              siblings = this.parentNode.childNodes;\n              for (var i = 0; i < siblings.length; i++) {\n                sibling = siblings[i];\n                if (sibling.id == this.id) { k = true; }\n                if ((k == true) && (sibling.nodeName == \"OUTPUT\")) {\n                  outputTag = sibling;\n                }\n              }\n              outputTag.innerHTML  = this.value;\n            }\n\n            function modifyInputs() {\n\n                var input_el = document.getElementById(UTF8ToString($0));\n                input_el.addEventListener(\"input\", modifyOffset);\n                // the following taken from http://stackoverflow.com/questions/2856513/trigger-onchange-event-manually\n                if (\"fireEvent\" in input_el) {\n                    input_el.fireEvent(\"oninput\");\n                } else {\n                    var evt = document.createEvent(\"HTMLEvents\");\n                    evt.initEvent(\"input\", false, true);\n                    input_el.dispatchEvent(evt);\n                }\n            }\n\n            modifyInputs();\n          }, id.c_str());\n        }\n      }\n\n      void DoChange(std::string new_val) {\n        if (curr_val == new_val) return;\n\n        if (!checker(new_val)) {\n          std::swap(curr_val, new_val);\n          UpdateValue(new_val);\n        } else {\n          curr_val = new_val;\n          callback(curr_val);\n          UpdateDependants();\n        }\n      }\n\n      void UpdateCallback(const std::function<void(std::string)> & in_cb) {\n        callback = in_cb;\n      }\n\n      void UpdateChecker(const std::function<bool(std::string)> & in_ck) {\n        checker = in_ck;\n      }\n\n      void UpdateLabel(const std::string & in_label) {\n        label = in_label;\n        if (state == Widget::ACTIVE) ReplaceHTML();     // If node is active, immediately redraw!\n      }\n      void UpdateType(const std::string & in_type) {\n        type = in_type;\n        if (state == Widget::ACTIVE) ReplaceHTML();     // If node is active, immediately redraw!\n      }\n      void UpdateMin(const std::string & in_min) {\n        min = in_min;\n        if (state == Widget::ACTIVE) ReplaceHTML();     // If node is active, immediately redraw!\n      }\n      void UpdateMin(const double & in_min) {\n        min = to_string(in_min);\n        if (state == Widget::ACTIVE) ReplaceHTML();     // If node is active, immediately redraw!\n      }\n      void UpdateMax(const std::string & in_max) {\n        max = in_max;\n        if (state == Widget::ACTIVE) ReplaceHTML();     // If node is active, immediately redraw!\n      }\n      void UpdateMax(const double & in_max) {\n        max = to_string(in_max);\n        if (state == Widget::ACTIVE) ReplaceHTML();     // If node is active, immediately redraw!\n      }\n      void UpdateValue(const std::string & in_value) {\n        value = in_value;\n        DoChange(in_value);\n        if (state == Widget::ACTIVE) ReplaceHTML();     // If node is active, immediately redraw!\n      }\n      void UpdateValue(const double & in_value) {\n        value = to_string(in_value);\n        DoChange(value);\n        if (state == Widget::ACTIVE) ReplaceHTML();     // If node is active, immediately redraw!\n      }\n      void UpdateStep(const std::string & in_step) {\n        step = in_step;\n        if (state == Widget::ACTIVE) ReplaceHTML();     // If node is active, immediately redraw!\n      }\n      void UpdateStep(const double & in_step) {\n        step = to_string(in_step);\n        if (state == Widget::ACTIVE) ReplaceHTML();     // If node is active, immediately redraw!\n      }\n      void UpdateAutofocus(bool in_af) {\n        autofocus = in_af;\n        if (state == Widget::ACTIVE) ReplaceHTML();     // If node is active, immediately redraw!\n      }\n      void UpdateDisabled(bool in_dis) {\n        if (in_dis) extras.SetAttr(\"disabled\", \"true\");\n        else extras.RemoveAttr(\"disabled\");\n        if (state == Widget::ACTIVE) ReplaceHTML();     // If node is active, immediately redraw!\n      }\n\n    public:\n      virtual std::string GetType() override { return \"web::InputInfo\"; }\n    }; // End of InputInfo definition\n    #endif // DOXYGEN_SHOULD_SKIP_THIS\n\n    // Get a properly cast version of info.\n    InputInfo * Info() { return (InputInfo *) info; }\n    const InputInfo * Info() const { return (InputInfo *) info; }\n\n    Input(InputInfo * in_info) : WidgetFacet(in_info) { ; }\n\n  public:\n\n    /// Create a new Input.\n    /// @param in_cb The function to call when the Input is changed.\n    /// @param in_type The type of this input.\n    /// @param in_label The label that should appear on the Input.\n    /// @param in_id The HTML ID to use for this Input (leave blank for auto-generated)\n    /// @param show_value Do you want to add an output element to display to value of this input?\n    /// @param is_checked Should the is_checked attribute by set to true or false?\n    Input(\n      const std::function<void(std::string)> & in_cb,\n      const std::string & in_type,\n      const std::string & in_label,\n      const std::string & in_id=\"\",\n      bool show_value=false,\n      bool is_checked=false\n    )\n      : WidgetFacet(in_id)\n    {\n      info = new InputInfo(in_id);\n\n      Info()->label = in_label;\n      Info()->type = in_type;\n      Info()->show_value = show_value;\n      Info()->autofocus = false;\n      Info()->curr_val = \"\";\n\n      Info()->callback = in_cb;\n      InputInfo * b_info = Info();\n      Info()->callback_id = JSWrap( std::function<void(std::string)>( [b_info](std::string new_val){b_info->DoChange(new_val);} )  );\n      Info()->onchange_info = emp::to_string(\"emp.Callback(\", Info()->callback_id, \", ['checkbox', 'radio'].includes(this.type) ? (this.checked ? '1' : '0') : this.value);\");\n      // Allows user to set the checkbox to start out on/checked\n      if (in_type.compare(\"checkbox\") == 0 && is_checked){\n        this->SetAttr(\"checked\", \"true\");\n      }\n    }\n\n    /// Link to an existing Input.\n    Input(const Input & in) : WidgetFacet(in) { ; }\n    Input(const Widget & in) : WidgetFacet(in) { emp_assert(in.IsInput()); }\n    Input() : WidgetFacet(\"\") { info = nullptr; }\n    virtual ~Input() { ; }\n\n    using INFO_TYPE = InputInfo;\n\n    /// Set a new callback function to trigger when the Input is clicked.\n    Input & Callback(const std::function<void(std::string)> & in_cb) {\n      Info()->UpdateCallback(in_cb);\n      return *this;\n    }\n\n    /// Set a new checker function to trigger when the Input is clicked.\n    Input & Checker(const std::function<bool(std::string)> & in_ck) {\n      Info()->UpdateChecker(in_ck);\n      return *this;\n    }\n\n    /// Set a new label to appear on this Input.\n    Input & Label(const std::string & in_label) { Info()->UpdateLabel(in_label); return *this; }\n\n    /// Update the type\n    Input & Type(const std::string & in_t) { Info()->UpdateType(in_t); return *this; }\n\n    /// Update the min\n    Input & Min(const std::string & in_m) { Info()->UpdateMin(in_m); return *this; }\n    /// Update the min\n    Input & Min(const double & in_m) { Info()->UpdateMin(in_m); return *this; }\n\n    /// Update the max\n    Input & Max(const std::string & in_m) { Info()->UpdateMax(in_m); return *this; }\n    /// Update the max\n    Input & Max(const double & in_m) { Info()->UpdateMax(in_m); return *this; }\n\n    /// Update the current value\n    Input & Value(const std::string & in_m) { Info()->UpdateValue(in_m); return *this; }\n    /// Update the current value\n    Input & Value(const double & in_m) { Info()->UpdateValue(in_m); return *this; }\n\n    /// Update the current step size\n    Input & Step(const std::string & in_m) { Info()->UpdateStep(in_m); return *this; }\n    /// Update the current step size\n    Input & Step(const double & in_m) { Info()->UpdateStep(in_m); return *this; }\n\n    /// Setup this Input to have autofocus (or remove it!)\n    Input & Autofocus(bool in_af=true) { Info()->UpdateAutofocus(in_af); return *this; }\n\n    /// Setup this Input to be disabled (or re-enable it!)\n    Input & Disabled(bool in_dis=true) { Info()->UpdateDisabled(in_dis); return *this; }\n\n    /// Get the current label on this Input.\n    const std::string & GetCurrValue() const { return Info()->curr_val; }\n\n    /// Get the current label on this Input.\n    const std::string & GetLabel() const { return Info()->label; }\n\n    /// Get the current type of this input.\n    const std::string & GetType() const { return Info()->type; }\n\n    /// Get the current min of this input.\n    const std::string & GetMin() const { return Info()->min; }\n\n    /// Get the current max of this input.\n    const std::string & GetMax() const { return Info()->max; }\n\n    /// Get the value attribute of this input.\n    const std::string & GetValue() const { return Info()->value; }\n\n    /// Get the value attribute of this input.\n    const std::string & GetStep() const { return Info()->step; }\n\n    /// Determine if this Input currently has autofocus.\n    bool HasAutofocus() const { return Info()->autofocus; }\n\n    /// Determine if this Input is currently disabled.\n    bool IsDisabled() const { return Info()->extras.HasAttr(\"disabled\"); }\n  };\n\n\n}\n}\n\n#endif // #ifndef EMP_WEB_INPUT_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2021\n *\n *  @file ToggleSwitch.hpp\n *  @brief Wraps Bootstrap's toggle switch.\n */\n\n#ifndef EMP_PREFAB_TOGGLESWITCH_HPP_INCLUDE\n#define EMP_PREFAB_TOGGLESWITCH_HPP_INCLUDE\n\n#include \"../tools/string_utils.hpp\"\n#include \"../web/Element.hpp\"\n#include \"../web/Input.hpp\"\n#include \"../web/Widget.hpp\"\n\nnamespace emp {\nnamespace prefab {\n  class ToggleSwitch: public web::Element {\n    private:\n      // Label for switch\n      web::Element label_element{emp::to_string(\"label\")};\n    public:\n      /**\n       * @param cb callback function passed onto input constructor\n       * @param label text for switch label\n       * @param is_checked is the switched defaulted to on?\n       * @param t_switch_id the id to assign the html object for this switch\n       */\n      ToggleSwitch(\n        const std::function<void(std::string)> & cb,\n        const std::string & label,\n        const bool is_checked=false,\n        const std::string & t_switch_id=\"\")\n        : web::Element(\"span\", t_switch_id) {\n\n        /*\n         * When constructing checkbox input, do not use built in label\n         * functionality because for toggle switch classes to work,\n         * the label element must come after input element. Label element is\n         * placed before input element in Input constructor.\n         */\n        web::Input checkbox(cb, \"checkbox\", \"\", \"\", false, is_checked);\n        *this << checkbox;\n        *this << label_element;\n        if (label != \"\") {\n          label_element << label;\n        }\n        checkbox.SetAttr(\"class\", \"custom-control-input\");\n        this->SetAttr(\"class\", \"custom-control custom-switch\");\n        this->SetCSS(\n          \"clear\", \"none\",\n          \"display\", \"inline\"\n        );\n        label_element.SetAttr(\n          \"class\", \"custom-control-label\",\n          \"for\", checkbox.GetID()\n        );\n      }\n\n      /// Add label to switch after constructor\n      template <typename T>\n      void AddLabel(const T usr_label) {\n        label_element << usr_label;\n      }\n  };\n}\n}\n\n#endif // #ifndef EMP_PREFAB_TOGGLESWITCH_HPP_INCLUDE\n","// -*- C++ -*-\n//===------------------------------ bit ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===---------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_BIT\n#define _LIBCPP_BIT\n\n/*\n    bit synopsis\n\nnamespace std {\n\n} // namespace std\n\n*/\n\n#include <__config>\n#include <version>\n\n#if defined(__IBMCPP__)\n#include \"support/ibm/support.h\"\n#endif\n#if defined(_LIBCPP_COMPILER_MSVC)\n#include <intrin.h>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#ifndef _LIBCPP_COMPILER_MSVC\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __ctz(unsigned __x)           { return __builtin_ctz(__x); }\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __ctz(unsigned long __x)      { return __builtin_ctzl(__x); }\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __ctz(unsigned long long __x) { return __builtin_ctzll(__x); }\n\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __clz(unsigned __x)           { return __builtin_clz(__x); }\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __clz(unsigned long __x)      { return __builtin_clzl(__x); }\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __clz(unsigned long long __x) { return __builtin_clzll(__x); }\n\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __popcount(unsigned __x)           { return __builtin_popcount(__x); }\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __popcount(unsigned long __x)      { return __builtin_popcountl(__x); }\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __popcount(unsigned long long __x) { return __builtin_popcountll(__x); }\n\n#else  // _LIBCPP_COMPILER_MSVC\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nint __ctz(unsigned __x) {\n  static_assert(sizeof(unsigned) == sizeof(unsigned long), \"\");\n  static_assert(sizeof(unsigned long) == 4, \"\");\n  unsigned long __where;\n  if (_BitScanForward(&__where, __x))\n    return static_cast<int>(__where);\n  return 32;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __ctz(unsigned long __x) {\n    static_assert(sizeof(unsigned long) == sizeof(unsigned), \"\");\n    return __ctz(static_cast<unsigned>(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __ctz(unsigned long long __x) {\n    unsigned long __where;\n#if defined(_LIBCPP_HAS_BITSCAN64)\n    (defined(_M_AMD64) || defined(__x86_64__))\n  if (_BitScanForward64(&__where, __x))\n    return static_cast<int>(__where);\n#else\n  // Win32 doesn't have _BitScanForward64 so emulate it with two 32 bit calls.\n  if (_BitScanForward(&__where, static_cast<unsigned long>(__x)))\n    return static_cast<int>(__where);\n  if (_BitScanForward(&__where, static_cast<unsigned long>(__x >> 32)))\n    return static_cast<int>(__where + 32);\n#endif\n  return 64;\n}\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nint __clz(unsigned __x) {\n  static_assert(sizeof(unsigned) == sizeof(unsigned long), \"\");\n  static_assert(sizeof(unsigned long) == 4, \"\");\n  unsigned long __where;\n  if (_BitScanReverse(&__where, __x))\n    return static_cast<int>(31 - __where);\n  return 32; // Undefined Behavior.\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __clz(unsigned long __x) {\n    static_assert(sizeof(unsigned) == sizeof(unsigned long), \"\");\n    return __clz(static_cast<unsigned>(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __clz(unsigned long long __x) {\n  unsigned long __where;\n#if defined(_LIBCPP_HAS_BITSCAN64)\n  if (_BitScanReverse64(&__where, __x))\n    return static_cast<int>(63 - __where);\n#else\n  // Win32 doesn't have _BitScanReverse64 so emulate it with two 32 bit calls.\n  if (_BitScanReverse(&__where, static_cast<unsigned long>(__x >> 32)))\n    return static_cast<int>(63 - (__where + 32));\n  if (_BitScanReverse(&__where, static_cast<unsigned long>(__x)))\n    return static_cast<int>(63 - __where);\n#endif\n  return 64; // Undefined Behavior.\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __popcount(unsigned __x) {\n  static_assert(sizeof(unsigned) == 4, \"\");\n  return __popcnt(__x);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __popcount(unsigned long __x) {\n  static_assert(sizeof(unsigned long) == 4, \"\");\n  return __popcnt(__x);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __popcount(unsigned long long __x) {\n  static_assert(sizeof(unsigned long long) == 8, \"\");\n  return __popcnt64(__x);\n}\n\n#endif // _LIBCPP_COMPILER_MSVC\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif // _LIBCPP_BIT\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2021.\n *\n *  @file Random.hpp\n *  @brief A versatile and non-patterned pseudo-random-number generator.\n *  @note Status: RELEASE\n */\n\n#ifndef EMP_MATH_RANDOM_HPP_INCLUDE\n#define EMP_MATH_RANDOM_HPP_INCLUDE\n\n#include <climits>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n\n#include \"../base/assert.hpp\"\n#include \"../base/Ptr.hpp\"\n#include \"../bits/bitset_utils.hpp\"\n\n#include \"Range.hpp\"\n\nnamespace emp {\n  using namespace emp;\n\n  ///  Middle Square Weyl Sequence: A versatile and non-patterned pseudo-random-number\n  ///  generator.\n  ///  Based on: https://en.wikipedia.org/wiki/Middle-square_method\n  class Random {\n  protected:\n\n    uint64_t value = 0;                       ///< Current squaring value\n    uint64_t weyl_state = 0;                  ///< Weyl sequence state\n    uint64_t original_seed = 0;               ///< Seed to start sequence; initialized weyl_state\n\n    // Members & functions for stat functions\n    double expRV = 0.0;    ///< Exponential Random Variable for the randNormal function\n\n    // Constants ////////////////////////////////////////////////////////////////\n    static constexpr const uint64_t RAND_CAP = 4294967296;  // 2^32\n    static constexpr const uint64_t STEP_SIZE = 0xb5ad4eceda1ce2a9;  ///< Weyl sequence step size\n\n    static constexpr const unsigned char BYTE1 = (unsigned char) 1;\n\n    /// Basic Random number\n    /// Returns a random number [0, RAND_CAP)\n    uint32_t Get() noexcept {\n      value *= value;                       // Square the current value.\n      value += (weyl_state += STEP_SIZE);   // Take a step in the Weyl sequence\n      value = (value>>32) | (value<<32);    // Return the middle of the value\n      return (uint32_t) value;\n    }\n\n  public:\n    /// Set up the random generator object with an optional seed value.\n    Random(const int seed = -1) noexcept {\n      ResetSeed(seed);  // Calls init()\n    }\n\n    ~Random() { ; }\n\n    /// Advance pseudorandom number generation engine one step.\n    void StepEngine() noexcept { Get(); }\n\n    /// @return The current seed used to initialize this pseudo-random sequence.\n    inline uint64_t GetSeed() const noexcept { return original_seed; }\n\n    /// Starts a new sequence of pseudo random numbers.  A negative seed means that the random\n    /// number generator gets its seed from the current system time and the process memory.\n    void ResetSeed(const int64_t seed) noexcept {\n      // If the provided seed is <= 0, choose a unique seed based on time and memory location.\n      if (seed <= 0) {\n        uint64_t seed_time = (uint64_t) time(NULL);\n        uint64_t seed_mem = (uint64_t) this;\n        weyl_state = seed_time ^ seed_mem;\n      }\n\n      else weyl_state = (uint64_t) seed;\n\n      // Save the seed that was ultimately used to start this pseudo-random sequence.\n      original_seed = weyl_state;\n\n      weyl_state *= 2;  // Make sure starting state is even.\n\n      Get(); // Prime the new sequence by skipping the first number.\n    }\n\n\n    // Random Number Generation /////////////////////////////////////////////////\n\n    /// @return A pseudo-random double value between 0.0 and 1.0\n    inline double GetDouble() noexcept { return Get() / (double) RAND_CAP; }\n\n    /// @return A pseudo-random double value between 0.0 and max\n    inline double GetDouble(const double max) noexcept { return GetDouble() * max; }\n\n    /// @return A pseudo-random double value between min and max\n    inline double GetDouble(const double min, const double max) noexcept {\n      return GetDouble() * (max - min) + min;\n    }\n\n    /// @return A pseudo-random double in the provided range.\n    inline double GetDouble(const Range<double> range) noexcept {\n      return GetDouble(range.GetLower(), range.GetUpper());\n     }\n\n\n    /// @return A pseudo-random 32-bit (4 byte) unsigned int value.\n    inline uint32_t GetUInt() noexcept { return Get(); }\n\n    /// @return A pseudo-random 32-bit unsigned int value between 0 and max\n    template <typename T>\n    inline uint32_t GetUInt(const T max) noexcept {\n      return static_cast<uint32_t>(GetDouble() * static_cast<double>(max));\n    }\n\n    /// @return A pseudo-random 32-bit unsigned int value between min and max\n    template <typename T1, typename T2>\n    inline uint32_t GetUInt(const T1 min, const T2 max) noexcept {\n      return GetUInt<uint32_t>((uint32_t) max - (uint32_t) min) + (uint32_t) min;\n    }\n\n    /// @return A pseudo-random 32-bit unsigned int value in the provided range.\n    template <typename T>\n    inline uint32_t GetUInt(const Range<T> range) noexcept {\n      return GetUInt(range.GetLower(), range.GetUpper());\n    }\n\n\n    /// @return A pseudo-random 32 bits (unsigned int) with a 12.5% chance of each bit being 1.\n    inline uint32_t GetBits12_5() noexcept { return Get() & Get() & Get(); }\n\n    /// @return A pseudo-random 32 bits (unsigned int) with a 25% chance of each bit being 1.\n    inline uint32_t GetBits25() noexcept { return Get() & Get(); }\n\n    /// @return A pseudo-random 32 bits (unsigned int) with a 37.5% chance of each bit being 1.\n    inline uint32_t GetBits37_5() noexcept { return (Get() | Get()) & Get(); }\n\n    /// @return A pseudo-random 32 bits (unsigned int) with a 50% chance of each bit being 1.\n    inline uint32_t GetBits50() noexcept { return Get(); }\n\n    /// @return A pseudo-random 32 bits (unsigned int) with a 62.5% chance of each bit being 1.\n    inline uint32_t GetBits62_5() noexcept { return (Get() & Get()) | Get(); }\n\n    /// @return A pseudo-random 32 bits (unsigned int) with a 75% chance of each bit being 1.\n    inline uint32_t GetBits75() noexcept { return Get() | Get(); }\n\n    /// @return A pseudo-random 32 bits (unsigned int) with a 87.5% chance of each bit being 1.\n    inline uint32_t GetBits87_5() noexcept { return Get() | Get() | Get(); }\n\n\n    /// @return A pseudo-random 64-bit (8 byte) unsigned int value.\n    inline uint64_t GetUInt64() noexcept {\n      return ( static_cast<uint64_t>(GetUInt()) << 32 )\n             + static_cast<uint64_t>(GetUInt());\n    }\n\n    /// @return A pseudo-random 64-bit unsigned int value between 0 and max\n    inline uint64_t GetUInt64(const uint64_t max) noexcept {\n      if (max <= RAND_CAP) return (uint64_t) GetUInt(max);  // Don't need extra precision.\n\n      size_t mask = emp::MaskUsed(max);              // Create a mask for just the bits we need.\n      uint64_t val = GetUInt64() & mask;             // Grab a value using just the current bits.\n      while (val >= max) val = GetUInt64() & mask;   // Grab new values until we find a valid one.\n\n      return val;\n    }\n\n\n    /// @return A pseudo-random 32-bit (4 byte) int value between 0 and max\n    inline int32_t GetInt(const int32_t max) noexcept {\n      return static_cast<int32_t>(GetUInt((uint32_t) max));\n    }\n\n    /// @return A pseudo-random 32-bit (4 byte) int value between min and max\n    inline int32_t GetInt(const int min, const int max) noexcept { return GetInt(max - min) + min; }\n\n    /// @return A pseudo-random 32-bit (4 byte) int value in range\n    inline int32_t GetInt(const Range<int> range) noexcept {\n      return GetInt(range.GetLower(), range.GetUpper());\n    }\n\n    /// Enumeration for common probabilities.\n    /// (not class, so can be referred to elsewhere as e.g., Random::PROB_50)\n    enum Prob { PROB_0   = 0,   PROB_12_5 = 125,\n                PROB_25  = 250, PROB_37_5 = 375,\n                PROB_50  = 500, PROB_62_5 = 625,\n                PROB_75  = 750, PROB_87_5 = 875,\n                PROB_100 = 1000 };\n\n    /// Shortcut type for all functions that deal witch chunks of memory.\n    using mem_ptr_t = emp::Ptr<unsigned char>;\n\n    /// Randomize a contiguous segment of memory.\n    void RandFill(mem_ptr_t dest, const size_t num_bytes) noexcept {\n      dest.FillMemoryFunction( num_bytes, [this](){ return Get(); } );\n    }\n\n    /// Randomize a contiguous segment of memory.\n    template <Prob PROB>\n    void RandFillP(mem_ptr_t dest, const size_t num_bytes) noexcept {\n      if constexpr (PROB == PROB_0) {\n        dest.FillMemoryFunction( num_bytes, [](){ return 0; } );\n      } else if constexpr (PROB == PROB_12_5) {\n        dest.FillMemoryFunction( num_bytes, [this](){ return GetBits12_5(); } );\n      } else if constexpr (PROB == PROB_25) {\n        dest.FillMemoryFunction( num_bytes, [this](){ return GetBits25(); } );\n      } else if constexpr (PROB == PROB_37_5) {\n        dest.FillMemoryFunction( num_bytes, [this](){ return GetBits37_5(); } );\n      } else if constexpr (PROB == PROB_50) {\n        dest.FillMemoryFunction( num_bytes, [this](){ return GetBits50(); } );\n      } else if constexpr (PROB == PROB_62_5) {\n        dest.FillMemoryFunction( num_bytes, [this](){ return GetBits62_5(); } );\n      } else if constexpr (PROB == PROB_75) {\n        dest.FillMemoryFunction( num_bytes, [this](){ return GetBits75(); } );\n      } else if constexpr (PROB == PROB_87_5) {\n        dest.FillMemoryFunction( num_bytes, [this](){ return GetBits87_5(); } );\n      } else if constexpr (PROB == PROB_100) {\n        dest.FillMemoryFunction( num_bytes, [](){ return (size_t) -1; } );\n      }\n    }\n\n    /// Randomize a contiguous segment of memory between specified bit positions.\n    template <Prob PROB>\n    void RandFillP(mem_ptr_t dest, [[maybe_unused]] const size_t num_bytes, size_t start_bit, size_t stop_bit) noexcept\n    {\n      emp_assert(start_bit <= stop_bit);\n      emp_assert(stop_bit <= num_bytes*8);\n\n      const size_t start_byte_id = start_bit >> 3;     // At which byte do we start?\n      const size_t end_byte_id = stop_bit >> 3;        // At which byte do we stop?\n      const size_t start_bit_id = start_bit & 7;       // Which bit to start at in byte?\n      const size_t end_bit_id = stop_bit & 7;          // Which bit to stop before in byte?\n      constexpr double p = ((double) PROB) / 1000.0;   // Determine actual probability of a 1\n\n      // If the start byte and end byte are the same, just fill those in.\n      if (start_byte_id == end_byte_id) {\n        for (size_t i = start_bit_id; i < end_bit_id; ++i) {\n          uint8_t mask = (uint8_t) (1 << i);\n          if (P(p)) dest[start_byte_id] |= mask;\n          else dest[start_byte_id] &= ~mask;\n        }\n        return;\n      }\n\n      const uint8_t start_byte = dest[start_byte_id];    // Save first byte to restore bits.\n\n      // Randomize the full bits we need to use.\n      RandFillP<PROB>(dest + start_byte_id, end_byte_id - start_byte_id);\n\n      // If we are not starting at the beginning of a byte, restore missing bits.\n      if (start_bit_id) {\n        const uint8_t mask = (uint8_t) ((1 << start_bit_id) - 1); // Signify how byte is divided.\n        (dest[start_byte_id] &= ~mask) |= (start_byte & mask);    // Stitch together byte parts.\n      }\n\n      // If we have a byte at the end to partially randomize, do so.\n      if (end_bit_id) {\n        uint8_t & end_byte = dest[end_byte_id];                 // Grab reference to end byte\n        const uint8_t mask = (uint8_t) ((1 << end_bit_id) - 1); // Signify how byte is divided.\n        end_byte &= ~mask;                                      // Clear out bits to be randomized.\n        for (size_t i = 0; i < end_bit_id; i++) {               // Step through bits to flip.\n          if (P(p)) end_byte |= ((uint8_t) 1 << i);             // Set appropriate bits.\n        }\n      }\n    }\n\n    // Shortcuts to randomize a contiguous segment of memory with fixed probabilities of a 1.\n    void RandFill0(   mem_ptr_t dest, const size_t bytes) noexcept { RandFillP<PROB_0>   (dest, bytes); }\n    void RandFill12_5(mem_ptr_t dest, const size_t bytes) noexcept { RandFillP<PROB_12_5>(dest, bytes); }\n    void RandFill25(  mem_ptr_t dest, const size_t bytes) noexcept { RandFillP<PROB_25>  (dest, bytes); }\n    void RandFill37_5(mem_ptr_t dest, const size_t bytes) noexcept { RandFillP<PROB_37_5>(dest, bytes); }\n    void RandFill50(  mem_ptr_t dest, const size_t bytes) noexcept { RandFillP<PROB_50>  (dest, bytes); }\n    void RandFill62_5(mem_ptr_t dest, const size_t bytes) noexcept { RandFillP<PROB_62_5>(dest, bytes); }\n    void RandFill75(  mem_ptr_t dest, const size_t bytes) noexcept { RandFillP<PROB_75>  (dest, bytes); }\n    void RandFill87_5(mem_ptr_t dest, const size_t bytes) noexcept { RandFillP<PROB_87_5>(dest, bytes); }\n    void RandFill100( mem_ptr_t dest, const size_t bytes) noexcept { RandFillP<PROB_100> (dest, bytes); }\n\n    void RandFill0(   mem_ptr_t dest, const size_t bytes, size_t start_bit, size_t stop_bit) noexcept\n      { RandFillP<PROB_0>   (dest, bytes, start_bit, stop_bit); }\n    void RandFill12_5(mem_ptr_t dest, const size_t bytes, size_t start_bit, size_t stop_bit) noexcept\n      { RandFillP<PROB_12_5>(dest, bytes, start_bit, stop_bit); }\n    void RandFill25(  mem_ptr_t dest, const size_t bytes, size_t start_bit, size_t stop_bit) noexcept\n      { RandFillP<PROB_25>  (dest, bytes, start_bit, stop_bit); }\n    void RandFill37_5(mem_ptr_t dest, const size_t bytes, size_t start_bit, size_t stop_bit) noexcept\n      { RandFillP<PROB_37_5>(dest, bytes, start_bit, stop_bit); }\n    void RandFill50(  mem_ptr_t dest, const size_t bytes, size_t start_bit, size_t stop_bit) noexcept\n      { RandFillP<PROB_50>  (dest, bytes, start_bit, stop_bit); }\n    void RandFill62_5(mem_ptr_t dest, const size_t bytes, size_t start_bit, size_t stop_bit) noexcept\n      { RandFillP<PROB_62_5>(dest, bytes, start_bit, stop_bit); }\n    void RandFill75(  mem_ptr_t dest, const size_t bytes, size_t start_bit, size_t stop_bit) noexcept\n      { RandFillP<PROB_75>  (dest, bytes, start_bit, stop_bit); }\n    void RandFill87_5(mem_ptr_t dest, const size_t bytes, size_t start_bit, size_t stop_bit) noexcept\n      { RandFillP<PROB_87_5>(dest, bytes, start_bit, stop_bit); }\n    void RandFill100( mem_ptr_t dest, const size_t bytes, size_t start_bit, size_t stop_bit) noexcept\n      { RandFillP<PROB_100> (dest, bytes, start_bit, stop_bit); }\n\n    /// Randomize a contiguous segment of memory with a given probability of each bit being on.\n    void RandFill(mem_ptr_t dest, const size_t num_bytes, const double p) noexcept {\n      // Try to find a shortcut if p allows....\n      if (p == 0.0)        return RandFill0(dest, num_bytes);\n      else if (p == 0.125) return RandFill12_5(dest, num_bytes);\n      else if (p == 0.25)  return RandFill25(dest, num_bytes);\n      else if (p == 0.375) return RandFill37_5(dest, num_bytes);\n      else if (p == 0.5)   return RandFill50(dest, num_bytes);\n      else if (p == 0.625) return RandFill62_5(dest, num_bytes);\n      else if (p == 0.75)  return RandFill75(dest, num_bytes);\n      else if (p == 0.875) return RandFill87_5(dest, num_bytes);\n      else if (p == 1.0)   return RandFill100(dest, num_bytes);\n\n      // This is not a special value of P, so let's set each bit manually\n      // (slow, but good for now; ideally use closest faster option above and modify)\n      for (size_t i = 0; i < num_bytes; i++) dest[i] = GetByte(p);\n    }\n\n    /// Randomize a contiguous segment of memory with a given probability of each bit being on.\n    void RandFill(mem_ptr_t dest, const size_t num_bytes, const double p,\n                  const size_t start_bit, const size_t stop_bit) noexcept {\n      emp_assert((stop_bit >> 3) <= num_bytes);\n\n      // Try to find a shortcut if p allows....\n      if (p == 0.0)        return RandFill0(dest, num_bytes, start_bit, stop_bit);\n      else if (p == 0.125) return RandFill12_5(dest, num_bytes, start_bit, stop_bit);\n      else if (p == 0.25)  return RandFill25(dest, num_bytes, start_bit, stop_bit);\n      else if (p == 0.375) return RandFill37_5(dest, num_bytes, start_bit, stop_bit);\n      else if (p == 0.5)   return RandFill50(dest, num_bytes, start_bit, stop_bit);\n      else if (p == 0.625) return RandFill62_5(dest, num_bytes, start_bit, stop_bit);\n      else if (p == 0.75)  return RandFill75(dest, num_bytes, start_bit, stop_bit);\n      else if (p == 0.875) return RandFill87_5(dest, num_bytes, start_bit, stop_bit);\n      else if (p == 1.0)   return RandFill100(dest, num_bytes, start_bit, stop_bit);\n\n      // This is not a special value of P, so let's set each bit manually\n      // (slow, but good for now; ideally use closest faster option above and modify)\n      size_t cur_byte = start_bit >> 3;\n      uint8_t cur_mask = (uint8_t) (1 << (start_bit & 7));\n      for (size_t i = start_bit; i < stop_bit; i++) {\n        if (P(p)) dest[cur_byte] |= cur_mask;     // Set the target bit.\n        else dest[cur_byte] &= ~cur_mask;         // Clear out the target bit.\n        cur_mask <<= 1;                           // Move to the next bit.\n        if (!cur_mask) {                          // If the next bit is out of this byte...\n          cur_byte++;                             //   move to the next byte.\n          cur_mask = 1;                           //   reset the mask.\n        }\n      }\n    }\n\n\n    // Random Event Generation //////////////////////////////////////////////////\n\n    /// Tests a random value [0,1) against a given probability p, and returns true of false.\n    /// @param p The probability of the result being \"true\".\n    inline bool P(const double p) noexcept {\n      emp_assert(p >= 0.0 && p <= 1.0, p);\n      return (Get() < (p * RAND_CAP));\n    }\n\n    /// Full random byte with each bit being a one with a given probability.\n    unsigned char GetByte(const double p) noexcept {\n      unsigned char out_byte = 0;\n      if (P(p)) out_byte |= 1;\n      if (P(p)) out_byte |= 2;\n      if (P(p)) out_byte |= 4;\n      if (P(p)) out_byte |= 8;\n      if (P(p)) out_byte |= 16;\n      if (P(p)) out_byte |= 32;\n      if (P(p)) out_byte |= 64;\n      if (P(p)) out_byte |= 128;\n      return out_byte;\n    }\n\n\n    // Statistical functions ////////////////////////////////////////////////////\n\n    // Distributions //\n\n    /// Generate a random variable drawn from a unit normal distribution.\n    double GetRandNormal() noexcept {\n      // Draw from a Unit Normal Dist\n      // Using Rejection Method and saving of initial exponential random variable\n      double expRV2;\n      while (1) {\n        expRV2 = -log(GetDouble());\n        expRV -= (expRV2-1)*(expRV2-1)/2;\n        if (expRV > 0) break;\n        expRV = -log(GetDouble());\n      }\n      if (P(.5)) return expRV2;\n      return -expRV2;\n    }\n\n    /// @return A random variable drawn from a normal distribution.\n    /// @param mean Center of distribution.\n    /// @param std Standard deviation of distribution.\n    inline double GetRandNormal(const double mean, const double std) { return mean + GetRandNormal() * std; }\n\n    /// Generate a random variable drawn from a Poisson distribution.\n    inline uint32_t GetRandPoisson(const double n, const double p) {\n      emp_assert(p >= 0.0 && p <= 1.0, p);\n      // Optimizes for speed and calculability using symetry of the distribution\n      if (p > .5) return (uint32_t) n - GetRandPoisson(n * (1 - p));\n      else return GetRandPoisson(n * p);\n    }\n\n    /// Generate a random variable drawn from a Poisson distribution.\n    inline uint32_t GetRandPoisson(const double mean) {\n      // Draw from a Poisson Dist with mean; if cannot calculate, return UINT_MAX.\n      // Uses Rejection Method\n      const double a = exp(-mean);\n      if (a <= 0) return UINT_MAX; // cannot calculate, so return UINT_MAX\n      uint32_t k = 0;\n      double u = GetDouble();\n      while (u >= a) {\n        u *= GetDouble();\n        ++k;\n      }\n      return k;\n    }\n\n    /// Generate a random variable drawn from a Binomial distribution.\n    ///\n    /// This function is exact, but slow.\n    /// @see Random::GetApproxRandBinomial\n    /// @see emp::Binomial in source/tools/Distribution.h\n    inline uint32_t GetRandBinomial(const double n, const double p) { // Exact\n      emp_assert(p >= 0.0 && p <= 1.0, p);\n      emp_assert(n >= 0.0, n);\n      // Actually try n Bernoulli events, each with probability p\n      uint32_t k = 0;\n      for (uint32_t i = 0; i < n; ++i) if (P(p)) k++;\n      return k;\n    }\n\n    inline uint32_t GetRandGeometric(double p){\n      emp_assert(p >= 0 && p <= 1, \"Pobabilities must be between 0 and 1\");\n      // TODO: When we have warnings, add one for passing a really small number to\n      // this function. Alternatively, make this function not ludicrously slow with small numbers.\n      // Looks like return floor(ln(GetDouble())/ln(1-p)) might be sufficient?\n      if (p == 0) {\n        return std::numeric_limits<uint32_t>::infinity();\n      }\n      uint32_t result = 1;\n      while (!P(p)) { result++;}\n      return result;\n    }\n\n  };\n\n\n  /// This is an adaptor to make Random behave like a proper STL random number generator.\n  struct RandomStdAdaptor {\n    typedef int argument_type;\n    typedef int result_type;\n\n    RandomStdAdaptor(Random& rng) : _rng(rng) { }\n    int operator()(int n) { return _rng.GetInt(n); }\n\n    Random& _rng;\n  };\n\n\n  /// Draw a sample (with replacement) from an input range, copying to the output range.\n  template <typename ForwardIterator, typename OutputIterator, typename RNG>\n  void sample_with_replacement(ForwardIterator first,\n                               ForwardIterator last,\n                               OutputIterator ofirst,\n                               OutputIterator olast,\n                               RNG rng) noexcept {\n    std::size_t range = std::distance(first, last);\n    while(ofirst != olast) {\n      *ofirst = *(first+rng(range));\n      ++ofirst;\n    }\n  }\n\n\n} // END emp namespace\n\n#endif // #ifndef EMP_MATH_RANDOM_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2017\n *\n *  @file alert.hpp\n *  @brief Define an Alert function that goes to std::cerr in c++ or to Alert() in Javascript.\n *  @note Status: RELEASE\n */\n\n#ifndef EMP_DEBUG_ALERT_HPP_INCLUDE\n#define EMP_DEBUG_ALERT_HPP_INCLUDE\n\n#include \"../tools/string_utils.hpp\"\n\n// If we are in emscripten, make sure to include the header.\n#ifdef __EMSCRIPTEN__\n#include <emscripten.h>\n#endif\n\n\nnamespace emp {\n#ifdef __EMSCRIPTEN__\n  void Alert(const std::string & msg) { EM_ASM_ARGS({\n    msg = UTF8ToString($0);\n    if (typeof alert == \"undefined\") {\n      // node polyfill\n      globalThis.alert = console.log;\n    }\n    alert(msg);\n  }, msg.c_str() ); }\n#else\n  /// Send msg to cerr if in C++, or show msg in an alert box if compiled to Javascript\n  /// Input can be any number of arguments of any types as long as the can be converted to\n  /// strings with emp::to_string().\n  void Alert(const std::string & msg) { std::cerr << msg << std::endl; }\n#endif\n  /// @cond TEMPLATES\n  template <typename... TYPE_SET>\n  void Alert(TYPE_SET... inputs) { Alert(emp::to_string(inputs...)); }\n  /// @endcond\n\n  /// A version of Alert that will cap how many times it can go off\n  template <typename... TYPE_SET>\n  static void CappedAlert(size_t cap, TYPE_SET... inputs) {\n    static size_t cur_count = 0;\n    if (cur_count++ < cap) Alert(emp::to_string(inputs...));\n  }\n\n  /// An object that will automatically output a message during construction or destruction,\n  /// usually for use in debugging to disentangle timings.\n  struct AlertObj {\n    std::string msg;    ///< Message for the alert to print.\n    bool on_construct;  ///< Should the message print automatically during construction?\n    bool on_destruct;   ///< Should the message print automatically during destruction?\n\n    AlertObj(const std::string & _msg, bool _on_c=true, bool _on_d=false)\n    : msg(_msg), on_construct(_on_c), on_destruct(_on_d) { if (on_construct) emp::Alert(msg); }\n    ~AlertObj() { if (on_destruct) emp::Alert(msg); }\n\n    void Trigger() { emp::Alert(msg); }\n    void SetMessage(const std::string & _msg) { msg = _msg; }\n  };\n}\n\n\n#endif // #ifndef EMP_DEBUG_ALERT_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2018\n *\n *  @file js_utils.hpp\n *  @brief Tools for passing data between C++ and Javascript.\n */\n\n#ifndef EMP_WEB_JS_UTILS_HPP_INCLUDE\n#define EMP_WEB_JS_UTILS_HPP_INCLUDE\n\n#include <map>\n#include <string>\n#include <typeinfo>\n\n#include \"../base/array.hpp\"\n#include \"../base/assert.hpp\"\n#include \"../base/map.hpp\"\n#include \"../base/vector.hpp\"\n\n#include \"init.hpp\"\n\n\nnamespace emp {\n\n  /// This function returns a std::map mapping typeid names to the appropriate\n  /// strings to describe those types in Javscript. This is useful when using\n  /// getValue() from within MAIN_THREAD_EM_ASM macros.\n  ///\n  ///  For example, say we have a templated function that takes a pointer to type\n  /// T. We find out the appropriate string for type T:\n  /// std::map<const char*, std::string> type_map = GetTypeToStringMap();\n  /// std::string type_string = type_map[typeid(T).name()];\n  ///\n  /// Now we can pass type_string.c_str() into MAIN_THREAD_EM_ASM:\n  /// `MAIN_THREAD_EM_ASM({\n  ///    var value = getValue($0, $1);\n  /// }, pointer, type_string.c_str();`\n\n  std::map<std::string, std::string> get_type_to_string_map() {\n    // Using typeid().name() could create problems because it varies by\n    // implementation. All that matters is consistency, but obscure could\n    // technically be given the same name. So far it seems to not be an issue\n    // with Emscripten, which is most critical for this code.\n    std::map<std::string, std::string> map_type_names;\n    map_type_names[typeid(int8_t).name()] = \"i8\";\n    map_type_names[typeid(int16_t).name()] = \"i16\";\n    map_type_names[typeid(int32_t).name()] = \"i32\";\n    map_type_names[typeid(int64_t).name()] = \"i64\";\n    map_type_names[typeid(float).name()] = \"float\";\n    map_type_names[typeid(double).name()] = \"double\";\n    map_type_names[typeid(int8_t*).name()] = \"i8*\";\n    map_type_names[typeid(int16_t*).name()] = \"i16*\";\n    map_type_names[typeid(int32_t*).name()] = \"i32*\";\n    map_type_names[typeid(int64_t*).name()] = \"i64*\";\n    map_type_names[typeid(float*).name()] = \"float*\";\n    map_type_names[typeid(double*).name()] = \"double*\";\n    map_type_names[typeid(void*).name()] = \"*\";\n    map_type_names[typeid(std::string).name()] = \"string\";\n\n    return map_type_names;\n  }\n\n  /// This function can be called to pass an array, vector, or other container with contiguously\n  /// stored data into Javascript.\n  /// The array will be stored in emp.__incoming_array. Currently supports\n  /// arrays containing all of the types defined in get_type_to_string_map, which\n  /// are also all of the types that emscripten supports getting via pointer.\n  /// This function also supports nested arrays, and arrays of objects created with\n  /// introspective tuple structs.\n\n  /// @cond TEMPLATES\n\n  // This code now works for all containers, as long as they store data contiguously\n\n  template<typename C, class = typename C::value_type>\n  typename std::enable_if<std::is_pod<typename C::value_type>::value, void>::type\n  pass_array_to_javascript(C values, emp::vector<int> recursive_el)\n  {\n    using T = typename C::value_type;\n    //Figure out what string to use for the type we've been given\n    std::map<std::string, std::string> map_type_names = get_type_to_string_map();\n    emp_assert((map_type_names.find(typeid(T).name()) != map_type_names.end()));\n    int type_size = sizeof(T);\n    (void) type_size;\n    std::string type_string = map_type_names[typeid(T).name()];\n\n    // Clear array, if this isn't a recursive call\n    if (recursive_el.size() == 0) {\n      MAIN_THREAD_EM_ASM({emp_i.__incoming_array = [];});\n    }\n\n    MAIN_THREAD_EM_ASM({\n      var curr_array = emp_i.__incoming_array;\n      var depth = 0;\n\n      // Make sure that we're at the right depth, in case of recursive call.\n      while (curr_array.length > 0) {\n        var next_index = getValue($4+(depth*4), \"i32\");\n        depth += 1;\n        curr_array = curr_array[next_index];\n      }\n\n      // Iterate over array, get values, and add them to incoming array.\n      for (i=0; i<$1; i++) {\n        curr_array.push(getValue($0+(i*$2), UTF8ToString($3)));\n      }\n    }, &values[0], values.size(), type_size, type_string.c_str(), recursive_el.data());\n  }\n\n  // Specialization for strings\n  template<typename C, class = typename C::value_type>\n  typename std::enable_if<std::is_same<typename C::value_type, std::string>::value, void>::type\n  pass_array_to_javascript(C values, emp::vector<int> recursive_el)\n  {\n    // Clear array, if this isn't a recursive call\n    if (recursive_el.size() == 0) {\n      MAIN_THREAD_EM_ASM({emp_i.__incoming_array = [];});\n    };\n\n    MAIN_THREAD_EM_ASM({\n      emp_i.__curr_array = emp_i.__incoming_array;\n      var depth = 0;\n\n      // Make sure that we are at the right depth, in case of recursive call.\n      while (emp_i.__curr_array.length > 0) {\n        var next_index = getValue($0+(depth*4), \"i32\");\n        depth += 1;\n        emp_i.__curr_array = emp_i.__curr_array[next_index];\n      };\n    }, recursive_el.data());\n\n    // Iterate over array, get values, and add them to incoming array.\n    for (auto val : values) {\n      (void) val;\n      MAIN_THREAD_EM_ASM({\n        emp_i.__curr_array.push(UTF8ToString($0));\n      }, val.c_str());\n    };\n\n    MAIN_THREAD_EM_ASM({delete emp_i.__curr_array;});\n  }\n\n  // Handle user-defined JSON_TYPE\n  template<typename C, class = typename C::value_type>\n  typename std::enable_if<C::value_type::n_fields != -1, void>::type\n  pass_array_to_javascript(C values, emp::vector<int> recursive_el) {\n\n    std::map<std::string, std::string> map_type_names = get_type_to_string_map();\n    // Initialize array in Javascript\n    if (recursive_el.size() == 0) {\n      MAIN_THREAD_EM_ASM({emp_i.__incoming_array = [];});\n    }\n\n    // Initialize objects in Javascript\n    MAIN_THREAD_EM_ASM({\n      var curr_array = emp_i.__incoming_array;\n      var depth = 0;\n\n      // Make sure that we're at the right depth, in case of recursive call.\n      while (curr_array.length > 0) {\n        var next_index = getValue($1+(depth*4), \"i32\");\n        depth += 1;\n        curr_array = curr_array[next_index];\n      }\n\n      // Append empty objects\n      for (i=0; i<$0; i++) {\n        var new_obj = {};\n        curr_array.push(new_obj);\n      }\n    }, values.size(), recursive_el.data());\n\n    for (std::size_t j = 0; j<values.size(); j++) { // Iterate over array\n      for (std::size_t i = 0; i<values[j].var_names.size(); i++) { // Iterate over object members\n\n        // Get variable name and type for this member variable\n        std::string var_name = values[j].var_names[i];\n        std::string type_string = map_type_names[values[j].var_types[i].name()];\n        // Make sure member variable is an allowed type\n        emp_assert((map_type_names.find(values[j].var_types[i].name())\n              != map_type_names.end()), values[j].var_types[i].name());\n\n        // Load data into array of objects\n        MAIN_THREAD_EM_ASM({\n          var curr_array = emp_i.__incoming_array;\n          var depth = 0;\n\n          // Make sure we are at the right depth, in case of recursive call.\n          while (curr_array[0].length > 0) {\n            var next_index = getValue($4+(depth*4), \"i32\");\n            depth += 1;\n            curr_array = curr_array[next_index];\n          }\n\n          if (UTF8ToString($1) == \"string\") {\n            curr_array[$3][UTF8ToString($2)] = UTF8ToString($0);\n          } else {\n            curr_array[$3][UTF8ToString($2)] = getValue($0, UTF8ToString($1));\n          }\n        }, values[j].pointers[i], type_string.c_str(), var_name.c_str(),\n        j, recursive_el.data());\n      }\n    }\n  }\n\n  /// @endcond\n\n  // This version of the function handles non-nested containers\n  template<typename C, class = typename C::value_type>\n  void pass_array_to_javascript(C values) {\n    pass_array_to_javascript(values, emp::vector<int>(0));\n  }\n\n  /// @cond TEMPLATES\n\n  // This version of the function handles nested arrays with recursive calls\n  // until a non-array type is found.\n  template<std::size_t SIZE1, std::size_t SIZE2, typename T>\n  void pass_array_to_javascript(emp::array<emp::array<T, SIZE1>, SIZE2> values,\n        emp::vector<int> recursive_el = emp::vector<int>()) {\n\n    // Initialize if this is the first call to this function\n    if (recursive_el.size() == 0) {\n      MAIN_THREAD_EM_ASM({emp_i.__incoming_array = [];});\n    }\n\n    // Append empty arrays to array that we are currently handling in recursion\n    MAIN_THREAD_EM_ASM({\n      var curr_array = emp_i.__incoming_array;\n      var depth = 0;\n      while (curr_array.length > 0) {\n        var next_index = getValue($0+(depth*4), \"i32\");\n        depth += 1;\n        curr_array = curr_array[next_index];\n      }\n      for (i=0; i<$1; i++) {\n        curr_array.push([]);\n      }\n    }, recursive_el.data(), values.size());\n\n    // Make recursive calls - recursive_els specifies coordinates of array we're\n    // currently operating on\n    for (std::size_t i = 0; i<values.size(); i++) {\n      emp::vector<int> new_recursive_el (recursive_el);\n      new_recursive_el.push_back((int) i);\n      pass_array_to_javascript(values[i], new_recursive_el);\n    }\n  }\n\n  // This version of the function handles nested vectors with recursive calls\n  // until a non-array type is found.\n  template<typename T>\n  void pass_array_to_javascript(emp::vector<emp::vector<T> > values,\n        emp::vector<int> recursive_el = emp::vector<int>()) {\n\n    // Initialize if this is the first call to this function\n    if (recursive_el.size() == 0) {\n      MAIN_THREAD_EM_ASM({emp_i.__incoming_array = [];});\n    }\n\n    // Append empty arrays to array that we are currently handling in recursion\n    MAIN_THREAD_EM_ASM({\n      var curr_array = emp_i.__incoming_array;\n      var depth = 0;\n      while (curr_array.length > 0) {\n        var next_index = getValue($0+(depth*4), \"i32\");\n        depth += 1;\n        curr_array = curr_array[next_index];\n      }\n      for (i=0; i<$1; i++) {\n        curr_array.push([]);\n      }\n    }, recursive_el.data(), values.size());\n\n    // Make recursive calls - recursive_els specifies coordinates of array we are\n    // currently operating on\n    for (std::size_t i = 0; i<values.size(); i++) {\n      emp::vector<int> new_recursive_el (recursive_el);\n      new_recursive_el.push_back((int) i);\n      pass_array_to_javascript(values[i], new_recursive_el);\n    }\n  }\n\n  /// @endcond\n\n  /// This function lets you pass an array from javascript to C++!\n  /// It takes a reference to the array as an argument and populates it\n  /// with the contents of emp.__outgoing_array.\n  ///\n  /// Currently accepts arrays of ints, floats, doubles, chars, and std::strings\n  /// The size of the passed array must be equal to the size of the array stored\n  /// in emp.__outgoing_array\n  //\n  // Don't worry about the recurse argument - it's for handling nested arrays\n  // internally\n  #ifdef __EMSCRIPTEN__\n  template <std::size_t SIZE, typename T>\n  void pass_array_to_cpp(emp::array<T, SIZE> & arr, bool recurse = false) {\n\n    //Figure out type stuff\n    std::map<std::string, std::string> map_type_names = get_type_to_string_map();\n    emp_assert((map_type_names.find(typeid(T).name()) != map_type_names.end()), typeid(T).name());\n    int type_size = sizeof(T);\n    (void) type_size;\n    std::string type_string = map_type_names[typeid(T).name()];\n\n    //Make sure arrays have the same length\n    emp_assert(arr.size() == MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length}),\n               arr.size(), MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length}));\n\n    //Write emp.__outgoing_array contents to a buffer\n    T * buffer = (T*) MAIN_THREAD_EM_ASM_INT({\n      var buffer = Module._malloc(emp_i.__outgoing_array.length*$0);\n\n      for (i=0; i<emp_i.__outgoing_array.length; i++) {\n        setValue(buffer+(i*$0), emp_i.__outgoing_array[i], UTF8ToString($1));\n      }\n\n      return buffer;\n    }, type_size, type_string.c_str());\n\n    // Populate array from buffer\n    for (std::size_t i=0; i<arr.size(); i++) {\n      arr[i] = *(buffer + i);\n    }\n\n    // Free the memory we allocated in Javascript\n    free(buffer);\n  }\n\n  #else\n\n  template <std::size_t SIZE, typename T>\n  void pass_array_to_cpp(emp::array<T, SIZE> & arr, bool recurse = false) {;}\n  #endif\n\n  /// Same as pass_array_to_cpp, but lets you store values in a vector instead\n  #ifdef __EMSCRIPTEN__\n  template <typename T>\n  void pass_vector_to_cpp(emp::vector<T> & arr, bool recurse = false) {\n\n    // Figure out type stuff\n    std::map<std::string, std::string> map_type_names = get_type_to_string_map();\n    emp_assert((map_type_names.find(typeid(T).name()) != map_type_names.end()), typeid(T).name());\n    int type_size = sizeof(T);\n    (void) type_size;\n    std::string type_string = map_type_names[typeid(T).name()];\n\n    // Write emp.__outgoing_array contents to a buffer\n    T * buffer = (T*) MAIN_THREAD_EM_ASM_INT({\n      var buffer = Module._malloc(emp_i.__outgoing_array.length*$0);\n\n      for (i=0; i<emp_i.__outgoing_array.length; i++) {\n        setValue(buffer+(i*$0), emp_i.__outgoing_array[i], UTF8ToString($1));\n      }\n\n      return buffer;\n    }, type_size, type_string.c_str());\n\n    // Populate array from buffer\n    for (int i=0; i < MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length}); i++) {\n      arr.push_back(*(buffer + i));\n    }\n\n    //Free the memory we allocated in Javascript\n    free(buffer);\n  }\n\n  #else\n  template <typename T>\n  void pass_vector_to_cpp(emp::vector<T> & arr, bool recurse = false) {;}\n  #endif\n\n  /// @cond TEMPLATES\n\n\n  // template <typename T>\n  // typename std::enable_if<C::value_type::n_fields != -1, void>::type\n  // pass_vector_to_cpp(emp::vector<T> & arr, bool recurse = false) {\n  //\n  //   // Figure out type stuff\n  //   std::map<std::string, std::string> map_type_names = get_type_to_string_map();\n  //   emp_assert((map_type_names.find(typeid(T).name()) != map_type_names.end()), typeid(T).name());\n  //   int type_size = sizeof(T);\n  //   (void) type_size;\n  //   std::string type_string = map_type_names[typeid(T).name()];\n  //\n  //   // Write emp.__outgoing_array contents to a buffer\n  //   T * buffer = (T*) MAIN_THREAD_EM_ASM_INT({\n  //       var buffer = Module._malloc(emp_i.__outgoing_array.length*$0);\n  //\n  //       for (i=0; i<emp_i.__outgoing_array.length; i++) {\n  //         setValue(buffer+(i*$0), emp_i.__outgoing_array[i], UTF8ToString($1));\n  //       }\n  //\n  //       return buffer;\n  //   }, type_size, type_string.c_str());\n  //\n  //   // Populate array from buffer\n  //   for (int i=0; i < MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length}); i++) {\n  //     arr.push_back(*(buffer + i));\n  //   }\n  //\n  //   //Free the memory we allocated in Javascript\n  //   free(buffer);\n  // }\n\n  // Chars aren't one of the types supported by setValue, but by treating them\n  // as strings in Javascript we can pass them out to a C++ array\n  #ifdef __EMSCRIPTEN__\n  template <std::size_t SIZE>\n  void pass_array_to_cpp(emp::array<char, SIZE> & arr, bool recurse = false) {\n\n    emp_assert(arr.size() == MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length}));\n\n    char * buffer = (char *) MAIN_THREAD_EM_ASM_INT({\n      // Since we're treating each char as it's own string, each one\n      // will be null-termianted. So we malloc length*2 addresses.\n      var new_length = emp_i.__outgoing_array.length*2;\n      var buffer = Module._malloc(new_length);\n\n      for (i=0; i<emp_i.__outgoing_array.length; i++) {\n        stringToUTF8(emp_i.__outgoing_array[i], buffer+(i*2),2);\n      }\n\n      return buffer;\n    });\n\n    for (size_t i=0; i<arr.size(); i++) {\n      arr[i] = *(buffer + i*2);\n    }\n\n    free(buffer);\n  }\n  #else\n  template <std::size_t SIZE>\n  void pass_array_to_cpp(emp::array<char, SIZE> & arr, bool recurse = false) {;}\n  #endif\n\n  // Chars aren't one of the types supported by setValue, but by treating them\n  // as strings in Javascript we can pass them out to a C++ array\n  #ifdef __EMSCRIPTEN__\n  void pass_vector_to_cpp(emp::vector<char> & arr, bool recurse = false) {\n\n    char * buffer = (char *) MAIN_THREAD_EM_ASM_INT({\n      // Since we're treating each char as it's own string, each one\n      // will be null-termianted. So we malloc length*2 addresses.\n      var buffer = Module._malloc(emp_i.__outgoing_array.length*2);\n\n      for (i=0; i<emp_i.__outgoing_array.length; i++) {\n        stringToUTF8(emp_i.__outgoing_array[i], buffer+(i*2),2);\n      }\n\n      return buffer;\n    });\n\n    for (int i=0; i<MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length}); i++) {\n      arr.push_back(*(buffer + i*2));\n    }\n\n    free(buffer);\n  }\n  #else\n  void pass_vector_to_cpp(emp::vector<char> & arr, bool recurse = false) {;}\n  #endif\n\n  // We can handle strings in a similar way\n  #ifdef __EMSCRIPTEN__\n  template <std::size_t SIZE>\n  void pass_array_to_cpp(emp::array<std::string, SIZE> & arr, bool recurse = false) {\n\n    emp_assert(arr.size() == MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length}));\n\n    char * buffer = (char *) MAIN_THREAD_EM_ASM_INT({\n      // Figure how much memory to allocate\n      var arr_size = 0;\n      for (i=0; i<emp_i.__outgoing_array.length; i++) {\n        arr_size += emp_i.__outgoing_array[i].length + 1;\n      }\n\n      var buffer = Module._malloc(arr_size);\n\n      // Track place in memory to write too\n      var cumulative_size = 0;\n      var cur_length = 0;\n      for (i=0; i<emp_i.__outgoing_array.length; i++) {\n        cur_length = emp_i.__outgoing_array[i].length + 1;\n        stringToUTF8(emp_i.__outgoing_array[i], buffer + (cumulative_size), cur_length);\n        cumulative_size += cur_length;\n      }\n\n      return buffer;\n    });\n\n    // Track place in memory to read from\n    int cumulative_size = 0;\n    for (size_t i=0; i<arr.size(); i++) {\n      // Since std::string constructor reads to null terminator, this just works.\n      arr[i] = std::string(buffer + cumulative_size);\n      cumulative_size += arr[i].size() + 1;\n    }\n\n    free(buffer);\n  }\n  #else\n  template <std::size_t SIZE>\n  void pass_array_to_cpp(emp::array<std::string, SIZE> & arr, bool recurse = false) {;}\n  #endif\n\n  // We can handle strings in a similar way\n  #ifdef __EMSCRIPTEN__\n  void pass_vector_to_cpp(emp::vector<std::string> & arr, bool recurse = false) {\n\n    char * buffer = (char *) MAIN_THREAD_EM_ASM_INT({\n      // Figure how much memory to allocate\n      var arr_size = 0;\n      for (i=0; i<emp_i.__outgoing_array.length; i++) {\n        arr_size += emp_i.__outgoing_array[i].length + 1;\n      }\n\n      var buffer = Module._malloc(arr_size);\n\n      // Track place in memory to write too\n      var cumulative_size = 0;\n      var cur_length = 0;\n      for (i=0; i<emp_i.__outgoing_array.length; i++) {\n        cur_length = emp_i.__outgoing_array[i].length + 1;\n        stringToUTF8(emp_i.__outgoing_array[i], buffer + (cumulative_size), cur_length);\n        cumulative_size += cur_length;\n      }\n\n      return buffer;\n    });\n\n    // Track place in memory to read from\n    int cumulative_size = 0;\n    for (int i=0; i<MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length}); i++) {\n      // Since std::string constructor reads to null terminator, this just works.\n      arr.push_back(std::string(buffer + cumulative_size));\n      cumulative_size += arr[(size_t)i].size() + 1;\n    }\n\n    free(buffer);\n  }\n  #else\n  void pass_vector_to_cpp(emp::vector<std::string> & arr, bool recurse = false) {;}\n  #endif\n\n  // We can handle nested arrays through recursive calls on chunks of them\n  #ifdef __EMSCRIPTEN__\n  template <std::size_t SIZE, std::size_t SIZE2, typename T>\n  void pass_array_to_cpp(emp::array<emp::array<T, SIZE2>, SIZE> & arr, bool recurse = false) {\n\n    emp_assert(arr.size() == MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length}));\n\n    // Create temp array to hold whole array while pieces are passed in\n    if (recurse == 0) {\n      MAIN_THREAD_EM_ASM({emp_i.__temp_array = [emp_i.__outgoing_array];});\n    } else {\n      // This is a little wasteful of space, but the alternatives are\n      // surprisingly ugly\n      MAIN_THREAD_EM_ASM({emp_i.__temp_array.push(emp_i.__outgoing_array);});\n    }\n\n    for (size_t i = 0; i < arr.size(); i++) {\n      MAIN_THREAD_EM_ASM({\n        emp_i.__outgoing_array = emp_i.__temp_array[emp_i.__temp_array.length - 1][$0];\n      }, i);\n      pass_array_to_cpp(arr[i], true);\n    }\n\n    // Clear temp array\n    if (recurse == 0) { MAIN_THREAD_EM_ASM({emp_i.__temp_array = [];}); }\n    else { MAIN_THREAD_EM_ASM({emp_i.__temp_array.pop();}); }\n  }\n  #else\n  template <std::size_t SIZE, std::size_t SIZE2, typename T>\n  void pass_array_to_cpp(emp::array<emp::array<T, SIZE2>, SIZE> & arr, bool recurse = false) {;}\n  #endif\n\n  /// We can handle nested arrays through recursive calls on chunks of them\n  #ifdef __EMSCRIPTEN__\n  template <typename T>\n  void pass_vector_to_cpp(emp::vector<emp::vector<T> > & arr, bool recurse = false) {\n\n    // Create temp array to hold whole array while pieces are passed in\n    int size = MAIN_THREAD_EM_ASM_INT({return emp_i.__outgoing_array.length});\n\n    if (recurse == 0) {\n      MAIN_THREAD_EM_ASM({\n        emp_i.__temp_array = [emp_i.__outgoing_array];\n      });\n    } else {\n      // This is a little wasteful of space, but the alternatives are\n      // surprisingly ugly\n      MAIN_THREAD_EM_ASM({emp_i.__temp_array.push(emp_i.__outgoing_array);});\n    }\n\n    for (int i = 0; i < size; i++) {\n      MAIN_THREAD_EM_ASM({\n        emp_i.__outgoing_array = emp_i.__temp_array[emp_i.__temp_array.length - 1][$0];\n      }, i);\n      while ((int)arr.size() <= i) {\n        arr.push_back(emp::vector<T>());\n      }\n      pass_vector_to_cpp(arr[i], true);\n    }\n\n    // Clear temp array\n    if (recurse == 0) {\n      MAIN_THREAD_EM_ASM({emp_i.__temp_array = [];});\n    } else {\n      MAIN_THREAD_EM_ASM({emp_i.__temp_array.pop();});\n    }\n  }\n  #else\n  template <typename T>\n  void pass_vector_to_cpp(emp::vector<emp::vector<T> > & arr, bool recurse = false) {;}\n  #endif\n\n  /// @endcond\n\n  /// This function can be called to pass a map into JavaScript.\n  /// The resulting JavaScript object will be stored in emp.__incoming_map.\n  /// @param dict the map being passed into JavaScript\n  template <typename KEY_T, typename VAL_T>\n  void pass_map_to_javascript(const emp::map<KEY_T, VAL_T> & dict) {\n\n    emp::vector<KEY_T> keys;\n    emp::vector<VAL_T> values;\n\n    // extract keys and values from dict\n    for (typename std::map<KEY_T, VAL_T>::const_iterator it = dict.begin(); it != dict.end(); ++it) {\n      keys.push_back(it->first);\n      values.push_back(it->second);\n    }\n\n    // pass in extracted keys vector to JS\n    emp::pass_array_to_javascript(keys);\n    MAIN_THREAD_EM_ASM({\n      emp_i.__incoming_map_keys = emp_i.__incoming_array;\n    });\n\n    // check to make sure each key is not an object or a function\n    #ifdef __EMSCRIPTEN__\n    emp_assert(\n        MAIN_THREAD_EM_ASM_INT({\n          emp_i.__incoming_map_keys.forEach(function(key) {\n            if (typeof key === \"object\" || typeof key === \"function\") { return 0; }\n          });\n          return 1;\n        }), \"Keys cannot be an object or a function\");\n    #endif\n\n    // pass in extracted values vector to JS\n    emp::pass_array_to_javascript(values);\n    MAIN_THREAD_EM_ASM({\n      emp_i.__incoming_map_values = emp_i.__incoming_array;\n\n      // create dictionary\n      emp_i.__incoming_map = ( {} );\n      emp_i.__incoming_map_keys.forEach(function(key, val) {\n        emp_i.__incoming_map[key] = emp_i.__incoming_map_values[val]\n      });\n\n      // clean up unneeded vars\n      delete emp_i.__incoming_map_keys;\n      delete emp_i.__incoming_map_values;\n    });\n  }\n\n\n  /// This function can be called to pass two arrays of the same length into JavaScript (where a map is then created)\n  /// One array should hold keys, and the other should hold values\n  /// (note that the key-value pairs must line up across the arrays)\n  /// The resulting JavaScript object will be stored in emp.__incoming_map.\n  /// @param keys an array holding the keys to the map\n  /// @param values an array holding the values to the map\n  template <typename KEY_T, typename VAL_T, size_t SIZE>\n  void pass_map_to_javascript(const emp::array<KEY_T, SIZE> & keys, const emp::array<VAL_T, SIZE> & values) {\n\n    // pass in keys vector to JS\n    emp::pass_array_to_javascript(keys);\n    MAIN_THREAD_EM_ASM({\n      emp_i.__incoming_map_keys = emp_i.__incoming_array;\n    });\n\n    // check to make sure each key is not an object or a function\n    #ifdef __EMSCRIPTEN__\n    emp_assert(\n        MAIN_THREAD_EM_ASM_INT({\n          emp_i.__incoming_map_keys.forEach(function(key) {\n            if (typeof key === \"object\" || typeof key === \"function\") { return 0; }\n          });\n          return 1;\n        }), \"Keys cannot be an object or a function\");\n    #endif\n\n    // pass in values vector to JS\n    emp::pass_array_to_javascript(values);\n    MAIN_THREAD_EM_ASM({\n      emp_i.__incoming_map_values = emp_i.__incoming_array;\n\n      // create dictionary\n      emp_i.__incoming_map = ( {} );\n      emp_i.__incoming_map_keys.forEach(function(key, val) {\n        emp_i.__incoming_map[key] = emp_i.__incoming_map_values[val]\n      });\n\n      // clean up unneeded vars\n      delete emp_i.__incoming_map_keys;\n      delete emp_i.__incoming_map_values;\n    });\n  }\n\n  /// Helper function that returns DOM view port size in pixels.\n  int GetViewPortSize() {\n    return MAIN_THREAD_EM_ASM_INT({\n      return Math.min(\n        Math.max(\n          document.documentElement.clientWidth,\n          $(window).width(),\n          window.innerWidth || 0\n        ),\n        Math.max(\n          document.documentElement.clientHeight,\n          $(window).height(),\n          window.innerHeight || 0\n        )\n       );\n    });\n  }\n\n}\n\n\n#endif // #ifndef EMP_WEB_JS_UTILS_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2021\n *\n *  @file Card.hpp\n *  @brief Wraps a Bootstrap card.\n */\n\n#ifndef EMP_PREFAB_CARD_HPP_INCLUDE\n#define EMP_PREFAB_CARD_HPP_INCLUDE\n\n#include \"../tools/string_utils.hpp\"\n#include \"../web/Div.hpp\"\n\n#include \"Collapse.hpp\"\n#include \"FontAwesomeIcon.hpp\"\n\nnamespace emp {\nnamespace prefab {\n\n  namespace internal {\n    /**\n     * Shared pointer held by instances of Card class representing\n     * the same conceptual Card DOM object.\n     * Contains state that should persist while Card DOM object\n     * persists.\n     */\n    class CardInfo : public web::internal::DivInfo {\n\n    public:\n      using on_toggle_fun_t = std::function<void()>;\n    protected:\n      on_toggle_fun_t toggle_handler;\n    public:\n      /**\n       * Construct a shared pointer to manage Card state.\n       * @param in_id HTML ID of Card div\n       */\n      CardInfo(const std::string & in_id=\"\")\n      : DivInfo(in_id), toggle_handler([]() {;}) { ; }\n\n      /**\n       * Get the on-toggle function for this component.\n       * @return the function called whenever the card's state\n       * is toggled open or closed\n       */\n      on_toggle_fun_t & GetOnToggle() {\n        return toggle_handler;\n      }\n\n      /**\n       * Set the on-toggle function for this component.\n       * @param on_toggle the function to be called whenever the\n       * card's state is toggled open or closed.\n       */\n      void SetOnToggle(on_toggle_fun_t on_toggle) {\n        toggle_handler = on_toggle;\n      }\n    };\n  }\n\n  /// Use Card class to create Bootstrap style cards.\n  class Card : public web::Div {\n\n    using on_toggle_fun_t = internal::CardInfo::on_toggle_fun_t;\n\n  private:\n    /**\n     * Get shared info pointer, cast to Card-specific type.\n     * @return cast pointer\n     */\n    internal::CardInfo * Info() {\n      return dynamic_cast<internal::CardInfo *>(info);\n    }\n\n    /**\n     * Get shared info pointer, cast to const Card-specific type.\n     * @return cast pointer\n     */\n    const internal::CardInfo * Info() const {\n      return dynamic_cast<internal::CardInfo *>(info);\n    }\n\n  protected:\n    // ID of card Div to be used in ID of associated card sub components\n    std::string card_base = this->GetID();\n    // all header content will be added here\n    web::Div card_header{emp::to_string(card_base, \"_card_header\")};\n    // all body content will be added here\n    web::Div card_body{emp::to_string(card_base, \"_card_body\")};\n    // Asssigns classes to card elements for styling\n    void AddBootstrap() {\n      this->SetAttr(\"class\", \"card\");\n      card_header.SetAttr(\"class\", \"card-header\");\n      card_body.SetAttr(\"class\", \"card-body\");\n    }\n\n  public:\n    /**\n     * @param state indicate whether card should be STATIC, INIT_OPEN, or INIT_CLOSED (default STATIC)\n     * @param show_glyphs should toggle icons show in collapsible card header? (default true)\n     * @param id user defined ID for card Div, (default emscripten generated)\n     */\n    Card(\n      const std::string & state=\"STATIC\",\n      const bool & show_glyphs=true,\n      const std::string & id=\"\"\n    ) : Card(state, show_glyphs, new internal::CardInfo(id)) { ; }\n\n  protected:\n    /**\n     * A protected constructor for a Card.\n     * @param state indicate whether card should be STATIC, INIT_OPEN, or INIT_CLOSED (default STATIC)\n     * @param show_glyphs should toggle icons show in collapsible card header? (default true)\n     * @param info_ref a pointer to the underlying ReadoutPanelInfo object for this ReadoutPanel\n     * or a pointer to a derived info object (simulating inheritance)\n     */\n    Card(\n      const std::string & state,\n      const bool & show_glyphs,\n      internal::CardInfo * in_info\n    ) : Div(in_info) {\n\n      AddBootstrap();\n      if (state == \"STATIC\") { // static card with no toggle enabled\n        static_cast<Div>(*this) << card_header; // Cast to Div prevents redefined\n        static_cast<Div>(*this) << card_body;   // stream operator from being used\n      } else {\n        // card is collapsible, make the collapse link the head of the card\n        prefab::CollapseCoupling accordion(card_header,\n          card_body,\n          state == \"INIT_OPEN\",\n          emp::to_string(card_base+ \"_card_collapse\")\n        );\n\n        Div header_div{accordion.GetControllerDiv()};\n        static_cast<Div>(*this) << header_div;\n        static_cast<Div>(*this) << accordion.GetTargetDiv();\n\n        on_toggle_fun_t & tog = GetOnToggle();\n        header_div.OnClick([header_div, &toggle = tog](){\n          toggle();\n          // TODO: toggle really should accept boolean so the user can trigger\n          // different events on open/close to prevent double click issues\n          // but getting that state is currently impossible, see\n          // https://github.com/devosoft/Empirical/issues/440.\n        });\n\n        if (show_glyphs) { // by default add glyphs to a collapsible card\n          prefab::FontAwesomeIcon up(\"fa-angle-double-up\");\n          prefab::FontAwesomeIcon down(\"fa-angle-double-down\");\n          card_header << up;\n          card_header << down;\n          up.AddAttr(\"class\", \"toggle_glyph\");\n          down.AddAttr(\"class\", \"toggle_glyph\");\n        }\n        card_header.AddAttr(\"class\", \"collapse_toggle_card_header\");\n      }\n    }\n  public:\n    /**\n     * Add content to header section of card.\n     *\n     * @param val content to be added to header, can be a web element or primitive type\n     * @param link_content indicates whether the content should have Bootstrap link properties (default false)\n     */\n    template <typename T>\n    void AddHeaderContent(T val, const bool link_content=false) {\n      /*\n       * Note: val can be a controller of a target area (made with CollapseCoupling class)\n       * but when added to header of the card, it will also trigger the card\n       * to collapse/expand\n       */\n      if (link_content) {\n        /*\n         * Add bootstrap link properities to content (hover, underline, etc.),\n         * but does not set a target or href because it is assumed that\n         * this content will control the card collapse, which is done in the\n         * constructor.\n         */\n        web::Div btn_link;\n        btn_link.SetAttr(\"class\", \"btn-link\");\n        card_header << btn_link << val;\n      } else {\n        card_header << val;\n      }\n    }\n\n    /**\n     * Add content to body section of card.\n     *\n     * @param val can be a web element or primitive type\n     * @deprecated Use stream operator instead\n     */\n    template <typename T>\n    [[deprecated(\"Use the stream operator (<<) to add to card body\")]]\n    void AddBodyContent(T val) {\n      card_body << val;\n    }\n\n    /**\n     * Add content to the body section of the card.\n     *\n     * @param in_val can be a web element or primitive type\n     */\n    template <typename IN_TYPE>\n    emp::prefab::Card & operator<<(IN_TYPE && in_val) {\n      card_body << std::forward<IN_TYPE>(in_val);\n      return (*this);\n    }\n\n    /**\n     * Sets the on-toggle function for this component.\n     * @param on_toggle the function to be called whenever the card's state is\n     * toggled open or closed\n     */\n    void SetOnToggle(on_toggle_fun_t on_toggle) {\n      Info()->SetOnToggle(on_toggle);\n    }\n\n    /**\n     * Get the on-toggle function for this component.\n     * @return the function to be called whenever the card's state is\n     * toggled open or closed\n     */\n    on_toggle_fun_t & GetOnToggle() {\n      return Info()->GetOnToggle();\n    }\n\n  };\n}\n}\n\n#endif // #ifndef EMP_PREFAB_CARD_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2021\n *\n *  @file FontAwesomeIcon.hpp\n *  @brief Wraps Font Awesome's icons.\n */\n\n#ifndef EMP_PREFAB_FONTAWESOMEICON_HPP_INCLUDE\n#define EMP_PREFAB_FONTAWESOMEICON_HPP_INCLUDE\n\n#include \"../tools/string_utils.hpp\"\n#include \"../web/Div.hpp\"\n#include \"../web/Element.hpp\"\n#include \"../web/Widget.hpp\"\n\nnamespace emp {\nnamespace prefab {\n  /**\n   * Use FontAwesomeIcon class to add a glyph from the\n   * FontAwesome library to your web app.\n   * (https://fontawesome.com/v4.7.0/icons/)\n   */\n  class FontAwesomeIcon: public web::Element {\n    public:\n      /**\n       * @param fa_name the font awesome class of the desired icon\n       * @param id optional unique id the icon can be referenced by\n       */\n\n      FontAwesomeIcon(const std::string fa_name, const std::string & id=\"\")\n        : web::Element(\"span\", id) {\n        std::string full_class = emp::to_string(\"fa \", fa_name);\n        this->SetAttr(\"class\", full_class);\n      }\n\n      /*\n       * TODO: Prevent user from streaming content into the icon, throw error\n       * The method below throws an error when trying to stream\n       * a code block into anything else (web element, html).\n       *\n       * template <typename T>\n       * void operator<<(T invalid) {\n       *      emp::LibraryError(\"Not allowed to add code to the FontAwesome icon\");\n       * }\n       */\n  };\n}\n}\n\n#endif // #ifndef EMP_PREFAB_FONTAWESOMEICON_HPP_INCLUDE\n","// -*- C++ -*-\n//===-------------------------- __string ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___STRING\n#define _LIBCPP___STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static constexpr void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static constexpr int    compare(const char_type* s1, const char_type* s2, size_t n);\n    static constexpr size_t length(const char_type* s);\n    static constexpr const char_type* \n                            find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\ntemplate <> struct char_traits<char8_t>;  // c++20\n\n}  // std\n\n*/\n\n#include <__config>\n#include <algorithm>  // for search and min\n#include <cstdio>     // For EOF.\n#include <memory>     // for __murmur2_or_cityhash\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TEMPLATE_VIS char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void _LIBCPP_CONSTEXPR_AFTER_CXX14\n        assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\n_LIBCPP_CONSTEXPR_AFTER_CXX14 int\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 size_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 const _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static inline size_t _LIBCPP_CONSTEXPR_AFTER_CXX14\n    length(const char_type* __s)  _NOEXCEPT {return __builtin_strlen(__s);}\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*) memmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)memcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_memcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return memcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char*\nchar_traits<char>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return nullptr;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_char_memchr(__s, to_int_type(__a), __n);\n#elif _LIBCPP_STD_VER <= 14\n    return (const char_type*) memchr(__s, to_int_type(__a), __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return nullptr;\n#endif\n}\n\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*)wmemmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)wmemcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)wmemset(__s, __a, __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<wchar_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wmemcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<wchar_t>::length(const char_type* __s) _NOEXCEPT\n{\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wcslen(__s);\n#elif _LIBCPP_STD_VER <= 14\n    return wcslen(__s);\n#else\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst wchar_t*\nchar_traits<wchar_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return nullptr;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wmemchr(__s, __a, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemchr(__s, __a, __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return nullptr;\n#endif\n}\n\n\n#ifndef _LIBCPP_NO_HAS_CHAR8_T\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char8_t>\n{\n    typedef char8_t        char_type;\n    typedef unsigned int   int_type;\n    typedef streamoff      off_type;\n    typedef u8streampos    pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline constexpr void assign(char_type& __c1, const char_type& __c2) noexcept\n        {__c1 = __c2;}\n    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept\n        {return __c1 == __c2;}\n    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept\n        {return __c1 < __c2;}\n\n    static constexpr\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n\n    static constexpr\n    size_t           length(const char_type* __s) _NOEXCEPT;\n \n    _LIBCPP_INLINE_VISIBILITY static constexpr\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n \n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*) memmove(__s1, __s2, __n);}\n \n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n       {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)memcpy(__s1, __s2, __n);\n       }\n \n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    static inline constexpr int_type  not_eof(int_type __c) noexcept\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline constexpr char_type to_char_type(int_type __c) noexcept\n        {return char_type(__c);}\n    static inline constexpr int_type to_int_type(char_type __c) noexcept\n        {return int_type(__c);}\n    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept\n        {return __c1 == __c2;}\n    static inline constexpr int_type eof() noexcept\n        {return int_type(EOF);}\n};\n\n// TODO use '__builtin_strlen' if it ever supports char8_t ??\ninline constexpr\nsize_t\nchar_traits<char8_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline constexpr\nint\nchar_traits<char8_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_memcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\n// TODO use '__builtin_char_memchr' if it ever supports char8_t ??\ninline constexpr\nconst char8_t*\nchar_traits<char8_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\n#endif // #_LIBCPP_NO_HAS_CHAR8_T\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char16_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char32_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// helper fns for basic_string and string_view\n\n// __str_find\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n             _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos >= __sz)\n        return __npos;\n    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 const _CharT *\n__search_substring(const _CharT *__first1, const _CharT *__last1,\n                   const _CharT *__first2, const _CharT *__last2) {\n  // Take advantage of knowing source and pattern lengths.\n  // Stop short when source is smaller than pattern.\n  const ptrdiff_t __len2 = __last2 - __first2;\n  if (__len2 == 0)\n    return __first1;\n\n  ptrdiff_t __len1 = __last1 - __first1;\n  if (__len1 < __len2)\n    return __last1;\n\n  // First element of __first2 is loop invariant.\n  _CharT __f2 = *__first2;\n  while (true) {\n    __len1 = __last1 - __first1;\n    // Check whether __first1 still has at least __len2 bytes.\n    if (__len1 < __len2)\n      return __last1;\n\n    // Find __f2 the first byte matching in __first1.\n    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);\n    if (__first1 == 0)\n      return __last1;\n\n    // It is faster to compare from the first byte of __first1 even if we\n    // already know that it matches the first byte of __first2: this is because\n    // __first2 is most likely aligned, as it is user's \"pattern\" string, and\n    // __first1 + 1 is most likely not aligned, as the match is in the middle of\n    // the string.\n    if (_Traits::compare(__first1, __first2, __len2) == 0)\n      return __first1;\n\n    ++__first1;\n  }\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n       const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos > __sz)\n        return __npos;\n\n    if (__n == 0) // There is nothing to search, just return __pos.\n        return __pos;\n\n    const _CharT *__r = __search_substring<_CharT, _Traits>(\n        __p + __pos, __p + __sz, __s, __s + __n);\n\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_rfind\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n              _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__sz < 1)\n        return __npos;\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n    {\n        if (_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n        const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const _CharT* __r = _VSTD::__find_end(\n                  __p, __p + __pos, __s, __s + __n, _Traits::eq, \n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__n > 0 && __r == __p + __pos)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n// __str_find_first_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_of(const _CharT *__p, _SizeT __sz,\n                const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos >= __sz || __n == 0)\n        return __npos;\n    const _CharT* __r = _VSTD::__find_first_of_ce\n        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_find_last_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_of(const _CharT *__p, _SizeT __sz,\n               const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n    {\n    if (__n != 0)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        {\n            const _CharT* __r = _Traits::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<_SizeT>(__ps - __p);\n        }\n    }\n    return __npos;\n}\n\n\n// __str_find_first_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                    const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (_Traits::find(__s, __n, *__ps) == 0)\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                          _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!_Traits::eq(*__ps, __c))\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\n// __str_find_last_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                   const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (_Traits::find(__s, __n, *--__ps) == 0)\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                         _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (!_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\ntemplate<class _Ptr>\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\ntemplate <class _CharT, class _Iter, class _Traits=char_traits<_CharT> >\nstruct __quoted_output_proxy\n{\n    _Iter  __first;\n    _Iter  __last;\n    _CharT  __delim;\n    _CharT  __escape;\n\n    __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)\n    : __first(__f), __last(__l), __delim(__d), __escape(__e) {}\n    //  This would be a nice place for a string_ref \n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP___STRING\n","// -*- C++ -*-\n//===-------------------------- optional ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_OPTIONAL\n#define _LIBCPP_OPTIONAL\n\n/*\n    optional synopsis\n\n// C++1z\n\nnamespace std {\n  // 23.6.3, optional for object types\n  template <class T> class optional;\n\n  // 23.6.4, no-value state indicator\n  struct nullopt_t{see below };\n  inline constexpr nullopt_t nullopt(unspecified );\n\n  // 23.6.5, class bad_optional_access\n  class bad_optional_access;\n\n  // 23.6.6, relational operators\n  template <class T, class U>\n  constexpr bool operator==(const optional<T>&, const optional<U>&);\n  template <class T, class U>\n  constexpr bool operator!=(const optional<T>&, const optional<U>&);\n  template <class T, class U>\n  constexpr bool operator<(const optional<T>&, const optional<U>&);\n  template <class T, class U>\n  constexpr bool operator>(const optional<T>&, const optional<U>&);\n  template <class T, class U>\n  constexpr bool operator<=(const optional<T>&, const optional<U>&);\n  template <class T, class U>\n  constexpr bool operator>=(const optional<T>&, const optional<U>&);\n\n  // 23.6.7 comparison with nullopt\n  template <class T> constexpr bool operator==(const optional<T>&, nullopt_t) noexcept;\n  template <class T> constexpr bool operator==(nullopt_t, const optional<T>&) noexcept;\n  template <class T> constexpr bool operator!=(const optional<T>&, nullopt_t) noexcept;\n  template <class T> constexpr bool operator!=(nullopt_t, const optional<T>&) noexcept;\n  template <class T> constexpr bool operator<(const optional<T>&, nullopt_t) noexcept;\n  template <class T> constexpr bool operator<(nullopt_t, const optional<T>&) noexcept;\n  template <class T> constexpr bool operator<=(const optional<T>&, nullopt_t) noexcept;\n  template <class T> constexpr bool operator<=(nullopt_t, const optional<T>&) noexcept;\n  template <class T> constexpr bool operator>(const optional<T>&, nullopt_t) noexcept;\n  template <class T> constexpr bool operator>(nullopt_t, const optional<T>&) noexcept;\n  template <class T> constexpr bool operator>=(const optional<T>&, nullopt_t) noexcept;\n  template <class T> constexpr bool operator>=(nullopt_t, const optional<T>&) noexcept;\n\n  // 23.6.8, comparison with T\n  template <class T, class U> constexpr bool operator==(const optional<T>&, const U&);\n  template <class T, class U> constexpr bool operator==(const T&, const optional<U>&);\n  template <class T, class U> constexpr bool operator!=(const optional<T>&, const U&);\n  template <class T, class U> constexpr bool operator!=(const T&, const optional<U>&);\n  template <class T, class U> constexpr bool operator<(const optional<T>&, const U&);\n  template <class T, class U> constexpr bool operator<(const T&, const optional<U>&);\n  template <class T, class U> constexpr bool operator<=(const optional<T>&, const U&);\n  template <class T, class U> constexpr bool operator<=(const T&, const optional<U>&);\n  template <class T, class U> constexpr bool operator>(const optional<T>&, const U&);\n  template <class T, class U> constexpr bool operator>(const T&, const optional<U>&);\n  template <class T, class U> constexpr bool operator>=(const optional<T>&, const U&);\n  template <class T, class U> constexpr bool operator>=(const T&, const optional<U>&);\n\n  // 23.6.9, specialized algorithms\n  template <class T> void swap(optional<T>&, optional<T>&) noexcept(see below );\n  template <class T> constexpr optional<see below > make_optional(T&&);\n  template <class T, class... Args>\n    constexpr optional<T> make_optional(Args&&... args);\n  template <class T, class U, class... Args>\n    constexpr optional<T> make_optional(initializer_list<U> il, Args&&... args);\n\n  // 23.6.10, hash support\n  template <class T> struct hash;\n  template <class T> struct hash<optional<T>>;\n\n  template <class T> class optional {\n  public:\n    using value_type = T;\n\n    // 23.6.3.1, constructors\n    constexpr optional() noexcept;\n    constexpr optional(nullopt_t) noexcept;\n    optional(const optional &);\n    optional(optional &&) noexcept(see below);\n    template <class... Args> constexpr explicit optional(in_place_t, Args &&...);\n    template <class U, class... Args>\n      constexpr explicit optional(in_place_t, initializer_list<U>, Args &&...);\n    template <class U = T>\n      constexpr EXPLICIT optional(U &&);\n    template <class U>\n      constexpr EXPLICIT optional(const optional<U> &);\n    template <class U>\n      constexpr EXPLICIT optional(optional<U> &&);\n\n    // 23.6.3.2, destructor\n    ~optional();\n\n    // 23.6.3.3, assignment\n    optional &operator=(nullopt_t) noexcept;\n    optional &operator=(const optional &);                // constexpr in C++20\n    optional &operator=(optional &&) noexcept(see below); // constexpr in C++20\n    template <class U = T> optional &operator=(U &&);\n    template <class U> optional &operator=(const optional<U> &);\n    template <class U> optional &operator=(optional<U> &&);\n    template <class... Args> T& emplace(Args &&...);\n    template <class U, class... Args>\n      T& emplace(initializer_list<U>, Args &&...);\n\n    // 23.6.3.4, swap\n    void swap(optional &) noexcept(see below );\n\n    // 23.6.3.5, observers\n    constexpr T const *operator->() const;\n    constexpr T *operator->();\n    constexpr T const &operator*() const &;\n    constexpr T &operator*() &;\n    constexpr T &&operator*() &&;\n    constexpr const T &&operator*() const &&;\n    constexpr explicit operator bool() const noexcept;\n    constexpr bool has_value() const noexcept;\n    constexpr T const &value() const &;\n    constexpr T &value() &;\n    constexpr T &&value() &&;\n    constexpr const T &&value() const &&;\n    template <class U> constexpr T value_or(U &&) const &;\n    template <class U> constexpr T value_or(U &&) &&;\n\n    // 23.6.3.6, modifiers\n    void reset() noexcept;\n\n  private:\n    T *val; // exposition only\n  };\n\ntemplate<class T>\n  optional(T) -> optional<T>;\n\n} // namespace std\n\n*/\n\n#include <__config>\n#include <__debug>\n#include <__functional_base>\n#include <functional>\n#include <initializer_list>\n#include <new>\n#include <stdexcept>\n#include <type_traits>\n#include <utility>\n#include <version>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI _LIBCPP_AVAILABILITY_BAD_OPTIONAL_ACCESS bad_optional_access\n    : public exception\n{\npublic:\n    // Get the key function ~bad_optional_access() into the dylib\n    virtual ~bad_optional_access() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n}  // std\n\n#if _LIBCPP_STD_VER > 14\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n_LIBCPP_NORETURN\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_AVAILABILITY_THROW_BAD_OPTIONAL_ACCESS\nvoid __throw_bad_optional_access() {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        throw bad_optional_access();\n#else\n        _VSTD::abort();\n#endif\n}\n\nstruct nullopt_t\n{\n    struct __secret_tag { _LIBCPP_INLINE_VISIBILITY explicit __secret_tag() = default; };\n    _LIBCPP_INLINE_VISIBILITY constexpr explicit nullopt_t(__secret_tag, __secret_tag) noexcept {}\n};\n\n_LIBCPP_INLINE_VAR constexpr nullopt_t nullopt{nullopt_t::__secret_tag{}, nullopt_t::__secret_tag{}};\n\ntemplate <class _Tp, bool = is_trivially_destructible<_Tp>::value>\nstruct __optional_destruct_base;\n\ntemplate <class _Tp>\nstruct __optional_destruct_base<_Tp, false>\n{\n    typedef _Tp value_type;\n    static_assert(is_object_v<value_type>,\n        \"instantiation of optional with a non-object type is undefined behavior\");\n    union\n    {\n        char __null_state_;\n        value_type __val_;\n    };\n    bool __engaged_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__optional_destruct_base()\n    {\n        if (__engaged_)\n            __val_.~value_type();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr __optional_destruct_base() noexcept\n        :  __null_state_(),\n           __engaged_(false) {}\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr explicit __optional_destruct_base(in_place_t, _Args&&... __args)\n        :  __val_(_VSTD::forward<_Args>(__args)...),\n           __engaged_(true) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() noexcept\n    {\n        if (__engaged_)\n        {\n            __val_.~value_type();\n            __engaged_ = false;\n        }\n    }\n};\n\ntemplate <class _Tp>\nstruct __optional_destruct_base<_Tp, true>\n{\n    typedef _Tp value_type;\n    static_assert(is_object_v<value_type>,\n        \"instantiation of optional with a non-object type is undefined behavior\");\n    union\n    {\n        char __null_state_;\n        value_type __val_;\n    };\n    bool __engaged_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr __optional_destruct_base() noexcept\n        :  __null_state_(),\n           __engaged_(false) {}\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr explicit __optional_destruct_base(in_place_t, _Args&&... __args)\n        :  __val_(_VSTD::forward<_Args>(__args)...),\n           __engaged_(true) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() noexcept\n    {\n        if (__engaged_)\n        {\n            __engaged_ = false;\n        }\n    }\n};\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value>\nstruct __optional_storage_base : __optional_destruct_base<_Tp>\n{\n    using __base = __optional_destruct_base<_Tp>;\n    using value_type = _Tp;\n    using __base::__base;\n\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr bool has_value() const noexcept\n    {\n        return this->__engaged_;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr value_type& __get() & noexcept\n    {\n        return this->__val_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr const value_type& __get() const& noexcept\n    {\n        return this->__val_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr value_type&& __get() && noexcept\n    {\n        return _VSTD::move(this->__val_);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr const value_type&& __get() const&& noexcept\n    {\n        return _VSTD::move(this->__val_);\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    void __construct(_Args&&... __args)\n    {\n        _LIBCPP_ASSERT(!has_value(), \"__construct called for engaged __optional_storage\");\n        ::new((void*)_VSTD::addressof(this->__val_)) value_type(_VSTD::forward<_Args>(__args)...);\n        this->__engaged_ = true;\n    }\n\n    template <class _That>\n    _LIBCPP_INLINE_VISIBILITY\n    void __construct_from(_That&& __opt)\n    {\n        if (__opt.has_value())\n            __construct(_VSTD::forward<_That>(__opt).__get());\n    }\n\n    template <class _That>\n    _LIBCPP_INLINE_VISIBILITY\n    void __assign_from(_That&& __opt)\n    {\n        if (this->__engaged_ == __opt.has_value())\n        {\n            if (this->__engaged_)\n                this->__val_ = _VSTD::forward<_That>(__opt).__get();\n        }\n        else\n        {\n            if (this->__engaged_)\n                this->reset();\n            else\n                __construct(_VSTD::forward<_That>(__opt).__get());\n        }\n    }\n};\n\n// optional<T&> is currently required ill-formed, however it may to be in the\n// future. For this reason it has already been implemented to ensure we can\n// make the change in an ABI compatible manner.\ntemplate <class _Tp>\nstruct __optional_storage_base<_Tp, true>\n{\n    using value_type = _Tp;\n    using __raw_type = remove_reference_t<_Tp>;\n    __raw_type* __value_;\n\n    template <class _Up>\n    static constexpr bool __can_bind_reference() {\n        using _RawUp = typename remove_reference<_Up>::type;\n        using _UpPtr = _RawUp*;\n        using _RawTp = typename remove_reference<_Tp>::type;\n        using _TpPtr = _RawTp*;\n        using _CheckLValueArg = integral_constant<bool,\n            (is_lvalue_reference<_Up>::value && is_convertible<_UpPtr, _TpPtr>::value)\n        ||  is_same<_RawUp, reference_wrapper<_RawTp>>::value\n        ||  is_same<_RawUp, reference_wrapper<typename remove_const<_RawTp>::type>>::value\n        >;\n        return (is_lvalue_reference<_Tp>::value && _CheckLValueArg::value)\n            || (is_rvalue_reference<_Tp>::value && !is_lvalue_reference<_Up>::value &&\n                is_convertible<_UpPtr, _TpPtr>::value);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr __optional_storage_base() noexcept\n        :  __value_(nullptr) {}\n\n    template <class _UArg>\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr explicit __optional_storage_base(in_place_t, _UArg&& __uarg)\n        :  __value_(_VSTD::addressof(__uarg))\n    {\n      static_assert(__can_bind_reference<_UArg>(),\n        \"Attempted to construct a reference element in tuple from a \"\n        \"possible temporary\");\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() noexcept { __value_ = nullptr; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr bool has_value() const noexcept\n      { return __value_ != nullptr; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr value_type& __get() const& noexcept\n      { return *__value_; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr value_type&& __get() const&& noexcept\n      { return _VSTD::forward<value_type>(*__value_); }\n\n    template <class _UArg>\n    _LIBCPP_INLINE_VISIBILITY\n    void __construct(_UArg&& __val)\n    {\n        _LIBCPP_ASSERT(!has_value(), \"__construct called for engaged __optional_storage\");\n        static_assert(__can_bind_reference<_UArg>(),\n            \"Attempted to construct a reference element in tuple from a \"\n            \"possible temporary\");\n        __value_ = _VSTD::addressof(__val);\n    }\n\n    template <class _That>\n    _LIBCPP_INLINE_VISIBILITY\n    void __construct_from(_That&& __opt)\n    {\n        if (__opt.has_value())\n            __construct(_VSTD::forward<_That>(__opt).__get());\n    }\n\n    template <class _That>\n    _LIBCPP_INLINE_VISIBILITY\n    void __assign_from(_That&& __opt)\n    {\n        if (has_value() == __opt.has_value())\n        {\n            if (has_value())\n                *__value_ = _VSTD::forward<_That>(__opt).__get();\n        }\n        else\n        {\n            if (has_value())\n                reset();\n            else\n                __construct(_VSTD::forward<_That>(__opt).__get());\n        }\n    }\n};\n\ntemplate <class _Tp, bool = is_trivially_copy_constructible<_Tp>::value>\nstruct __optional_copy_base : __optional_storage_base<_Tp>\n{\n    using __optional_storage_base<_Tp>::__optional_storage_base;\n};\n\ntemplate <class _Tp>\nstruct __optional_copy_base<_Tp, false> : __optional_storage_base<_Tp>\n{\n    using __optional_storage_base<_Tp>::__optional_storage_base;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_copy_base() = default;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_copy_base(const __optional_copy_base& __opt)\n    {\n        this->__construct_from(__opt);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_copy_base(__optional_copy_base&&) = default;\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_copy_base& operator=(const __optional_copy_base&) = default;\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_copy_base& operator=(__optional_copy_base&&) = default;\n};\n\ntemplate <class _Tp, bool = is_trivially_move_constructible<_Tp>::value>\nstruct __optional_move_base : __optional_copy_base<_Tp>\n{\n    using __optional_copy_base<_Tp>::__optional_copy_base;\n};\n\ntemplate <class _Tp>\nstruct __optional_move_base<_Tp, false> : __optional_copy_base<_Tp>\n{\n    using value_type = _Tp;\n    using __optional_copy_base<_Tp>::__optional_copy_base;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_move_base() = default;\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_move_base(const __optional_move_base&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_move_base(__optional_move_base&& __opt)\n        noexcept(is_nothrow_move_constructible_v<value_type>)\n    {\n        this->__construct_from(_VSTD::move(__opt));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_move_base& operator=(const __optional_move_base&) = default;\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_move_base& operator=(__optional_move_base&&) = default;\n};\n\ntemplate <class _Tp, bool =\n    is_trivially_destructible<_Tp>::value &&\n    is_trivially_copy_constructible<_Tp>::value &&\n    is_trivially_copy_assignable<_Tp>::value>\nstruct __optional_copy_assign_base : __optional_move_base<_Tp>\n{\n    using __optional_move_base<_Tp>::__optional_move_base;\n};\n\ntemplate <class _Tp>\nstruct __optional_copy_assign_base<_Tp, false> : __optional_move_base<_Tp>\n{\n    using __optional_move_base<_Tp>::__optional_move_base;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_copy_assign_base() = default;\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_copy_assign_base(const __optional_copy_assign_base&) = default;\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_copy_assign_base(__optional_copy_assign_base&&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_copy_assign_base& operator=(const __optional_copy_assign_base& __opt)\n    {\n        this->__assign_from(__opt);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_copy_assign_base& operator=(__optional_copy_assign_base&&) = default;\n};\n\ntemplate <class _Tp, bool =\n    is_trivially_destructible<_Tp>::value &&\n    is_trivially_move_constructible<_Tp>::value &&\n    is_trivially_move_assignable<_Tp>::value>\nstruct __optional_move_assign_base : __optional_copy_assign_base<_Tp>\n{\n    using __optional_copy_assign_base<_Tp>::__optional_copy_assign_base;\n};\n\ntemplate <class _Tp>\nstruct __optional_move_assign_base<_Tp, false> : __optional_copy_assign_base<_Tp>\n{\n    using value_type = _Tp;\n    using __optional_copy_assign_base<_Tp>::__optional_copy_assign_base;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_move_assign_base() = default;\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_move_assign_base(const __optional_move_assign_base& __opt) = default;\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_move_assign_base(__optional_move_assign_base&&) = default;\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_move_assign_base& operator=(const __optional_move_assign_base&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __optional_move_assign_base& operator=(__optional_move_assign_base&& __opt)\n        noexcept(is_nothrow_move_assignable_v<value_type> &&\n                 is_nothrow_move_constructible_v<value_type>)\n    {\n        this->__assign_from(_VSTD::move(__opt));\n        return *this;\n    }\n};\n\ntemplate <class _Tp>\nusing __optional_sfinae_ctor_base_t = __sfinae_ctor_base<\n    is_copy_constructible<_Tp>::value,\n    is_move_constructible<_Tp>::value\n>;\n\ntemplate <class _Tp>\nusing __optional_sfinae_assign_base_t = __sfinae_assign_base<\n    (is_copy_constructible<_Tp>::value && is_copy_assignable<_Tp>::value),\n    (is_move_constructible<_Tp>::value && is_move_assignable<_Tp>::value)\n>;\n\ntemplate <class _Tp>\nclass optional\n    : private __optional_move_assign_base<_Tp>\n    , private __optional_sfinae_ctor_base_t<_Tp>\n    , private __optional_sfinae_assign_base_t<_Tp>\n{\n    using __base = __optional_move_assign_base<_Tp>;\npublic:\n    using value_type = _Tp;\n\nprivate:\n     // Disable the reference extension using this static assert.\n    static_assert(!is_same_v<value_type, in_place_t>,\n        \"instantiation of optional with in_place_t is ill-formed\");\n    static_assert(!is_same_v<__uncvref_t<value_type>, nullopt_t>,\n        \"instantiation of optional with nullopt_t is ill-formed\");\n    static_assert(!is_reference_v<value_type>,\n        \"instantiation of optional with a reference type is ill-formed\");\n    static_assert(is_destructible_v<value_type>,\n        \"instantiation of optional with a non-destructible type is ill-formed\");\n\n    // LWG2756: conditionally explicit conversion from _Up\n    struct _CheckOptionalArgsConstructor {\n      template <class _Up>\n      static constexpr bool __enable_implicit() {\n          return is_constructible_v<_Tp, _Up&&> &&\n                 is_convertible_v<_Up&&, _Tp>;\n      }\n\n      template <class _Up>\n      static constexpr bool __enable_explicit() {\n          return is_constructible_v<_Tp, _Up&&> &&\n                 !is_convertible_v<_Up&&, _Tp>;\n      }\n    };\n    template <class _Up>\n    using _CheckOptionalArgsCtor = conditional_t<\n        !is_same_v<__uncvref_t<_Up>, in_place_t> &&\n        !is_same_v<__uncvref_t<_Up>, optional>,\n        _CheckOptionalArgsConstructor,\n        __check_tuple_constructor_fail\n    >;\n    template <class _QualUp>\n    struct _CheckOptionalLikeConstructor {\n      template <class _Up, class _Opt = optional<_Up>>\n      using __check_constructible_from_opt = __lazy_or<\n          is_constructible<_Tp, _Opt&>,\n          is_constructible<_Tp, _Opt const&>,\n          is_constructible<_Tp, _Opt&&>,\n          is_constructible<_Tp, _Opt const&&>,\n          is_convertible<_Opt&, _Tp>,\n          is_convertible<_Opt const&, _Tp>,\n          is_convertible<_Opt&&, _Tp>,\n          is_convertible<_Opt const&&, _Tp>\n      >;\n      template <class _Up, class _Opt = optional<_Up>>\n      using __check_assignable_from_opt = __lazy_or<\n          is_assignable<_Tp&, _Opt&>,\n          is_assignable<_Tp&, _Opt const&>,\n          is_assignable<_Tp&, _Opt&&>,\n          is_assignable<_Tp&, _Opt const&&>\n      >;\n      template <class _Up, class _QUp = _QualUp>\n      static constexpr bool __enable_implicit() {\n          return is_convertible<_QUp, _Tp>::value &&\n              !__check_constructible_from_opt<_Up>::value;\n      }\n      template <class _Up, class _QUp = _QualUp>\n      static constexpr bool __enable_explicit() {\n          return !is_convertible<_QUp, _Tp>::value &&\n              !__check_constructible_from_opt<_Up>::value;\n      }\n      template <class _Up, class _QUp = _QualUp>\n      static constexpr bool __enable_assign() {\n          // Construction and assignability of _Qup to _Tp has already been\n          // checked.\n          return !__check_constructible_from_opt<_Up>::value &&\n              !__check_assignable_from_opt<_Up>::value;\n      }\n    };\n\n    template <class _Up, class _QualUp>\n    using _CheckOptionalLikeCtor = conditional_t<\n      __lazy_and<\n          __lazy_not<is_same<_Up, _Tp>>,\n          is_constructible<_Tp, _QualUp>\n      >::value,\n      _CheckOptionalLikeConstructor<_QualUp>,\n      __check_tuple_constructor_fail\n    >;\n    template <class _Up, class _QualUp>\n    using _CheckOptionalLikeAssign = conditional_t<\n      __lazy_and<\n          __lazy_not<is_same<_Up, _Tp>>,\n          is_constructible<_Tp, _QualUp>,\n          is_assignable<_Tp&, _QualUp>\n      >::value,\n      _CheckOptionalLikeConstructor<_QualUp>,\n      __check_tuple_constructor_fail\n    >;\npublic:\n\n    _LIBCPP_INLINE_VISIBILITY constexpr optional() noexcept {}\n    _LIBCPP_INLINE_VISIBILITY constexpr optional(const optional&) = default;\n    _LIBCPP_INLINE_VISIBILITY constexpr optional(optional&&) = default;\n    _LIBCPP_INLINE_VISIBILITY constexpr optional(nullopt_t) noexcept {}\n\n    template <class... _Args, class = enable_if_t<\n        is_constructible_v<value_type, _Args...>>\n    >\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr explicit optional(in_place_t, _Args&&... __args)\n        : __base(in_place, _VSTD::forward<_Args>(__args)...) {}\n\n    template <class _Up, class... _Args, class = enable_if_t<\n        is_constructible_v<value_type, initializer_list<_Up>&, _Args...>>\n    >\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr explicit optional(in_place_t, initializer_list<_Up> __il, _Args&&... __args)\n        : __base(in_place, __il, _VSTD::forward<_Args>(__args)...) {}\n\n    template <class _Up = value_type, enable_if_t<\n        _CheckOptionalArgsCtor<_Up>::template __enable_implicit<_Up>()\n    , int> = 0>\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr optional(_Up&& __v)\n        : __base(in_place, _VSTD::forward<_Up>(__v)) {}\n\n    template <class _Up, enable_if_t<\n        _CheckOptionalArgsCtor<_Up>::template __enable_explicit<_Up>()\n    , int> = 0>\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr explicit optional(_Up&& __v)\n        : __base(in_place, _VSTD::forward<_Up>(__v)) {}\n\n    // LWG2756: conditionally explicit conversion from const optional<_Up>&\n    template <class _Up, enable_if_t<\n        _CheckOptionalLikeCtor<_Up, _Up const&>::template __enable_implicit<_Up>()\n    , int> = 0>\n    _LIBCPP_INLINE_VISIBILITY\n    optional(const optional<_Up>& __v)\n    {\n        this->__construct_from(__v);\n    }\n    template <class _Up, enable_if_t<\n        _CheckOptionalLikeCtor<_Up, _Up const&>::template __enable_explicit<_Up>()\n    , int> = 0>\n    _LIBCPP_INLINE_VISIBILITY\n    explicit optional(const optional<_Up>& __v)\n    {\n        this->__construct_from(__v);\n    }\n\n    // LWG2756: conditionally explicit conversion from optional<_Up>&&\n    template <class _Up, enable_if_t<\n        _CheckOptionalLikeCtor<_Up, _Up &&>::template __enable_implicit<_Up>()\n    , int> = 0>\n    _LIBCPP_INLINE_VISIBILITY\n    optional(optional<_Up>&& __v)\n    {\n        this->__construct_from(_VSTD::move(__v));\n    }\n    template <class _Up, enable_if_t<\n        _CheckOptionalLikeCtor<_Up, _Up &&>::template __enable_explicit<_Up>()\n    , int> = 0>\n    _LIBCPP_INLINE_VISIBILITY\n    explicit optional(optional<_Up>&& __v)\n    {\n        this->__construct_from(_VSTD::move(__v));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    optional& operator=(nullopt_t) noexcept\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY optional& operator=(const optional&) = default;\n    _LIBCPP_INLINE_VISIBILITY optional& operator=(optional&&) = default;\n\n    // LWG2756\n    template <class _Up = value_type,\n              class = enable_if_t\n                      <__lazy_and<\n                          integral_constant<bool,\n                              !is_same_v<__uncvref_t<_Up>, optional> &&\n                              !(is_same_v<_Up, value_type> && is_scalar_v<value_type>)\n                          >,\n                          is_constructible<value_type, _Up>,\n                          is_assignable<value_type&, _Up>\n                      >::value>\n             >\n    _LIBCPP_INLINE_VISIBILITY\n    optional&\n    operator=(_Up&& __v)\n    {\n        if (this->has_value())\n            this->__get() = _VSTD::forward<_Up>(__v);\n        else\n            this->__construct(_VSTD::forward<_Up>(__v));\n        return *this;\n    }\n\n    // LWG2756\n    template <class _Up, enable_if_t<\n        _CheckOptionalLikeAssign<_Up, _Up const&>::template __enable_assign<_Up>()\n    , int> = 0>\n    _LIBCPP_INLINE_VISIBILITY\n    optional&\n    operator=(const optional<_Up>& __v)\n    {\n        this->__assign_from(__v);\n        return *this;\n    }\n\n    // LWG2756\n    template <class _Up, enable_if_t<\n        _CheckOptionalLikeCtor<_Up, _Up &&>::template __enable_assign<_Up>()\n    , int> = 0>\n    _LIBCPP_INLINE_VISIBILITY\n    optional&\n    operator=(optional<_Up>&& __v)\n    {\n        this->__assign_from(_VSTD::move(__v));\n        return *this;\n    }\n\n    template <class... _Args,\n              class = enable_if_t\n                      <\n                          is_constructible_v<value_type, _Args...>\n                      >\n             >\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp &\n    emplace(_Args&&... __args)\n    {\n        reset();\n        this->__construct(_VSTD::forward<_Args>(__args)...);\n        return this->__get();\n    }\n\n    template <class _Up, class... _Args,\n              class = enable_if_t\n                      <\n                          is_constructible_v<value_type, initializer_list<_Up>&, _Args...>\n                      >\n             >\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp &\n    emplace(initializer_list<_Up> __il, _Args&&... __args)\n    {\n        reset();\n        this->__construct(__il, _VSTD::forward<_Args>(__args)...);\n        return this->__get();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(optional& __opt)\n        noexcept(is_nothrow_move_constructible_v<value_type> &&\n                 is_nothrow_swappable_v<value_type>)\n    {\n        if (this->has_value() == __opt.has_value())\n        {\n            using _VSTD::swap;\n            if (this->has_value())\n                swap(this->__get(), __opt.__get());\n        }\n        else\n        {\n            if (this->has_value())\n            {\n                __opt.__construct(_VSTD::move(this->__get()));\n                reset();\n            }\n            else\n            {\n                this->__construct(_VSTD::move(__opt.__get()));\n                __opt.reset();\n            }\n        }\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    add_pointer_t<value_type const>\n    operator->() const\n    {\n        _LIBCPP_ASSERT(this->has_value(), \"optional operator-> called for disengaged value\");\n#ifndef _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n        return _VSTD::addressof(this->__get());\n#else\n        return __operator_arrow(__has_operator_addressof<value_type>{}, this->__get());\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    add_pointer_t<value_type>\n    operator->()\n    {\n        _LIBCPP_ASSERT(this->has_value(), \"optional operator-> called for disengaged value\");\n#ifndef _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n        return _VSTD::addressof(this->__get());\n#else\n        return __operator_arrow(__has_operator_addressof<value_type>{}, this->__get());\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    const value_type&\n    operator*() const&\n    {\n        _LIBCPP_ASSERT(this->has_value(), \"optional operator* called for disengaged value\");\n        return this->__get();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    value_type&\n    operator*() &\n    {\n        _LIBCPP_ASSERT(this->has_value(), \"optional operator* called for disengaged value\");\n        return this->__get();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    value_type&&\n    operator*() &&\n    {\n        _LIBCPP_ASSERT(this->has_value(), \"optional operator* called for disengaged value\");\n        return _VSTD::move(this->__get());\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    const value_type&&\n    operator*() const&&\n    {\n        _LIBCPP_ASSERT(this->has_value(), \"optional operator* called for disengaged value\");\n        return _VSTD::move(this->__get());\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr explicit operator bool() const noexcept { return has_value(); }\n\n    using __base::has_value;\n    using __base::__get;\n\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_AVAILABILITY_THROW_BAD_OPTIONAL_ACCESS\n    constexpr value_type const& value() const&\n    {\n        if (!this->has_value())\n            __throw_bad_optional_access();\n        return this->__get();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_AVAILABILITY_THROW_BAD_OPTIONAL_ACCESS\n    constexpr value_type& value() &\n    {\n        if (!this->has_value())\n            __throw_bad_optional_access();\n        return this->__get();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_AVAILABILITY_THROW_BAD_OPTIONAL_ACCESS\n    constexpr value_type&& value() &&\n    {\n        if (!this->has_value())\n            __throw_bad_optional_access();\n        return _VSTD::move(this->__get());\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_AVAILABILITY_THROW_BAD_OPTIONAL_ACCESS\n    constexpr value_type const&& value() const&&\n    {\n        if (!this->has_value())\n            __throw_bad_optional_access();\n        return _VSTD::move(this->__get());\n    }\n\n    template <class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr value_type value_or(_Up&& __v) const&\n    {\n        static_assert(is_copy_constructible_v<value_type>,\n                      \"optional<T>::value_or: T must be copy constructible\");\n        static_assert(is_convertible_v<_Up, value_type>,\n                      \"optional<T>::value_or: U must be convertible to T\");\n        return this->has_value() ? this->__get() :\n                                  static_cast<value_type>(_VSTD::forward<_Up>(__v));\n    }\n\n    template <class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr value_type value_or(_Up&& __v) &&\n    {\n        static_assert(is_move_constructible_v<value_type>,\n                      \"optional<T>::value_or: T must be move constructible\");\n        static_assert(is_convertible_v<_Up, value_type>,\n                      \"optional<T>::value_or: U must be convertible to T\");\n        return this->has_value() ? _VSTD::move(this->__get()) :\n                                  static_cast<value_type>(_VSTD::forward<_Up>(__v));\n    }\n\n    using __base::reset;\n\nprivate:\n    template <class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    static _Up*\n    __operator_arrow(true_type, _Up& __x)\n    {\n        return _VSTD::addressof(__x);\n    }\n\n    template <class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    static constexpr _Up*\n    __operator_arrow(false_type, _Up& __x)\n    {\n        return &__x;\n    }\n};\n\n#ifndef _LIBCPP_HAS_NO_DEDUCTION_GUIDES\ntemplate<class T>\n    optional(T) -> optional<T>;\n#endif\n\n// Comparisons between optionals\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VISIBILITY constexpr\nenable_if_t<\n    is_convertible_v<decltype(_VSTD::declval<const _Tp&>() ==\n        _VSTD::declval<const _Up&>()), bool>,\n    bool\n>\noperator==(const optional<_Tp>& __x, const optional<_Up>& __y)\n{\n    if (static_cast<bool>(__x) != static_cast<bool>(__y))\n        return false;\n    if (!static_cast<bool>(__x))\n        return true;\n    return *__x == *__y;\n}\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VISIBILITY constexpr\nenable_if_t<\n    is_convertible_v<decltype(_VSTD::declval<const _Tp&>() !=\n        _VSTD::declval<const _Up&>()), bool>,\n    bool\n>\noperator!=(const optional<_Tp>& __x, const optional<_Up>& __y)\n{\n    if (static_cast<bool>(__x) != static_cast<bool>(__y))\n        return true;\n    if (!static_cast<bool>(__x))\n        return false;\n    return *__x != *__y;\n}\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VISIBILITY constexpr\nenable_if_t<\n    is_convertible_v<decltype(_VSTD::declval<const _Tp&>() <\n        _VSTD::declval<const _Up&>()), bool>,\n    bool\n>\noperator<(const optional<_Tp>& __x, const optional<_Up>& __y)\n{\n    if (!static_cast<bool>(__y))\n        return false;\n    if (!static_cast<bool>(__x))\n        return true;\n    return *__x < *__y;\n}\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VISIBILITY constexpr\nenable_if_t<\n    is_convertible_v<decltype(_VSTD::declval<const _Tp&>() >\n        _VSTD::declval<const _Up&>()), bool>,\n    bool\n>\noperator>(const optional<_Tp>& __x, const optional<_Up>& __y)\n{\n    if (!static_cast<bool>(__x))\n        return false;\n    if (!static_cast<bool>(__y))\n        return true;\n    return *__x > *__y;\n}\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VISIBILITY constexpr\nenable_if_t<\n    is_convertible_v<decltype(_VSTD::declval<const _Tp&>() <=\n        _VSTD::declval<const _Up&>()), bool>,\n    bool\n>\noperator<=(const optional<_Tp>& __x, const optional<_Up>& __y)\n{\n    if (!static_cast<bool>(__x))\n        return true;\n    if (!static_cast<bool>(__y))\n        return false;\n    return *__x <= *__y;\n}\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VISIBILITY constexpr\nenable_if_t<\n    is_convertible_v<decltype(_VSTD::declval<const _Tp&>() >=\n        _VSTD::declval<const _Up&>()), bool>,\n    bool\n>\noperator>=(const optional<_Tp>& __x, const optional<_Up>& __y)\n{\n    if (!static_cast<bool>(__y))\n        return true;\n    if (!static_cast<bool>(__x))\n        return false;\n    return *__x >= *__y;\n}\n\n// Comparisons with nullopt\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY constexpr\nbool\noperator==(const optional<_Tp>& __x, nullopt_t) noexcept\n{\n    return !static_cast<bool>(__x);\n}\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY constexpr\nbool\noperator==(nullopt_t, const optional<_Tp>& __x) noexcept\n{\n    return !static_cast<bool>(__x);\n}\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY constexpr\nbool\noperator!=(const optional<_Tp>& __x, nullopt_t) noexcept\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY constexpr\nbool\noperator!=(nullopt_t, const optional<_Tp>& __x) noexcept\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY constexpr\nbool\noperator<(const optional<_Tp>&, nullopt_t) noexcept\n{\n    return false;\n}\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY constexpr\nbool\noperator<(nullopt_t, const optional<_Tp>& __x) noexcept\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY constexpr\nbool\noperator<=(const optional<_Tp>& __x, nullopt_t) noexcept\n{\n    return !static_cast<bool>(__x);\n}\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY constexpr\nbool\noperator<=(nullopt_t, const optional<_Tp>&) noexcept\n{\n    return true;\n}\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY constexpr\nbool\noperator>(const optional<_Tp>& __x, nullopt_t) noexcept\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY constexpr\nbool\noperator>(nullopt_t, const optional<_Tp>&) noexcept\n{\n    return false;\n}\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY constexpr\nbool\noperator>=(const optional<_Tp>&, nullopt_t) noexcept\n{\n    return true;\n}\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY constexpr\nbool\noperator>=(nullopt_t, const optional<_Tp>& __x) noexcept\n{\n    return !static_cast<bool>(__x);\n}\n\n// Comparisons with T\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VISIBILITY constexpr\nenable_if_t<\n    is_convertible_v<decltype(_VSTD::declval<const _Tp&>() ==\n        _VSTD::declval<const _Up&>()), bool>,\n    bool\n>\noperator==(const optional<_Tp>& __x, const _Up& __v)\n{\n    return static_cast<bool>(__x) ? *__x == __v : false;\n}\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VISIBILITY constexpr\nenable_if_t<\n    is_convertible_v<decltype(_VSTD::declval<const _Tp&>() ==\n        _VSTD::declval<const _Up&>()), bool>,\n    bool\n>\noperator==(const _Tp& __v, const optional<_Up>& __x)\n{\n    return static_cast<bool>(__x) ? __v == *__x : false;\n}\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VISIBILITY constexpr\nenable_if_t<\n    is_convertible_v<decltype(_VSTD::declval<const _Tp&>() !=\n        _VSTD::declval<const _Up&>()), bool>,\n    bool\n>\noperator!=(const optional<_Tp>& __x, const _Up& __v)\n{\n    return static_cast<bool>(__x) ? *__x != __v : true;\n}\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VISIBILITY constexpr\nenable_if_t<\n    is_convertible_v<decltype(_VSTD::declval<const _Tp&>() !=\n        _VSTD::declval<const _Up&>()), bool>,\n    bool\n>\noperator!=(const _Tp& __v, const optional<_Up>& __x)\n{\n    return static_cast<bool>(__x) ? __v != *__x : true;\n}\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VISIBILITY constexpr\nenable_if_t<\n    is_convertible_v<decltype(_VSTD::declval<const _Tp&>() <\n        _VSTD::declval<const _Up&>()), bool>,\n    bool\n>\noperator<(const optional<_Tp>& __x, const _Up& __v)\n{\n    return static_cast<bool>(__x) ? *__x < __v : true;\n}\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VISIBILITY constexpr\nenable_if_t<\n    is_convertible_v<decltype(_VSTD::declval<const _Tp&>() <\n        _VSTD::declval<const _Up&>()), bool>,\n    bool\n>\noperator<(const _Tp& __v, const optional<_Up>& __x)\n{\n    return static_cast<bool>(__x) ? __v < *__x : false;\n}\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VISIBILITY constexpr\nenable_if_t<\n    is_convertible_v<decltype(_VSTD::declval<const _Tp&>() <=\n        _VSTD::declval<const _Up&>()), bool>,\n    bool\n>\noperator<=(const optional<_Tp>& __x, const _Up& __v)\n{\n    return static_cast<bool>(__x) ? *__x <= __v : true;\n}\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VISIBILITY constexpr\nenable_if_t<\n    is_convertible_v<decltype(_VSTD::declval<const _Tp&>() <=\n        _VSTD::declval<const _Up&>()), bool>,\n    bool\n>\noperator<=(const _Tp& __v, const optional<_Up>& __x)\n{\n    return static_cast<bool>(__x) ? __v <= *__x : false;\n}\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VISIBILITY constexpr\nenable_if_t<\n    is_convertible_v<decltype(_VSTD::declval<const _Tp&>() >\n        _VSTD::declval<const _Up&>()), bool>,\n    bool\n>\noperator>(const optional<_Tp>& __x, const _Up& __v)\n{\n    return static_cast<bool>(__x) ? *__x > __v : false;\n}\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VISIBILITY constexpr\nenable_if_t<\n    is_convertible_v<decltype(_VSTD::declval<const _Tp&>() >\n        _VSTD::declval<const _Up&>()), bool>,\n    bool\n>\noperator>(const _Tp& __v, const optional<_Up>& __x)\n{\n    return static_cast<bool>(__x) ? __v > *__x : true;\n}\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VISIBILITY constexpr\nenable_if_t<\n    is_convertible_v<decltype(_VSTD::declval<const _Tp&>() >=\n        _VSTD::declval<const _Up&>()), bool>,\n    bool\n>\noperator>=(const optional<_Tp>& __x, const _Up& __v)\n{\n    return static_cast<bool>(__x) ? *__x >= __v : false;\n}\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VISIBILITY constexpr\nenable_if_t<\n    is_convertible_v<decltype(_VSTD::declval<const _Tp&>() >=\n        _VSTD::declval<const _Up&>()), bool>,\n    bool\n>\noperator>=(const _Tp& __v, const optional<_Up>& __x)\n{\n    return static_cast<bool>(__x) ? __v >= *__x : true;\n}\n\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nenable_if_t<\n    is_move_constructible_v<_Tp> && is_swappable_v<_Tp>,\n    void\n>\nswap(optional<_Tp>& __x, optional<_Tp>& __y) noexcept(noexcept(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY constexpr\noptional<decay_t<_Tp>> make_optional(_Tp&& __v)\n{\n    return optional<decay_t<_Tp>>(_VSTD::forward<_Tp>(__v));\n}\n\ntemplate <class _Tp, class... _Args>\n_LIBCPP_INLINE_VISIBILITY constexpr\noptional<_Tp> make_optional(_Args&&... __args)\n{\n    return optional<_Tp>(in_place, _VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class _Up, class... _Args>\n_LIBCPP_INLINE_VISIBILITY constexpr\noptional<_Tp> make_optional(initializer_list<_Up> __il,  _Args&&... __args)\n{\n    return optional<_Tp>(in_place, __il, _VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash<\n    __enable_hash_helper<optional<_Tp>, remove_const_t<_Tp>>\n>\n{\n    typedef optional<_Tp> argument_type;\n    typedef size_t        result_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __opt) const\n    {\n        return static_cast<bool>(__opt) ? hash<remove_const_t<_Tp>>()(*__opt) : 0;\n    }\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STD_VER > 14\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_OPTIONAL\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2020.\n *\n *  @file optional.hpp\n *  @brief Audited implementation of std::optional.\n *  @note Status: RELEASE\n *\n *  Drop-in replacements for std::optional.\n *  In debug mode, operator * and operator-> value accesses are checked for undefined behavior.\n */\n\n#ifndef EMP_BASE_OPTIONAL_HPP_INCLUDE\n#define EMP_BASE_OPTIONAL_HPP_INCLUDE\n\n#include <optional>\n#include <type_traits>\n#include <utility>\n\n#include \"assert.hpp\"\n\n#ifdef EMP_NDEBUG\n\nnamespace emp {\n  template <typename T> using optional = std::optional<T>;\n\n  template <class T>\n  inline auto make_optional(T&& val) {\n    return std::make_optional<T>(std::forward<T>(val));\n  }\n\n  template <class T, class... Args>\n  inline auto make_optional(Args&&... args) {\n    return std::make_optional<T>(std::forward<Args>(args)... );\n  }\n\n}\n\n#else // #EMP_NDEBUG *not* set\n\nnamespace emp {\n\n  template<class T>\n  class optional : public std::optional<T> {\n\n    using parent_t = std::optional<T>;\n\n  public:\n\n    // inherit parent's constructors\n    // adapted from https://stackoverflow.com/a/434784\n    using parent_t::parent_t;\n\n    constexpr const T* operator->() const { return &parent_t::value(); }\n\n    constexpr T* operator->() { return &parent_t::value(); }\n\n    constexpr const T& operator*() const& { return parent_t::value(); }\n\n    constexpr T& operator*() & { return parent_t::value(); }\n\n    constexpr T&& operator*() && { return std::move( parent_t::value() ); }\n\n    constexpr const T&& operator*() const&& {\n      return std::move( parent_t::value() );\n    }\n\n  };\n\n  template <class T>\n  constexpr emp::optional<std::decay_t<T>>\n  make_optional(T&& value) {\n    return emp::optional<std::decay_t<T>>{\n      std::forward<T>(value)\n    };\n  }\n\n  template <class T, class... Args>\n  constexpr emp::optional<T>\n  make_optional(Args&&... args) {\n    return emp::optional<T>{\n      std::in_place,\n      std::forward<Args>(args)...\n    };\n  }\n\n  template <class T, class Elem, class... Args>\n  constexpr emp::optional<T> make_optional(\n    std::initializer_list<Elem> il,\n    Args&&... args\n  ) {\n    return emp::optional<T>{\n      std::in_place,\n      il,\n      std::forward<Args>(args)...\n    };\n  }\n\n} // namespace emp\n\nnamespace std {\n\n  template <typename T>\n  struct hash<emp::optional<T>> {\n    size_t operator()( const emp::optional<T>& opt ) const {\n      return std::hash<std::optional<T>>{}( opt );\n    }\n  };\n\n} // namespace std\n\n#endif\n\n#endif // #ifndef EMP_BASE_OPTIONAL_HPP_INCLUDE\n","// -*- C++ -*-\n//===--------------------------- tuple ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TUPLE\n#define _LIBCPP_TUPLE\n\n/*\n    tuple synopsis\n\nnamespace std\n{\n\ntemplate <class... T>\nclass tuple {\npublic:\n    constexpr tuple();\n    explicit tuple(const T&...);  // constexpr in C++14\n    template <class... U>\n        explicit tuple(U&&...);  // constexpr in C++14\n    tuple(const tuple&) = default;\n    tuple(tuple&&) = default;\n    template <class... U>\n        tuple(const tuple<U...>&);  // constexpr in C++14\n    template <class... U>\n        tuple(tuple<U...>&&);  // constexpr in C++14\n    template <class U1, class U2>\n        tuple(const pair<U1, U2>&); // iff sizeof...(T) == 2 // constexpr in C++14\n    template <class U1, class U2>\n        tuple(pair<U1, U2>&&); // iff sizeof...(T) == 2  // constexpr in C++14\n\n    // allocator-extended constructors\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, const T&...);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, U&&...);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, const tuple&);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, tuple&&);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, const tuple<U...>&);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, tuple<U...>&&);\n    template <class Alloc, class U1, class U2>\n        tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);\n    template <class Alloc, class U1, class U2>\n        tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);\n\n    tuple& operator=(const tuple&);\n    tuple&\n        operator=(tuple&&) noexcept(AND(is_nothrow_move_assignable<T>::value ...));\n    template <class... U>\n        tuple& operator=(const tuple<U...>&);\n    template <class... U>\n        tuple& operator=(tuple<U...>&&);\n    template <class U1, class U2>\n        tuple& operator=(const pair<U1, U2>&); // iff sizeof...(T) == 2\n    template <class U1, class U2>\n        tuple& operator=(pair<U1, U2>&&); // iff sizeof...(T) == 2\n\n    void swap(tuple&) noexcept(AND(swap(declval<T&>(), declval<T&>())...));\n};\n\ninline constexpr unspecified ignore;\n\ntemplate <class... T> tuple<V...>  make_tuple(T&&...); // constexpr in C++14\ntemplate <class... T> tuple<ATypes...> forward_as_tuple(T&&...) noexcept; // constexpr in C++14\ntemplate <class... T> tuple<T&...> tie(T&...) noexcept; // constexpr in C++14\ntemplate <class... Tuples> tuple<CTypes...> tuple_cat(Tuples&&... tpls); // constexpr in C++14\n\n// [tuple.apply], calling a function with a tuple of arguments:\ntemplate <class F, class Tuple>\n  constexpr decltype(auto) apply(F&& f, Tuple&& t); // C++17\ntemplate <class T, class Tuple>\n  constexpr T make_from_tuple(Tuple&& t); // C++17\n\n// 20.4.1.4, tuple helper classes:\ntemplate <class T> struct tuple_size; // undefined\ntemplate <class... T> struct tuple_size<tuple<T...>>;\ntemplate <class T>\n inline constexpr size_t tuple_size_v = tuple_size<T>::value; // C++17\ntemplate <size_t I, class T> class tuple_element; // undefined\ntemplate <size_t I, class... T> class tuple_element<I, tuple<T...>>;\ntemplate <size_t I, class T>\n  using tuple_element_t = typename tuple_element <I, T>::type; // C++14\n\n// 20.4.1.5, element access:\ntemplate <size_t I, class... T>\n    typename tuple_element<I, tuple<T...>>::type&\n    get(tuple<T...>&) noexcept; // constexpr in C++14\ntemplate <size_t I, class... T>\n    const typename tuple_element<I, tuple<T...>>::type&\n    get(const tuple<T...>&) noexcept; // constexpr in C++14\ntemplate <size_t I, class... T>\n    typename tuple_element<I, tuple<T...>>::type&&\n    get(tuple<T...>&&) noexcept; // constexpr in C++14\ntemplate <size_t I, class... T>\n    const typename tuple_element<I, tuple<T...>>::type&&\n    get(const tuple<T...>&&) noexcept; // constexpr in C++14\n\ntemplate <class T1, class... T>\n    constexpr T1& get(tuple<T...>&) noexcept;  // C++14\ntemplate <class T1, class... T>\n    constexpr const T1& get(const tuple<T...>&) noexcept;   // C++14\ntemplate <class T1, class... T>\n    constexpr T1&& get(tuple<T...>&&) noexcept;   // C++14\ntemplate <class T1, class... T>\n    constexpr const T1&& get(const tuple<T...>&&) noexcept;   // C++14\n\n// 20.4.1.6, relational operators:\ntemplate<class... T, class... U> bool operator==(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator<(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14\ntemplate<class... T, class... U> bool operator!=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator>(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14\ntemplate<class... T, class... U> bool operator<=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator>=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\n\ntemplate <class... Types, class Alloc>\n  struct uses_allocator<tuple<Types...>, Alloc>;\n\ntemplate <class... Types>\n  void\n  swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <cstddef>\n#include <type_traits>\n#include <__functional_base>\n#include <utility>\n#include <version>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#ifndef _LIBCPP_CXX03_LANG\n\n\n// __tuple_leaf\n\ntemplate <size_t _Ip, class _Hp,\n          bool=is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value\n         >\nclass __tuple_leaf;\n\ntemplate <size_t _Ip, class _Hp, bool _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)\n    _NOEXCEPT_(__is_nothrow_swappable<_Hp>::value)\n{\n    swap(__x.get(), __y.get());\n}\n\ntemplate <size_t _Ip, class _Hp, bool>\nclass __tuple_leaf\n{\n    _Hp __value_;\n\n    template <class _Tp>\n    static constexpr bool __can_bind_reference() {\n#if __has_keyword(__reference_binds_to_temporary)\n      return !__reference_binds_to_temporary(_Hp, _Tp);\n#else\n      return true;\n#endif\n    }\n\n    __tuple_leaf& operator=(const __tuple_leaf&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()\n             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) : __value_()\n       {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)\n            : __value_()\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)\n            : __value_(allocator_arg_t(), __a)\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)\n            : __value_(__a)\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Tp,\n              class = typename enable_if<\n                  __lazy_and<\n                      __lazy_not<is_same<typename __uncvref<_Tp>::type, __tuple_leaf>>\n                    , is_constructible<_Hp, _Tp>\n                    >::value\n                >::type\n            >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))\n            : __value_(_VSTD::forward<_Tp>(__t))\n        {static_assert(__can_bind_reference<_Tp&&>(),\n       \"Attempted construction of reference element binds to a temporary whose lifetime has ended\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)\n            : __value_(_VSTD::forward<_Tp>(__t))\n        {static_assert(__can_bind_reference<_Tp&&>(),\n       \"Attempted construction of reference element binds to a temporary whose lifetime has ended\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)\n            : __value_(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t))\n        {static_assert(!is_reference<_Hp>::value,\n            \"Attempted to uses-allocator construct a reference element in a tuple\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)\n            : __value_(_VSTD::forward<_Tp>(__t), __a)\n        {static_assert(!is_reference<_Hp>::value,\n           \"Attempted to uses-allocator construct a reference element in a tuple\");}\n\n    __tuple_leaf(const __tuple_leaf& __t) = default;\n    __tuple_leaf(__tuple_leaf&& __t) = default;\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf&\n        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))\n        {\n            __value_ = _VSTD::forward<_Tp>(__t);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)\n    {\n        _VSTD::swap(*this, __t);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return __value_;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return __value_;}\n};\n\ntemplate <size_t _Ip, class _Hp>\nclass __tuple_leaf<_Ip, _Hp, true>\n    : private _Hp\n{\n\n    __tuple_leaf& operator=(const __tuple_leaf&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()\n             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)\n            : _Hp(allocator_arg_t(), __a) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)\n            : _Hp(__a) {}\n\n    template <class _Tp,\n              class = typename enable_if<\n                  __lazy_and<\n                        __lazy_not<is_same<typename __uncvref<_Tp>::type, __tuple_leaf>>\n                      , is_constructible<_Hp, _Tp>\n                    >::value\n                >::type\n            >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))\n            : _Hp(_VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)\n            : _Hp(_VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)\n            : _Hp(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)\n            : _Hp(_VSTD::forward<_Tp>(__t), __a) {}\n\n    __tuple_leaf(__tuple_leaf const &) = default;\n    __tuple_leaf(__tuple_leaf &&) = default;\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf&\n        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))\n        {\n            _Hp::operator=(_VSTD::forward<_Tp>(__t));\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int\n    swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)\n    {\n        _VSTD::swap(*this, __t);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return static_cast<_Hp&>(*this);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return static_cast<const _Hp&>(*this);}\n};\n\ntemplate <class ..._Tp>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swallow(_Tp&&...) _NOEXCEPT {}\n\ntemplate <class ..._Tp>\nstruct __lazy_all : __all<_Tp::value...> {};\n\ntemplate <class _Tp>\nstruct __all_default_constructible;\n\ntemplate <class ..._Tp>\nstruct __all_default_constructible<__tuple_types<_Tp...>>\n    : __all<is_default_constructible<_Tp>::value...>\n{ };\n\n// __tuple_impl\n\ntemplate<class _Indx, class ..._Tp> struct __tuple_impl;\n\ntemplate<size_t ..._Indx, class ..._Tp>\nstruct _LIBCPP_DECLSPEC_EMPTY_BASES __tuple_impl<__tuple_indices<_Indx...>, _Tp...>\n    : public __tuple_leaf<_Indx, _Tp>...\n{\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR __tuple_impl()\n        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}\n\n    template <size_t ..._Uf, class ..._Tf,\n              size_t ..._Ul, class ..._Tl, class ..._Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,\n                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,\n                     _Up&&... __u)\n                     _NOEXCEPT_((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value &&\n                                 __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :\n            __tuple_leaf<_Uf, _Tf>(_VSTD::forward<_Up>(__u))...,\n            __tuple_leaf<_Ul, _Tl>()...\n            {}\n\n    template <class _Alloc, size_t ..._Uf, class ..._Tf,\n              size_t ..._Ul, class ..._Tl, class ..._Up>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        __tuple_impl(allocator_arg_t, const _Alloc& __a,\n                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,\n                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,\n                     _Up&&... __u) :\n            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,\n            _VSTD::forward<_Up>(__u))...,\n            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...\n            {}\n\n    template <class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        __tuple_impl(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))\n            : __tuple_leaf<_Indx, _Tp>(_VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...\n            {}\n\n    template <class _Alloc, class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,\n                                       _VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...\n            {}\n\n    template <class _Tuple>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            __tuple_assignable<_Tuple, tuple<_Tp...> >::value,\n            __tuple_impl&\n        >::type\n        operator=(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_assignable<_Tp&, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))\n        {\n            __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...);\n            return *this;\n        }\n\n    __tuple_impl(const __tuple_impl&) = default;\n    __tuple_impl(__tuple_impl&&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tuple_impl&\n    operator=(const __tuple_impl& __t) _NOEXCEPT_((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t).get())...);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tuple_impl&\n    operator=(__tuple_impl&& __t) _NOEXCEPT_((__all<is_nothrow_move_assignable<_Tp>::value...>::value))\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<_Tp>(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t).get()))...);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(__tuple_impl& __t)\n        _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);\n    }\n};\n\n\n\ntemplate <class ..._Tp>\nclass _LIBCPP_TEMPLATE_VIS tuple\n{\n    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> _BaseT;\n\n    _BaseT __base_;\n\n#if defined(_LIBCPP_ENABLE_TUPLE_IMPLICIT_REDUCED_ARITY_EXTENSION)\n    static constexpr bool _EnableImplicitReducedArityExtension = true;\n#else\n    static constexpr bool _EnableImplicitReducedArityExtension = false;\n#endif\n\n    template <class ..._Args>\n    struct _PackExpandsToThisTuple : false_type {};\n\n    template <class _Arg>\n    struct _PackExpandsToThisTuple<_Arg>\n        : is_same<typename __uncvref<_Arg>::type, tuple> {};\n\n    template <bool _MaybeEnable, class _Dummy = void>\n    struct _CheckArgsConstructor : __check_tuple_constructor_fail {};\n\n    template <class _Dummy>\n    struct _CheckArgsConstructor<true, _Dummy>\n    {\n        template <class ..._Args>\n        static constexpr bool __enable_default() {\n            return __all<is_default_constructible<_Args>::value...>::value;\n        }\n\n        template <class ..._Args>\n        static constexpr bool __enable_explicit() {\n            return\n                __tuple_constructible<\n                    tuple<_Args...>,\n                    typename __make_tuple_types<tuple,\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value &&\n                !__tuple_convertible<\n                    tuple<_Args...>,\n                    typename __make_tuple_types<tuple,\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value &&\n                __all_default_constructible<\n                    typename __make_tuple_types<tuple, sizeof...(_Tp),\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value;\n        }\n\n        template <class ..._Args>\n        static constexpr bool __enable_implicit() {\n            return\n                __tuple_convertible<\n                    tuple<_Args...>,\n                    typename __make_tuple_types<tuple,\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value &&\n                __all_default_constructible<\n                    typename __make_tuple_types<tuple, sizeof...(_Tp),\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value;\n        }\n    };\n\n    template <bool _MaybeEnable,\n              bool = sizeof...(_Tp) == 1,\n              class _Dummy = void>\n    struct _CheckTupleLikeConstructor : __check_tuple_constructor_fail {};\n\n    template <class _Dummy>\n    struct _CheckTupleLikeConstructor<true, false, _Dummy>\n    {\n        template <class _Tuple>\n        static constexpr bool __enable_implicit() {\n            return __tuple_convertible<_Tuple, tuple>::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_explicit() {\n            return __tuple_constructible<_Tuple, tuple>::value\n               && !__tuple_convertible<_Tuple, tuple>::value;\n        }\n    };\n\n    template <class _Dummy>\n    struct _CheckTupleLikeConstructor<true, true, _Dummy>\n    {\n        // This trait is used to disable the tuple-like constructor when\n        // the UTypes... constructor should be selected instead.\n        // See LWG issue #2549.\n        template <class _Tuple>\n        using _PreferTupleLikeConstructor = __lazy_or<\n            // Don't attempt the two checks below if the tuple we are given\n            // has the same type as this tuple.\n            is_same<typename __uncvref<_Tuple>::type, tuple>,\n            __lazy_and<\n                __lazy_not<is_constructible<_Tp..., _Tuple>>,\n                __lazy_not<is_convertible<_Tuple, _Tp...>>\n            >\n        >;\n\n        template <class _Tuple>\n        static constexpr bool __enable_implicit() {\n            return __lazy_and<\n                __tuple_convertible<_Tuple, tuple>,\n                _PreferTupleLikeConstructor<_Tuple>\n            >::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_explicit() {\n            return __lazy_and<\n                __tuple_constructible<_Tuple, tuple>,\n                _PreferTupleLikeConstructor<_Tuple>,\n                __lazy_not<__tuple_convertible<_Tuple, tuple>>\n            >::value;\n        }\n    };\n\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        const typename tuple_element<_Jp, tuple<_Up...> >::type&& get(const tuple<_Up...>&&) _NOEXCEPT;\npublic:\n\n    template <bool _Dummy = true, class = typename enable_if<\n        _CheckArgsConstructor<_Dummy>::template __enable_default<_Tp...>()\n    >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR tuple()\n        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}\n\n    tuple(tuple const&) = default;\n    tuple(tuple&&) = default;\n\n    template <class _AllocArgT, class _Alloc, bool _Dummy = true, class = typename enable_if<\n        __lazy_and<\n            is_same<allocator_arg_t, _AllocArgT>,\n            __lazy_all<__dependent_type<is_default_constructible<_Tp>, _Dummy>...>\n       >::value\n    >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    tuple(_AllocArgT, _Alloc const& __a)\n      : __base_(allocator_arg_t(), __a,\n                    __tuple_indices<>(), __tuple_types<>(),\n                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),\n                    __tuple_types<_Tp...>()) {}\n\n    template <bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_implicit<_Tp const&...>(),\n                         bool\n                      >::type = false\n        >\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    tuple(const _Tp& ... __t) _NOEXCEPT_((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))\n        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_explicit<_Tp const&...>(),\n                         bool\n                      >::type = false\n        >\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit tuple(const _Tp& ... __t) _NOEXCEPT_((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))\n        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class _Alloc, bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_implicit<_Tp const&...>(),\n                         bool\n                      >::type = false\n        >\n      _LIBCPP_INLINE_VISIBILITY\n      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)\n        : __base_(allocator_arg_t(), __a,\n                typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class _Alloc, bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_explicit<_Tp const&...>(),\n                         bool\n                      >::type = false\n        >\n      _LIBCPP_INLINE_VISIBILITY\n      explicit\n      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)\n        : __base_(allocator_arg_t(), __a,\n                typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class ..._Up,\n              bool _PackIsTuple = _PackExpandsToThisTuple<_Up...>::value,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) == sizeof...(_Tp)\n                             && !_PackIsTuple\n                         >::template __enable_implicit<_Up...>() ||\n                        _CheckArgsConstructor<\n                            _EnableImplicitReducedArityExtension\n                            && sizeof...(_Up) < sizeof...(_Tp)\n                            && !_PackIsTuple\n                         >::template __enable_implicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        tuple(_Up&&... __u)\n            _NOEXCEPT_((\n                is_nothrow_constructible<_BaseT,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,\n                    _Up...\n                >::value\n            ))\n            : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) <= sizeof...(_Tp)\n                             && !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_explicit<_Up...>() ||\n                         _CheckArgsConstructor<\n                            !_EnableImplicitReducedArityExtension\n                            && sizeof...(_Up) < sizeof...(_Tp)\n                            && !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_implicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        tuple(_Up&&... __u)\n            _NOEXCEPT_((\n                is_nothrow_constructible<_BaseT,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,\n                    _Up...\n                >::value\n            ))\n            : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Alloc, class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) == sizeof...(_Tp) &&\n                             !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_implicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)\n            : __base_(allocator_arg_t(), __a,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Alloc, class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) == sizeof...(_Tp) &&\n                             !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_explicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)\n            : __base_(allocator_arg_t(), __a,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                             && !_PackExpandsToThisTuple<_Tuple>::value\n                         >::template __enable_implicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<_BaseT, _Tuple>::value))\n            : __base_(_VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                             && !_PackExpandsToThisTuple<_Tuple>::value\n                         >::template __enable_explicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<_BaseT, _Tuple>::value))\n            : __base_(_VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Alloc, class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                         >::template __enable_implicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : __base_(allocator_arg_t(), __a, _VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Alloc, class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                         >::template __enable_explicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : __base_(allocator_arg_t(), __a, _VSTD::forward<_Tuple>(__t)) {}\n\n    using _CanCopyAssign = __all<is_copy_assignable<_Tp>::value...>;\n    using _CanMoveAssign = __all<is_move_assignable<_Tp>::value...>;\n\n    _LIBCPP_INLINE_VISIBILITY\n    tuple& operator=(typename conditional<_CanCopyAssign::value, tuple, __nat>::type const& __t)\n        _NOEXCEPT_((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))\n    {\n        __base_.operator=(__t.__base_);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    tuple& operator=(typename conditional<_CanMoveAssign::value, tuple, __nat>::type&& __t)\n        _NOEXCEPT_((__all<is_nothrow_move_assignable<_Tp>::value...>::value))\n    {\n        __base_.operator=(static_cast<_BaseT&&>(__t.__base_));\n        return *this;\n    }\n\n    template <class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_assignable<_Tuple, tuple>::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple&\n        operator=(_Tuple&& __t) _NOEXCEPT_((is_nothrow_assignable<_BaseT&, _Tuple>::value))\n        {\n            __base_.operator=(_VSTD::forward<_Tuple>(__t));\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(tuple& __t) _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n        {__base_.swap(__t.__base_);}\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS tuple<>\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR tuple() _NOEXCEPT {}\n    template <class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT {}\n    template <class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT {}\n    template <class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(array<_Up, 0>) _NOEXCEPT {}\n    template <class _Alloc, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(tuple&) _NOEXCEPT {}\n};\n\n#ifndef _LIBCPP_HAS_NO_DEDUCTION_GUIDES\n// NOTE: These are not yet standardized, but are required to simulate the\n// implicit deduction guide that should be generated had libc++ declared the\n// tuple-like constructors \"correctly\"\ntemplate <class _Alloc, class ..._Args>\ntuple(allocator_arg_t, const _Alloc&, tuple<_Args...> const&) -> tuple<_Args...>;\ntemplate <class _Alloc, class ..._Args>\ntuple(allocator_arg_t, const _Alloc&, tuple<_Args...>&&) -> tuple<_Args...>;\n#endif\n\ntemplate <class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __all<__is_swappable<_Tp>::value...>::value,\n    void\n>::type\nswap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)\n                 _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n    {__t.swap(__u);}\n\n// get\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(tuple<_Tp...>& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<__tuple_leaf<_Ip, type>&>(__t.__base_).get();\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(const tuple<_Tp...>& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.__base_).get();\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&&\nget(tuple<_Tp...>&& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<type&&>(\n             static_cast<__tuple_leaf<_Ip, type>&&>(__t.__base_).get());\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&&\nget(const tuple<_Tp...>&& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<const type&&>(\n             static_cast<const __tuple_leaf<_Ip, type>&&>(__t.__base_).get());\n}\n\n#if _LIBCPP_STD_VER > 11\n\nnamespace __find_detail {\n\nstatic constexpr size_t __not_found = -1;\nstatic constexpr size_t __ambiguous = __not_found - 1;\n\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr size_t __find_idx_return(size_t __curr_i, size_t __res, bool __matches) {\n    return !__matches ? __res :\n        (__res == __not_found ? __curr_i : __ambiguous);\n}\n\ntemplate <size_t _Nx>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr size_t __find_idx(size_t __i, const bool (&__matches)[_Nx]) {\n  return __i == _Nx ? __not_found :\n      __find_idx_return(__i, __find_idx(__i + 1, __matches), __matches[__i]);\n}\n\ntemplate <class _T1, class ..._Args>\nstruct __find_exactly_one_checked {\n    static constexpr bool __matches[sizeof...(_Args)] = {is_same<_T1, _Args>::value...};\n    static constexpr size_t value = __find_detail::__find_idx(0, __matches);\n    static_assert(value != __not_found, \"type not found in type list\" );\n    static_assert(value != __ambiguous, \"type occurs more than once in type list\");\n};\n\ntemplate <class _T1>\nstruct __find_exactly_one_checked<_T1> {\n    static_assert(!is_same<_T1, _T1>::value, \"type not in empty type list\");\n};\n\n} // namespace __find_detail;\n\ntemplate <typename _T1, typename... _Args>\nstruct __find_exactly_one_t\n    : public __find_detail::__find_exactly_one_checked<_T1, _Args...> {\n};\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1& get(tuple<_Args...>& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1&& get(tuple<_Args...>&& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));\n}\n\n#endif\n\n// tie\n\ntemplate <class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<_Tp&...>\ntie(_Tp&... __t) _NOEXCEPT\n{\n    return tuple<_Tp&...>(__t...);\n}\n\ntemplate <class _Up>\nstruct __ignore_t\n{\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const __ignore_t& operator=(_Tp&&) const {return *this;}\n};\n\nnamespace {\n  _LIBCPP_INLINE_VAR constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();\n}\n\ntemplate <class... _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<typename __unwrap_ref_decay<_Tp>::type...>\nmake_tuple(_Tp&&... __t)\n{\n    return tuple<typename __unwrap_ref_decay<_Tp>::type...>(_VSTD::forward<_Tp>(__t)...);\n}\n\ntemplate <class... _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<_Tp&&...>\nforward_as_tuple(_Tp&&... __t) _NOEXCEPT\n{\n    return tuple<_Tp&&...>(_VSTD::forward<_Tp>(__t)...);\n}\n\ntemplate <size_t _Ip>\nstruct __tuple_equal\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        return __tuple_equal<_Ip - 1>()(__x, __y) && _VSTD::get<_Ip-1>(__x) == _VSTD::get<_Ip-1>(__y);\n    }\n};\n\ntemplate <>\nstruct __tuple_equal<0>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp&, const _Up&)\n    {\n        return true;\n    }\n};\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <size_t _Ip>\nstruct __tuple_less\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        const size_t __idx = tuple_size<_Tp>::value - _Ip;\n        if (_VSTD::get<__idx>(__x) < _VSTD::get<__idx>(__y))\n            return true;\n        if (_VSTD::get<__idx>(__y) < _VSTD::get<__idx>(__x))\n            return false;\n        return __tuple_less<_Ip-1>()(__x, __y);\n    }\n};\n\ntemplate <>\nstruct __tuple_less<0>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp&, const _Up&)\n    {\n        return false;\n    }\n};\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __tuple_less<sizeof...(_Tp)>()(__x, __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__y < __x);\n}\n\n// tuple_cat\n\ntemplate <class _Tp, class _Up> struct __tuple_cat_type;\n\ntemplate <class ..._Ttypes, class ..._Utypes>\nstruct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >\n{\n    typedef tuple<_Ttypes..., _Utypes...> type;\n};\n\ntemplate <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>\nstruct __tuple_cat_return_1\n{\n};\n\ntemplate <class ..._Types, class _Tuple0>\nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>\n{\n    typedef typename __tuple_cat_type<tuple<_Types...>,\n            typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type>::type\n                                                                           type;\n};\n\ntemplate <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>\nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>\n    : public __tuple_cat_return_1<\n                 typename __tuple_cat_type<\n                     tuple<_Types...>,\n                     typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type\n                 >::type,\n                 __tuple_like<typename remove_reference<_Tuple1>::type>::value,\n                 _Tuple1, _Tuples...>\n{\n};\n\ntemplate <class ..._Tuples> struct __tuple_cat_return;\n\ntemplate <class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return<_Tuple0, _Tuples...>\n    : public __tuple_cat_return_1<tuple<>,\n         __tuple_like<typename remove_reference<_Tuple0>::type>::value, _Tuple0,\n                                                                     _Tuples...>\n{\n};\n\ntemplate <>\nstruct __tuple_cat_return<>\n{\n    typedef tuple<> type;\n};\n\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<>\ntuple_cat()\n{\n    return tuple<>();\n}\n\ntemplate <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return_ref_imp;\n\ntemplate <class ..._Types, size_t ..._I0, class _Tuple0>\nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>\n{\n    typedef typename remove_reference<_Tuple0>::type _T0;\n    typedef tuple<_Types..., typename __apply_cv<_Tuple0,\n                          typename tuple_element<_I0, _T0>::type>::type&&...> type;\n};\n\ntemplate <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>\nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,\n                                  _Tuple0, _Tuple1, _Tuples...>\n    : public __tuple_cat_return_ref_imp<\n         tuple<_Types..., typename __apply_cv<_Tuple0,\n               typename tuple_element<_I0,\n                  typename remove_reference<_Tuple0>::type>::type>::type&&...>,\n         typename __make_tuple_indices<tuple_size<typename\n                                 remove_reference<_Tuple1>::type>::value>::type,\n         _Tuple1, _Tuples...>\n{\n};\n\ntemplate <class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return_ref\n    : public __tuple_cat_return_ref_imp<tuple<>,\n               typename __make_tuple_indices<\n                        tuple_size<typename remove_reference<_Tuple0>::type>::value\n               >::type, _Tuple0, _Tuples...>\n{\n};\n\ntemplate <class _Types, class _I0, class _J0>\nstruct __tuple_cat;\n\ntemplate <class ..._Types, size_t ..._I0, size_t ..._J0>\nstruct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >\n{\n    template <class _Tuple0>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type\n    operator()(tuple<_Types...> __t, _Tuple0&& __t0)\n    {\n        return forward_as_tuple(_VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,\n                                      _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...);\n    }\n\n    template <class _Tuple0, class _Tuple1, class ..._Tuples>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type\n    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)\n    {\n        typedef typename remove_reference<_Tuple0>::type _T0;\n        typedef typename remove_reference<_Tuple1>::type _T1;\n        return __tuple_cat<\n           tuple<_Types..., typename __apply_cv<_Tuple0, typename tuple_element<_J0, _T0>::type>::type&&...>,\n           typename __make_tuple_indices<sizeof ...(_Types) + tuple_size<_T0>::value>::type,\n           typename __make_tuple_indices<tuple_size<_T1>::value>::type>()\n                           (forward_as_tuple(\n                              _VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,\n                              _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...\n                            ),\n                            _VSTD::forward<_Tuple1>(__t1),\n                            _VSTD::forward<_Tuples>(__tpls)...);\n    }\n};\n\ntemplate <class _Tuple0, class... _Tuples>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename __tuple_cat_return<_Tuple0, _Tuples...>::type\ntuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)\n{\n    typedef typename remove_reference<_Tuple0>::type _T0;\n    return __tuple_cat<tuple<>, __tuple_indices<>,\n                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()\n                  (tuple<>(), _VSTD::forward<_Tuple0>(__t0),\n                                            _VSTD::forward<_Tuples>(__tpls)...);\n}\n\ntemplate <class ..._Tp, class _Alloc>\nstruct _LIBCPP_TEMPLATE_VIS uses_allocator<tuple<_Tp...>, _Alloc>\n    : true_type {};\n\ntemplate <class _T1, class _T2>\ntemplate <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1, _T2>::pair(piecewise_construct_t,\n                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)\n    :  first(_VSTD::forward<_Args1>(_VSTD::get<_I1>( __first_args))...),\n      second(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n{\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR constexpr size_t tuple_size_v = tuple_size<_Tp>::value;\n\n#define _LIBCPP_NOEXCEPT_RETURN(...) noexcept(noexcept(__VA_ARGS__)) { return __VA_ARGS__; }\n\ntemplate <class _Fn, class _Tuple, size_t ..._Id>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr decltype(auto) __apply_tuple_impl(_Fn && __f, _Tuple && __t,\n                                            __tuple_indices<_Id...>)\n_LIBCPP_NOEXCEPT_RETURN(\n    _VSTD::__invoke_constexpr(\n        _VSTD::forward<_Fn>(__f),\n        _VSTD::get<_Id>(_VSTD::forward<_Tuple>(__t))...)\n)\n\ntemplate <class _Fn, class _Tuple>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr decltype(auto) apply(_Fn && __f, _Tuple && __t)\n_LIBCPP_NOEXCEPT_RETURN(\n    _VSTD::__apply_tuple_impl(\n        _VSTD::forward<_Fn>(__f), _VSTD::forward<_Tuple>(__t),\n        typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{})\n)\n\ntemplate <class _Tp, class _Tuple, size_t... _Idx>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _Tp __make_from_tuple_impl(_Tuple&& __t, __tuple_indices<_Idx...>)\n_LIBCPP_NOEXCEPT_RETURN(\n    _Tp(_VSTD::get<_Idx>(_VSTD::forward<_Tuple>(__t))...)\n)\n\ntemplate <class _Tp, class _Tuple>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _Tp make_from_tuple(_Tuple&& __t)\n_LIBCPP_NOEXCEPT_RETURN(\n    _VSTD::__make_from_tuple_impl<_Tp>(_VSTD::forward<_Tuple>(__t),\n        typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{})\n)\n\n#undef _LIBCPP_NOEXCEPT_RETURN\n\n#endif // _LIBCPP_STD_VER > 14\n\n#endif // !defined(_LIBCPP_CXX03_LANG)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TUPLE\n","// -*- C++ -*-\n//===---------------------------- set -------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_SET\n#define _LIBCPP_SET\n\n/*\n\n    set synopsis\n\nnamespace std\n{\n\ntemplate <class Key, class Compare = less<Key>,\n          class Allocator = allocator<Key>>\nclass set\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef key_type                                 value_type;\n    typedef Compare                                  key_compare;\n    typedef key_compare                              value_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n    typedef unspecified                              node_type;               // C++17\n    typedef INSERT_RETURN_TYPE<iterator, node_type>  insert_return_type;      // C++17\n\n    // construct/copy/destroy:\n    set()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit set(const value_compare& comp);\n    set(const value_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        set(InputIterator first, InputIterator last,\n            const value_compare& comp = value_compare());\n    template <class InputIterator>\n        set(InputIterator first, InputIterator last, const value_compare& comp,\n            const allocator_type& a);\n    set(const set& s);\n    set(set&& s)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit set(const allocator_type& a);\n    set(const set& s, const allocator_type& a);\n    set(set&& s, const allocator_type& a);\n    set(initializer_list<value_type> il, const value_compare& comp = value_compare());\n    set(initializer_list<value_type> il, const value_compare& comp,\n        const allocator_type& a);\n    template <class InputIterator>\n        set(InputIterator first, InputIterator last, const allocator_type& a)\n            : set(first, last, Compare(), a) {}  // C++14\n    set(initializer_list<value_type> il, const allocator_type& a)\n        : set(il, Compare(), a) {}  // C++14\n    ~set();\n\n    set& operator=(const set& s);\n    set& operator=(set&& s)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    set& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator,bool> insert(const value_type& v);\n    pair<iterator,bool> insert(value_type&& v);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position, value_type&& v);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    node_type extract(const_iterator position);                                       // C++17\n    node_type extract(const key_type& x);                                             // C++17\n    insert_return_type insert(node_type&& nh);                                        // C++17\n    iterator insert(const_iterator hint, node_type&& nh);                             // C++17\n\n    iterator  erase(const_iterator position);\n    iterator  erase(iterator position);  // C++14\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    template<class C2>\n      void merge(set<Key, C2, Allocator>& source);         // C++17\n    template<class C2>\n      void merge(set<Key, C2, Allocator>&& source);        // C++17\n    template<class C2>\n      void merge(multiset<Key, C2, Allocator>& source);    // C++17\n    template<class C2>\n      void merge(multiset<Key, C2, Allocator>&& source);   // C++17\n\n    void swap(set& s)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // set operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator==(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator< (const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator!=(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator> (const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator>=(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator<=(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class Compare, class Allocator>\nvoid\nswap(set<Key, Compare, Allocator>& x, set<Key, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class Compare, class Allocator, class Predicate>\n  void erase_if(set<Key, Compare, Allocator>& c, Predicate pred);  // C++20\n\ntemplate <class Key, class Compare = less<Key>,\n          class Allocator = allocator<Key>>\nclass multiset\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef key_type                                 value_type;\n    typedef Compare                                  key_compare;\n    typedef key_compare                              value_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n    typedef unspecified                              node_type;               // C++17\n\n    // construct/copy/destroy:\n    multiset()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit multiset(const value_compare& comp);\n    multiset(const value_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        multiset(InputIterator first, InputIterator last,\n                 const value_compare& comp = value_compare());\n    template <class InputIterator>\n        multiset(InputIterator first, InputIterator last,\n                 const value_compare& comp, const allocator_type& a);\n    multiset(const multiset& s);\n    multiset(multiset&& s)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit multiset(const allocator_type& a);\n    multiset(const multiset& s, const allocator_type& a);\n    multiset(multiset&& s, const allocator_type& a);\n    multiset(initializer_list<value_type> il, const value_compare& comp = value_compare());\n    multiset(initializer_list<value_type> il, const value_compare& comp,\n             const allocator_type& a);\n    template <class InputIterator>\n        multiset(InputIterator first, InputIterator last, const allocator_type& a)\n            : set(first, last, Compare(), a) {}  // C++14\n    multiset(initializer_list<value_type> il, const allocator_type& a)\n        : set(il, Compare(), a) {}  // C++14\n    ~multiset();\n\n    multiset& operator=(const multiset& s);\n    multiset& operator=(multiset&& s)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    multiset& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& v);\n    iterator insert(value_type&& v);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position, value_type&& v);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    node_type extract(const_iterator position);                                       // C++17\n    node_type extract(const key_type& x);                                             // C++17\n    iterator insert(node_type&& nh);                                                  // C++17\n    iterator insert(const_iterator hint, node_type&& nh);                             // C++17\n\n    iterator  erase(const_iterator position);\n    iterator  erase(iterator position);  // C++14\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    template<class C2>\n      void merge(multiset<Key, C2, Allocator>& source);    // C++17\n    template<class C2>\n      void merge(multiset<Key, C2, Allocator>&& source);   // C++17\n    template<class C2>\n      void merge(set<Key, C2, Allocator>& source);         // C++17\n    template<class C2>\n      void merge(set<Key, C2, Allocator>&& source);        // C++17\n\n    void swap(multiset& s)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // set operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator==(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator< (const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator!=(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator> (const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator>=(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator<=(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class Compare, class Allocator>\nvoid\nswap(multiset<Key, Compare, Allocator>& x, multiset<Key, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class Compare, class Allocator, class Predicate>\n  void erase_if(multiset<Key, Compare, Allocator>& c, Predicate pred);  // C++20\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tree>\n#include <__node_handle>\n#include <functional>\n#include <version>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _Compare, class _Allocator>\nclass multiset;\n\ntemplate <class _Key, class _Compare = less<_Key>,\n          class _Allocator = allocator<_Key> >\nclass _LIBCPP_TEMPLATE_VIS set\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef key_type                                 value_type;\n    typedef _Compare                                 key_compare;\n    typedef key_compare                              value_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), \"\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\nprivate:\n    typedef __tree<value_type, value_compare, allocator_type> __base;\n    typedef allocator_traits<allocator_type>                  __alloc_traits;\n    typedef typename __base::__node_holder                    __node_holder;\n\n    __base __tree_;\n\npublic:\n    typedef typename __base::pointer               pointer;\n    typedef typename __base::const_pointer         const_pointer;\n    typedef typename __base::size_type             size_type;\n    typedef typename __base::difference_type       difference_type;\n    typedef typename __base::const_iterator        iterator;\n    typedef typename __base::const_iterator        const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>       reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator> const_reverse_iterator;\n\n#if _LIBCPP_STD_VER > 14\n    typedef __set_node_handle<typename __base::__node, allocator_type> node_type;\n    typedef __insert_return_type<iterator, node_type> insert_return_type;\n#endif\n\n    template <class _Key2, class _Compare2, class _Alloc2>\n        friend class _LIBCPP_TEMPLATE_VIS set;\n    template <class _Key2, class _Compare2, class _Alloc2>\n        friend class _LIBCPP_TEMPLATE_VIS multiset;\n\n    _LIBCPP_INLINE_VISIBILITY\n    set()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(value_compare()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit set(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__comp) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit set(const value_compare& __comp, const allocator_type& __a)\n        : __tree_(__comp, __a) {}\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        set(_InputIterator __f, _InputIterator __l,\n            const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        set(_InputIterator __f, _InputIterator __l, const value_compare& __comp,\n            const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n        template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        set(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n            : set(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    set(const set& __s)\n        : __tree_(__s.__tree_)\n        {\n            insert(__s.begin(), __s.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    set& operator=(const set& __s)\n        {\n            __tree_ = __s.__tree_;\n            return *this;\n        }\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    set(set&& __s)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__s.__tree_)) {}\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit set(const allocator_type& __a)\n        : __tree_(__a) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    set(const set& __s, const allocator_type& __a)\n        : __tree_(__s.__tree_.value_comp(), __a)\n        {\n            insert(__s.begin(), __s.end());\n        }\n\n#ifndef _LIBCPP_CXX03_LANG\n    set(set&& __s, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    set(initializer_list<value_type> __il, const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    set(initializer_list<value_type> __il, const value_compare& __comp,\n        const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n    set(initializer_list<value_type> __il, const allocator_type& __a)\n        : set(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    set& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_unique(__il.begin(), __il.end());\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    set& operator=(set&& __s)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__s.__tree_);\n            return *this;\n        }\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT       {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT         {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT\n            {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    // modifiers:\n#ifndef _LIBCPP_CXX03_LANG\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> emplace(_Args&&... __args)\n            {return __tree_.__emplace_unique(_VSTD::forward<_Args>(__args)...);}\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace_hint(const_iterator __p, _Args&&... __args)\n            {return __tree_.__emplace_hint_unique(__p, _VSTD::forward<_Args>(__args)...);}\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,bool> insert(const value_type& __v)\n        {return __tree_.__insert_unique(__v);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n        {return __tree_.__insert_unique(__p, __v);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_unique(__e, *__f);\n        }\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,bool> insert(value_type&& __v)\n        {return __tree_.__insert_unique(_VSTD::move(__v));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __v)\n        {return __tree_.__insert_unique(__p, _VSTD::move(__v));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __p) {return __tree_.erase(__p);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k)\n        {return __tree_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f, __l);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    insert_return_type insert(node_type&& __nh)\n    {\n        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),\n            \"node_type with incompatible allocator passed to set::insert()\");\n        return __tree_.template __node_handle_insert_unique<\n            node_type, insert_return_type>(_VSTD::move(__nh));\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __hint, node_type&& __nh)\n    {\n        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),\n            \"node_type with incompatible allocator passed to set::insert()\");\n        return __tree_.template __node_handle_insert_unique<node_type>(\n            __hint, _VSTD::move(__nh));\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    node_type extract(key_type const& __key)\n    {\n        return __tree_.template __node_handle_extract<node_type>(__key);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    node_type extract(const_iterator __it)\n    {\n        return __tree_.template __node_handle_extract<node_type>(__it);\n    }\n    template <class _Compare2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(set<key_type, _Compare2, allocator_type>& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        __tree_.__node_handle_merge_unique(__source.__tree_);\n    }\n    template <class _Compare2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(set<key_type, _Compare2, allocator_type>&& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        __tree_.__node_handle_merge_unique(__source.__tree_);\n    }\n    template <class _Compare2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(multiset<key_type, _Compare2, allocator_type>& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        __tree_.__node_handle_merge_unique(__source.__tree_);\n    }\n    template <class _Compare2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(multiset<key_type, _Compare2, allocator_type>&& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        __tree_.__node_handle_merge_unique(__source.__tree_);\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(set& __s) _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__s.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return __tree_.value_comp();}\n\n    // set operations:\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k) const                    {return __tree_.__count_multi(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n        {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n        {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n        {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator> equal_range(const key_type& __k)\n        {return __tree_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n        {return __tree_.__equal_range_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_multi(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}\n#endif\n};\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Compare, class _Allocator>\nset<_Key, _Compare, _Allocator>::set(set&& __s, const allocator_type& __a)\n    : __tree_(_VSTD::move(__s.__tree_), __a)\n{\n    if (__a != __s.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__s.empty())\n            insert(__e, _VSTD::move(__s.__tree_.remove(__s.begin())->__value_));\n    }\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\n// specialized algorithms:\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(set<_Key, _Compare, _Allocator>& __x,\n     set<_Key, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n#if _LIBCPP_STD_VER > 17\ntemplate <class _Key, class _Compare, class _Allocator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid erase_if(set<_Key, _Compare, _Allocator>& __c, _Predicate __pred)\n{ __libcpp_erase_if_container(__c, __pred); }\n#endif\n\ntemplate <class _Key, class _Compare = less<_Key>,\n          class _Allocator = allocator<_Key> >\nclass _LIBCPP_TEMPLATE_VIS multiset\n{\npublic:\n    // types:\n    typedef _Key                                      key_type;\n    typedef key_type                                 value_type;\n    typedef _Compare                                  key_compare;\n    typedef key_compare                              value_compare;\n    typedef _Allocator                                allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), \"\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\nprivate:\n    typedef __tree<value_type, value_compare, allocator_type> __base;\n    typedef allocator_traits<allocator_type>                  __alloc_traits;\n    typedef typename __base::__node_holder                    __node_holder;\n\n    __base __tree_;\n\npublic:\n    typedef typename __base::pointer               pointer;\n    typedef typename __base::const_pointer         const_pointer;\n    typedef typename __base::size_type             size_type;\n    typedef typename __base::difference_type       difference_type;\n    typedef typename __base::const_iterator        iterator;\n    typedef typename __base::const_iterator        const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>       reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator> const_reverse_iterator;\n\n#if _LIBCPP_STD_VER > 14\n    typedef __set_node_handle<typename __base::__node, allocator_type> node_type;\n#endif\n\n    template <class _Key2, class _Compare2, class _Alloc2>\n        friend class _LIBCPP_TEMPLATE_VIS set;\n    template <class _Key2, class _Compare2, class _Alloc2>\n        friend class _LIBCPP_TEMPLATE_VIS multiset;\n\n    // construct/copy/destroy:\n    _LIBCPP_INLINE_VISIBILITY\n    multiset()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(value_compare()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multiset(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__comp) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multiset(const value_compare& __comp, const allocator_type& __a)\n        : __tree_(__comp, __a) {}\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multiset(_InputIterator __f, _InputIterator __l,\n                 const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n        template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multiset(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n            : multiset(__f, __l, key_compare(), __a) {}\n#endif\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multiset(_InputIterator __f, _InputIterator __l,\n                 const value_compare& __comp, const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__f, __l);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(const multiset& __s)\n        : __tree_(__s.__tree_.value_comp(),\n          __alloc_traits::select_on_container_copy_construction(__s.__tree_.__alloc()))\n        {\n            insert(__s.begin(), __s.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset& operator=(const multiset& __s)\n        {\n            __tree_ = __s.__tree_;\n            return *this;\n        }\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(multiset&& __s)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__s.__tree_)) {}\n\n    multiset(multiset&& __s, const allocator_type& __a);\n#endif  // _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multiset(const allocator_type& __a)\n        : __tree_(__a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(const multiset& __s, const allocator_type& __a)\n        : __tree_(__s.__tree_.value_comp(), __a)\n        {\n            insert(__s.begin(), __s.end());\n        }\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(initializer_list<value_type> __il, const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(initializer_list<value_type> __il, const value_compare& __comp,\n        const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(initializer_list<value_type> __il, const allocator_type& __a)\n        : multiset(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_multi(__il.begin(), __il.end());\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset& operator=(multiset&& __s)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__s.__tree_);\n            return *this;\n        }\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT       {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT         {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT\n            {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    // modifiers:\n#ifndef _LIBCPP_CXX03_LANG\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace(_Args&&... __args)\n            {return __tree_.__emplace_multi(_VSTD::forward<_Args>(__args)...);}\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace_hint(const_iterator __p, _Args&&... __args)\n            {return __tree_.__emplace_hint_multi(__p, _VSTD::forward<_Args>(__args)...);}\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __v)\n        {return __tree_.__insert_multi(__v);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n        {return __tree_.__insert_multi(__p, __v);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_multi(__e, *__f);\n        }\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(value_type&& __v)\n        {return __tree_.__insert_multi(_VSTD::move(__v));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __v)\n        {return __tree_.__insert_multi(__p, _VSTD::move(__v));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __p) {return __tree_.erase(__p);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f, __l);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(node_type&& __nh)\n    {\n        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),\n            \"node_type with incompatible allocator passed to multiset::insert()\");\n        return __tree_.template __node_handle_insert_multi<node_type>(\n            _VSTD::move(__nh));\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __hint, node_type&& __nh)\n    {\n        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),\n            \"node_type with incompatible allocator passed to multiset::insert()\");\n        return __tree_.template __node_handle_insert_multi<node_type>(\n            __hint, _VSTD::move(__nh));\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    node_type extract(key_type const& __key)\n    {\n        return __tree_.template __node_handle_extract<node_type>(__key);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    node_type extract(const_iterator __it)\n    {\n        return __tree_.template __node_handle_extract<node_type>(__it);\n    }\n    template <class _Compare2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(multiset<key_type, _Compare2, allocator_type>& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        __tree_.__node_handle_merge_multi(__source.__tree_);\n    }\n    template <class _Compare2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(multiset<key_type, _Compare2, allocator_type>&& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        __tree_.__node_handle_merge_multi(__source.__tree_);\n    }\n    template <class _Compare2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(set<key_type, _Compare2, allocator_type>& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        __tree_.__node_handle_merge_multi(__source.__tree_);\n    }\n    template <class _Compare2>\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(set<key_type, _Compare2, allocator_type>&& __source)\n    {\n        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),\n                       \"merging container with incompatible allocator\");\n        __tree_.__node_handle_merge_multi(__source.__tree_);\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(multiset& __s)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__s.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return __tree_.value_comp();}\n\n    // set operations:\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k) const            {return __tree_.__count_multi(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n            {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n            {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n            {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator>             equal_range(const key_type& __k)\n            {return __tree_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n            {return __tree_.__equal_range_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_multi(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}\n#endif\n};\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Compare, class _Allocator>\nmultiset<_Key, _Compare, _Allocator>::multiset(multiset&& __s, const allocator_type& __a)\n    : __tree_(_VSTD::move(__s.__tree_), __a)\n{\n    if (__a != __s.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__s.empty())\n            insert(__e, _VSTD::move(__s.__tree_.remove(__s.begin())->__value_));\n    }\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(multiset<_Key, _Compare, _Allocator>& __x,\n     multiset<_Key, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n#if _LIBCPP_STD_VER > 17\ntemplate <class _Key, class _Compare, class _Allocator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid erase_if(multiset<_Key, _Compare, _Allocator>& __c, _Predicate __pred)\n{ __libcpp_erase_if_container(__c, __pred); }\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SET\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2021\n *\n *  @file CommentBox.hpp\n *  @brief Create a light grey \"comment bubble.\"\n *\n * TODO: When prefab tools for adding mobile only and desktop only\n * content are created, remove AddMobileContent(), desktop_content\n * and mobile_content divs, and ConfigPanel as a friend class.\n * AddConent() should stream into all_content div.\n */\n\n#ifndef EMP_PREFAB_COMMENTBOX_HPP_INCLUDE\n#define EMP_PREFAB_COMMENTBOX_HPP_INCLUDE\n\n#include \"../tools/string_utils.hpp\"\n#include \"../web/Div.hpp\"\n\nnamespace emp {\nnamespace prefab {\n  class ConfigPanel;\n  /**\n   * Use CommentBox class to create a light grey \"comment bubble\".\n   * Optionally, it can contain text and other web elements.\n   */\n  class CommentBox: public web::Div {\n    friend prefab::ConfigPanel;\n    private:\n      // ID for the comment box Div\n      std::string box_base = this->GetID();\n      // Provides stylized \"carrot\" for box\n      web::Div triangle{emp::to_string(box_base, \"_triangle\")};\n      // Contains Divs for mobile and desktop content\n      web::Div all_content{emp::to_string(box_base, \"_all_content\")};\n      // Content that shows on all screen sizes\n      web::Div desktop_content{emp::to_string(box_base, \"_desktop_content\")};\n      // Content that shows only on mobile devices\n      web::Div mobile_content{emp::to_string(box_base, \"_mobile_content\")};\n\n    protected:\n      /// Add content only to be shown on small screens\n\n      /*\n       * TODO: In the future, remove this method and instead\n       * have a prefab tool that can add mobile content to\n       *  web element.\n       */\n      template <typename T>\n      void AddMobileContent(T val) {\n        mobile_content << val;\n      }\n\n    public:\n      CommentBox(const std::string id=\"\") : web::Div(id) {\n        *this << triangle;\n        *this << all_content;\n        all_content << desktop_content;\n        all_content << mobile_content;\n\n        triangle.SetAttr(\"class\", \"commentbox_triangle\");\n        all_content.SetAttr(\"class\", \"commentbox_content\");\n        mobile_content.SetAttr(\"class\", \"mobile_commentbox\");\n      }\n\n      /**\n       * Take input of any type and add it to the comment box.\n       * Content will show on all screen sizes.\n       */\n\n      /*\n       * TODO: override the input operator to stream into the correct div\n       * See issue #345 (https://github.com/devosoft/Empirical/issues/345)\n       * for methods tried already.\n       */\n      template <typename T>\n      void AddContent(T val) {\n        desktop_content << val;\n      }\n  };\n}\n}\n\n#endif // #ifndef EMP_PREFAB_COMMENTBOX_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2020\n *\n *  @file Collapse.hpp\n *  @brief Sets up a collapsable DOM element.\n */\n\n#ifndef EMP_PREFAB_COLLAPSE_HPP_INCLUDE\n#define EMP_PREFAB_COLLAPSE_HPP_INCLUDE\n\n#include \"../tools/string_utils.hpp\"\n#include \"../web/Div.hpp\"\n#include \"../web/_FacetedWidget.hpp\"\n#include \"../web/Widget.hpp\"\n\nnamespace emp {\nnamespace prefab {\n  namespace internal {\n\n    /**\n     * CollpaseController class adds necessary html attributes to controller\n     * to function as the controller for a group or groups of target areas.\n     * Only ever called by CollapseCoupling class.\n     */\n    class CollapseController {\n      private:\n        web::Div inner_controller; // reference to controller passed to constructor\n\n      public:\n        /**\n         * @param controller web element that cause target area(s) to expand/collapse when clicked\n         * @param expanded whether or not the target(s) are initially in an expanded/open state\n         */\n        template <typename T>\n        CollapseController(\n          T controller,\n          const std::string controls_class,\n          bool expanded, std::string id=\"\"\n        ) : inner_controller(id) {\n\n          inner_controller = controller;\n          inner_controller.SetAttr(\n            \"role\", \"button\",\n            \"data-toggle\", \"collapse\"\n          );\n          inner_controller.AddAttr(\n            \"data-target\", \".\" + controls_class,\n            \"aria-controls\", \".\" + controls_class,\n            \"class\", \"collapse_toggle\"\n          );\n\n          inner_controller.SetAttr(\"aria-expanded\", expanded ? \"true\" : \"false\");\n\n          if (!expanded) {\n            inner_controller.AddAttr(\"class\", \"collapsed\");\n          }\n        }\n\n        web::Div & GetLinkDiv() { return inner_controller; }\n    };\n  }\n\n  /**\n   * CollapseCoupling class maintains a group of targets and controllers.\n   * When a controller is clicked on a web page, all the associated targets\n   * will change state (expand/collapse).\n   */\n  class CollapseCoupling {\n    private:\n      // all web elements that expand/collapse with this coupling\n      emp::vector<web::Widget> targets;\n      // all web elements that control expanding/collapsing with this coupling\n      emp::vector<web::Widget> controllers;\n      // class associated with this\n      std::string target_class;\n      // counter used to generate unique class names, shared by all instances of this class\n      inline static int counter = 0;\n\n    public:\n      /**\n       * Constructor which takes web elements as the controller and target.\n       * It will put each in a vector and call the constructor which takes\n       * vectors as controller and target parameters.\n       */\n      CollapseCoupling(\n        web::Widget controller,\n        web::Widget target,\n        const bool expanded=false,\n        const std::string in_class=\"\"\n      ) : CollapseCoupling(emp::vector<web::Widget>{controller},\n            emp::vector<web::Widget>{target}, expanded, in_class) { ; }\n\n      /**\n       * Constructor which takes vectors of web elements as the controller and target\n       * It will create the collapse coupling by adding necessary HTML attributes\n       * to all controllers and targets\n       */\n      CollapseCoupling(\n        emp::vector<web::Widget> controllers,\n        emp::vector<web::Widget> targets,\n        const bool expanded=false,\n        const std::string in_class=\"\"\n      ) {\n          /*\n           * if a class is defined by the user, use it\n           * Otherwise generate a unique class\n           */\n          if (in_class == \"\") {\n            target_class = \"emp__collapse_class_\" + std::to_string(counter);\n            counter++;\n          } else {\n            target_class = in_class;\n          }\n\n          // add controllers to this coupling\n          for (auto & widget : controllers) {\n            AddController(widget, expanded);\n          }\n          // add targets to this coupling\n          for (auto & widget : targets) {\n            AddTarget(widget, expanded);\n          }\n      }\n\n      /*\n       * TODO: Ideally, this constructor will be templated and can handle any input that is\n       * not a Widget or vector of Widgets.\n       * When we tried this before, all input would go through to this constructor.\n       * This caused issues when it tried to stream widgets into a div but the widget\n       * already had another parent.\n       *\n       * Note: Maybe if we web::internal::FacetedWidget intead of web::Widget in the\n       * first constructor, templating this constructor will work?\n       */\n      /**\n       * Constructor which takes strings as the controller and target\n       * It will put each in a Div element and call the constructor which takes\n       * web elements as controller and target parameters.\n       */\n      CollapseCoupling(\n        const std::string controller,\n        const std::string target,\n        const bool expanded=false,\n        const std::string in_class=\"\"\n      ): CollapseCoupling(web::Div{} << controller, web::Div{} << target, expanded, in_class) { ; }\n\n      /**\n       * Adds a controller to the vector of controllers for this CollapseCouple\n       *\n       * @param controller new controller to add to coupling is of type Widget\n       * @param expaned initial state of the target(s), is it expaned or not?\n       */\n      void AddController(web::Widget controller, const bool expanded) {\n        internal::CollapseController controller_widget(controller, target_class, expanded);\n        controllers.push_back(controller_widget.GetLinkDiv());\n      }\n\n      /** Adds a controller to the vector of controllers for this CollapseCouple.\n       *\n       * @param controller new controller to add to coupling is of type string\n       * @param expaned initial state of the target(s), is it expaned or not?\n       */\n\n      /*\n       * TODO: Ideally, this method would be templated, but running into same issues\n       * as when trying to do this with the constructor\n       */\n      void AddController(const std::string controller, const bool expanded) {\n        AddController(web::Div{} << controller, expanded);\n      }\n\n      /**\n       * Adds a target to the vector of targets for this CollapseCouple\n       *\n       *  @param widget new target to add to coupling is a web element\n       *  @param expaned initial state of the target(s), is it expaned or not?\n       */\n      void AddTarget(web::internal::FacetedWidget widget, const bool expanded) {\n        if (expanded) {\n          widget.AddAttr(\"class\", \"collapse show\");\n        } else {\n          widget.AddAttr(\"class\", \"collapse\");\n        }\n        widget.AddAttr(\"class\", target_class);\n        targets.push_back(widget);\n      }\n\n      /**\n       * Adds a target to the vector of targets for this CollapseCouple\n       *\n       * @param widget new target to add to coupling is a string\n       * @param expaned initial state of the target(s), is it expaned or not?\n       */\n\n      /*\n       * If the target is not a web widget, place it in a div and call the other AddTarget function\n       * TODO: Ideally, this method would be templated, but running into same issues\n       * as when trying to do this with the constructor\n       */\n      void AddTarget(const std::string target, const bool expanded) {\n        AddTarget(web::Div{} << target, expanded);\n      }\n\n      /// Returns the target_class associated with this CollapseCouple\n      std::string GetTargetClass() { return target_class; }\n\n      /*\n       * Functions used to retrieve controllers and targets\n       * TODO: In the future, add capability to call controllers and targets by name\n       * (Like dictionary accesses, key/value pairs)\n       */\n\n      /// Returns the vector of all controllers associated with this CollapseCouple\n      emp::vector<web::Widget> & GetControllerDivs() { return controllers; }\n\n      /// Returns the controller at the given index\n      web::Widget & GetControllerDiv(const int index=0) { return controllers[index]; }\n\n      /// Returns the vector of all targets associated with this CollapseCouple\n      emp::vector<web::Widget> & GetTargetDivs() { return targets; }\n\n      /// Returns the target at the given index\n      web::Widget & GetTargetDiv(const int index=0) { return targets[index]; }\n  };\n}\n}\n\n#endif // #ifndef EMP_PREFAB_COLLAPSE_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2020\n *\n *  @file _FacetedWidget.hpp\n *  @brief The FacetedWidget class is used to access the protected methods of WidgetFacet such\n *          as SetCSS and SetAttr. An example of its use can be found in include/emp/prefab/Collapse.h\n *\n */\n\n#ifndef EMP_WEB__FACETEDWIDGET_HPP_INCLUDE\n#define EMP_WEB__FACETEDWIDGET_HPP_INCLUDE\n\n#include \"../web/Widget.hpp\"\n\n#ifndef DOXYGEN_SHOULD_SKIP_THIS\n\nnamespace emp{\nnamespace web{\n  namespace internal{\n    class FacetedWidget : public internal::WidgetFacet<FacetedWidget>\n    {\n      public:\n      using base_t = internal::WidgetFacet<FacetedWidget>;\n      using INFO_TYPE = internal::WidgetInfo;\n      FacetedWidget(const Widget & widget) : base_t(widget){\n      }\n    };\n  }\n}\n}\n\n#endif\n\n#endif // #ifndef EMP_WEB__FACETEDWIDGET_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2019\n *\n *  @file MapProxy.hpp\n *  @brief A proxy for indecies returned from any map type to ensure they are initialized.\n *  @note Status: ALPHA\n */\n\n#ifndef EMP_BASE_MAPPROXY_HPP_INCLUDE\n#define EMP_BASE_MAPPROXY_HPP_INCLUDE\n\n#include \"assert.hpp\"\n\nnamespace emp {\n\n  // The MapProxy class is returned in the place of a mapped type to track usage.\n  // @CAO: Note that ideally we should have two proxy classes; one for when the wrapped type is a\n  //       class itself and we can derive from it (thus, perhaps, keeping member functions working?)\n  //       and the other being when it is a base type (and there are no member functions).\n  //       Fundamentally this problem comes from the fact that we cannot overload the . operator,\n  //       and thus cannot get it working directly for the Proxy class.\n  template <typename T>\n  class MapProxy {\n  private:\n    T & value;\n    bool is_init;  ///< Has this value been set yet?\n  public:\n    MapProxy(T & in_value, bool in_init) : value(in_value), is_init(in_init) { }\n\n    T & emp_GetValue() { emp_assert(is_init); return value; }\n    const T & emp_GetValue() const { emp_assert(is_init); return value; }\n    bool emp_IsInit() const { return is_init; }\n\n    // A regular assignment is allowed with the creation of a new map value.\n    template <typename R_T> T & operator=(R_T && _in) { is_init = true; return value = std::forward<R_T>(_in); }\n\n    // Setup other assignment operators\n    template <typename R_T> T & operator+=(R_T && _in) { return emp_GetValue() += std::forward<R_T>(_in); }\n    template <typename R_T> T & operator-=(R_T && _in) { return emp_GetValue() -= std::forward<R_T>(_in); }\n    template <typename R_T> T & operator*=(R_T && _in) { return emp_GetValue() *= std::forward<R_T>(_in); }\n    template <typename R_T> T & operator/=(R_T && _in) { return emp_GetValue() /= std::forward<R_T>(_in); }\n    template <typename R_T> T & operator%=(R_T && _in) { return emp_GetValue() %= std::forward<R_T>(_in); }\n    template <typename R_T> T & operator&=(R_T && _in) { return emp_GetValue() &= std::forward<R_T>(_in); }\n    template <typename R_T> T & operator|=(R_T && _in) { return emp_GetValue() |= std::forward<R_T>(_in); }\n    template <typename R_T> T & operator^=(R_T && _in) { return emp_GetValue() ^= std::forward<R_T>(_in); }\n    template <typename R_T> T & operator<<=(R_T && _in) { return emp_GetValue() <<= std::forward<R_T>(_in); }\n    template <typename R_T> T & operator>>=(R_T && _in) { return emp_GetValue() >>= std::forward<R_T>(_in); }\n\n    // Setup increment, decrement\n    auto & operator++() { return ++emp_GetValue(); }\n    auto & operator--() { return --emp_GetValue(); }\n    auto operator++(int) { return emp_GetValue()++; }\n    auto operator--(int) { return emp_GetValue()--; }\n\n    // Setup basic arithmatic\n    auto operator+() const { return +emp_GetValue(); }\n    auto operator-() const { return -emp_GetValue(); }\n    auto operator!() const { return !emp_GetValue(); }\n    auto operator~() const { return ~emp_GetValue(); }\n    template <typename R_T> auto operator + (const R_T & r) const { return emp_GetValue() + r; }\n    template <typename R_T> auto operator - (const R_T & r) const { return emp_GetValue() - r; }\n    template <typename R_T> auto operator * (const R_T & r) const { return emp_GetValue() * r; }\n    template <typename R_T> auto operator / (const R_T & r) const { return emp_GetValue() / r; }\n    template <typename R_T> auto operator % (const R_T & r) const { return emp_GetValue() % r; }\n\n    template <typename R_T> auto operator & (const R_T & r) const { return emp_GetValue() & r; }\n    template <typename R_T> auto operator | (const R_T & r) const { return emp_GetValue() | r; }\n    template <typename R_T> auto operator ^ (const R_T & r) const { return emp_GetValue() ^ r; }\n    template <typename R_T> auto operator << (const R_T & r) const { return emp_GetValue() << r; }\n    template <typename R_T> auto operator >> (const R_T & r) const { return emp_GetValue() >> r; }\n    template <typename R_T> auto operator && (const R_T & r) const { return emp_GetValue() && r; }\n    template <typename R_T> auto operator || (const R_T & r) const { return emp_GetValue() || r; }\n\n    // Setup comparison operators\n    template <typename R_T> bool operator == (const R_T & r) const { return emp_GetValue() == r; }\n    template <typename R_T> bool operator != (const R_T & r) const { return emp_GetValue() != r; }\n    template <typename R_T> bool operator <  (const R_T & r) const { return emp_GetValue() < r; }\n    template <typename R_T> bool operator <= (const R_T & r) const { return emp_GetValue() <= r; }\n    template <typename R_T> bool operator >  (const R_T & r) const { return emp_GetValue() > r; }\n    template <typename R_T> bool operator >= (const R_T & r) const { return emp_GetValue() >= r; }\n\n    // Setup member access\n    template <typename R_T> auto & operator [] (const R_T & r) { emp_assert(is_init); return value[r]; }\n    template <typename R_T> const auto & operator [] (const R_T & r) const { emp_assert(is_init); return value[r]; }\n    auto & operator * () { emp_assert(is_init); return *value; }\n    const auto & operator * () const { emp_assert(is_init); return *value; }\n    auto operator & () { emp_assert(is_init); return &value; }\n    auto operator -> () { emp_assert(is_init); return value; }\n    template <typename R_T> auto & operator ->* (const R_T & r) { emp_assert(is_init); return value->*r; }\n\n    // Setup remaining misc operators.\n    template <typename... R_Ts> auto operator () (R_Ts &&... rs) { emp_assert(is_init); return value( std::forward<R_Ts>(rs)... ); }\n    template <typename... R_Ts> auto operator () (R_Ts &&... rs) const {\n      emp_assert(is_init); return value( std::forward<R_Ts>(rs)... );\n    }\n    template <typename R_T> auto operator , (const R_T & r) { emp_assert(is_init); return value , r; }\n\n    // Reflect over some common functionality for working with pointers.\n    bool IsNull() const { return value.IsNull(); }\n    void Delete() { value.Delete(); }\n    void DeleteArray() { value.DeleteArray(); }\n\n    // Dynamic casting to internal type.\n    operator T&() { return value; } // Note that a non-const reference doesn't need var to be initialized yet.\n    operator const T&() const { emp_assert(is_init); return value; }\n  };\n\n\n  /// A type trait to determine if a class is a MapProxy\n  template <typename> struct is_MapProxy : public std::false_type { };\n\n  template <typename T>\n  struct is_MapProxy<MapProxy<T>> : public std::true_type { };\n\n\n  // Build externaly binary operators with MapProxy as the second argument.\n  #ifndef DOXYGEN_SHOULD_SKIP_THIS // Doxygen is getting tripped up by the enable_ifs\n  template <typename T1, typename T2, typename std::enable_if<is_MapProxy<T1>() == false>::type* = nullptr>\n  auto operator + (T1 v1, const MapProxy<T2> & v2) { return v1 + v2.emp_GetValue(); }\n  template <typename T1, typename T2, typename std::enable_if<is_MapProxy<T1>() == false>::type* = nullptr>\n  auto operator - (T1 v1, const MapProxy<T2> & v2) { return v1 - v2.emp_GetValue(); }\n  template <typename T1, typename T2, typename std::enable_if<is_MapProxy<T1>() == false>::type* = nullptr>\n  auto operator * (T1 v1, const MapProxy<T2> & v2) { return v1 * v2.emp_GetValue(); }\n  template <typename T1, typename T2, typename std::enable_if<is_MapProxy<T1>() == false>::type* = nullptr>\n  auto operator / (T1 v1, const MapProxy<T2> & v2) { return v1 / v2.emp_GetValue(); }\n  template <typename T1, typename T2, typename std::enable_if<is_MapProxy<T1>() == false>::type* = nullptr>\n  auto operator % (T1 v1, const MapProxy<T2> & v2) { return v1 % v2.emp_GetValue(); }\n  template <typename T1, typename T2, typename std::enable_if<is_MapProxy<T1>() == false>::type* = nullptr>\n  auto operator & (T1 v1, const MapProxy<T2> & v2) { return v1 & v2.emp_GetValue(); }\n  template <typename T1, typename T2, typename std::enable_if<is_MapProxy<T1>() == false>::type* = nullptr>\n  auto operator | (T1 v1, const MapProxy<T2> & v2) { return v1 | v2.emp_GetValue(); }\n  template <typename T1, typename T2, typename std::enable_if<is_MapProxy<T1>() == false>::type* = nullptr>\n  auto operator ^ (T1 v1, const MapProxy<T2> & v2) { return v1 ^ v2.emp_GetValue(); }\n  template <typename T1, typename T2, typename std::enable_if<is_MapProxy<T1>() == false>::type* = nullptr>\n  auto operator << (T1 v1, const MapProxy<T2> & v2) { return v1 << v2.emp_GetValue(); }\n  template <typename T1, typename T2, typename std::enable_if<is_MapProxy<T1>() == false>::type* = nullptr>\n  auto operator >> (T1 v1, const MapProxy<T2> & v2) { return v1 >> v2.emp_GetValue(); }\n  template <typename T1, typename T2, typename std::enable_if<is_MapProxy<T1>() == false>::type* = nullptr>\n  auto operator && (T1 v1, const MapProxy<T2> & v2) { return v1 && v2.emp_GetValue(); }\n  template <typename T1, typename T2, typename std::enable_if<is_MapProxy<T1>() == false>::type* = nullptr>\n  auto operator || (T1 v1, const MapProxy<T2> & v2) { return v1 || v2.emp_GetValue(); }\n  template <typename T1, typename T2, typename std::enable_if<is_MapProxy<T1>() == false>::type* = nullptr>\n  auto operator == (T1 v1, const MapProxy<T2> & v2) { return v1 == v2.emp_GetValue(); }\n  template <typename T1, typename T2, typename std::enable_if<is_MapProxy<T1>() == false>::type* = nullptr>\n  auto operator != (T1 v1, const MapProxy<T2> & v2) { return v1 != v2.emp_GetValue(); }\n  template <typename T1, typename T2, typename std::enable_if<is_MapProxy<T1>() == false>::type* = nullptr>\n  auto operator <  (T1 v1, const MapProxy<T2> & v2) { return v1 < v2.emp_GetValue(); }\n  template <typename T1, typename T2, typename std::enable_if<is_MapProxy<T1>() == false>::type* = nullptr>\n  auto operator <= (T1 v1, const MapProxy<T2> & v2) { return v1 <= v2.emp_GetValue(); }\n  template <typename T1, typename T2, typename std::enable_if<is_MapProxy<T1>() == false>::type* = nullptr>\n  auto operator >  (T1 v1, const MapProxy<T2> & v2) { return v1 > v2.emp_GetValue(); }\n  template <typename T1, typename T2, typename std::enable_if<is_MapProxy<T1>() == false>::type* = nullptr>\n  auto operator >= (T1 v1, const MapProxy<T2> & v2) { return v1 >= v2.emp_GetValue(); }\n  template <typename T1, typename T2, typename std::enable_if<is_MapProxy<T1>() == false>::type* = nullptr>\n  auto operator , (T1 v1, const MapProxy<T2> & v2) { return v1 , v2.emp_GetValue(); }\n  #endif /*DOXYGEN_SHOULD_SKIP_THIS*/\n}\n\n// A crude, generic printing function for emp::MapProxy.\ntemplate <typename T>\nstd::ostream & operator<<(std::ostream & out, const typename emp::MapProxy<T> & p) {\n  out << p.emp_GetValue();\n  return out;\n}\n\ntemplate <typename T>\nstd::istream & operator>>(std::istream & is, typename emp::MapProxy<T> & p) {\n  is >> p.emp_GetValue();\n  return is;\n}\n\n#endif // #ifndef EMP_BASE_MAPPROXY_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2019-2020.\n *\n *  @file unordered_map.hpp\n *  @brief A drop-in wrapper for std::unordered_map and unordered_multi_map; makes sure we create vars on access.\n *  @note Status: ALPHA\n */\n\n#ifndef EMP_BASE_UNORDERED_MAP_HPP_INCLUDE\n#define EMP_BASE_UNORDERED_MAP_HPP_INCLUDE\n\n#include <initializer_list>\n#include <unordered_map>\n\n#include \"assert.hpp\"\n#include \"MapProxy.hpp\"\n\n// If debug is turned out, translate back to std::map\n#ifdef EMP_NDEBUG\n\n// Seemlessly translate emp::unordered_map to std::unordered_map\nnamespace emp {\n  template <typename... Ts> using unordered_map = std::unordered_map<Ts...>;\n}\n\n// Seemlessly translate emp::unordered_multimap to std::unordered_multimap\nnamespace emp {\n  template <typename... Ts> using unordered_multimap = std::unordered_multimap<Ts...>;\n}\n\n#else // #EMP_NDEBUG *not* set, so debug is ON.\n\nnamespace emp {\n\n  template < class Key, class T, class... Ts >\n  class unordered_map : public std::unordered_map<Key, T, Ts...> {\n  private:\n    using this_t = emp::unordered_map<Key,T,Ts...>;\n    using base_t = std::unordered_map<Key,T,Ts...>;\n    using proxy_t = MapProxy<std::decay_t<T>>;\n\n  public:\n    using key_type = Key;\n    using mapped_type = T;\n    using value_type = std::pair<const key_type,mapped_type>;\n    using hasher = typename base_t::hasher;\n    using key_equal = typename base_t::key_equal;\n    using allocator_type = typename base_t::allocator_type;\n    using reference = typename base_t::reference;\n    using const_reference = typename base_t::const_reference;\n    using pointer = typename base_t::pointer;\n    using const_pointer = typename base_t::const_pointer;\n    using iterator = typename base_t::iterator;\n    using const_iterator = typename base_t::const_iterator;\n    using local_iterator = typename base_t::local_iterator;\n    using const_local_iterator = typename base_t::const_local_iterator;\n    using difference_type = typename base_t::difference_type;\n    using size_type = typename base_t::size_type;\n\n    unordered_map() = default;\n\n    explicit unordered_map ( size_type n,\n                             const hasher& hf = hasher(),\n                             const key_equal& eql = key_equal(),\n                             const allocator_type& alloc = allocator_type() )\n      : base_t (n, hf, eql, alloc) { }\n    explicit unordered_map ( const allocator_type& alloc ) : base_t (alloc) { }\n    unordered_map ( size_type n, const allocator_type& alloc ) : base_t (n, alloc) { }\n    unordered_map ( size_type n, const hasher& hf, const allocator_type& alloc ) : base_t (n, hf, alloc)  { }\n\n    template <class InputIterator>\n    unordered_map ( InputIterator first, InputIterator last) : base_t(first, last) { }\n    template <class InputIterator>\n    unordered_map ( InputIterator first, InputIterator last, size_type n,\n                    const hasher& hf = hasher(),\n                    const key_equal& eql = key_equal(),\n                    const allocator_type& alloc = allocator_type() )\n      : base_t (first, last, n, hf, eql, alloc) { }\n\n    template <class InputIterator>\n    unordered_map ( InputIterator first, InputIterator last,\n                    size_type n, const allocator_type& alloc )\n      : base_t (first, last, n, alloc) { }\n\n    template <class InputIterator>\n    unordered_map ( InputIterator first, InputIterator last,\n                    size_type n, const hasher& hf, const allocator_type& alloc )\n      : base_t (first, last, n, hf, alloc) { }\n\n    unordered_map ( const unordered_map & ump ) : base_t(ump) { }\n    unordered_map ( const unordered_map & ump, const allocator_type & alloc ) : base_t(ump, alloc) { }\n\n    unordered_map ( unordered_map && ump ) : base_t(ump) { }\n    unordered_map ( unordered_map && ump, const allocator_type & alloc ) : base_t(ump, alloc) { }\n\n    unordered_map ( std::initializer_list<value_type> il ) : base_t(il) { }\n\n    unordered_map ( std::initializer_list<value_type> il,\n                    size_type n,\n                    const hasher& hf = hasher(),\n                    const key_equal& eql = key_equal(),\n                    const allocator_type& alloc = allocator_type() )\n      : base_t(il, n, hf, eql, alloc) { }\n\n    unordered_map ( std::initializer_list<value_type> il,\n                    size_type n, const allocator_type& alloc )\n      : base_t(il, n, alloc) { }\n    unordered_map ( std::initializer_list<value_type> il,\n                    size_type n, const hasher& hf, const allocator_type& alloc )\n      : base_t(il, n ,hf, alloc) { }\n\n    this_t & operator=(const this_t &) = default;\n    this_t & operator=(this_t &&) = default;\n\n    proxy_t operator[] (const Key & k) {\n      const bool is_init = (this->find(k) != this->end());\n      return proxy_t(base_t::operator[](k), is_init);\n    }\n  };\n\n  template < class Key, class T, class... Ts >\n  class unordered_multimap : public std::unordered_multimap<Key, T, Ts...> {\n  private:\n    using this_t = emp::unordered_multimap<Key,T,Ts...>;\n    using base_t = std::unordered_multimap<Key,T,Ts...>;\n    using proxy_t = MapProxy<std::decay_t<T>>;\n\n  public:\n    using key_type = Key;\n    using mapped_type = T;\n    using value_type = std::pair<const key_type,mapped_type>;\n    using hasher = typename base_t::hasher;\n    using key_equal = typename base_t::key_equal;\n    using allocator_type = typename base_t::allocator_type;\n    using reference = typename base_t::reference;\n    using const_reference = typename base_t::const_reference;\n    using pointer = typename base_t::pointer;\n    using const_pointer = typename base_t::const_pointer;\n    using iterator = typename base_t::iterator;\n    using const_iterator = typename base_t::const_iterator;\n    using local_iterator = typename base_t::local_iterator;\n    using const_local_iterator = typename base_t::const_local_iterator;\n    using difference_type = typename base_t::difference_type;\n    using size_type = typename base_t::size_type;\n\n    unordered_multimap() = default;\n    explicit unordered_multimap ( size_type n,\n                             const hasher& hf = hasher(),\n                             const key_equal& eql = key_equal(),\n                             const allocator_type& alloc = allocator_type() )\n      : base_t (n, hf, eql, alloc) { }\n    explicit unordered_multimap ( const allocator_type& alloc ) : base_t (alloc) { }\n    unordered_multimap ( size_type n, const allocator_type& alloc ) : base_t (n, alloc) { }\n    unordered_multimap ( size_type n, const hasher& hf, const allocator_type& alloc ) : base_t (n, hf, alloc)  { }\n\n    template <class InputIterator>\n    unordered_multimap ( InputIterator first, InputIterator last) : base_t(first, last) { }\n    template <class InputIterator>\n    unordered_multimap ( InputIterator first, InputIterator last, size_type n,\n                    const hasher& hf = hasher(),\n                    const key_equal& eql = key_equal(),\n                    const allocator_type& alloc = allocator_type() )\n      : base_t (first, last, n, hf, eql, alloc) { }\n\n    template <class InputIterator>\n    unordered_multimap ( InputIterator first, InputIterator last,\n                    size_type n, const allocator_type& alloc )\n      : base_t (first, last, n, alloc) { }\n\n    template <class InputIterator>\n    unordered_multimap ( InputIterator first, InputIterator last,\n                    size_type n, const hasher& hf, const allocator_type& alloc )\n      : base_t (first, last, n, hf, alloc) { }\n\n    unordered_multimap ( const unordered_multimap & ump ) : base_t(ump) { }\n    unordered_multimap ( const unordered_multimap & ump, const allocator_type & alloc ) : base_t(ump, alloc) { }\n\n    unordered_multimap ( unordered_multimap && ump ) : base_t(ump) { }\n    unordered_multimap ( unordered_multimap && ump, const allocator_type & alloc ) : base_t(ump, alloc) { }\n\n    unordered_multimap ( std::initializer_list<value_type> il ) : base_t(il) { }\n\n    unordered_multimap ( std::initializer_list<value_type> il,\n                    size_type n,\n                    const hasher& hf = hasher(),\n                    const key_equal& eql = key_equal(),\n                    const allocator_type& alloc = allocator_type() )\n      : base_t(il, n, hf, eql, alloc) { }\n\n    unordered_multimap ( std::initializer_list<value_type> il,\n                    size_type n, const allocator_type& alloc )\n      : base_t(il, n, alloc) { }\n    unordered_multimap ( std::initializer_list<value_type> il,\n                    size_type n, const hasher& hf, const allocator_type& alloc )\n      : base_t(il, n ,hf, alloc) { }\n\n    this_t & operator=(const this_t &) = default;\n    this_t & operator=(this_t &&) = default;\n\n    proxy_t operator[] (const Key & k) {\n      const bool is_init = (this->find(k) != this->end());\n      return proxy_t(base_t::operator[](k), is_init);\n    }\n  };\n}\n\n#endif\n\n\n\n#endif // #ifndef EMP_BASE_UNORDERED_MAP_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2017\n *\n *  @file Font.hpp\n *  @brief Maintains basic information about a font to be used in HTML.\n */\n\n#ifndef EMP_WEB_FONT_HPP_INCLUDE\n#define EMP_WEB_FONT_HPP_INCLUDE\n\n\n#include <sstream>\n#include <string>\n\n#include \"color_map.hpp\"\n#include \"Style.hpp\"\n\nnamespace emp {\nnamespace web {\n\n  /// Maintain information about an HTML font.\n  class Font {\n  protected:\n    std::string family;     ///< Font family to use.\n    int size;               ///< Font size (in px) to use.\n    std::string color;      ///< Font color.\n    std::string line_color; ///< Color of lines through the text (underline, linethrough, etc.)\n\n    bool is_bold;           ///< Is this font bold?\n    bool is_italic;         ///< Is this font italic?\n    bool is_smallcaps;      ///< Should this text be in small caps?\n    bool is_underlined;     ///< Should this text be underlined?\n    bool is_overlined;      ///< Should this text have a line above it?\n    bool is_linethrough;    ///< Should this text have a line through it?\n    bool is_wavy_line;      ///< Should lines be made wavy?\n\n  public:\n    Font(const Font &) = default;\n    Font(Font &&) = default;\n    Font(const std::string & _family=\"Helvetica\", int _size=15,\n         const std::string & _color=\"black\", bool _bold=false, bool _italic=false)\n      : family(_family), size(_size), color(_color)\n      , is_bold(_bold), is_italic(_italic), is_smallcaps(false)\n      , is_underlined(false), is_overlined(false), is_linethrough(false), is_wavy_line(false)  { ; }\n    Font(int _size, const std::string & _color=\"black\", bool _bold=false, bool _italic=false)\n      : Font(\"Helvetica\", _size, _color, _bold, _italic)  { ; }\n    ~Font() { ; }\n\n    Font & operator=(const Font &) = default;\n    Font & operator=(Font &&) = default;\n\n    /// @returns font family\n    const std::string & GetFamily() const { return family; }\n    /// @returns font size (in pixels)\n    int GetSize() const { return size; }\n    /// @returns font color\n    const std::string & GetColor() const { return color; }\n    /// @returns color of lines through text (underline or strikethrough)\n    const std::string & GetLineColor() const { return line_color; }\n    /// @returns boolean indicating whether font is bold\n    bool IsBold() const { return is_bold; }\n    /// @returns boolean indicating whether font is italic\n    bool IsItalic() const { return is_italic; }\n     /// @returns boolean indicating whether font is in small caps\n    bool IsSmallcaps() const { return is_smallcaps; }\n    /// @returns boolean indicating whether font is underlined\n    bool IsUnderlined() const { return is_underlined; }\n    /// @returns boolean indicating whether font is overlined\n    bool IsOverlined() const { return is_overlined; }\n    /// @returns boolean indicating whether font is strikethrough\n    bool IsStrikethrough() const { return is_linethrough; }\n    /// @returns boolean indicating whether font is wavy line\n    bool IsWavyLine() const { return is_wavy_line; }\n    /// @returns boolean indicating whether font has any kind of line (underline, overline, or strikethrough)\n    bool HasLine() const { return is_underlined || is_overlined || is_linethrough; }\n\n    /// Sets font family to specified value\n    /// @returns reference to this font for easy chaining\n    Font & SetFamily(const std::string & _family) { family = _family; return *this; }\n    /// Sets font size to specified value\n    /// @returns reference to this font for easy chaining\n    Font & SetSize(int _size) { size = _size; return *this; }\n    /// Sets font color to specified value\n    /// @returns reference to this font for easy chaining\n    Font & SetColor(const std::string & _color) { color = _color; return *this; }\n    /// Sets color of any lines through, under, or over this font\n    /// @returns reference to this font for easy chaining\n    Font & SetLineColor(const std::string & _color) { line_color = _color; return *this; }\n    /// Sets whether font is bold\n    /// @returns reference to this font for easy chaining\n    Font & SetBold(bool _in=true) { is_bold = _in; return *this; }\n    /// Sets whether font is italic\n    /// @returns reference to this font for easy chaining\n    Font & SetItalic(bool _in=true) { is_italic = _in; return *this; }\n    /// Sets whether font is small caps\n    /// @returns reference to this font for easy chaining\n    Font & SetSmallcaps(bool _in=true) { is_smallcaps = _in; return *this; }\n    /// Sets whether font is underlined\n    /// @returns reference to this font for easy chaining\n    Font & SetUnderlined(bool _in = true) { is_underlined = _in; return *this; }\n    /// Sets whether font is overlined\n    /// @returns reference to this font for easy chaining\n    Font & SetOverlined(bool _in = true) { is_overlined = _in; return *this; }\n    /// Sets whether font is strikethrough-ed\n    /// @returns reference to this font for easy chaining\n    Font & SetStrikethrough(bool _in = true) { is_linethrough = _in; return *this; }\n    /// Sets whether font is wavy line\n    /// @returns reference to this font for easy chaining\n    Font & SetWavyLine(bool _in = true) { is_wavy_line = _in; return *this; }\n\n    /// Take a Style object an fill it out based on this font information.\n    void ConfigStyle(Style & style) const {\n      style.Set(\"color\", color);\n      style.Set(\"font-family\", family);\n      style.Set(\"font-size\", to_string(size,\"px\"));\n      if (is_bold) style.Set(\"font-weight\", \"bold\");\n      if (is_italic) style.Set(\"font-style\", \"italic\");\n      if (is_smallcaps) style.Set(\"font-variant\", \"small-caps\");\n      if (HasLine()) {\n        std::string decoration(\"\");\n        if (is_underlined) decoration += \" underline\";\n        if (is_overlined) decoration += \" overline\";\n        if (is_linethrough) decoration += \" line-through\";\n        if (line_color != \"\") { decoration += \" \"; decoration += line_color; }\n        if (is_wavy_line) decoration += \" wavy\";\n        style.Set(\"text-decoration\", decoration);\n      }\n    }\n\n    /// @returns a style object filled out according to this font information\n    Style AsStyle() const {\n      Style style;\n      ConfigStyle(style);\n      return style;\n    }\n\n    /// @returns a string containing the html necessary to open a span\n    /// element using this font.\n    std::string GetHTMLStart() {\n      std::stringstream ss;\n      ss << \"<span style=\\\"color:\" << color\n         << \"; font-family:\" << family\n         << \"; font-size:\" << size;\n      if (is_bold) ss << \"; font-weight:bold\";\n      if (is_italic) ss << \"; font-style:italic\";\n      if (is_smallcaps) ss << \"; font-variant:small-caps\";\n      if (HasLine()) {\n        ss << \"; text-decoration:\";\n        if (is_underlined) ss << \" underline\";\n        if (is_overlined) ss << \" overline\";\n        if (is_linethrough) ss << \" line-through\";\n        if (line_color != \"\") ss << \" \" << line_color;\n        if (is_wavy_line) ss << \" wavy\";\n      }\n      ss << \"\\\">\";\n      return ss.str();\n    }\n\n    /// @returns a string containing the html necessary to close a span\n    /// element created by \\c GetHTMLStart()\n    std::string GetHTMLEnd() { return \"</span>\"; }\n\n    /// Fonts will evaluate to equal if all of their properties are the same\n    bool operator==(const Font & _in) const {\n      return (family == _in.family)\n        && (size == _in.size)\n        && (color == _in.color)\n        && (line_color == _in.line_color)\n        && (is_bold == _in.is_bold)\n        && (is_italic == _in.is_italic)\n        && (is_smallcaps == _in.is_smallcaps)\n        && (is_underlined == _in.is_underlined)\n        && (is_overlined == _in.is_overlined)\n        && (is_linethrough == _in.is_linethrough)\n        && (is_wavy_line == _in.is_wavy_line)\n        ;\n    }\n\n    /// Fonts will evaluate to equal if all of their properties are the same\n    bool operator!=(const Font & _in) const { return !operator==(_in); }\n  };\n\n}\n}\n\n#endif // #ifndef EMP_WEB_FONT_HPP_INCLUDE\n","// -*- C++ -*-\n//===----------------------- initializer_list -----------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_INITIALIZER_LIST\n#define _LIBCPP_INITIALIZER_LIST\n\n/*\n    initializer_list synopsis\n\nnamespace std\n{\n\ntemplate<class E>\nclass initializer_list\n{\npublic:\n    typedef E        value_type;\n    typedef const E& reference;\n    typedef const E& const_reference;\n    typedef size_t   size_type;\n\n    typedef const E* iterator;\n    typedef const E* const_iterator;\n\n    initializer_list() noexcept; // constexpr in C++14\n\n    size_t   size()  const noexcept; // constexpr in C++14\n    const E* begin() const noexcept; // constexpr in C++14\n    const E* end()   const noexcept; // constexpr in C++14\n};\n\ntemplate<class E> const E* begin(initializer_list<E> il) noexcept; // constexpr in C++14\ntemplate<class E> const E* end(initializer_list<E> il) noexcept; // constexpr in C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not versioned\n{\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate<class _Ep>\nclass _LIBCPP_TEMPLATE_VIS initializer_list\n{\n    const _Ep* __begin_;\n    size_t    __size_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR_AFTER_CXX11\n    initializer_list(const _Ep* __b, size_t __s) _NOEXCEPT\n        : __begin_(__b),\n          __size_(__s)\n        {}\npublic:\n    typedef _Ep        value_type;\n    typedef const _Ep& reference;\n    typedef const _Ep& const_reference;\n    typedef size_t    size_type;\n\n    typedef const _Ep* iterator;\n    typedef const _Ep* const_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR_AFTER_CXX11\n    initializer_list() _NOEXCEPT : __begin_(nullptr), __size_(0) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR_AFTER_CXX11\n    size_t    size()  const _NOEXCEPT {return __size_;}\n    \n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _Ep* begin() const _NOEXCEPT {return __begin_;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _Ep* end()   const _NOEXCEPT {return __begin_ + __size_;}\n};\n\ntemplate<class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Ep*\nbegin(initializer_list<_Ep> __il) _NOEXCEPT\n{\n    return __il.begin();\n}\n\ntemplate<class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Ep*\nend(initializer_list<_Ep> __il) _NOEXCEPT\n{\n    return __il.end();\n}\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\n}  // std\n\n#endif  // _LIBCPP_INITIALIZER_LIST\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2016-2017\n *\n *  @file map_utils.hpp\n *  @brief A set of simple functions to manipulate maps.\n *  @note Status: BETA\n */\n\n#ifndef EMP_DATASTRUCTS_MAP_UTILS_HPP_INCLUDE\n#define EMP_DATASTRUCTS_MAP_UTILS_HPP_INCLUDE\n\n#include <map>\n#include <unordered_map>\n\n#include \"../base/map.hpp\"\n#include \"../base/vector.hpp\"\n\nnamespace emp {\n\n  /// Take any map type, and run find to determine if a key is present.\n  template <class MAP_T, class KEY_T>\n  inline bool Has( const MAP_T & in_map, const KEY_T & key ) {\n    return in_map.find(key) != in_map.end();\n  }\n\n\n  template <class MAP_T>\n  inline auto Keys( const MAP_T & in_map) -> emp::vector<typename std::remove_const<decltype(in_map.begin()->first)>::type> {\n    using KEY_T = typename std::remove_const<decltype(in_map.begin()->first)>::type;\n    emp::vector<KEY_T> keys;\n    for (auto it : in_map) {\n      keys.push_back(it.first);\n    }\n\n    return keys;\n\n  }\n\n\n  /// Take any map, run find() member function, and return the result found\n  /// (or default value if no results found).\n  template <class MAP_T, class KEY_T>\n  inline auto Find( const MAP_T & in_map, const KEY_T & key, const typename MAP_T::mapped_type & dval) {\n    auto val_it = in_map.find(key);\n    if (val_it == in_map.end()) return dval;\n    return val_it->second;\n  }\n\n\n  /// Take any map and element, run find() member function, and return a reference to\n  /// the result found (or default value if no results found).\n  template <class MAP_T, class KEY_T>\n  inline const auto & FindRef( const MAP_T & in_map, const KEY_T & key, const typename MAP_T::mapped_type & dval) {\n    auto val_it = in_map.find(key);\n    if (val_it == in_map.end()) return dval;\n    return val_it->second;\n  }\n\n\n  // The following two functions are from:\n  // http://stackoverflow.com/questions/5056645/sorting-stdmap-using-value\n\n  /// Take an std::pair<A,B> and return the flipped pair std::pair<B,A>\n  template<typename A, typename B> constexpr std::pair<B,A> flip_pair(const std::pair<A,B> &p)\n  {\n    return std::pair<B,A>(p.second, p.first);\n  }\n\n  /// Take an std::map<A,B> and return the flipped map (now multimap to be safe): std::multimap<B,A>\n  template<typename A, typename B> std::multimap<B,A> flip_map(const std::map<A,B> &src)\n  {\n    std::multimap<B,A> dst;\n    for (const auto & x : src) dst.insert( flip_pair(x) );\n    return dst;\n  }\n\n  // If debug is turned on, support flip_map on emp::map/multimap.\n  // Otherwise, emp::map and emp::multimap compile down to std::map/std::multimap, so this function is equivalent to flip_map above.\n  #ifndef EMP_NDEBUG\n  /// Take an emp::map<A,B> and return the flipped map (now multimap to be safe): emp::multimap<B,A>\n  template<typename A, typename B> emp::multimap<B,A> flip_map(const emp::map<A,B> &src)\n  {\n    emp::multimap<B,A> dst;\n    for (const auto & x : src) dst.insert( flip_pair(x) );\n    return dst;\n  }\n  #endif\n\n}\n\n#endif // #ifndef EMP_DATASTRUCTS_MAP_UTILS_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2019\n *\n *  @file Element.hpp\n *  @brief Element Widgets maintain an ordered collection of other widgets\n *  in a HTML element with any tag (e.g., div, footer, header, p, etc.)\n *\n *  When printed to the web page, these internal widgets are presented in order.\n *\n */\n\n#ifndef EMP_WEB_ELEMENT_HPP_INCLUDE\n#define EMP_WEB_ELEMENT_HPP_INCLUDE\n\n\n#include \"Animate.hpp\"\n#include \"Div.hpp\"\n#include \"Text.hpp\"\n#include \"Widget.hpp\"\n\n#include \"init.hpp\"\n\nnamespace emp {\nnamespace web {\n\n  /// A widget to track an element in an HTML file, and all of its contents.\n  class Element : public Div {\n  public:\n    /// @param in_tag sets the html tag for used this object (i.e., div, footer, header, p, etc.)\n    /// @param in_name sets the id of this html element\n    Element(const std::string & in_tag, const std::string & in_name=\"\")\n    : Div(in_name) {\n      // When a name is provided, create an associated Widget info.\n      Info()->DoSetTag(in_tag);\n    }\n    /// Construct Element from a Widget.\n    Element(const Widget & in) : Div(in) { ; }\n  };\n\n}\n}\n\n#endif // #ifndef EMP_WEB_ELEMENT_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2017\n *\n *  @file Listeners.hpp\n *  @brief A class for tracking font event listeners for Widgets\n */\n\n#ifndef EMP_WEB_LISTENERS_HPP_INCLUDE\n#define EMP_WEB_LISTENERS_HPP_INCLUDE\n\n\n\n#ifdef __EMSCRIPTEN__\n#include <emscripten.h>\n#endif\n\n#include \"../tools/string_utils.hpp\"\n\n#include <map>\n#include <string>\n\nnamespace emp {\nnamespace web {\n\n  /// Track a set of JavaScript Listeners with their callback IDs.\n  class Listeners {\n  private:\n    std::map<std::string, size_t> listeners;  ///< Map triggers to callback IDs\n\n  public:\n    Listeners() { ; }\n    Listeners(const Listeners &) = default;\n    Listeners & operator=(const Listeners &) = default;\n\n    /// How many listeners are we tracking?\n    size_t GetSize() const { return listeners.size(); }\n\n    /// Use a pre-calculated function ID with a new listener.\n    Listeners & Set(const std::string & name, size_t fun_id) {\n      emp_assert(!Has(name));\n      listeners[name] = fun_id;\n      return *this;\n    }\n\n    /// Calculate its own function ID with JSWrap.\n    template <typename... Ts>\n    Listeners & Set(const std::string & name, const std::function<void(Ts... args)> & in_fun) {\n      emp_assert(!Has(name));\n      listeners[name] = JSWrap(in_fun);\n      return *this;\n    }\n\n    /// Determine if a specified listener exists.\n    bool Has(const std::string & event_name) const {\n      return listeners.find(event_name) != listeners.end();\n    }\n\n    /// Get the ID associated with a specific listener.\n    size_t GetID(const std::string & event_name) {\n      emp_assert(Has(event_name));\n      return listeners[event_name];\n    }\n\n    const std::map<std::string, size_t> & GetMap() const {\n      return listeners;\n    }\n\n    /// Remove all listeners\n    void Clear() {\n      // @CAO: Delete functions to be called.\n      listeners.clear();\n    }\n\n    /// Remove a specific listener.\n    void Remove(const std::string & event_name) {\n      // @CAO: Delete function to be called.\n      listeners.erase(event_name);\n    }\n\n    /// Apply all of the listeners being tracked.\n    void Apply(const std::string & widget_id) {\n      // Find the current object only once.\n#ifdef __EMSCRIPTEN__\n      MAIN_THREAD_EM_ASM({\n          var id = UTF8ToString($0);\n          emp_i.cur_obj = $( '#' + id );\n        }, widget_id.c_str());\n#endif\n\n      for (auto event_pair : listeners) {\n#ifdef __EMSCRIPTEN__\n        MAIN_THREAD_EM_ASM({\n          var name = UTF8ToString($0);\n          emp_i.cur_obj.on( name, function(evt) { emp.Callback($1, evt); } );\n        }, event_pair.first.c_str(), event_pair.second);\n#else\n        std::cout << \"Setting '\" << widget_id << \"' listener '\" << event_pair.first\n                  << \"' to '\" << event_pair.second << \"'.\";\n#endif\n      }\n    }\n\n\n    /// Apply a SPECIFIC listener.\n    static void Apply(const std::string & widget_id,\n                      const std::string event_name,\n                      size_t fun_id) {\n#ifdef __EMSCRIPTEN__\n        MAIN_THREAD_EM_ASM({\n          var id = UTF8ToString($0);\n          var name = UTF8ToString($1);\n          $( '#' + id ).on( name, function(evt) { emp.Callback($2, evt); } );\n        }, widget_id.c_str(), event_name.c_str(), fun_id);\n#else\n        std::cout << \"Setting '\" << widget_id << \"' listener '\" << event_name\n                  << \"' to function id '\" << fun_id << \"'.\";\n#endif\n    }\n\n    /// true/false : do any listeners exist?\n    operator bool() const { return (bool) listeners.size(); }\n  };\n\n\n}\n}\n\n\n#endif // #ifndef EMP_WEB_LISTENERS_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2017\n *\n *  @file Attributes.hpp\n *  @brief An Attributes class for tracking non-style features about HTML objects\n */\n\n#ifndef EMP_WEB_ATTRIBUTES_HPP_INCLUDE\n#define EMP_WEB_ATTRIBUTES_HPP_INCLUDE\n\n\n#ifdef __EMSCRIPTEN__\n#include <emscripten.h>\n#endif\n\n#include \"../base/errors.hpp\"\n#include \"../tools/string_utils.hpp\"\n\n#include <map>\n#include <string>\n\nnamespace emp {\nnamespace web {\n\n  ///  @brief Maintains a map of attribute names to values for use in JavaScript\n  ///  Closely related to Style.h, which is for CSS-values.\n\n  class Attributes {\n  private:\n    std::map<std::string, std::string> settings;\n\n  public:\n    Attributes() { ; }\n    Attributes(const Attributes &) = default;\n    Attributes & operator=(const Attributes &) = default;\n\n    /// Return a count of the number of attributes that have been set.\n    int GetSize() const { return (int) settings.size(); }\n\n    Attributes & DoSet(const std::string & in_set, const std::string & in_val) {\n      settings[in_set] = in_val;\n      return *this;\n    }\n\n    /// Append a new value to an existing attribute\n    /// @param in_attr attribute name\n    /// @param in_val attribute value to be added\n    Attributes & DoAddAttr(const std::string in_attr, const std::string & in_val) {\n      if (!Has(in_attr)){\n        // Attribute has not been assigned to this Widget. Add it with DoSet instead\n        DoSet(in_attr, in_val);\n      } else if(settings[in_attr].find(in_val) == std::string::npos){\n        // New value is not a duplicate of any values assigned to this attribute. Append it.\n        settings[in_attr] += \" \" + in_val;\n      }\n      return *this;\n    }\n\n    std::string GetAttrValue(const std::string & in_set){\n      return settings[in_set];\n    }\n\n    /// Record that attribute \"a\" is set to value \"v\" (converted to string) and return this object.\n    template <typename SET_TYPE>\n    Attributes & Set(const std::string & s, SET_TYPE v) {\n      return DoSet(s, emp::to_string(v));\n    }\n\n    /// Set all values from in_attr here as well.  Return this object.\n    Attributes & Insert(const Attributes & in_attr) {\n      settings.insert(in_attr.settings.begin(), in_attr.settings.end());\n      return *this;\n    }\n\n    /// Return true/false based on whether \"setting\" has been given a value in this Attributes obj.\n    bool Has(const std::string & setting) const {\n      return settings.find(setting) != settings.end();\n    }\n\n    /// Return the (string) value of \"setting\" that has been recorded in this Attributes obj.\n    const std::string & Get(const std::string & setting) const {\n      // Note: if setting did not exist, this does return (but not create) an empty entry.\n      auto it = settings.find(setting);\n      return (it == settings.end()) ? emp::empty_string() : it->second;\n    }\n\n    const std::map<std::string, std::string> & GetMap() const {\n      return settings;\n    }\n\n    void Remove(const std::string & setting) {\n      settings.erase(setting);\n    }\n\n    /// Remove all setting values.\n    void Clear() { settings.clear(); }\n\n    /// Apply ALL of the Attribute's settings to dom element \"widget_id\".\n    void Apply(const std::string & widget_id) {\n      // Stop immediately if nothing to set.\n      if (settings.size() == 0) return;\n\n      // Find the current object only once.\n#ifdef __EMSCRIPTEN__\n      MAIN_THREAD_EM_ASM({\n          var id = UTF8ToString($0);\n          emp_i.cur_obj = $( '#' + id );\n        }, widget_id.c_str());\n#endif\n\n      for (auto attr_pair : settings) {\n        if (attr_pair.second == \"\") continue; // Ignore empty entries.\n#ifdef __EMSCRIPTEN__\n        MAIN_THREAD_EM_ASM({\n            var name = UTF8ToString($0);\n            var value = UTF8ToString($1);\n            emp_i.cur_obj.attr( name, value);\n          }, attr_pair.first.c_str(), attr_pair.second.c_str());\n#else\n        std::cout << \"Setting '\" << widget_id << \"' attribute '\" << attr_pair.first\n                  << \"' to '\" << attr_pair.second << \"'.\";\n#endif\n      }\n    }\n\n    /// Apply only a SPECIFIC attributes setting from the setting library to widget_id.\n    void Apply(const std::string & widget_id, const std::string & setting) {\n      emp_assert(Has(setting));\n\n#ifdef __EMSCRIPTEN__\n      MAIN_THREAD_EM_ASM({\n          var id = UTF8ToString($0);\n          var setting = UTF8ToString($1);\n          var value = UTF8ToString($2);\n          $( '#' + id ).attr( setting, value);\n        }, widget_id.c_str(), setting.c_str(), settings[setting].c_str());\n#else\n      std::cout << \"Setting '\" << widget_id << \"' attribute '\" << setting\n                << \"' to '\" << settings[setting] << \"'.\";\n#endif\n    }\n\n    /// Apply onlay a SPECIFIC attributes setting with a specifid value!\n    static void Apply(const std::string & widget_id, const std::string & setting,\n                      const std::string & value) {\n#ifdef __EMSCRIPTEN__\n      MAIN_THREAD_EM_ASM({\n          var id = UTF8ToString($0);\n          var setting = UTF8ToString($1);\n          var value = UTF8ToString($2);\n          $( '#' + id ).attr( setting, value);\n        }, widget_id.c_str(), setting.c_str(), value.c_str());\n#else\n      std::cout << \"Setting '\" << widget_id << \"' attribute '\" << setting\n                << \"' to '\" << value << \"'.\";\n#endif\n    }\n\n    /// Convert to true if there are any setting, false otherwise.\n    operator bool() const { return (bool) settings.size(); }\n  };\n\n\n}\n}\n\n\n#endif // #ifndef EMP_WEB_ATTRIBUTES_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2018\n *\n *  @file CanvasAction.hpp\n *  @brief Define a base class for all actions that can be done to widgets, plus simple actions.\n *\n *  CanvasAction objects modify the appearance of a canvas and can be tracked to reconstruct the\n *  state of the canvas from scratch.\n *\n *  Other, more specific actions defined here are:\n *    CanvasStrokeColor\n *    CanvasRotate\n *    CanvasFont\n *\n *  See also CanvasShape.h for more actions.\n */\n\n#ifndef EMP_WEB_CANVASACTION_HPP_INCLUDE\n#define EMP_WEB_CANVASACTION_HPP_INCLUDE\n\n\n#include <string>\n\n#include \"../geometry/Point2D.hpp\"\n\n#include \"RawImage.hpp\"\n#include \"Widget.hpp\"\n\nnamespace emp {\nnamespace web {\n\n  /// Base class to maintain canvas actions.\n  class CanvasAction {\n  protected:\n    /// Helper function to set the fill status.\n    void Fill(const std::string & style=\"\") {\n      if (style != \"\") {\n        EM_ASM({\n            emp_i.ctx.fillStyle = UTF8ToString($0);\n          }, style.c_str());\n      }\n      EM_ASM({ emp_i.ctx.fill(); });\n    }\n\n    /// Helper function to set the stroke status.\n    void Stroke(const std::string & style=\"\") {\n      if (style != \"\") {\n        EM_ASM({\n            emp_i.ctx.strokeStyle = UTF8ToString($0);\n          }, style.c_str());\n      }\n      EM_ASM({ emp_i.ctx.stroke(); });\n    }\n\n    /// Helper function to set the stroke status.\n    void LineWidth(double line_width=1.0) {\n      EM_ASM({\n          emp_i.ctx.lineWidth = $0;\n        }, line_width);\n    }\n\n  public:\n    CanvasAction() { EMP_TRACK_CONSTRUCT(CanvasAction); }\n    CanvasAction(const CanvasAction &) { EMP_TRACK_CONSTRUCT(CanvasAction); }\n    virtual ~CanvasAction() { EMP_TRACK_DESTRUCT(CanvasAction); }\n\n\n    virtual void Apply() = 0;                  ///< Apply current action to emp_i.ctx.\n    virtual CanvasAction * Clone() const = 0;  ///< Make a copy of the current action.\n  };\n\n\n  /// Set the line color on subsequent draw-related actions.\n  class CanvasStrokeColor : public CanvasAction {\n  protected:\n    std::string color;  ///< Color to use.\n  public:\n    CanvasStrokeColor(const std::string & c) : color(c) { ; }\n\n    void Apply() {\n      EM_ASM({\n        var color = UTF8ToString($0);\n        emp_i.ctx.strokeStyle = color;\n      }, color.c_str());\n    }\n    CanvasAction * Clone() const { return new CanvasStrokeColor(*this); }\n  };\n\n  /// Rotate the entire canvas for subsequent drawings.\n  class CanvasRotate : public CanvasAction {\n  protected:\n    double angle;\n  public:\n    CanvasRotate(double a) : angle(a) { ; }\n\n    void Apply() {\n      EM_ASM({\n        emp_i.ctx.rotate($0);\n      }, angle);\n    }\n    CanvasAction * Clone() const { return new CanvasRotate(*this); }\n  };\n\n\n  /// Change the default font to be used.\n  class CanvasFont : public CanvasAction {\n  protected:\n    std::string font;\n  public:\n    CanvasFont(const std::string & f) : font(f) { ; }\n\n    void Apply() {\n      EM_ASM({\n        emp_i.ctx.font = UTF8ToString($0);\n      }, font.c_str());\n    }\n    CanvasAction * Clone() const { return new CanvasFont(*this); }\n  };\n\n  /// Change the default font to be used.\n  class CanvasImage : public CanvasAction {\n  protected:\n    RawImage image;\n    Point position;\n    double width; double height;\n  public:\n    CanvasImage(const RawImage & raw_image, double _x=0.0, double _y=0.0, double _w=0.0, double _h=0.0)\n      : image(raw_image), position(_x,_y), width(_w), height(_h) { ; }\n    CanvasImage(const RawImage & raw_image, Point _p, double _w=0.0, double _h=0.0)\n      : image(raw_image), position(_p), width(_w), height(_h) { ; }\n    CanvasImage(const std::string & url, double _x=0.0, double _y=0.0, double _w=0.0, double _h=0.0)\n      : image(url), position(_x,_y), width(_w), height(_h) { ; }\n    CanvasImage(const std::string & url, Point _p, double _w=0.0, double _h=0.0)\n      : image(url), position(_p), width(_w), height(_h) { ; }\n\n    void Apply() {\n      image.OnLoad([this](){\n        if (width == 0.0) {\n          EM_ASM({\n            emp_i.ctx.drawImage(emp_i.images[$0], $1, $2);\n          }, image.GetID(), position.GetX(), position.GetY());\n        } else {\n          EM_ASM({\n            emp_i.ctx.drawImage(emp_i.images[$0], $1, $2, $3, $4);\n          }, image.GetID(), position.GetX(), position.GetY(), width, height);\n        }\n      });\n    }\n\n    CanvasAction * Clone() const { return new CanvasImage(*this); }\n  };\n\n}\n}\n\n#endif // #ifndef EMP_WEB_CANVASACTION_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2017\n *\n *  @file alert.hpp\n *  @brief Define an Alert function that goes to std::cerr in c++ or to Alert() in Javascript.\n *  @note Status: RELEASE\n */\n\n#ifndef EMP_DEBUG_ALERT_HPP_INCLUDE\n#define EMP_DEBUG_ALERT_HPP_INCLUDE\n\n#include \"../tools/string_utils.hpp\"\n\n// If we are in emscripten, make sure to include the header.\n#ifdef __EMSCRIPTEN__\n#include <emscripten.h>\n#endif\n\n\nnamespace emp {\n#ifdef __EMSCRIPTEN__\n  void Alert(const std::string & msg) { EM_ASM_ARGS({\n    msg = UTF8ToString($0);\n    if (typeof alert == \"undefined\") {\n      // node polyfill\n      globalThis.alert = console.log;\n    }\n    alert(msg);\n  }, msg.c_str() ); }\n#else\n  /// Send msg to cerr if in C++, or show msg in an alert box if compiled to Javascript\n  /// Input can be any number of arguments of any types as long as the can be converted to\n  /// strings with emp::to_string().\n  void Alert(const std::string & msg) { std::cerr << msg << std::endl; }\n#endif\n  /// @cond TEMPLATES\n  template <typename... TYPE_SET>\n  void Alert(TYPE_SET... inputs) { Alert(emp::to_string(inputs...)); }\n  /// @endcond\n\n  /// A version of Alert that will cap how many times it can go off\n  template <typename... TYPE_SET>\n  static void CappedAlert(size_t cap, TYPE_SET... inputs) {\n    static size_t cur_count = 0;\n    if (cur_count++ < cap) Alert(emp::to_string(inputs...));\n  }\n\n  /// An object that will automatically output a message during construction or destruction,\n  /// usually for use in debugging to disentangle timings.\n  struct AlertObj {\n    std::string msg;    ///< Message for the alert to print.\n    bool on_construct;  ///< Should the message print automatically during construction?\n    bool on_destruct;   ///< Should the message print automatically during destruction?\n\n    AlertObj(const std::string & _msg, bool _on_c=true, bool _on_d=false)\n    : msg(_msg), on_construct(_on_c), on_destruct(_on_d) { if (on_construct) emp::Alert(msg); }\n    ~AlertObj() { if (on_destruct) emp::Alert(msg); }\n\n    void Trigger() { emp::Alert(msg); }\n    void SetMessage(const std::string & _msg) { msg = _msg; }\n  };\n}\n\n\n#endif // #ifndef EMP_DEBUG_ALERT_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2019-2020.\n *\n *  @file map.hpp\n *  @brief A drop-in wrapper for std::map and std:multimap; makes sure we create vars on access.\n *  @note Status: ALPHA\n *\n *  This class is a drop-in wrapper for std::map, adding on debbing where the indexing operator\n *  [square brackets] returns a proxy.  That proxy can either be assigned to OR convert an\n *  existing value ONLY if it exists.  This mechanism ensures that we don't accidentally write\n *  a default value to a map when all we meant to do was read from it, but had a typo.\n *  If EMP_NDEBUG is set then it reverts back to std::map.\n */\n\n#ifndef EMP_BASE_MAP_HPP_INCLUDE\n#define EMP_BASE_MAP_HPP_INCLUDE\n\n#include <initializer_list>\n#include <map>\n\n#include \"assert.hpp\"\n#include \"MapProxy.hpp\"\n\n// If debug is turned out, translate back to std::map\n#ifdef EMP_NDEBUG\n\n// Seemlessly translate emp::map to std::map\nnamespace emp {\n  template <typename... Ts> using map = std::map<Ts...>;\n}\n\n// Seemlessly translate emp::multimap to std::multimap\nnamespace emp {\n  template <typename... Ts> using multimap = std::multimap<Ts...>;\n}\n\n#else // #EMP_NDEBUG *not* set, so debug is ON.\n\nnamespace emp {\n\n  template < class Key, class T, class... Ts >\n  class map : public std::map<Key, T, Ts...> {\n  private:\n    using this_t = emp::map<Key,T,Ts...>;\n    using base_t = std::map<Key,T,Ts...>;\n    using proxy_t = MapProxy<std::decay_t<T>>;\n\n  public:\n    using key_type = Key;\n    using mapped_type = T;\n    using value_type = std::pair<const key_type,mapped_type>;\n    using key_compare = typename base_t::key_compare;\n    using value_compare = typename base_t::value_compare;\n    using allocator_type = typename base_t::allocator_type;\n    using reference = typename base_t::reference;\n    using const_reference = typename base_t::const_reference;\n    using pointer = typename base_t::pointer;\n    using const_pointer = typename base_t::const_pointer;\n    using iterator = typename base_t::iterator;\n    using const_iterator = typename base_t::const_iterator;\n    using reverse_iterator = typename base_t::reverse_iterator;\n    using const_reverse_iterator = typename base_t::const_reverse_iterator;\n    using difference_type = typename base_t::difference_type;\n    using size_type = typename base_t::size_type;\n\n    explicit map (const key_compare& comp = key_compare(), const allocator_type& alloc = allocator_type())\n      : base_t(comp, alloc) { }\n    explicit map (const allocator_type& alloc) : base_t(alloc) { }\n    template <class InputIterator>\n    map (InputIterator first, InputIterator last,\n         const key_compare& comp = key_compare(), const allocator_type& alloc = allocator_type())\n      : base_t(first, last, comp, alloc) { }\n    map (const this_t& x) : base_t(x) { }\n    map (const this_t& x, const allocator_type& alloc) : base_t(x, alloc) { }\n    map (this_t && x) : base_t(std::move(x)) { }\n    map (this_t && x, const allocator_type& alloc) : base_t(std::move(x), alloc) { }\n    map (std::initializer_list<value_type> il, const key_compare& comp = key_compare(),\n         const allocator_type& alloc = allocator_type())\n      : base_t(il, comp, alloc) { }\n\n    this_t & operator=(const this_t &) = default;\n    this_t & operator=(this_t &&) = default;\n\n    proxy_t operator[] (const Key & k) {\n      const bool is_init = (this->find(k) != this->end());\n      return proxy_t(base_t::operator[](k), is_init);\n    }\n  };\n\n  template < class Key, class T, class... Ts >\n  class multimap : public std::multimap<Key, T, Ts...> {\n  private:\n    using this_t = emp::multimap<Key,T,Ts...>;\n    using base_t = std::multimap<Key,T,Ts...>;\n    using proxy_t = MapProxy<std::decay_t<T>>;\n\n  public:\n    using key_type = Key;\n    using mapped_type = T;\n    using value_type = std::pair<const key_type,mapped_type>;\n    using key_compare = typename base_t::key_compare;\n    using value_compare = typename base_t::value_compare;\n    using allocator_type = typename base_t::allocator_type;\n    using reference = typename base_t::reference;\n    using const_reference = typename base_t::const_reference;\n    using pointer = typename base_t::pointer;\n    using const_pointer = typename base_t::const_pointer;\n    using iterator = typename base_t::iterator;\n    using const_iterator = typename base_t::const_iterator;\n    using reverse_iterator = typename base_t::reverse_iterator;\n    using const_reverse_iterator = typename base_t::const_reverse_iterator;\n    using difference_type = typename base_t::difference_type;\n    using size_type = typename base_t::size_type;\n\n    explicit multimap (const key_compare& comp = key_compare(), const allocator_type& alloc = allocator_type())\n      : base_t(comp, alloc) { }\n    explicit multimap (const allocator_type& alloc) : base_t(alloc) { }\n    template <class InputIterator>\n    multimap (InputIterator first, InputIterator last,\n         const key_compare& comp = key_compare(), const allocator_type& alloc = allocator_type())\n      : base_t(first, last, comp, alloc) { }\n    multimap (const this_t & x) : base_t(x) { }\n    multimap (const this_t & x, const allocator_type& alloc) : base_t(x, alloc) { }\n    multimap (this_t && x) : base_t(std::move(x)) { }\n    multimap (this_t && x, const allocator_type& alloc) : base_t(std::move(x), alloc) { }\n    multimap (std::initializer_list<value_type> il, const key_compare& comp = key_compare(),\n         const allocator_type& alloc = allocator_type())\n      : base_t(il, comp, alloc) { }\n\n    this_t & operator=(const this_t &) = default;\n    this_t & operator=(this_t &&) = default;\n\n    proxy_t operator[] (const Key & k) {\n      const bool is_init = (this->find(k) != this->end());\n      return proxy_t(base_t::operator[](k), is_init);\n    }\n  };\n}\n\n#endif\n\n\n\n#endif // #ifndef EMP_BASE_MAP_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2016-2020.\n *\n *  @file Ptr.hpp\n *  @brief A wrapper for pointers that does careful memory tracking (but only in debug mode).\n *  @note Status: BETA\n *\n *  Ptr objects behave as normal pointers under most conditions.  However, if a program is\n *  compiled with EMP_TRACK_MEM set, then these pointers perform extra tests to ensure that\n *  they point to valid memory and that memory is freed before pointers are released.\n *\n *  If you want to prevent pointers to pointers (a common source of errors, but MAY be done\n *  intentionally) you can define EMP_NO_PTR_TO_PTR\n *\n *  If you trip an assert, you can re-do the run a track a specific pointer by defining\n *  EMP_ABORT_PTR_NEW or EMP_ABORT_PTR_DELETE to the ID of the pointer in question.  This will\n *  allow you to track the pointer more easily in a debugger.\n *\n *  @todo Track information about emp::vector and emp::array objects to make sure we don't\n *    point directly into them? (A resize() could make such pointers invalid!) Or better, warn\n *    it vector memory could have moved.\n *  @todo Get working with threads\n */\n\n#ifndef EMP_BASE_PTR_HPP_INCLUDE\n#define EMP_BASE_PTR_HPP_INCLUDE\n\n#include <cstring>\n#include <unordered_map>\n\n#include \"assert.hpp\"\n#include \"vector.hpp\"\n\nnamespace emp {\n\n  // ------------ Pre-declare some helper types and functions --------------\n\n  template <typename TYPE> class Ptr;\n\n\n  template <typename T>\n  inline void FillMemory(emp::Ptr<unsigned char>  mem_ptr, const size_t num_bytes, T fill_value);\n\n  /// Fill an array by repeatedly calling the provided fill functions.\n  template <typename T>\n  inline void FillMemoryFunction(emp::Ptr<unsigned char>  mem_ptr, const size_t num_bytes, T fill_fun);\n\n  #ifndef DOXYGEN_SHOULD_SKIP_THIS\n  namespace internal {\n    /// An anonymous log2 calculator for hashing below.\n    static constexpr size_t Log2(size_t x) { return x <= 1 ? 0 : (Log2(x/2) + 1); }\n\n    static bool ptr_debug = false;\n  }\n  #endif // DOXYGEN_SHOULD_SKIP_THIS\n  inline void SetPtrDebug(bool _d = true) { internal::ptr_debug = _d; }\n  inline bool GetPtrDebug() { return internal::ptr_debug; }\n\n  enum class PtrStatus { DELETED=0, ACTIVE, ARRAY };\n\n  class PtrInfo {\n  private:\n    const void * ptr;   ///< Which pointer are we keeping data on?\n    int count;          ///< How many of this pointer do we have?\n    PtrStatus status;   ///< Has this pointer been deleted? (i.e., if so, don't access it!)\n    size_t array_bytes; ///< How big is the array pointed to (in bytes)?\n\n  public:\n    PtrInfo(const void * _ptr) : ptr(_ptr), count(1), status(PtrStatus::ACTIVE), array_bytes(0) {\n      if (internal::ptr_debug) std::cout << \"Created info for pointer: \" << ptr << std::endl;\n    }\n    PtrInfo(const void * _ptr, size_t _array_bytes)\n      : ptr(_ptr), count(1), status(PtrStatus::ARRAY), array_bytes(_array_bytes)\n    {\n      emp_assert(_array_bytes >= 1);\n      if (internal::ptr_debug) {\n        std::cout << \"Created info for array pointer (bytes=\" << array_bytes << \"): \"\n                  << ptr << std::endl;\n      }\n    }\n    PtrInfo(const PtrInfo &) = default;\n    PtrInfo(PtrInfo &&) = default;\n    PtrInfo & operator=(const PtrInfo &) = default;\n    PtrInfo & operator=(PtrInfo &&) = default;\n\n    ~PtrInfo() {\n      if (internal::ptr_debug) std::cout << \"Deleted info for pointer \" << ptr << std::endl;\n    }\n\n    /// What pointer does this one hold information about?\n    const void * GetPtr() const noexcept { return ptr; }\n\n    /// How many Ptr objects point to the associated position?\n    int GetCount() const noexcept { return count; }\n\n    /// If this ptr is to an array, how many bytes large is the array (may be different from size!)\n    size_t GetArrayBytes() const noexcept { return array_bytes; }\n\n    /// Is this pointer currently valid to access?\n    bool IsActive() const noexcept { return (bool) status; }\n\n    /// Is this pointer pointing to an array?\n    bool IsArray() const noexcept { return status == PtrStatus::ARRAY; }\n\n    /// Denote that this pointer is an array.\n    void SetArray(size_t bytes) noexcept { array_bytes = bytes; status = PtrStatus::ARRAY; }\n\n    /// Add one more pointer.\n    void Inc([[maybe_unused]] const size_t id) {\n      if (internal::ptr_debug) std::cout << \"Inc info for pointer \" << ptr << std::endl;\n      emp_assert(status != PtrStatus::DELETED, \"Incrementing deleted pointer!\", id);\n      count++;\n    }\n\n    /// Remove a pointer.\n    void Dec([[maybe_unused]] const size_t id) {\n      if (internal::ptr_debug) std::cout << \"Dec info for pointer \" << ptr << std::endl;\n\n      // Make sure that we have more than one copy, -or- we've already deleted this pointer\n      emp_assert(count > 1 || status == PtrStatus::DELETED, \"Removing last reference to owned Ptr!\", id);\n      count--;\n    }\n\n    /// Indicate that the associated position has been deleted.\n    void MarkDeleted() {\n      if (internal::ptr_debug) std::cout << \"Marked deleted for pointer \" << ptr << std::endl;\n      status = PtrStatus::DELETED;\n    }\n\n    /// Debug utility to determine if everything looks okay with this pointer's information.\n    bool OK() const noexcept {\n      if (ptr == nullptr) return false;     // Should not have info for a null pointer.\n      if (status == PtrStatus::ARRAY) {\n        if (array_bytes == 0) return false; // Arrays cannot be size 0.\n        if (count == 0) return false;       // Active arrays must have pointers to them.\n      }\n      if (status == PtrStatus::ACTIVE) {\n        if (array_bytes > 0) return false;  // non-arrays must be array size 0.\n        if (count == 0) return false;       // Active pointers must have references to them.\n      }\n      return true;\n    }\n  };\n\n\n  /// Facilitate tracking of all Ptr objects in this run.\n  class PtrTracker {\n  private:\n    std::unordered_map<const void *, size_t> ptr_id;  ///< Associate raw pointers with unique IDs\n    emp::vector<PtrInfo> id_info;                     ///< Associate IDs with pointer information.\n    static constexpr size_t UNTRACKED_ID = (size_t) -1;\n\n    // Make PtrTracker a singleton.\n    PtrTracker() : ptr_id(), id_info() {\n      std::cout << \"EMP_TRACK_MEM: Pointer tracking is active!\\n\";\n    }\n    PtrTracker(const PtrTracker &) = delete;\n    PtrTracker(PtrTracker &&) = delete;\n    PtrTracker & operator=(const PtrTracker &) = delete;\n    PtrTracker & operator=(PtrTracker &&) = delete;\n\n  public:\n    ~PtrTracker() {\n      // Track stats about pointer record.\n      size_t total = 0;\n      size_t remain = 0;\n      emp::vector<PtrInfo> undeleted_info;\n\n      // Scan through live pointers and make sure all have been deleted.\n      for (const auto & info : id_info) {\n        total++;\n        if (info.GetCount()) remain++;\n\n        if (info.IsActive()) {\n          undeleted_info.push_back(info);\n        }\n      }\n\n      if (undeleted_info.size()) {\n        std::cerr << undeleted_info.size() << \" undeleted pointers at end of exectution.\\n\";\n        for (size_t i = 0; i < undeleted_info.size() && i < 10; ++i) {\n          const auto & info = undeleted_info[i];\n          std::cerr << \"  PTR=\" << info.GetPtr()\n                    << \"  count=\" << info.GetCount()\n                    << \"  active=\" << info.IsActive()\n                    << \"  id=\" << ptr_id[info.GetPtr()]\n                    << std::endl;\n        }\n        if (undeleted_info.size() > 10) {\n          std::cerr << \"  ...\" << std::endl;\n        }\n        abort();\n      }\n\n      std::cout << \"EMP_TRACK_MEM: No memory leaks found!\\n \"\n                << total << \" pointers found; \";\n      if (remain) {\n        std::cout << remain << \" still exist with a non-null value (but have been properly deleted)\";\n      } else std::cout << \"all have been cleaned up fully.\";\n      std::cout << std::endl;\n    }\n\n    /// Treat this class as a singleton with a single Get() method to retrieve it.\n    static PtrTracker & Get() { static PtrTracker tracker; return tracker; }\n\n    /// Get the info associated with an existing pointer.\n    PtrInfo & GetInfo(const void * ptr) { return id_info[ptr_id[ptr]]; }\n    PtrInfo & GetInfo(size_t id) { return id_info[id]; }\n\n    /// Determine if a pointer is being tracked.\n    bool HasPtr(const void * ptr) const {\n      if (internal::ptr_debug) std::cout << \"HasPtr: \" << ptr << std::endl;\n      return ptr_id.find(ptr) != ptr_id.end();\n    }\n\n    /// Retrive the ID associated with a pointer.\n    size_t GetCurID(const void * ptr) { emp_assert(HasPtr(ptr)); return ptr_id[ptr]; }\n\n    /// Lookup how many pointers are being tracked.\n    size_t GetNumIDs() const { return id_info.size(); }\n\n    /// How big is an array associated with an ID?\n    size_t GetArrayBytes(size_t id) const { return id_info[id].GetArrayBytes(); }\n\n    /// Check if an ID is for a pointer that has been deleted.\n    bool IsDeleted(size_t id) const {\n      if (id == UNTRACKED_ID) return false;   // Not tracked, so not deleted.\n      if (internal::ptr_debug) std::cout << \"IsDeleted: \" << id << std::endl;\n      return !id_info[id].IsActive();\n    }\n\n    /// Is a pointer active and ready to be used?\n    bool IsActive(const void * ptr) {\n      if (internal::ptr_debug) std::cout << \"IsActive: \" << ptr << std::endl;\n      if (ptr_id.find(ptr) == ptr_id.end()) return false; // Not in database.\n      return GetInfo(ptr).IsActive();\n    }\n\n    /// Is a pointer id associated with a pointer that's active and ready to be used?\n    bool IsActiveID(size_t id) {\n      if (id == UNTRACKED_ID) return false;\n      if (id >= id_info.size()) return false;\n      return id_info[id].IsActive();\n    }\n\n    /// Is an ID associated with an array?\n    bool IsArrayID(size_t id) {\n      if (internal::ptr_debug) std::cout << \"IsArrayID: \" << id << std::endl;\n      if (id == UNTRACKED_ID) return false;\n      if (id >= id_info.size()) return false;\n      return id_info[id].IsArray();\n    }\n\n    /// How many Ptr objects are associated with an ID?\n    int GetIDCount(size_t id) const {\n      if (internal::ptr_debug) std::cout << \"Count:  \" << id << std::endl;\n      return id_info[id].GetCount();\n    }\n\n    /// This pointer was just created as a Ptr!\n    size_t New(const void * ptr) {\n      emp_assert(ptr);     // Cannot track a null pointer.\n      size_t id = id_info.size();\n#ifdef EMP_ABORT_PTR_NEW\n      if (id == EMP_ABORT_PTR_NEW) {\n        std::cerr << \"Aborting at creation of Ptr id \" << id << std::endl;\n        abort();\n      }\n#endif\n      if (internal::ptr_debug) std::cout << \"New:    \" << id << \" (\" << ptr << \")\" << std::endl;\n      // Make sure pointer is not already stored -OR- hase been deleted (since re-use is possible).\n      emp_assert(!HasPtr(ptr) || IsDeleted(GetCurID(ptr)), id);\n      id_info.emplace_back(ptr);\n      ptr_id[ptr] = id;\n      return id;\n    }\n\n    /// This pointer was just created as a Ptr ARRAY!\n    size_t NewArray(const void * ptr, size_t array_bytes) {\n      size_t id = New(ptr);  // Build the new pointer.\n      if (internal::ptr_debug) std::cout << \"  ...Array of size \" << array_bytes << std::endl;\n      id_info[id].SetArray(array_bytes);\n      return id;\n    }\n\n    /// Increment the nuber of Pointers associated with an ID\n    void IncID(size_t id) {\n      if (id == UNTRACKED_ID) return;   // Not tracked!\n      if (internal::ptr_debug) std::cout << \"Inc:    \" << id << std::endl;\n      id_info[id].Inc(id);\n    }\n\n    /// Decrement the nuber of Pointers associated with an ID\n    void DecID(size_t id) {\n      if (id == UNTRACKED_ID) return;   // Not tracked!\n      auto & info = id_info[id];\n      if (internal::ptr_debug) std::cout << \"Dec:    \" << id << \"(\" << info.GetPtr() << \")\" << std::endl;\n      emp_assert(info.GetCount() > 0, \"Decrementing Ptr, but already zero!\",\n                 id, info.GetPtr(), info.IsActive());\n      info.Dec(id);\n    }\n\n    /// Mark the pointers associated with this ID as deleted.\n    void MarkDeleted(size_t id) {\n#ifdef EMP_ABORT_PTR_DELETE\n      if (id == EMP_ABORT_PTR_DELETE) {\n        std::cerr << \"Aborting at deletion of Ptr id \" << id << std::endl;\n        abort();\n      }\n#endif\n      if (internal::ptr_debug) std::cout << \"Delete: \" << id << std::endl;\n      emp_assert(id_info[id].IsActive(), \"Deleting same emp::Ptr a second time!\", id);\n      id_info[id].MarkDeleted();\n    }\n  };\n\n\n//////////////////////////////////\n//\n//  --- Ptr implementation ---\n//\n//////////////////////////////////\n\n#ifdef EMP_TRACK_MEM\n\n  namespace {\n    // @CAO: Build this for real!\n    template <typename FROM, typename TO>\n    bool PtrIsConvertable(FROM * ptr) { (void) ptr; return true; }\n    // emp_assert( (std::is_same<TYPE,T2>() || dynamic_cast<TYPE*>(in_ptr)) );\n\n    // Debug information provided for each pointer type.\n    struct PtrDebug {\n      size_t current;\n      size_t total;\n      PtrDebug() : current(0), total(0) { ; }\n      void AddPtr() { current++; total++; }\n      void RemovePtr() { current--; }\n    };\n  }\n\n  /// Base class with common functionality (that should not exist in void pointers)\n  template <typename TYPE>\n  class BasePtr {\n  public:\n    TYPE * ptr;                 ///< The raw pointer associated with this Ptr object.\n    size_t id;                  ///< A unique ID for this pointer type.\n\n    static constexpr size_t UNTRACKED_ID = (size_t) -1;\n\n    BasePtr(TYPE * in_ptr, size_t in_id) : ptr(in_ptr), id(in_id) {\n      #ifdef EMP_NO_PTR_TO_PTR\n      emp_assert(!std::is_pointer_v<TYPE>, \"Pointers to pointers are disallowed!\");\n      #endif\n    }\n\n    static PtrTracker & Tracker() { return PtrTracker::Get(); }  // Single tracker for al Ptr types\n\n    /// Dereference a pointer.\n    [[nodiscard]] TYPE & operator*() const {\n      // Make sure a pointer is active and non-null before we dereference it.\n      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);\n      emp_assert(ptr != nullptr, \"Do not dereference a null pointer!\");\n      return *ptr;\n    }\n\n    /// Follow a pointer.\n    TYPE * operator->() const {\n      // Make sure a pointer is active before we follow it.\n      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);\n      emp_assert(ptr != nullptr, \"Do not follow a null pointer!\");\n      return ptr;\n    }\n\n    /// Indexing into array\n    TYPE & operator[](size_t pos) const {\n      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);\n      emp_assert(id == UNTRACKED_ID || Tracker().IsArrayID(id), \"Only arrays can be indexed into.\", id);\n      emp_assert(id == UNTRACKED_ID || Tracker().GetArrayBytes(id) > (pos*sizeof(TYPE)),\n        \"Indexing out of range.\", id, ptr, pos, sizeof(TYPE), Tracker().GetArrayBytes(id));\n      emp_assert(ptr != nullptr, \"Do not follow a null pointer!\");\n      return ptr[pos];\n    }\n\n  };\n\n\n  /// Base class with functionality only needed in void pointers.\n  template <>\n  class BasePtr<void> {\n  public:\n    void * ptr;                 ///< The raw pointer associated with this Ptr object.\n    size_t id;                  ///< A unique ID for this pointer type.\n\n    BasePtr(void * in_ptr, size_t in_id) : ptr(in_ptr), id(in_id) { }\n    static PtrTracker & Tracker() { return PtrTracker::Get(); }  // Single tracker for al Ptr types\n  };\n\n  /// Base class with functionality only needed in void pointers.\n  template <>\n  class BasePtr<const void> {\n  public:\n    const void * ptr;                 ///< The raw pointer associated with this Ptr object.\n    size_t id;                  ///< A unique ID for this pointer type.\n\n    BasePtr(const void * in_ptr, size_t in_id) : ptr(in_ptr), id(in_id) { }\n    static PtrTracker & Tracker() { return PtrTracker::Get(); }  // Single tracker for al Ptr types\n  };\n\n  /// Main Ptr class DEBUG definition.\n  template <typename TYPE>\n  class Ptr : public BasePtr<TYPE> {\n  public:\n    using BasePtr<TYPE>::ptr;\n    using BasePtr<TYPE>::id;\n    using BasePtr<TYPE>::Tracker;\n\n    using element_type = TYPE;  ///< Type being pointed at.\n\n    static constexpr size_t UNTRACKED_ID = (size_t) -1;\n\n    static PtrDebug & DebugInfo() { static PtrDebug info; return info; } // Debug info for each type\n\n    /// Construct a null Ptr by default.\n    Ptr() : BasePtr<TYPE>(nullptr, UNTRACKED_ID) {\n      if (internal::ptr_debug) {\n        std::cout << \"null construct.\" << std::endl;\n      }\n    }\n\n    /// Construct using copy constructor\n    Ptr(const Ptr<TYPE> & _in) : BasePtr<TYPE>(_in.ptr, _in.id) {\n      if (internal::ptr_debug) std::cout << \"copy construct: \" << ptr << std::endl;\n      Tracker().IncID(id);\n    }\n\n    /// Construct from a raw pointer of campatable type.\n    template <typename T2>\n    Ptr(T2 * in_ptr, bool track=false) : BasePtr<TYPE>(in_ptr, UNTRACKED_ID)\n    {\n      if (internal::ptr_debug) std::cout << \"raw construct: \" << ptr << \". track=\" << track << std::endl;\n      emp_assert( (PtrIsConvertable<T2, TYPE>(in_ptr)) );\n\n      // If this pointer is already active, link to it.\n      if (Tracker().IsActive(ptr)) {\n        id = Tracker().GetCurID(ptr);\n        Tracker().IncID(id);\n      }\n      // If we are not already tracking this pointer, but should be, add it.\n      else if (track) {\n        id = Tracker().New(ptr);\n        DebugInfo().AddPtr();\n      }\n    }\n\n    /// Construct from a raw pointer of compatible ARRAY type.\n    template <typename T2>\n    Ptr(T2 * _ptr, size_t array_size, bool track) : BasePtr<TYPE>(_ptr, UNTRACKED_ID)\n    {\n      const size_t array_bytes = array_size * sizeof(T2);\n      if (internal::ptr_debug) std::cout << \"raw ARRAY construct: \" << ptr\n                               << \". size=\" << array_size << \"(\" << array_bytes\n                               << \" bytes); track=\" << track << std::endl;\n      emp_assert( (PtrIsConvertable<T2, TYPE>(_ptr)) );\n\n      // If this pointer is already active, link to it.\n      if (Tracker().IsActive(ptr)) {\n        id = Tracker().GetCurID(ptr);\n        Tracker().IncID(id);\n        emp_assert(Tracker().GetArrayBytes(id) == array_bytes); // Make sure pointer is consistent.\n      }\n      // If we are not already tracking this pointer, but should be, add it.\n      else if (track) {\n        id = Tracker().NewArray(ptr, array_bytes);\n        DebugInfo().AddPtr();\n      }\n    }\n\n    /// Construct from another Ptr<> object of compatible type.\n    template <typename T2>\n    Ptr(Ptr<T2> _in) : BasePtr<TYPE>(_in.Raw(), _in.GetID()) {\n      if (internal::ptr_debug) std::cout << \"inexact copy construct: \" << ptr << std::endl;\n      emp_assert( (PtrIsConvertable<T2, TYPE>(_in.Raw())), id );\n      Tracker().IncID(id);\n    }\n\n    /// Construct from nullptr.\n    Ptr(std::nullptr_t) : Ptr() {\n      if (internal::ptr_debug) std::cout << \"null construct 2.\" << std::endl;\n    }\n\n    /// Destructor.\n    ~Ptr() {\n      if (internal::ptr_debug) {\n        std::cout << \"destructing Ptr instance \";\n        if (ptr) std::cout << id << \" (\" << ptr << \")\\n\";\n        else std::cout << \"(nullptr)\\n\";\n      }\n      Tracker().DecID(id);\n    }\n\n    /// Is this Ptr currently nullptr?\n    [[nodiscard]] bool IsNull() const { return ptr == nullptr; }\n\n    /// Convert this Ptr to a raw pointer that isn't going to be tracked.\n    [[nodiscard]] TYPE * Raw() const {\n      emp_assert(Tracker().IsDeleted(id) == false, \"Do not convert deleted Ptr to raw.\", id);\n      return ptr;\n    }\n\n    /// Convert this Ptr to a raw pointer of a position in an array.\n    [[nodiscard]] TYPE * Raw(size_t pos) const {\n      emp_assert(Tracker().IsDeleted(id) == false, \"Do not convert deleted Ptr to array raw.\", id);\n      return &(ptr[pos]);\n    }\n\n    /// Cast this Ptr to a different type.\n    template <typename T2>\n    [[nodiscard]] Ptr<T2> Cast() const {\n      emp_assert(Tracker().IsDeleted(id) == false, \"Do not cast deleted pointers.\", id);\n      return (T2*) ptr;\n    }\n\n    /// Change constness of this Ptr's target; throw an assert of the cast fails.\n    template <typename T2>\n    [[nodiscard]] Ptr<T2> ConstCast() const {\n      emp_assert(Tracker().IsDeleted(id) == false, \"Do not cast deleted pointers.\", id);\n      emp_assert( (std::is_same< std::remove_const_t<TYPE> , std::remove_const_t<T2> >()) );\n      return const_cast<T2*>(ptr);\n    }\n\n    /// Dynamically cast this Ptr to another type; throw an assert of the cast fails.\n    template <typename T2>\n    [[nodiscard]] Ptr<T2> DynamicCast() const {\n      emp_assert(Tracker().IsDeleted(id) == false, \"Do not cast deleted pointers.\", id);\n      return dynamic_cast<T2*>(ptr);\n    }\n\n    /// Reinterpret this Ptr to another type; throw an assert of the cast fails.\n    template <typename T2>\n    [[nodiscard]] Ptr<T2> ReinterpretCast() const {\n      emp_assert(Tracker().IsDeleted(id) == false, \"Do not cast deleted pointers.\", id);\n      #ifdef EMP_NO_PTR_TO_PTR\n      emp_assert(!std::is_pointer_v<TYPE>, \"Reinterpreting as pointers to pointers is disallowed!\");\n      #endif\n      return reinterpret_cast<T2*>(ptr);\n    }\n\n    /// Get the unique ID associated with this pointer.\n    size_t GetID() const { return id; }\n\n    /// Reallocate this Ptr to a newly allocated value using arguments passed in.\n    template <typename... T>\n    void New(T &&... args) {\n      Tracker().DecID(id);                               // Remove a pointer to any old memory...\n\n      ptr = new TYPE(std::forward<T>(args)...);          // Special new that uses allocated space.\n      // ptr = (TYPE*) malloc (sizeof(TYPE));            // Build a new raw pointer.\n      // emp_emscripten_assert(ptr);                     // No exceptions in emscripten; assert alloc!\n      // ptr = new (ptr) TYPE(std::forward<T>(args)...); // Special new that uses allocated space.\n\n      if (internal::ptr_debug) std::cout << \"Ptr::New() : \" << ptr << std::endl;\n      id = Tracker().New(ptr);                        // And track it!\n      DebugInfo().AddPtr();\n    }\n\n    /// Reallocate this Ptr to a newly allocated array using the size passed in.\n    // template <typename... Ts>\n    // void NewArray(size_t array_size, Ts &&... args) {\n    void NewArray(size_t array_size) {\n      Tracker().DecID(id);                              // Remove a pointer to any old memory...\n\n      // @CAO: This next portion of code is allocating an array of the appropriate type.\n      //       We are currently using \"new\", but should shift over to malloc since new throws an\n      //       exception when there's a problem, which will trigger an abort in Emscripten mode.\n      //       We'd rather be able to identify a more specific problem.\n      ptr = new TYPE[array_size];                     // Build a new raw pointer to an array.\n      // ptr = (TYPE*) malloc (array_size * sizeof(TYPE)); // Build a new raw pointer.\n      // emp_emscripten_assert(ptr, array_size);           // No exceptions in emscripten; assert alloc!\n      // for (size_t i = 0; i < array_size; i++) {\n      //   new (ptr + i*sizeof(TYPE)) TYPE(args...);\n      // }\n\n      if (internal::ptr_debug) std::cout << \"Ptr::NewArray() : \" << ptr << std::endl;\n      id = Tracker().NewArray(ptr, array_size * sizeof(TYPE));   // And track it!\n      DebugInfo().AddPtr();\n    }\n\n    /// Delete this pointer (must NOT be an array).\n    void Delete() {\n      emp_assert(ptr, \"Trying to delete null Ptr.\");\n      emp_assert(id < Tracker().GetNumIDs(), id, \"Trying to delete Ptr that we are not resposible for.\");\n      emp_assert(Tracker().IsArrayID(id) == false, id, \"Trying to delete array pointer as non-array.\");\n      emp_assert(Tracker().IsActive(ptr), id, \"Trying to delete inactive pointer (already deleted!)\");\n      if (internal::ptr_debug) std::cout << \"Ptr::Delete() : \" << ptr << std::endl;\n      delete ptr;\n      Tracker().MarkDeleted(id);\n      DebugInfo().RemovePtr();\n    }\n\n    /// Delete this pointer to an array (must be an array).\n    void DeleteArray() {\n      emp_assert(id < Tracker().GetNumIDs(), id, \"Trying to delete Ptr that we are not resposible for.\");\n      emp_assert(ptr, \"Trying to delete null Ptr.\");\n      emp_assert(Tracker().IsArrayID(id), id, \"Trying to delete non-array pointer as array.\");\n      emp_assert(Tracker().IsActive(ptr), id, \"Trying to delete inactive pointer (already deleted!)\");\n      if (internal::ptr_debug) std::cout << \"Ptr::DeleteArray() : \" << ptr << std::endl;\n      delete [] ptr;\n      Tracker().MarkDeleted(id);\n      DebugInfo().RemovePtr();\n    }\n\n    /// Convert this pointer to a hash value.\n    size_t Hash() const noexcept {\n      // Chop off useless bits of pointer...\n      static constexpr size_t shift = internal::Log2(1 + sizeof(TYPE));\n      return (size_t)(ptr) >> shift;\n    }\n    struct hash_t { size_t operator()(const Ptr<TYPE> & t) const noexcept { return t.Hash(); } };\n\n    /// Copy assignment\n    Ptr<TYPE> & operator=(const Ptr<TYPE> & _in) {\n      if (internal::ptr_debug) {\n        std::cout << \"copy assignment from id \" << _in.id << \" to id \" << id\n                  << std::endl;\n      }\n      emp_assert(Tracker().IsDeleted(_in.id) == false, _in.id, \"Do not copy deleted pointers.\");\n      if (id != _in.id || ptr != _in.ptr) {        // Assignments only need to happen if ptrs are different.\n        if (internal::ptr_debug) std::cout << \"...pointers differ -- copying!\" << std::endl;\n        Tracker().DecID(id);\n        ptr = _in.ptr;\n        id = _in.id;\n        Tracker().IncID(id);\n      } else {\n        if (internal::ptr_debug) std::cout << \"...pointers same -- no copying!\" << std::endl;\n      }\n      return *this;\n    }\n\n    /// Assign to a raw pointer of the correct type; if this is already tracked, hooked in\n    /// correctly, otherwise don't track.\n    template <typename T2>\n    Ptr<TYPE> & operator=(T2 * _in) {\n      if (internal::ptr_debug) std::cout << \"raw assignment\" << std::endl;\n      emp_assert( (PtrIsConvertable<T2, TYPE>(_in)) );\n\n      Tracker().DecID(id);    // Decrement references to former pointer at this position.\n      ptr = _in;              // Update to new pointer.\n\n      // If this pointer is already active, link to it.\n      if (Tracker().IsActive(ptr)) {\n        id = Tracker().GetCurID(ptr);\n        Tracker().IncID(id);\n      }\n      // Otherwise, since this ptr was passed in as a raw pointer, we do not manage it.\n      else {\n        id = UNTRACKED_ID;\n      }\n\n      return *this;\n    }\n\n    /// Assign to a convertable Ptr\n    template <typename T2>\n    Ptr<TYPE> & operator=(Ptr<T2> _in) {\n      if (internal::ptr_debug) std::cout << \"convert-copy assignment\" << std::endl;\n      emp_assert( (PtrIsConvertable<T2, TYPE>(_in.Raw())), _in.id );\n      emp_assert(Tracker().IsDeleted(_in.id) == false, _in.id, \"Do not copy deleted pointers.\");\n      Tracker().DecID(id);\n      ptr = _in.Raw();\n      id = _in.GetID();\n      Tracker().IncID(id);\n      return *this;\n    }\n\n    /// Auto-cast to raw pointer type.\n    operator TYPE *() {\n      // Make sure a pointer is active before we convert it.\n      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);\n\n      // We should not automatically convert managed pointers to raw pointers; use .Raw()\n      emp_assert(id != UNTRACKED_ID /*, typeid(TYPE).name() */, id,\n                 \"Use Raw() to convert to an untracked Ptr\");\n      return ptr;\n    }\n\n    /// Does this pointer exist?\n    operator bool() { return ptr != nullptr; }\n\n    /// Does this const pointer exist?\n    operator bool() const { return ptr != nullptr; }\n\n    /// Does this Ptr point to the same memory position?\n    bool operator==(const Ptr<TYPE> & in_ptr) const { return ptr == in_ptr.ptr; }\n\n    /// Does this Ptr point to different memory positions?\n    bool operator!=(const Ptr<TYPE> & in_ptr) const { return ptr != in_ptr.ptr; }\n\n    /// Does this Ptr point to a memory position before another?\n    bool operator<(const Ptr<TYPE> & in_ptr)  const { return ptr < in_ptr.ptr; }\n\n    /// Does this Ptr point to a memory position before or equal to another?\n    bool operator<=(const Ptr<TYPE> & in_ptr) const { return ptr <= in_ptr.ptr; }\n\n    /// Does this Ptr point to a memory position after another?\n    bool operator>(const Ptr<TYPE> & in_ptr)  const { return ptr > in_ptr.ptr; }\n\n    /// Does this Ptr point to a memory position after or equal to another?\n    bool operator>=(const Ptr<TYPE> & in_ptr) const { return ptr >= in_ptr.ptr; }\n\n\n    /// Does this Ptr point to the same memory position as a raw pointer?\n    bool operator==(const TYPE * in_ptr) const { return ptr == in_ptr; }\n\n    /// Does this Ptr point to different memory positions as a raw pointer?\n    bool operator!=(const TYPE * in_ptr) const { return ptr != in_ptr; }\n\n    /// Does this Ptr point to a memory position before a raw pointer?\n    bool operator<(const TYPE * in_ptr)  const { return ptr < in_ptr; }\n\n    /// Does this Ptr point to a memory position before or equal to a raw pointer?\n    bool operator<=(const TYPE * in_ptr) const { return ptr <= in_ptr; }\n\n    /// Does this Ptr point to a memory position after a raw pointer?\n    bool operator>(const TYPE * in_ptr)  const { return ptr > in_ptr; }\n\n    /// Does this Ptr point to a memory position after or equal to a raw pointer?\n    bool operator>=(const TYPE * in_ptr) const { return ptr >= in_ptr; }\n\n    [[nodiscard]] Ptr<TYPE> operator+(int value) const { return ptr + value; }\n    [[nodiscard]] Ptr<TYPE> operator-(int value) const { return ptr - value; }\n    [[nodiscard]] Ptr<TYPE> operator+(size_t value) const { return ptr + value; }\n    [[nodiscard]] Ptr<TYPE> operator-(size_t value) const { return ptr - value; }\n\n    /// Fill an array with the provided fill_value.\n    /// If fill_value is a function, repeatedly call function.\n    template <typename T>\n    void FillMemoryFunction(const size_t num_bytes, T fill_fun) {\n      // Make sure a pointer is active before we write to it.\n      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);\n      emp_assert(id == UNTRACKED_ID || Tracker().IsArrayID(id), \"Only arrays can fill memory.\", id);\n      emp_assert(id == UNTRACKED_ID || Tracker().GetArrayBytes(id) >= num_bytes,\n        \"Overfilling memory.\", id, ptr, sizeof(TYPE), Tracker().GetArrayBytes(id));\n      emp_assert(ptr != nullptr, \"Do not follow a null pointer!\");\n\n      emp::FillMemoryFunction(*this, num_bytes, fill_fun);\n    }\n\n    /// Fill an array with the provided fill_value.\n    /// If fill_value is a function, repeatedly call function.\n    template <typename T>\n    void FillMemory(const size_t num_bytes, T fill_value) {\n      // Make sure a pointer is active before we write to it.\n      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);\n      emp_assert(Tracker().IsArrayID(id) || id == UNTRACKED_ID, \"Only arrays can fill memory.\", id);\n      emp_assert(Tracker().GetArrayBytes(id) >= num_bytes,\n        \"Overfilling memory.\", id, ptr, sizeof(TYPE), Tracker().GetArrayBytes(id));\n      emp_assert(ptr != nullptr, \"Do not follow a null pointer!\");\n\n      emp::FillMemory(*this, num_bytes, fill_value);\n    }\n\n    /// Some debug testing functions\n    int DebugGetCount() const { return Tracker().GetIDCount(id); }\n    bool DebugIsArray() const { return Tracker().IsArrayID(id); }\n    size_t DebugGetArrayBytes() const { return Tracker().GetArrayBytes(id); }\n    bool DebugIsActive() const { return Tracker().IsActiveID(id); }\n\n    bool OK() const {\n      // Untracked ID's should not have pointers in the Tracker.\n      if (id == UNTRACKED_ID) return !Tracker().HasPtr(ptr);\n\n      // Make sure this pointer is linked to the correct info.\n      if (Tracker().GetInfo(id).GetPtr() != ptr) return false;\n\n      // And make sure that info itself is okay.\n      return Tracker().GetInfo(id).OK();\n    }\n\n    // Prevent use of new and delete on Ptr\n    // static void* operator new(std::size_t) noexcept {\n    //   emp_assert(false, \"No Ptr::operator new; use emp::NewPtr for clarity.\");\n    //   return nullptr;\n    // }\n    // static void* operator new[](std::size_t sz) noexcept {\n    //   emp_assert(false, \"No Ptr::operator new[]; use emp::NewPtrArray for clarity.\");\n    //   return nullptr;\n    // }\n    //\n    // static void operator delete(void* ptr, std::size_t sz) {\n    //   emp_assert(false, \"No Ptr::operator delete; use Delete() member function for clarity.\");\n    // }\n    // static void operator delete[](void* ptr, std::size_t sz) {\n    //   emp_assert(false, \"No Ptr::operator delete[]; use DeleteArray() member function for clarity.\");\n    // }\n\n  };\n\n#else  // EMP_MEM_TRACK off...\n\n\n  template <typename TYPE>\n  class BasePtr {\n  protected:\n    TYPE * ptr;                 ///< The raw pointer associated with this Ptr object.\n\n  public:\n    BasePtr(TYPE * in_ptr) : ptr(in_ptr) { }\n\n    // Dereference a pointer.\n    [[nodiscard]] TYPE & operator*() const { return *ptr; }\n\n    // Follow a pointer.\n    TYPE * operator->() const { return ptr; }\n\n    // Should implement operator->* to follow a pointer to a member function.\n    // For an example, see:\n    //  https://stackoverflow.com/questions/27634036/overloading-operator-in-c\n\n    // Indexing into array\n    TYPE & operator[](size_t pos) const { return ptr[pos]; }\n  };\n\n  /// Base class with functionality only needed in void pointers.\n  template <> class BasePtr<void> {\n  protected: void * ptr;                 ///< The raw pointer associated with this Ptr object.\n  public: BasePtr(void * in_ptr) : ptr(in_ptr) { }\n  };\n\n  template <> class BasePtr<const void> {\n  protected: const void * ptr;           ///< The raw pointer associated with this Ptr object.\n  public: BasePtr(const void * in_ptr) : ptr(in_ptr) { }\n  };\n\n  template <typename TYPE>\n  class Ptr : public BasePtr<TYPE> {\n  private:\n    using BasePtr<TYPE>::ptr;\n\n  public:\n    using element_type = TYPE;\n\n    /// Default constructor\n    Ptr() : BasePtr<TYPE>(nullptr) {}\n\n    /// Copy constructor\n    Ptr(const Ptr<TYPE> & _in) : BasePtr<TYPE>(_in.ptr) {}\n\n    /// Construct from raw ptr\n    template <typename T2> Ptr(T2 * in_ptr, bool=false) : BasePtr<TYPE>(in_ptr) {}\n\n    /// Construct from array\n    template <typename T2> Ptr(T2 * _ptr, size_t, bool) : BasePtr<TYPE>(_ptr) {}\n\n    /// From compatible Ptr\n    template <typename T2> Ptr(Ptr<T2> _in) : BasePtr<TYPE>(_in.Raw()) {}\n\n    /// From nullptr\n    Ptr(std::nullptr_t) : Ptr() {}\n\n    /// Destructor\n    ~Ptr() { ; }\n\n    [[nodiscard]] bool IsNull() const { return ptr == nullptr; }\n    [[nodiscard]] TYPE * Raw() const { return ptr; }\n    [[nodiscard]] TYPE * Raw(size_t pos) const { return &(ptr[pos]); }\n    template <typename T2> Ptr<T2> Cast() const { return (T2*) ptr; }\n    template <typename T2> Ptr<T2> ConstCast() const { return const_cast<T2*>(ptr); }\n    template <typename T2> Ptr<T2> DynamicCast() const { return dynamic_cast<T2*>(ptr); }\n    template <typename T2> Ptr<T2> ReinterpretCast() const { return reinterpret_cast<T2*>(ptr); }\n\n    template <typename... T>\n    void New(T &&... args) { ptr = new TYPE(std::forward<T>(args)...); }  // New raw pointer.\n    void NewArray(size_t array_size) { ptr = new TYPE[array_size]; }\n    void Delete() { delete ptr; }\n    void DeleteArray() { delete [] ptr; }\n\n    size_t Hash() const noexcept {\n      static constexpr size_t shift = internal::Log2(1 + sizeof(TYPE));  // Chop off useless bits...\n      return (size_t)(ptr) >> shift;\n    }\n    struct hash_t { size_t operator()(const Ptr<TYPE> & t) const noexcept { return t.Hash(); } };\n\n    // Copy assignments\n    Ptr<TYPE> & operator=(const Ptr<TYPE> & _in) { ptr = _in.ptr; return *this; }\n\n    // Assign to compatible Ptr or raw (non-managed) pointer.\n    template <typename T2> Ptr<TYPE> & operator=(T2 * _in) { ptr = _in; return *this; }\n    template <typename T2> Ptr<TYPE> & operator=(Ptr<T2> _in) { ptr = _in.Raw(); return *this; }\n\n    // Auto-cast to raw pointer type.\n    operator TYPE *() { return ptr; }\n\n    operator bool() { return ptr != nullptr; }\n    operator bool() const { return ptr != nullptr; }\n\n    // Comparisons to other Ptr objects\n    bool operator==(const Ptr<TYPE> & in_ptr) const { return ptr == in_ptr.ptr; }\n    bool operator!=(const Ptr<TYPE> & in_ptr) const { return ptr != in_ptr.ptr; }\n    bool operator<(const Ptr<TYPE> & in_ptr)  const { return ptr < in_ptr.ptr; }\n    bool operator<=(const Ptr<TYPE> & in_ptr) const { return ptr <= in_ptr.ptr; }\n    bool operator>(const Ptr<TYPE> & in_ptr)  const { return ptr > in_ptr.ptr; }\n    bool operator>=(const Ptr<TYPE> & in_ptr) const { return ptr >= in_ptr.ptr; }\n\n    // Comparisons to raw pointers.\n    bool operator==(const TYPE * in_ptr) const { return ptr == in_ptr; }\n    bool operator!=(const TYPE * in_ptr) const { return ptr != in_ptr; }\n    bool operator<(const TYPE * in_ptr)  const { return ptr < in_ptr; }\n    bool operator<=(const TYPE * in_ptr) const { return ptr <= in_ptr; }\n    bool operator>(const TYPE * in_ptr)  const { return ptr > in_ptr; }\n    bool operator>=(const TYPE * in_ptr) const { return ptr >= in_ptr; }\n\n    [[nodiscard]] Ptr<TYPE> operator+(int value) const { return ptr + value; }\n    [[nodiscard]] Ptr<TYPE> operator-(int value) const { return ptr - value; }\n    [[nodiscard]] Ptr<TYPE> operator+(size_t value) const { return ptr + value; }\n    [[nodiscard]] Ptr<TYPE> operator-(size_t value) const { return ptr - value; }\n\n    // Extra functionality (not in raw pointers)\n\n    /// Fill an array with the provided fill_value.\n    /// If fill_value is a function, repeatedly call function.\n    template <typename T>\n    void FillMemoryFunction(const size_t num_bytes, T fill_fun) {\n      emp::FillMemoryFunction(*this, num_bytes, fill_fun);\n    }\n\n    /// Fill an array with the provided fill_value.\n    /// If fill_value is a function, repeatedly call function.\n    template <typename T>\n    void FillMemory(const size_t num_bytes, T fill_value) {\n      emp::FillMemory(*this, num_bytes, fill_value);\n    }\n\n    // Stubs for debug-related functions when outside debug mode.\n    int DebugGetCount() const { return -1; }\n    bool DebugIsArray() const { emp_assert(false); return false; }\n    size_t DebugGetArrayBytes() const { return 0; }\n    bool DebugIsActive() const { return true; }\n    bool OK() const { return true; }\n  };\n\n#endif // #ifdef EMP_TRACK_MEM\n\n  // IO\n  template <typename T>\n  std::ostream & operator<<(std::ostream & out, const emp::Ptr<T> & ptr) {\n    out << ptr.Raw();\n    return out;\n  }\n\n  // @CAO: Reading a pointer from a stream seems like a terrible idea in most situations, but I\n  // can imagine limited circumstances where it would be needed.\n  template <typename T, typename... Ts>\n  std::istream & operator>>(std::istream & is, emp::Ptr<T> & ptr) {\n    T * val;\n    is >> val;\n    ptr = val;\n    return is;\n  }\n\n  /// Convert a T* to a Ptr<T>.  By default, don't track.\n  template <typename T>\n  [[nodiscard]] Ptr<T> ToPtr(T * _in, bool own=false) { return Ptr<T>(_in, own); }\n\n  /// Convert a T* to a Ptr<T> that we DO track.\n  template <typename T>\n  [[nodiscard]] Ptr<T> TrackPtr(T * _in, bool own=true) { return Ptr<T>(_in, own); }\n\n  /// Create a new Ptr of the target type; use the args in the constructor.\n  template <typename T, typename... ARGS>\n  [[nodiscard]] Ptr<T> NewPtr(ARGS &&... args) {\n    auto ptr = new T(std::forward<ARGS>(args)...);\n    // auto ptr = (T*) malloc (sizeof(T));         // Build a new raw pointer.\n    // emp_assert(ptr);                            // No exceptions in emscripten; assert alloc!\n    // new (ptr) T(std::forward<ARGS>(args)...);   // Special new that uses allocated space.\n    return Ptr<T>(ptr, true);\n  }\n\n  /// Copy an object pointed to and return a Ptr to the copy.\n  template <typename T>\n  [[nodiscard]] Ptr<T> CopyPtr(Ptr<T> in) { return NewPtr<T>(*in); }\n\n  /// Copy a vector of objects pointed to; return a vector of Ptrs to the new copies.\n  template <typename T>\n  [[nodiscard]] emp::vector<Ptr<T>> CopyPtrs(const emp::vector<Ptr<T>> & in) {\n    emp::vector<Ptr<T>> out_ptrs(in.size());\n    for (size_t i = 0; i < in.size(); i++) out_ptrs[i] = CopyPtr(in[i]);\n    return out_ptrs;\n  }\n\n  /// Copy a vector of objects pointed to by using their Clone() member function; return vector.\n  template <typename T>\n  [[nodiscard]] emp::vector<Ptr<T>> ClonePtrs(const emp::vector<Ptr<T>> & in) {\n    emp::vector<Ptr<T>> out_ptrs(in.size());\n    for (size_t i = 0; i < in.size(); i++) out_ptrs[i] = in[i]->Clone();\n    return out_ptrs;\n  }\n\n  /// Create a pointer to an array of objects.\n  template <typename T>\n  [[nodiscard]] Ptr<T> NewArrayPtr(size_t array_size) {\n    auto ptr = new T[array_size];                     // Build a new raw pointer.\n    // const size_t alloc_size = array_size * sizeof(T);\n    // auto ptr = (T*) malloc (alloc_size);\n    emp_assert(ptr, array_size);                      // No exceptions in emscripten; assert alloc!\n    // for (size_t i = 0; i < array_size; i++) {         // Loop through all array elements.\n    //   new (ptr + i*sizeof(T)) T(args...);             //    ...and initialize them.\n    // }\n    return Ptr<T>(ptr, array_size, true);\n  }\n\n  /// Fill an array with the provided fill_value.\n  /// If fill_value is a function, repeatedly call function.\n  template <typename T>\n  void FillMemory(emp::Ptr<unsigned char>  mem_ptr, const size_t num_bytes, T fill_value) {\n    // If the fill value is a function, call that function for each memory position.\n    if constexpr (std::is_invocable_v<T>) {\n      FillMemoryFunction(mem_ptr, num_bytes, std::forward<T>(fill_value));\n    }\n\n    constexpr size_t FILL_SIZE = sizeof(T);\n\n    const size_t leftover = num_bytes % FILL_SIZE;\n    const size_t limit = num_bytes - leftover;\n    unsigned char * dest = mem_ptr.Raw();\n\n    // Fill out random bytes in groups of FILL_SIZE.\n    for (size_t byte = 0; byte < limit; byte += FILL_SIZE) {\n      std::memcpy(dest+byte, &fill_value, FILL_SIZE);\n    }\n\n    // If we don't have a multiple of FILL_SIZE, fill in part of the remaining.\n    if (leftover) std::memcpy(dest+limit, &fill_value, leftover);\n  }\n\n  /// Fill an array by repeatedly calling the provided fill functions.\n  template <typename T>\n  void FillMemoryFunction(emp::Ptr<unsigned char>  mem_ptr, const size_t num_bytes, T fill_fun) {\n    static_assert(std::is_invocable_v<T>, \"FillMemoryFunction requires an invocable fill_fun.\");\n    using return_t = decltype(fill_fun());\n    constexpr size_t FILL_SIZE = sizeof(return_t);\n\n    const size_t leftover = num_bytes % FILL_SIZE;\n    const size_t limit = num_bytes - leftover;\n    unsigned char * dest = mem_ptr.Raw();\n\n    // Fill out random bytes in groups of FILL_SIZE.\n    return_t fill_value;\n    for (size_t byte = 0; byte < limit; byte += FILL_SIZE) {\n      fill_value = fill_fun();\n      std::memcpy(dest+byte, &fill_value, FILL_SIZE);\n    }\n\n    // If we don't have a multiple of FILL_SIZE, fill in part of the remaining.\n    if (leftover) {\n      fill_value = fill_fun();\n      std::memcpy(dest+limit, &fill_value, leftover);\n    }\n  }\n\n} // namespace emp\n\n#endif // #ifndef EMP_BASE_PTR_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2016-2021.\n *\n *  @file math.hpp\n *  @brief Useful mathematical functions (that are constexpr when possible.)\n *  @note Status: BETA (though new functions are added frequently)\n */\n\n#ifndef EMP_MATH_MATH_HPP_INCLUDE\n#define EMP_MATH_MATH_HPP_INCLUDE\n\n\n#include <algorithm>\n#include <cmath>\n#include <initializer_list>\n#include <numeric>\n\n#include \"../base/assert.hpp\"\n#include \"../meta/reflection.hpp\"\n\n#include \"constants.hpp\"\n#include \"Random.hpp\"\n\nnamespace emp {\n\n  /// % is actually remainder; Mod is a proper modulus command that handles negative #'s correctly\n  inline constexpr int Mod(int in_val, int mod_val) {\n    emp_assert(mod_val != 0);\n    in_val %= mod_val;\n    return (in_val < 0) ? (in_val + mod_val) : in_val;\n  }\n\n  /// Regular Mod doesn't work on doubles.  Build one that does!\n  // @CAO Make constexpr?\n  inline double Mod(double in_val, double mod_val) {\n    emp_assert(mod_val != 0);\n    const double remain = std::remainder(in_val, mod_val);\n    return (remain < 0.0) ? (remain + mod_val) : remain;\n  }\n\n  /// Calculate the sign (i.e., +1, -1, or 0) of a value.\n  template <typename T> inline int Sgn(T val) {\n    return (T(0) < val) - (val < T(0));\n  }\n\n  /// Find the absolute value for any variable.\n  template <typename T> constexpr T Abs(T in) { return (in > 0) ? in : (-in); }\n\n  /// Divide one integer by another, rounding towards minus infinity.\n  int inline FloorDivide(int dividend, int divisor) {\n    int q = dividend/divisor;\n    int r = dividend%divisor;\n    if ((r!=0) && ((r<0) != (divisor<0))) --q;\n    return q;\n  }\n\n  /// Default integer division is truncated, not rounded.\n  /// Round the division result instead of truncating it.\n  /// Rounding ties (i.e., result % divisor == 0.5) are rounded up.\n  int inline RoundedDivide(int dividend, int divisor) {\n    //TODO add emp_assert to check for overflow\n    emp_assert(divisor != 0);\n    // adding divisor/2 to dividend\n    // is equivalent to adding 1/2 to the result\n    return FloorDivide(dividend + divisor / 2, divisor);\n  }\n\n  /// Default integer division is truncated, not rounded.\n  /// Round the division result instead of truncating it.\n  /// Rounding ties (i.e., result % divisor == 0.5)\n  /// will be rounded up.\n  size_t inline RoundedDivide(size_t dividend, size_t divisor) {\n    //TODO add emp_assert to check for overflow\n    emp_assert(divisor != 0);\n    // adding divisor/2 to dividend\n    // is equivalent to adding 1/2 to the result\n    return (dividend + divisor / 2) / divisor;\n  }\n\n  /// Regular integer division is truncated, not rounded.\n  /// Round the division result instead of truncating it.\n  /// Rounding ties (i.e., result % divisor == 0.5) are broken\n  /// by coin toss.\n  int inline UnbiasedDivide(int dividend, int divisor, emp::Random& r) {\n    //TODO add emp_assert to check for overflow\n    int res = RoundedDivide(dividend, divisor);\n    // if dividend/divisor % 1 == 0.5...\n    if (Abs(dividend % divisor) * 2 == Abs(divisor)) {\n      // ... by default, the result is rounded up;\n      // with 1/2 probability round down instead\n      res -= r.GetInt(2);\n    }\n    return res;\n  }\n\n  /// Regular integer division is truncated, not rounded.\n  /// Round the division result instead of truncating it.\n  /// Rounding ties (i.e., result % divisor == 0.5) are broken\n  /// by coin toss.\n  inline size_t UnbiasedDivide(size_t dividend, size_t divisor, emp::Random& r) {\n    //TODO add emp_assert to check for overflow\n    size_t res = RoundedDivide(dividend, divisor);\n    // if dividend/divisor % 1 == 0.5...\n    if ((dividend % divisor) * 2 == divisor) {\n      // ... by default, the result is rounded up;\n      // with 1/2 probability round down instead\n      res -= r.GetUInt(2);\n    }\n    return res;\n  }\n\n  /// Run both min and max on a value to put it into a desired range.\n  template <typename TYPE> constexpr TYPE ToRange(const TYPE & value, const TYPE & in_min, const TYPE & in_max) {\n    emp_assert(in_min <= in_max);\n    return (value < in_min) ? in_min : ((value > in_max) ? in_max : value);\n  }\n\n  /// Min of only one element is that element itself!\n  template <typename T> constexpr T Min(T in1) { return in1; }\n\n  /// Min of multiple elements is solved recursively.\n  template <typename T, typename... Ts>\n  constexpr T Min(T in1, T in2, Ts... extras) {\n    T cur_result = Min(in2, extras...);\n    return (in1 < cur_result) ? in1 : cur_result;\n  }\n\n\n  /// Max of only one element is that element itself!\n  template <typename T> constexpr T Max(T in1) { return in1; }\n\n  /// Max of multiple elements is solved recursively.\n  template <typename T, typename... Ts>\n  constexpr T Max(T in1, T in2, Ts... extras) {\n    T cur_result = Max(in2, extras...);\n    return (in1 < cur_result) ? cur_result : in1;\n  }\n\n  /// MinRef works like Min, but never copies any inputs; always treats as references.\n  /// MinRef of only one element returns reference to that element itself!\n  template <typename T> constexpr const T & MinRef(const T& in1) { return in1; }\n\n  /// MinRef of multiple elements returns reference to minimum value.\n  template <typename T, typename... Ts>\n  constexpr const T & MinRef(const T& in1, const T& in2, const Ts&... extras) {\n    const T & cur_result = MinRef(in2, extras...);\n    return (in1 < cur_result) ? in1 : cur_result;\n  }\n\n\n  /// MaxRef works like Max, but never copies any inputs; always treats as references.\n  /// MaxRef of only one element returns reference to that element itself!\n  template <typename T> constexpr const T & MaxRef(const T& in1) { return in1; }\n\n  /// MaxRef of multiple elements returns reference to maximum value.\n  template <typename T, typename... Ts>\n  constexpr const T & MaxRef(const T& in1, const T& in2, const Ts&... extras) {\n    const T & cur_result = MaxRef(in2, extras...);\n    return (in1 < cur_result) ? cur_result : in1;\n  }\n\n  #ifndef DOXYGEN_SHOULD_SKIP_THIS\n  namespace internal {\n    // A compile-time log calculator for values [1,2)\n    static constexpr double Log2_base(double x) {\n      emp_assert(x > 0);\n      return log2_chart_1_2[(int)((x-1.0)*1024)];\n      // return InterpolateTable(log2_chart_1_2, x-1.0, 1024);\n    }\n\n    // A compile-time log calculator for values < 1\n    static constexpr double Log2_frac(double x) {\n      emp_assert(x > 0);\n      return (x >= 1.0) ? Log2_base(x) : (Log2_frac(x*2.0) - 1.0);\n    }\n\n    // A compile-time log calculator for values >= 2\n    static constexpr double Log2_pos(double x) {\n      emp_assert(x > 0);\n      emp_assert(x != INFINITY);\n      return (x < 2.0) ? Log2_base(x) : (Log2_pos(x/2.0) + 1.0);\n    }\n\n  }\n  #endif // DOXYGEN_SHOULD_SKIP_THIS\n\n  /// Compile-time log base 2 calculator.\n  static constexpr double Log2(double x) {\n    emp_assert(x > 0);\n    return (x < 1.0) ? internal::Log2_frac(x) : internal::Log2_pos(x);\n  }\n\n  /// Compile-time log calculator\n  static constexpr double Log(double x, double base=10.0) { return Log2(x) / Log2(base); }\n  /// Compile-time natural log calculator\n  static constexpr double Ln(double x) { return Log(x, emp::E); }   // Natural Log...\n  /// Compile-time log base 10 calculator.\n  static constexpr double Log10(double x) { return Log(x, 10.0); }\n\n  /// A simple function to square a value.\n  template <typename T>\n  static constexpr T Square(T val) { return val * val; }\n\n  // Pow helper functions.\n  #ifndef DOXYGEN_SHOULD_SKIP_THIS\n  namespace internal {\n    static constexpr double Pow2_lt1(double exp, int id=0) {\n      return (id==32) ? 1.0 :\n        ( (exp > 0.5) ? (pow2_chart_bits[id]*Pow2_lt1(exp*2.0-1.0,id+1)) : Pow2_lt1(exp*2.0,id+1) );\n    }\n\n    static constexpr double Pow2_impl(double exp) {\n      return (exp >= 1.0) ? (2.0*Pow2_impl(exp-1.0)) : Pow2_lt1(exp);\n    }\n  }\n\n  namespace internal {\n  /// A fast (O(log p)) integral-power command.\n  template <typename T>\n  static constexpr T PowIntImpl(T base, T p) {\n    if (p <= 0) return 1;\n    if (p & 1) return base * PowIntImpl(base, p-1); // Odd exponent: strip one mulitple off and recurse.\n    return emp::Square( PowIntImpl(base,p/2) );          // Even exponent: calc for half and square result.\n  }\n  } // namespace internal\n  #endif // DOXYGEN_SHOULD_SKIP_THIS\n\n  /// A fast 2^x command.\n  static constexpr double Pow2(double exp) {\n    if (exp > 1024) return std::numeric_limits<double>::infinity();\n    return (exp < 0.0) ? (1.0/internal::Pow2_impl(-exp)) : internal::Pow2_impl(exp);\n  }\n\n  /// A fast method for calculating exponents for int types.\n  template <typename TYPE>\n  static constexpr TYPE IntPow(TYPE base, TYPE exp) {\n    emp_assert(exp < 65536); // Set a crazy-high limit for exp to identify problems...\n    return exp < 1 ? 1 : (base * IntPow(base, exp-1));\n  }\n\n  #ifndef DOXYGEN_SHOULD_SKIP_THIS\n  namespace internal {\n  /// A fast method for calculating exponents on doubles.\n  static constexpr double PowDoubleImpl(double base, double exp) {\n    // Normally, convert to a base of 2 and then use Pow2.\n    // If base is negative, we don't want to deal with imaginary numbers, so use IntPow.\n    return (base > 0)\n      ? emp::Pow2(emp::Log2(base) * exp)\n      : emp::IntPow(base,exp);\n  }\n\n  // adapted from https://stackoverflow.com/a/30836042\n  // prevents argument from being used for type deduction\n  template <typename T> struct identity { typedef T type; };\n\n  } // namespace internal\n  #endif // DOXYGEN_SHOULD_SKIP_THIS\n\n  /// A fast method for calculating exponents on doubles or integral types.\n  /// Uses if constexpr to work around compiler bug in Emscripten (issue #296).\n  template<typename T>\n  static constexpr T Pow(\n    T base, typename internal::identity<T>::type exp\n  ) {\n    // TODO cpp20, C++20 replace with std::is_constant_evaluated\n    // adapted from https://stackoverflow.com/a/62610143\n    // exclude clang versions with compiler bug https://reviews.llvm.org/D35190\n    #if defined(__clang__) && __clang_major__>=9 || defined(__GNUC__) && !defined(__clang__)\n    // if base is not known at compile time, use std::pow which is faster\n    if ( !__builtin_constant_p( base ) ) return std::pow(base, exp);\n    // otherwise, use constexpr-friendly implementations\n    else\n    #endif\n    if constexpr( std::is_integral<T>::value ){\n      return internal::PowIntImpl(base, exp);\n    } else return internal::PowDoubleImpl(base, exp);\n  }\n\n  // A fast (O(log p)) integer-power command.\n  // static constexpr int Pow(int base, int p) {\n  //   return (p <= 0) ? 1 : (base * Pow(base, p-1));\n  // }\n\n  /// A fast method of calculating e^x\n  static constexpr double Exp(double exp) {\n    return Pow2(Log2(emp::E) * exp);  // convert to a base of e.\n  }\n\n\n  /// A compile-time int-log calculator (aka, significant bits)\n  template <typename TYPE>\n  static constexpr int IntLog2(TYPE x) { return x <= 1 ? 0 : (IntLog2(x/2) + 1); }\n\n\n  /// Return the minimum of three values.\n  template <typename T> constexpr const T & Min(const T& in1, const T& in2, const T& in3) {\n    return std::min(std::min(in1,in2), in3);\n  }\n\n  /// A version of Min that allows a variable number of inputs to be compared.\n  template <typename T> const T & Min(std::initializer_list<const T&> lst) {\n    emp_assert(lst.size > 0); // Nothing to return if nothing in the list!\n    auto min_found = lst.begin();\n    for (auto it = lst.begin()+1; it < lst.end(); it++) {\n      if (*it < *min_found) min_found = it;\n    }\n    return *min_found;\n  }\n\n  /// A version of Max that allows a variable number of inputs to be compared.\n  template <typename T> const T & Max(std::initializer_list<const T&> lst) {\n    emp_assert(lst.size > 0); // Nothing to return if nothing in the list!\n    auto max_found = lst.begin();\n    for (auto it = lst.begin()+1; it < lst.end(); it++) {\n      if (*it > *max_found) max_found = it;\n    }\n    return *max_found;\n  }\n\n  /// Returns the next power of two (in 64-bits) that is strictly greater than A.\n  /// Returns zero on overflow.\n  inline uint64_t NextPowerOf2(uint64_t A) {\n    A |= (A >> 1);\n    A |= (A >> 2);\n    A |= (A >> 4);\n    A |= (A >> 8);\n    A |= (A >> 16);\n    A |= (A >> 32);\n    return A + 1;\n  }\n\n  /// Tests if a number is a power of two.\n  inline constexpr bool IsPowerOf2(const size_t x) {\n    return x > 0 && !(x & (x - 1));\n  }\n\n  inline constexpr int Factorial(int i) {\n    int result = 1;\n    while (i > 0) {\n      result *= i;\n      i--;\n    }\n    return result;\n  }\n\n  /// Toggle an input bool.\n  inline bool Toggle(bool & in_bool) { return (in_bool = !in_bool); }\n\n  /// Combine bools to AND them all together.\n  inline constexpr bool AllTrue() { return true; }\n  template <typename... Ts>\n  inline bool AllTrue(bool result, Ts... OTHER) {\n    return result && AllTrue(OTHER...);\n  }\n\n  /// Combine bools to OR them all together.\n  inline constexpr bool AnyTrue() { return false; }\n  template <typename... Ts>\n  inline bool AnyTrue(bool result, Ts... OTHER) {\n    return result || AnyTrue(OTHER...);\n  }\n\n\n  // Number theory functions\n\n  /// Greatest Common Divisor\n  template <typename T>\n  [[deprecated(\"Replaced by std::gcd\")]]\n  constexpr T GCD(const T v1, const T v2) {\n    emp_assert(v1 > 0 && v2 > 0, v1, v2); // Must both be positive values.\n    return std::gcd<T, T>(v1, v2);\n  }\n\n  /// Least common multiple\n  template <typename T>\n  [[deprecated(\"Replaced by std::lcm\")]]\n  constexpr T LCM(const T v1, const T v2) {\n    emp_assert(v1 > 0 && v2 > 0, v1, v2); // Must both be positive values.\n    return std::lcm<T, T>(v1, v2);\n  }\n\n}\n\n#endif // #ifndef EMP_MATH_MATH_HPP_INCLUDE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2021\n *\n *  @file Point2D.hpp\n *  @brief A simple class to track value pairs of any kind, optimized for points in 2D Space.\n *\n * @note For maximal efficiency, prefer SquareMagnitude() and SquareDistance()\n * over Magnitude() and Distance() as the latter require a square-root.\n */\n\n#ifndef EMP_GEOMETRY_POINT2D_HPP_INCLUDE\n#define EMP_GEOMETRY_POINT2D_HPP_INCLUDE\n\n#include <cmath>\n#include <iostream>\n\n#include \"../math/math.hpp\"\n\nnamespace emp {\n\n  template <typename TYPE=double> class Point2D {\n  private:\n    TYPE x;\n    TYPE y;\n\n  public:\n    constexpr Point2D() : x(0.0), y(0.0) { ; }                      // Default = 0,0\n    constexpr Point2D(const Point2D & _in) : x(_in.x), y(_in.y) { ; } // Copy constructor\n    constexpr Point2D(TYPE _x, TYPE _y) : x(_x), y(_y) { ; }        // Two ints -> x and y\n    constexpr Point2D(const Point2D & _in, TYPE new_magnitude)\n      : x(_in.x * ((double) new_magnitude) / ((double) _in.Magnitude()))\n      , y(_in.y * ((double) new_magnitude) / ((double) _in.Magnitude()))\n     { ; }\n    // ~Point2D() { ; }\n\n    const Point2D & operator=(const Point2D & _in) { x = _in.x; y = _in.y; return *this; }\n    constexpr bool operator==(const Point2D & _in) const { return (x == _in.x) && (y == _in.y); }\n    constexpr bool operator!=(const Point2D & _in) const { return (x != _in.x) || (y != _in.y); }\n\n    // Inequalities have to do with BOTH ponts.\n    constexpr bool operator<=(const Point2D & _in) const { return (x <= _in.x) && (y <= _in.y); }\n    constexpr bool operator>=(const Point2D & _in) const { return (x >= _in.x) && (y >= _in.y); }\n\n    constexpr inline TYPE GetX() const { return x; }\n    constexpr inline TYPE GetY() const { return y; }\n    inline Point2D & SetX(TYPE in_x) { x = in_x; return *this; }\n    inline Point2D & SetY(TYPE in_y) { y = in_y; return *this; }\n    Point2D & Set(TYPE _x, TYPE _y) { x=_x; y=_y; return *this; }\n\n    constexpr double SquareMagnitude() const { return x*x + y*y; }\n    constexpr double Magnitude() const { return sqrt( x*x + y*y ); }\n    constexpr bool AtOrigin() const { return x == 0 && y == 0; }\n    constexpr bool NonZero() const { return x != 0 || y != 0; }\n\n    // Determine a new point, but don't change this one\n    constexpr Point2D GetMidpoint(const Point2D & p2) const { return Point2D((x+p2.x)/2, (y+p2.y)/2); }\n    constexpr Point2D GetRot90() const { return Point2D(y, -x); }\n    constexpr Point2D GetRot180() const { return Point2D(-x, -y); }\n    constexpr Point2D GetRot270() const { return Point2D(-y, x); }\n    constexpr Point2D GetOffset(TYPE off_x, TYPE off_y) const { return Point2D(x+off_x, y+off_y); }\n\n    constexpr Point2D operator+(const Point2D & _in) const { return Point2D(x + _in.x , y + _in.y); }\n    constexpr Point2D operator-(const Point2D & _in) const { return Point2D(x - _in.x , y - _in.y); }\n    constexpr Point2D operator*(double mult) const { return Point2D(((double) x) * mult, ((double) y) * mult); }\n    constexpr Point2D operator/(double div) const { return Point2D(((double) x) / div, ((double) y) / div); }\n    constexpr Point2D operator*(int mult) const { return Point2D(x * mult, y * mult); }\n    constexpr Point2D operator/(int div) const { return Point2D(x / div, y / div); }\n    constexpr Point2D operator-() const { return Point2D(-x, -y); } // Unary minus\n\n    constexpr Point2D Abs() const { return Point2D(std::abs(x), std::abs(y)); } // Absolute value\n\n    // Modify this point.\n    Point2D & Translate(TYPE shift_x, TYPE shift_y) { x += shift_x; y += shift_y; return *this; }\n    Point2D & TranslateX(TYPE shift) { x += shift; return *this; }\n    Point2D & TranslateY(TYPE shift) { y += shift; return *this; }\n    Point2D & Scale(double scale) { x *= scale; y *= scale; return *this; }\n    Point2D & Scale(double scale_x, double scale_y) { x *= scale_x; y *= scale_y; return *this; }\n    Point2D & ToOrigin() { x = 0; y = 0; return *this; }\n    Point2D & NegateX() { x = -x; return *this; }\n    Point2D & NegateY() { y = -y; return *this; }\n    Point2D & Mod(const Point2D & limits) { x = emp::Mod(x, limits.x); y = emp::Mod(y, limits.y); return *this; }\n\n    Point2D & operator+=(const Point2D & _in) { x += _in.x; y += _in.y; return *this; }\n    Point2D & operator-=(const Point2D & _in) { x -= _in.x; y -= _in.y; return *this; }\n    Point2D & operator*=(double mult) { x *= mult; y *= mult; return *this; }\n    Point2D & operator/=(double val) { if (val != 0.0) { x /= val;  y /= val; }; return *this; }\n    Point2D & operator*=(int mult) { x *= mult; y *= mult; return *this; }\n    Point2D & operator/=(int val) { if (val != 0.0) { x /= val;  y /= val; }; return *this; }\n\n    Point2D & Rot90() { return Set(y, -x); }\n    Point2D & Rot180() { return Set(-x, -y); }\n    Point2D & Rot270() { return Set(-y, x); }\n\n    // Square-roots are slow to calculate; if we're just doing comparisons, square-distance\n    // is usualy going to be sufficient.\n    TYPE SquareDistance(const Point2D & _in) const {\n      const TYPE x_dist = x - _in.x;\n      const TYPE y_dist = y - _in.y;\n      return x_dist*x_dist + y_dist*y_dist;\n    }\n\n    TYPE Distance(const Point2D & _in) const { return sqrt( SquareDistance(_in) ); }\n  };\n\n  using Point = Point2D<>;\n\n}\n\nnamespace std {\n  // Overload ostream to work with points.\n  template <typename TYPE> std::ostream & operator<<(std::ostream & os,\n                                                    const emp::Point2D<TYPE> & point) {\n    return os << \"(\" << point.GetX() << \",\" << point.GetY() << \")\";\n  }\n}\n\n#endif // #ifndef EMP_GEOMETRY_POINT2D_HPP_INCLUDE\n","// -*- C++ -*-\n//===--------------------------- iomanip ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOMANIP\n#define _LIBCPP_IOMANIP\n\n/*\n    iomanip synopsis\n\nnamespace std {\n\n// types T1, T2, ... are unspecified implementation types\nT1 resetiosflags(ios_base::fmtflags mask);\nT2 setiosflags (ios_base::fmtflags mask);\nT3 setbase(int base);\ntemplate<charT> T4 setfill(charT c);\nT5 setprecision(int n);\nT6 setw(int n);\ntemplate <class moneyT> T7 get_money(moneyT& mon, bool intl = false);\ntemplate <class charT, class moneyT> T8 put_money(const moneyT& mon, bool intl = false);\ntemplate <class charT> T9 get_time(struct tm* tmb, const charT* fmt);\ntemplate <class charT> T10 put_time(const struct tm* tmb, const charT* fmt);\n\ntemplate <class charT>\n  T11 quoted(const charT* s, charT delim=charT('\"'), charT escape=charT('\\\\')); // C++14\n\ntemplate <class charT, class traits, class Allocator>\n  T12 quoted(const basic_string<charT, traits, Allocator>& s,\n             charT delim=charT('\"'), charT escape=charT('\\\\')); // C++14\n\ntemplate <class charT, class traits, class Allocator>\n  T13 quoted(basic_string<charT, traits, Allocator>& s,\n             charT delim=charT('\"'), charT escape=charT('\\\\')); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__string>\n#include <istream>\n#include <version>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// resetiosflags\n\nclass __iom_t1\n{\n    ios_base::fmtflags __mask_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t1(ios_base::fmtflags __m) : __mask_(__m) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t1& __x)\n    {\n        __is.unsetf(__x.__mask_);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t1& __x)\n    {\n        __os.unsetf(__x.__mask_);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t1\nresetiosflags(ios_base::fmtflags __mask)\n{\n    return __iom_t1(__mask);\n}\n\n// setiosflags\n\nclass __iom_t2\n{\n    ios_base::fmtflags __mask_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t2(ios_base::fmtflags __m) : __mask_(__m) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t2& __x)\n    {\n        __is.setf(__x.__mask_);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t2& __x)\n    {\n        __os.setf(__x.__mask_);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t2\nsetiosflags(ios_base::fmtflags __mask)\n{\n    return __iom_t2(__mask);\n}\n\n// setbase\n\nclass __iom_t3\n{\n    int __base_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t3(int __b) : __base_(__b) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t3& __x)\n    {\n        __is.setf(__x.__base_ == 8  ? ios_base::oct :\n                  __x.__base_ == 10 ? ios_base::dec :\n                  __x.__base_ == 16 ? ios_base::hex :\n                  ios_base::fmtflags(0), ios_base::basefield);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t3& __x)\n    {\n        __os.setf(__x.__base_ == 8  ? ios_base::oct :\n                  __x.__base_ == 10 ? ios_base::dec :\n                  __x.__base_ == 16 ? ios_base::hex :\n                  ios_base::fmtflags(0), ios_base::basefield);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t3\nsetbase(int __base)\n{\n    return __iom_t3(__base);\n}\n\n// setfill\n\ntemplate<class _CharT>\nclass __iom_t4\n{\n    _CharT __fill_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t4(_CharT __c) : __fill_(__c) {}\n\n    template <class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t4& __x)\n    {\n        __os.fill(__x.__fill_);\n        return __os;\n    }\n};\n\ntemplate<class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t4<_CharT>\nsetfill(_CharT __c)\n{\n    return __iom_t4<_CharT>(__c);\n}\n\n// setprecision\n\nclass __iom_t5\n{\n    int __n_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t5(int __n) : __n_(__n) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t5& __x)\n    {\n        __is.precision(__x.__n_);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t5& __x)\n    {\n        __os.precision(__x.__n_);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t5\nsetprecision(int __n)\n{\n    return __iom_t5(__n);\n}\n\n// setw\n\nclass __iom_t6\n{\n    int __n_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t6(int __n) : __n_(__n) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t6& __x)\n    {\n        __is.width(__x.__n_);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t6& __x)\n    {\n        __os.width(__x.__n_);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t6\nsetw(int __n)\n{\n    return __iom_t6(__n);\n}\n\n// get_money\n\ntemplate <class _MoneyT> class __iom_t7;\n\ntemplate <class _CharT, class _Traits, class _MoneyT>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_MoneyT>& __x);\n\ntemplate <class _MoneyT>\nclass __iom_t7\n{\n    _MoneyT& __mon_;\n    bool __intl_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __iom_t7(_MoneyT& __mon, bool __intl)\n        : __mon_(__mon), __intl_(__intl) {}\n\n    template <class _CharT, class _Traits, class _Mp>\n    friend\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_Mp>& __x);\n};\n\ntemplate <class _CharT, class _Traits, class _MoneyT>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_MoneyT>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __s(__is);\n        if (__s)\n        {\n            typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n            typedef money_get<_CharT, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            const _Fp& __mf = use_facet<_Fp>(__is.getloc());\n            __mf.get(_Ip(__is), _Ip(), __x.__intl_, __is, __err, __x.__mon_);\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate <class _MoneyT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t7<_MoneyT>\nget_money(_MoneyT& __mon, bool __intl = false)\n{\n    return __iom_t7<_MoneyT>(__mon, __intl);\n}\n\n// put_money\n\ntemplate <class _MoneyT> class __iom_t8;\n\ntemplate <class _CharT, class _Traits, class _MoneyT>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_MoneyT>& __x);\n\ntemplate <class _MoneyT>\nclass __iom_t8\n{\n    const _MoneyT& __mon_;\n    bool __intl_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __iom_t8(const _MoneyT& __mon, bool __intl)\n        : __mon_(__mon), __intl_(__intl) {}\n\n    template <class _CharT, class _Traits, class _Mp>\n    friend\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_Mp>& __x);\n};\n\ntemplate <class _CharT, class _Traits, class _MoneyT>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_MoneyT>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            typedef money_put<_CharT, _Op> _Fp;\n            const _Fp& __mf = use_facet<_Fp>(__os.getloc());\n            if (__mf.put(_Op(__os), __x.__intl_, __os, __os.fill(), __x.__mon_).failed())\n                __os.setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate <class _MoneyT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t8<_MoneyT>\nput_money(const _MoneyT& __mon, bool __intl = false)\n{\n    return __iom_t8<_MoneyT>(__mon, __intl);\n}\n\n// get_time\n\ntemplate <class _CharT> class __iom_t9;\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t9<_CharT>& __x);\n\ntemplate <class _CharT>\nclass __iom_t9\n{\n    tm* __tm_;\n    const _CharT* __fmt_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __iom_t9(tm* __tm, const _CharT* __fmt)\n        : __tm_(__tm), __fmt_(__fmt) {}\n\n    template <class _Cp, class _Traits>\n    friend\n    basic_istream<_Cp, _Traits>&\n    operator>>(basic_istream<_Cp, _Traits>& __is, const __iom_t9<_Cp>& __x);\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t9<_CharT>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __s(__is);\n        if (__s)\n        {\n            typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n            typedef time_get<_CharT, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            const _Fp& __tf = use_facet<_Fp>(__is.getloc());\n            __tf.get(_Ip(__is), _Ip(), __is, __err, __x.__tm_,\n                     __x.__fmt_, __x.__fmt_ + _Traits::length(__x.__fmt_));\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t9<_CharT>\nget_time(tm* __tm, const _CharT* __fmt)\n{\n    return __iom_t9<_CharT>(__tm, __fmt);\n}\n\n// put_time\n\ntemplate <class _CharT> class __iom_t10;\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t10<_CharT>& __x);\n\ntemplate <class _CharT>\nclass __iom_t10\n{\n    const tm* __tm_;\n    const _CharT* __fmt_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __iom_t10(const tm* __tm, const _CharT* __fmt)\n        : __tm_(__tm), __fmt_(__fmt) {}\n\n    template <class _Cp, class _Traits>\n    friend\n    basic_ostream<_Cp, _Traits>&\n    operator<<(basic_ostream<_Cp, _Traits>& __os, const __iom_t10<_Cp>& __x);\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t10<_CharT>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            typedef time_put<_CharT, _Op> _Fp;\n            const _Fp& __tf = use_facet<_Fp>(__os.getloc());\n            if (__tf.put(_Op(__os), __os, __os.fill(), __x.__tm_,\n                         __x.__fmt_, __x.__fmt_ + _Traits::length(__x.__fmt_)).failed())\n                __os.setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t10<_CharT>\nput_time(const tm* __tm, const _CharT* __fmt)\n{\n    return __iom_t10<_CharT>(__tm, __fmt);\n}\n\ntemplate <class _CharT, class _Traits, class _ForwardIterator>\nstd::basic_ostream<_CharT, _Traits> &\n__quoted_output ( basic_ostream<_CharT, _Traits> &__os, \n        _ForwardIterator __first, _ForwardIterator __last, _CharT __delim, _CharT __escape )\n{\n    _VSTD::basic_string<_CharT, _Traits> __str;\n    __str.push_back(__delim);\n    for ( ; __first != __last; ++ __first )\n    {\n        if (_Traits::eq (*__first, __escape) || _Traits::eq (*__first, __delim))\n            __str.push_back(__escape);\n        __str.push_back(*__first);\n    }\n    __str.push_back(__delim);\n    return __put_character_sequence(__os, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _String>\nbasic_istream<_CharT, _Traits> &\n__quoted_input ( basic_istream<_CharT, _Traits> &__is, _String & __string, _CharT __delim, _CharT __escape )\n{\n    __string.clear ();\n    _CharT __c;\n    __is >> __c;\n    if ( __is.fail ())\n        return __is;\n\n    if (!_Traits::eq (__c, __delim))    // no delimiter, read the whole string\n    {\n        __is.unget ();\n        __is >> __string;\n        return __is;\n    }\n\n    __save_flags<_CharT, _Traits> sf(__is);\n    noskipws (__is);\n    while (true)\n        {\n        __is >> __c;\n        if ( __is.fail ())\n            break;\n        if (_Traits::eq (__c, __escape))\n        {\n            __is >> __c;\n            if ( __is.fail ())\n                break;\n        }\n        else if (_Traits::eq (__c, __delim))\n            break;\n        __string.push_back ( __c );\n        }\n    return __is;\n}\n\n\ntemplate <class _CharT, class _Traits, class _Iter>\nbasic_ostream<_CharT, _Traits>& operator<<(\n         basic_ostream<_CharT, _Traits>& __os, \n         const __quoted_output_proxy<_CharT, _Iter, _Traits> & __proxy)\n{\n    return __quoted_output (__os, __proxy.__first, __proxy.__last, __proxy.__delim, __proxy.__escape);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nstruct __quoted_proxy\n{\n    basic_string<_CharT, _Traits, _Allocator> &__string;\n    _CharT  __delim;\n    _CharT  __escape;\n\n    __quoted_proxy(basic_string<_CharT, _Traits, _Allocator> &__s, _CharT __d, _CharT __e)\n    : __string(__s), __delim(__d), __escape(__e) {}\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>& operator<<(\n        basic_ostream<_CharT, _Traits>& __os, \n        const __quoted_proxy<_CharT, _Traits, _Allocator> & __proxy)\n{\n    return __quoted_output (__os, __proxy.__string.cbegin (), __proxy.__string.cend (), __proxy.__delim, __proxy.__escape);\n}\n\n//  extractor for non-const basic_string& proxies\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>& operator>>(\n        basic_istream<_CharT, _Traits>& __is, \n        const __quoted_proxy<_CharT, _Traits, _Allocator> & __proxy)\n{\n    return __quoted_input ( __is, __proxy.__string, __proxy.__delim, __proxy.__escape );\n}\n\n\ntemplate <class _CharT>\n_LIBCPP_INLINE_VISIBILITY\n__quoted_output_proxy<_CharT, const _CharT *>\nquoted ( const _CharT *__s, _CharT __delim = _CharT('\"'), _CharT __escape =_CharT('\\\\'))\n{\n    const _CharT *__end = __s;\n    while ( *__end ) ++__end;\n    return __quoted_output_proxy<_CharT, const _CharT *> ( __s, __end, __delim, __escape );\n}\n\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY\n__quoted_output_proxy<_CharT, typename basic_string <_CharT, _Traits, _Allocator>::const_iterator>\n__quoted ( const basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('\"'), _CharT __escape=_CharT('\\\\'))\n{\n    return __quoted_output_proxy<_CharT,\n            typename basic_string <_CharT, _Traits, _Allocator>::const_iterator>\n                    ( __s.cbegin(), __s.cend (), __delim, __escape );\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY\n__quoted_proxy<_CharT, _Traits, _Allocator>\n__quoted ( basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('\"'), _CharT __escape=_CharT('\\\\'))\n{\n    return __quoted_proxy<_CharT, _Traits, _Allocator>( __s, __delim, __escape );\n}\n\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY\n__quoted_output_proxy<_CharT, typename basic_string <_CharT, _Traits, _Allocator>::const_iterator>\nquoted ( const basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('\"'), _CharT __escape=_CharT('\\\\'))\n{\n    return __quoted(__s, __delim, __escape);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY\n__quoted_proxy<_CharT, _Traits, _Allocator>\nquoted ( basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('\"'), _CharT __escape=_CharT('\\\\'))\n{\n    return __quoted(__s, __delim, __escape);\n}\n\ntemplate <class _CharT, class _Traits>\n__quoted_output_proxy<_CharT, const _CharT *, _Traits>\nquoted (basic_string_view <_CharT, _Traits> __sv,\n             _CharT __delim = _CharT('\"'), _CharT __escape=_CharT('\\\\'))\n{\n    return __quoted_output_proxy<_CharT, const _CharT *, _Traits> \n         ( __sv.data(), __sv.data() + __sv.size(), __delim, __escape );\n}\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOMANIP\n","// -*- C++ -*-\n//===-------------------------- locale ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_LOCALE\n#define _LIBCPP_LOCALE\n\n/*\n    locale synopsis\n\nnamespace std\n{\n\nclass locale\n{\npublic:\n    // types:\n    class facet;\n    class id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0x000,\n        collate  = 0x010,\n        ctype    = 0x020,\n        monetary = 0x040,\n        numeric  = 0x080,\n        time     = 0x100,\n        messages = 0x200,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale() noexcept;\n    locale(const locale& other) noexcept;\n    explicit locale(const char* std_name);\n    explicit locale(const string& std_name);\n    locale(const locale& other, const char* std_name, category);\n    locale(const locale& other, const string& std_name, category);\n    template <class Facet> locale(const locale& other, Facet* f);\n    locale(const locale& other, const locale& one, category);\n\n    ~locale(); // not virtual\n\n    const locale& operator=(const locale& other) noexcept;\n\n    template <class Facet> locale combine(const locale& other) const;\n\n    // locale operations:\n    basic_string<char> name() const;\n    bool operator==(const locale& other) const;\n    bool operator!=(const locale& other) const;\n    template <class charT, class Traits, class Allocator>\n      bool operator()(const basic_string<charT,Traits,Allocator>& s1,\n                      const basic_string<charT,Traits,Allocator>& s2) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n};\n\ntemplate <class Facet> const Facet& use_facet(const locale&);\ntemplate <class Facet> bool has_facet(const locale&) noexcept;\n\n// 22.3.3, convenience interfaces:\ntemplate <class charT> bool isspace (charT c, const locale& loc);\ntemplate <class charT> bool isprint (charT c, const locale& loc);\ntemplate <class charT> bool iscntrl (charT c, const locale& loc);\ntemplate <class charT> bool isupper (charT c, const locale& loc);\ntemplate <class charT> bool islower (charT c, const locale& loc);\ntemplate <class charT> bool isalpha (charT c, const locale& loc);\ntemplate <class charT> bool isdigit (charT c, const locale& loc);\ntemplate <class charT> bool ispunct (charT c, const locale& loc);\ntemplate <class charT> bool isxdigit(charT c, const locale& loc);\ntemplate <class charT> bool isalnum (charT c, const locale& loc);\ntemplate <class charT> bool isgraph (charT c, const locale& loc);\ntemplate <class charT> charT toupper(charT c, const locale& loc);\ntemplate <class charT> charT tolower(charT c, const locale& loc);\n\ntemplate<class Codecvt, class Elem = wchar_t,\n         class Wide_alloc = allocator<Elem>,\n         class Byte_alloc = allocator<char>>\nclass wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, Byte_alloc> byte_string;\n    typedef basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;\n    typedef typename Codecvt::state_type                      state_type;\n    typedef typename wide_string::traits_type::int_type       int_type;\n\n    explicit wstring_convert(Codecvt* pcvt = new Codecvt);          // explicit in C++14\n    wstring_convert(Codecvt* pcvt, state_type state);\n    explicit wstring_convert(const byte_string& byte_err,           // explicit in C++14\n                    const wide_string& wide_err = wide_string());\n    wstring_convert(const wstring_convert&) = delete;               // C++14\n    wstring_convert & operator=(const wstring_convert &) = delete;  // C++14\n    ~wstring_convert();\n\n    wide_string from_bytes(char byte);\n    wide_string from_bytes(const char* ptr);\n    wide_string from_bytes(const byte_string& str);\n    wide_string from_bytes(const char* first, const char* last);\n\n    byte_string to_bytes(Elem wchar);\n    byte_string to_bytes(const Elem* wptr);\n    byte_string to_bytes(const wide_string& wstr);\n    byte_string to_bytes(const Elem* first, const Elem* last);\n\n    size_t converted() const; // noexcept in C++14\n    state_type state() const;\n};\n\ntemplate <class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>\nclass wbuffer_convert\n    : public basic_streambuf<Elem, Tr>\n{\npublic:\n    typedef typename Tr::state_type state_type;\n\n    explicit wbuffer_convert(streambuf* bytebuf = 0, Codecvt* pcvt = new Codecvt,\n                    state_type state = state_type());       // explicit in C++14\n    wbuffer_convert(const wbuffer_convert&) = delete;               // C++14\n    wbuffer_convert & operator=(const wbuffer_convert &) = delete;  // C++14\n    ~wbuffer_convert();                                             // C++14\n    \n    streambuf* rdbuf() const;\n    streambuf* rdbuf(streambuf* bytebuf);\n\n    state_type state() const;\n};\n\n// 22.4.1 and 22.4.1.3, ctype:\nclass ctype_base;\ntemplate <class charT> class ctype;\ntemplate <> class ctype<char>; // specialization\ntemplate <class charT> class ctype_byname;\ntemplate <> class ctype_byname<char>; // specialization\n\nclass codecvt_base;\ntemplate <class internT, class externT, class stateT> class codecvt;\ntemplate <class internT, class externT, class stateT> class codecvt_byname;\n\n// 22.4.2 and 22.4.3, numeric:\ntemplate <class charT, class InputIterator> class num_get;\ntemplate <class charT, class OutputIterator> class num_put;\ntemplate <class charT> class numpunct;\ntemplate <class charT> class numpunct_byname;\n\n// 22.4.4, col lation:\ntemplate <class charT> class collate;\ntemplate <class charT> class collate_byname;\n\n// 22.4.5, date and time:\nclass time_base;\ntemplate <class charT, class InputIterator> class time_get;\ntemplate <class charT, class InputIterator> class time_get_byname;\ntemplate <class charT, class OutputIterator> class time_put;\ntemplate <class charT, class OutputIterator> class time_put_byname;\n\n// 22.4.6, money:\nclass money_base;\ntemplate <class charT, class InputIterator> class money_get;\ntemplate <class charT, class OutputIterator> class money_put;\ntemplate <class charT, bool Intl> class moneypunct;\ntemplate <class charT, bool Intl> class moneypunct_byname;\n\n// 22.4.7, message retrieval:\nclass messages_base;\ntemplate <class charT> class messages;\ntemplate <class charT> class messages_byname;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__locale>\n#include <__debug>\n#include <algorithm>\n#include <memory>\n#include <ios>\n#include <streambuf>\n#include <iterator>\n#include <limits>\n#include <version>\n#ifndef __APPLE__\n#include <cstdarg>\n#endif\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#ifdef _LIBCPP_HAS_CATOPEN\n#include <nl_types.h>\n#endif\n\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n#include <__bsd_locale_defaults.h>\n#else\n#include <__bsd_locale_fallbacks.h>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if defined(__APPLE__) || defined(__FreeBSD__)\n#  define _LIBCPP_GET_C_LOCALE 0\n#elif defined(__CloudABI__) || defined(__NetBSD__)\n#  define _LIBCPP_GET_C_LOCALE LC_C_LOCALE\n#else\n#  define _LIBCPP_GET_C_LOCALE __cloc()\n   // Get the C locale object\n   _LIBCPP_FUNC_VIS locale_t __cloc();\n#define __cloc_defined\n#endif\n\n// __scan_keyword\n// Scans [__b, __e) until a match is found in the basic_strings range\n//  [__kb, __ke) or until it can be shown that there is no match in [__kb, __ke).\n//  __b will be incremented (visibly), consuming CharT until a match is found\n//  or proved to not exist.  A keyword may be \"\", in which will match anything.\n//  If one keyword is a prefix of another, and the next CharT in the input\n//  might match another keyword, the algorithm will attempt to find the longest\n//  matching keyword.  If the longer matching keyword ends up not matching, then\n//  no keyword match is found.  If no keyword match is found, __ke is returned\n//  and failbit is set in __err.\n//  Else an iterator pointing to the matching keyword is found.  If more than\n//  one keyword matches, an iterator to the first matching keyword is returned.\n//  If on exit __b == __e, eofbit is set in __err.  If __case_sensitive is false,\n//  __ct is used to force to lower case before comparing characters.\n//  Examples:\n//  Keywords:  \"a\", \"abb\"\n//  If the input is \"a\", the first keyword matches and eofbit is set.\n//  If the input is \"abc\", no match is found and \"ab\" are consumed.\ntemplate <class _InputIterator, class _ForwardIterator, class _Ctype>\n_LIBCPP_HIDDEN\n_ForwardIterator\n__scan_keyword(_InputIterator& __b, _InputIterator __e,\n               _ForwardIterator __kb, _ForwardIterator __ke,\n               const _Ctype& __ct, ios_base::iostate& __err,\n               bool __case_sensitive = true)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type _CharT;\n    size_t __nkw = static_cast<size_t>(_VSTD::distance(__kb, __ke));\n    const unsigned char __doesnt_match = '\\0';\n    const unsigned char __might_match = '\\1';\n    const unsigned char __does_match = '\\2';\n    unsigned char __statbuf[100];\n    unsigned char* __status = __statbuf;\n    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, free);\n    if (__nkw > sizeof(__statbuf))\n    {\n        __status = (unsigned char*)malloc(__nkw);\n        if (__status == 0)\n            __throw_bad_alloc();\n        __stat_hold.reset(__status);\n    }\n    size_t __n_might_match = __nkw;  // At this point, any keyword might match\n    size_t __n_does_match = 0;       // but none of them definitely do\n    // Initialize all statuses to __might_match, except for \"\" keywords are __does_match\n    unsigned char* __st = __status;\n    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)\n    {\n        if (!__ky->empty())\n            *__st = __might_match;\n        else\n        {\n            *__st = __does_match;\n            --__n_might_match;\n            ++__n_does_match;\n        }\n    }\n    // While there might be a match, test keywords against the next CharT\n    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)\n    {\n        // Peek at the next CharT but don't consume it\n        _CharT __c = *__b;\n        if (!__case_sensitive)\n            __c = __ct.toupper(__c);\n        bool __consume = false;\n        // For each keyword which might match, see if the __indx character is __c\n        // If a match if found, consume __c\n        // If a match is found, and that is the last character in the keyword,\n        //    then that keyword matches.\n        // If the keyword doesn't match this character, then change the keyword\n        //    to doesn't match\n        __st = __status;\n        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)\n        {\n            if (*__st == __might_match)\n            {\n                _CharT __kc = (*__ky)[__indx];\n                if (!__case_sensitive)\n                    __kc = __ct.toupper(__kc);\n                if (__c == __kc)\n                {\n                    __consume = true;\n                    if (__ky->size() == __indx+1)\n                    {\n                        *__st = __does_match;\n                        --__n_might_match;\n                        ++__n_does_match;\n                    }\n                }\n                else\n                {\n                    *__st = __doesnt_match;\n                    --__n_might_match;\n                }\n            }\n        }\n        // consume if we matched a character\n        if (__consume)\n        {\n            ++__b;\n            // If we consumed a character and there might be a matched keyword that\n            //   was marked matched on a previous iteration, then such keywords\n            //   which are now marked as not matching.\n            if (__n_might_match + __n_does_match > 1)\n            {\n                __st = __status;\n                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)\n                {\n                    if (*__st == __does_match && __ky->size() != __indx+1)\n                    {\n                        *__st = __doesnt_match;\n                        --__n_does_match;\n                    }\n                }\n            }\n        }\n    }\n    // We've exited the loop because we hit eof and/or we have no more \"might matches\".\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    // Return the first matching result\n    for (__st = __status; __kb != __ke; ++__kb, (void) ++__st)\n        if (*__st == __does_match)\n            break;\n    if (__kb == __ke)\n        __err |= ios_base::failbit;\n    return __kb;\n}\n\nstruct _LIBCPP_TYPE_VIS __num_get_base\n{\n    static const int __num_get_buf_sz = 40;\n\n    static int __get_base(ios_base&);\n    static const char __src[33];\n};\n\n_LIBCPP_FUNC_VIS\nvoid __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,\n                      ios_base::iostate& __err);\n\ntemplate <class _CharT>\nstruct __num_get\n    : protected __num_get_base\n{\n    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                                      _CharT& __thousands_sep);\n\n    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,\n                                   char* __a, char*& __a_end,\n                                   _CharT __decimal_point, _CharT __thousands_sep,\n                                   const string& __grouping, unsigned* __g,\n                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);\n#ifndef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET\n    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);\n    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);\n\n#else\n    static string __stage2_int_prep(ios_base& __iob, _CharT& __thousands_sep)\n    {\n        locale __loc = __iob.getloc();\n        const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n        __thousands_sep = __np.thousands_sep();\n        return __np.grouping();\n    }\n\n    const _CharT* __do_widen(ios_base& __iob, _CharT* __atoms) const\n    {\n      return __do_widen_p(__iob, __atoms);\n    }\n\n\n    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, const _CharT* __atoms);\nprivate:\n    template<typename T>\n    const T* __do_widen_p(ios_base& __iob, T* __atoms) const\n    {\n      locale __loc = __iob.getloc();\n      use_facet<ctype<T> >(__loc).widen(__src, __src + 26, __atoms);\n      return __atoms;\n    }\n\n    const char* __do_widen_p(ios_base& __iob, char* __atoms) const\n    {\n      (void)__iob;\n      (void)__atoms;\n      return __src;\n    }\n#endif\n};\n\n#ifndef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n#endif\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                    _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __decimal_point = __np.decimal_point();\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nint\n#ifndef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET\n__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)\n#else\n__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, const _CharT* __atoms)\n\n#endif\n{\n    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))\n    {\n        *__a_end++ = __ct == __atoms[24] ? '+' : '-';\n        __dc = 0;\n        return 0;\n    }\n    if (__grouping.size() != 0 && __ct == __thousands_sep)\n    {\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;\n    if (__f >= 24)\n        return -1;\n    switch (__base)\n    {\n    case 8:\n    case 10:\n        if (__f >= __base)\n            return -1;\n        break;\n    case 16:\n        if (__f < 22)\n            break;\n        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')\n        {\n            __dc = 0;\n            *__a_end++ = __src[__f];\n            return 0;\n        }\n        return -1;\n    }\n    *__a_end++ = __src[__f];\n    ++__dc;\n    return 0;\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,\n                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,\n                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)\n{\n    if (__ct == __decimal_point)\n    {\n        if (!__in_units)\n            return -1;\n        __in_units = false;\n        *__a_end++ = '.';\n        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n            *__g_end++ = __dc;\n        return 0;\n    }\n    if (__ct == __thousands_sep && __grouping.size() != 0)\n    {\n        if (!__in_units)\n            return -1;\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;\n    if (__f >= 32)\n        return -1;\n    char __x = __src[__f];\n    if (__x == '-' || __x == '+')\n    {\n        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))\n        {\n            *__a_end++ = __x;\n            return 0;\n        }\n        return -1;\n    }\n    if (__x == 'x' || __x == 'X')\n        __exp = 'P';\n    else if ((__x & 0x5F) == __exp)\n    {\n        __exp |= 0x80;\n        if (__in_units)\n        {\n            __in_units = false;\n            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n                *__g_end++ = __dc;\n        }\n    }\n    *__a_end++ = __x;\n    if (__f >= 22)\n        return 0;\n    ++__dc;\n    return 0;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS num_get\n    : public locale::facet,\n      private __num_get<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _InputIterator iter_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit num_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, bool& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned short& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned int& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, float& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, void*& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~num_get() {}\n\n    template <class _Fp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    iter_type __do_get_floating_point\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Fp& __v) const;\n\n    template <class _Signed>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    iter_type __do_get_signed\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Signed& __v) const;\n\n    template <class _Unsigned>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    iter_type __do_get_unsigned\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Unsigned& __v) const;\n\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, bool& __v) const;\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned short& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned int& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, float& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, void*& __v) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nnum_get<_CharT, _InputIterator>::id;\n\ntemplate <class _Tp>\n_LIBCPP_HIDDEN _Tp\n__num_get_signed_integral(const char* __a, const char* __a_end,\n                          ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        long long __ll = strtoll_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE         ||\n                 __ll < numeric_limits<_Tp>::min() ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            if (__ll > 0)\n                return numeric_limits<_Tp>::max();\n            else\n                return numeric_limits<_Tp>::min();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_LIBCPP_HIDDEN _Tp\n__num_get_unsigned_integral(const char* __a, const char* __a_end,\n                            ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        const bool __negate = *__a == '-';\n        if (__negate && ++__a == __a_end) {\n          __err = ios_base::failbit;\n          return 0;\n        }\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        unsigned long long __ll = strtoull_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE || numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            return numeric_limits<_Tp>::max();\n        }\n        _Tp __res = static_cast<_Tp>(__ll);\n        if (__negate) __res = -__res;\n        return __res;\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\n_Tp __do_strtod(const char* __a, char** __p2);\n\ntemplate <>\ninline _LIBCPP_INLINE_VISIBILITY\nfloat __do_strtod<float>(const char* __a, char** __p2) {\n    return strtof_l(__a, __p2, _LIBCPP_GET_C_LOCALE);\n}\n\ntemplate <>\ninline _LIBCPP_INLINE_VISIBILITY\ndouble __do_strtod<double>(const char* __a, char** __p2) {\n    return strtod_l(__a, __p2, _LIBCPP_GET_C_LOCALE);\n}\n\ntemplate <>\ninline _LIBCPP_INLINE_VISIBILITY\nlong double __do_strtod<long double>(const char* __a, char** __p2) {\n    return strtold_l(__a, __p2, _LIBCPP_GET_C_LOCALE);\n}\n\ntemplate <class _Tp>\n_LIBCPP_HIDDEN\n_Tp\n__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        _Tp __ld = __do_strtod<_Tp>(__a, &__p2);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE)\n            __err = ios_base::failbit;\n        return __ld;\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        bool& __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n    {\n        long __lv = -1;\n        __b = do_get(__b, __e, __iob, __err, __lv);\n        switch (__lv)\n        {\n        case 0:\n            __v = false;\n            break;\n        case 1:\n            __v = true;\n            break;\n        default:\n            __v = true;\n            __err = ios_base::failbit;\n            break;\n        }\n        return __b;\n    }\n    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());\n    typedef typename numpunct<_CharT>::string_type string_type;\n    const string_type __names[2] = {__np.truename(), __np.falsename()};\n    const string_type* __i = __scan_keyword(__b, __e, __names, __names+2,\n                                            __ct, __err);\n    __v = __i == __names;\n    return __b;\n}\n\n// signed\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Signed>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Signed& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __thousands_sep;\n    const int __atoms_size = 26;\n#ifdef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET\n    char_type __atoms1[__atoms_size];\n    const char_type *__atoms = this->__do_widen(__iob, __atoms1);\n    string __grouping = this->__stage2_int_prep(__iob, __thousands_sep);\n#else\n    char_type __atoms[__atoms_size];\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n#endif\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// unsigned\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Unsigned>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Unsigned& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __thousands_sep;\n    const int __atoms_size = 26;\n#ifdef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET\n    char_type __atoms1[__atoms_size];\n    const char_type *__atoms = this->__do_widen(__iob, __atoms1);\n    string __grouping = this->__stage2_int_prep(__iob, __thousands_sep);\n#else\n    char_type __atoms[__atoms_size];\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n#endif\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// floating point\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Fp>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Fp& __v) const\n{\n    // Stage 1, nothing to do\n    // Stage 2\n    char_type __atoms[32];\n    char_type __decimal_point;\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_float_prep(__iob, __atoms,\n                                                  __decimal_point,\n                                                  __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    bool __in_units = true;\n    char __exp = 'E';\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,\n                                      __decimal_point, __thousands_sep,\n                                      __grouping, __g, __g_end,\n                                      __dc, __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_float<_Fp>(__a, __a_end, __err);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        void*& __v) const\n{\n    // Stage 1\n    int __base = 16;\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep = 0;\n    string __grouping;\n    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,\n                                                    __num_get_base::__src + 26, __atoms);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping,\n                                    __g, __g_end, __atoms))\n            break;\n    }\n    // Stage 3\n    __buf.resize(__a_end - __a);\n    if (__libcpp_sscanf_l(__buf.c_str(), _LIBCPP_GET_C_LOCALE, \"%p\", &__v) != 1)\n        __err = ios_base::failbit;\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_get<wchar_t>)\n\nstruct _LIBCPP_TYPE_VIS __num_put_base\n{\nprotected:\n    static void __format_int(char* __fmt, const char* __len, bool __signd,\n                             ios_base::fmtflags __flags);\n    static bool __format_float(char* __fmt, const char* __len,\n                               ios_base::fmtflags __flags);\n    static char* __identify_padding(char* __nb, char* __ne,\n                                    const ios_base& __iob);\n};\n\ntemplate <class _CharT>\nstruct __num_put\n    : protected __num_put_base\n{\n    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                      const locale& __loc);\n    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                        const locale& __loc);\n};\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                         const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    if (__grouping.empty())\n    {\n        __ct.widen(__nb, __ne, __ob);\n        __oe = __ob + (__ne - __nb);\n    }\n    else\n    {\n        __oe = __ob;\n        char* __nf = __nb;\n        if (*__nf == '-' || *__nf == '+')\n            *__oe++ = __ct.widen(*__nf++);\n        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                                   __nf[1] == 'X'))\n        {\n            *__oe++ = __ct.widen(*__nf++);\n            *__oe++ = __ct.widen(*__nf++);\n        }\n        reverse(__nf, __ne);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ne; ++__p)\n        {\n            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&\n                __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                           const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    __oe = __ob;\n    char* __nf = __nb;\n    if (*__nf == '-' || *__nf == '+')\n        *__oe++ = __ct.widen(*__nf++);\n    char* __ns;\n    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                               __nf[1] == 'X'))\n    {\n        *__oe++ = __ct.widen(*__nf++);\n        *__oe++ = __ct.widen(*__nf++);\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isxdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    else\n    {\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    if (__grouping.empty())\n    {\n        __ct.widen(__nf, __ns, __oe);\n        __oe += __ns - __nf;\n    }\n    else\n    {\n        reverse(__nf, __ns);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ns; ++__p)\n        {\n            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    for (__nf = __ns; __nf < __ne; ++__nf)\n    {\n        if (*__nf == '.')\n        {\n            *__oe++ = __npt.decimal_point();\n            ++__nf;\n            break;\n        }\n        else\n            *__oe++ = __ct.widen(*__nf);\n    }\n    __ct.widen(__nf, __ne, __oe);\n    __oe += __ne - __nf;\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS num_put\n    : public locale::facet,\n      private __num_put<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit num_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  bool __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const void* __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~num_put() {}\n\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             bool __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             const void* __v) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nnum_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_LIBCPP_HIDDEN\n_OutputIterator\n__pad_and_output(_OutputIterator __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    for (;__ob < __op; ++__ob, ++__s)\n        *__s = *__ob;\n    for (; __ns; --__ns, ++__s)\n        *__s = __fl;\n    for (; __ob < __oe; ++__ob, ++__s)\n        *__s = *__ob;\n    __iob.width(0);\n    return __s;\n}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\ntemplate <class _CharT, class _Traits>\n_LIBCPP_HIDDEN\nostreambuf_iterator<_CharT, _Traits>\n__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    if (__s.__sbuf_ == nullptr)\n        return __s;\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    streamsize __np = __op - __ob;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__ob, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    if (__ns > 0)\n    {\n        basic_string<_CharT, _Traits> __sp(__ns, __fl);\n        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __np = __oe - __op;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__op, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __iob.width(0);\n    return __s;\n}\n\n#endif\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, bool __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n        return do_put(__s, __iob, __fl, (unsigned long)__v);\n    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());\n    typedef typename numpunct<char_type>::string_type string_type;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    string_type __tmp(__v ? __np.truename() : __np.falsename());\n    string_type __nm = _VSTD::move(__tmp);\n#else\n    string_type __nm = __v ? __np.truename() : __np.falsename();\n#endif\n    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)\n        *__s = *__i;\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long>::digits / 3)\n                          + ((numeric_limits<long>::digits % 3) != 0)\n                          + ((__iob.flags() & ios_base::showbase) != 0)\n                          + 2;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)\n                          + ((numeric_limits<long long>::digits % 3) != 0)\n                          + ((__iob.flags() & ios_base::showbase) != 0)\n                          + 2;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)\n                          + ((numeric_limits<unsigned long>::digits % 3) != 0)\n                          + ((__iob.flags() & ios_base::showbase) != 0)\n                          + 1;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)\n                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)\n                          + ((__iob.flags() & ios_base::showbase) != 0)\n                          + 1;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n    else\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n        else\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"L\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n    else\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n        else\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, const void* __v) const\n{\n    // Stage 1 - Get pointer in narrow char\n    char __fmt[6] = \"%p\";\n    const unsigned __nbuf = 20;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __ct.widen(__nar, __ne, __o);\n    __oe = __o + (__ne - __nar);\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __o + (__np - __nar);\n    // [__o, __oe) contains wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_put<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator>\n_LIBCPP_HIDDEN\nint\n__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,\n                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)\n{\n    // Precondition:  __n >= 1\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return 0;\n    }\n    // get first digit\n    _CharT __c = *__b;\n    if (!__ct.is(ctype_base::digit, __c))\n    {\n        __err |= ios_base::failbit;\n        return 0;\n    }\n    int __r = __ct.narrow(__c, 0) - '0';\n    for (++__b, (void) --__n; __b != __e && __n > 0; ++__b, (void) --__n)\n    {\n        // get next digit\n        __c = *__b;\n        if (!__ct.is(ctype_base::digit, __c))\n            return __r;\n        __r = __r * 10 + __ct.narrow(__c, 0) - '0';\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __r;\n}\n\nclass _LIBCPP_TYPE_VIS time_base\n{\npublic:\n    enum dateorder {no_order, dmy, mdy, ymd, ydm};\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS __time_get_c_storage\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    virtual const string_type* __weeks() const;\n    virtual const string_type* __months() const;\n    virtual const string_type* __am_pm() const;\n    virtual const string_type& __c() const;\n    virtual const string_type& __r() const;\n    virtual const string_type& __x() const;\n    virtual const string_type& __X() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__time_get_c_storage() {}\n};\n\ntemplate <> _LIBCPP_FUNC_VIS const string* __time_get_c_storage<char>::__weeks() const;\ntemplate <> _LIBCPP_FUNC_VIS const string* __time_get_c_storage<char>::__months() const;\ntemplate <> _LIBCPP_FUNC_VIS const string* __time_get_c_storage<char>::__am_pm() const;\ntemplate <> _LIBCPP_FUNC_VIS const string& __time_get_c_storage<char>::__c() const;\ntemplate <> _LIBCPP_FUNC_VIS const string& __time_get_c_storage<char>::__r() const;\ntemplate <> _LIBCPP_FUNC_VIS const string& __time_get_c_storage<char>::__x() const;\ntemplate <> _LIBCPP_FUNC_VIS const string& __time_get_c_storage<char>::__X() const;\n\ntemplate <> _LIBCPP_FUNC_VIS const wstring* __time_get_c_storage<wchar_t>::__weeks() const;\ntemplate <> _LIBCPP_FUNC_VIS const wstring* __time_get_c_storage<wchar_t>::__months() const;\ntemplate <> _LIBCPP_FUNC_VIS const wstring* __time_get_c_storage<wchar_t>::__am_pm() const;\ntemplate <> _LIBCPP_FUNC_VIS const wstring& __time_get_c_storage<wchar_t>::__c() const;\ntemplate <> _LIBCPP_FUNC_VIS const wstring& __time_get_c_storage<wchar_t>::__r() const;\ntemplate <> _LIBCPP_FUNC_VIS const wstring& __time_get_c_storage<wchar_t>::__x() const;\ntemplate <> _LIBCPP_FUNC_VIS const wstring& __time_get_c_storage<wchar_t>::__X() const;\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_get\n    : public locale::facet,\n      public time_base,\n      private __time_get_c_storage<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef time_base::dateorder    dateorder;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    dateorder date_order() const\n    {\n        return this->do_date_order();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_time(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                          ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_weekday(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                            ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_monthname(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_year(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm *__tm,\n                  char __fmt, char __mod = 0) const\n    {\n        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);\n    }\n\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm* __tm,\n                  const char_type* __fmtb, const char_type* __fmte) const;\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~time_get() {}\n\n    virtual dateorder do_date_order() const;\n    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                                     ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                                       ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, tm* __tm,\n                             char __fmt, char __mod) const;\nprivate:\n    void __get_white_space(iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;\n    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n\n    void __get_weekdayname(int& __m,\n                           iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err,\n                           const ctype<char_type>& __ct) const;\n    void __get_monthname(int& __m,\n                         iter_type& __b, iter_type __e,\n                         ios_base::iostate& __err,\n                         const ctype<char_type>& __ct) const;\n    void __get_day(int& __d,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_month(int& __m,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_year(int& __y,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_year4(int& __y,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_hour(int& __d,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_12_hour(int& __h,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_am_pm(int& __h,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_minute(int& __m,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_second(int& __s,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_weekday(int& __w,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_day_year_num(int& __w,\n                            iter_type& __b, iter_type __e,\n                            ios_base::iostate& __err,\n                            const ctype<char_type>& __ct) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\ntime_get<_CharT, _InputIterator>::id;\n\n// time_get primitives\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,\n                                                    iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __wk = this->__weeks();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;\n    if (__i < 14)\n        __w = __i % 7;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_monthname(int& __m,\n                                                  iter_type& __b, iter_type __e,\n                                                  ios_base::iostate& __err,\n                                                  const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __month = this->__months();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;\n    if (__i < 24)\n        __m = __i % 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day(int& __d,\n                                            iter_type& __b, iter_type __e,\n                                            ios_base::iostate& __err,\n                                            const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_month(int& __m,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;\n    if (!(__err & ios_base::failbit) && __t <= 11)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year(int& __y,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n    {\n        if (__t < 69)\n            __t += 2000;\n        else if (69 <= __t && __t <= 99)\n            __t += 1900;\n        __y = __t - 1900;\n    }\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year4(int& __y,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n        __y = __t - 1900;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_hour(int& __h,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 23)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_12_hour(int& __h,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_minute(int& __m,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 59)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_second(int& __s,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 60)\n        __s = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekday(int& __w,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);\n    if (!(__err & ios_base::failbit) && __t <= 6)\n        __w = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,\n                                                     iter_type& __b, iter_type __e,\n                                                     ios_base::iostate& __err,\n                                                     const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);\n    if (!(__err & ios_base::failbit) && __t <= 365)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)\n        ;\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_am_pm(int& __h,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    const string_type* __ap = this->__am_pm();\n    if (__ap[0].size() + __ap[1].size() == 0)\n    {\n        __err |= ios_base::failbit;\n        return;\n    }\n    ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;\n    if (__i == 0 && __h == 12)\n        __h = 0;\n    else if (__i == 1 && __h < 12)\n        __h += 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return;\n    }\n    if (__ct.narrow(*__b, 0) != '%')\n        __err |= ios_base::failbit;\n    else if(++__b == __e)\n        __err |= ios_base::eofbit;\n}\n\n// time_get end primitives\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,\n                                      ios_base& __iob,\n                                      ios_base::iostate& __err, tm* __tm,\n                                      const char_type* __fmtb, const char_type* __fmte) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __err = ios_base::goodbit;\n    while (__fmtb != __fmte && __err == ios_base::goodbit)\n    {\n        if (__b == __e)\n        {\n            __err = ios_base::failbit;\n            break;\n        }\n        if (__ct.narrow(*__fmtb, 0) == '%')\n        {\n            if (++__fmtb == __fmte)\n            {\n                __err = ios_base::failbit;\n                break;\n            }\n            char __cmd = __ct.narrow(*__fmtb, 0);\n            char __opt = '\\0';\n            if (__cmd == 'E' || __cmd == '0')\n            {\n                if (++__fmtb == __fmte)\n                {\n                    __err = ios_base::failbit;\n                    break;\n                }\n                __opt = __cmd;\n                __cmd = __ct.narrow(*__fmtb, 0);\n            }\n            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);\n            ++__fmtb;\n        }\n        else if (__ct.is(ctype_base::space, *__fmtb))\n        {\n            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)\n                ;\n            for (        ;    __b != __e    && __ct.is(ctype_base::space, *__b);    ++__b)\n                ;\n        }\n        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))\n        {\n            ++__b;\n            ++__fmtb;\n        }\n        else\n            __err = ios_base::failbit;\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\ntypename time_get<_CharT, _InputIterator>::dateorder\ntime_get<_CharT, _InputIterator>::do_date_order() const\n{\n    return mdy;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const string_type& __fmt = this->__x();\n    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,\n                                                 ios_base& __iob,\n                                                 ios_base::iostate& __err,\n                                                 tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,\n                                                   ios_base& __iob,\n                                                   ios_base::iostate& __err,\n                                                   tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_year(__tm->tm_year, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                         ios_base& __iob,\n                                         ios_base::iostate& __err, tm* __tm,\n                                         char __fmt, char) const\n{\n    __err = ios_base::goodbit;\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    switch (__fmt)\n    {\n    case 'a':\n    case 'A':\n        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'b':\n    case 'B':\n    case 'h':\n        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'c':\n        {\n        const string_type& __fm = this->__c();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'd':\n    case 'e':\n        __get_day(__tm->tm_mday, __b, __e, __err, __ct);\n        break;\n    case 'D':\n        {\n        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'F':\n        {\n        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'H':\n        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'I':\n        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'j':\n        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);\n        break;\n    case 'm':\n        __get_month(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'M':\n        __get_minute(__tm->tm_min, __b, __e, __err, __ct);\n        break;\n    case 'n':\n    case 't':\n        __get_white_space(__b, __e, __err, __ct);\n        break;\n    case 'p':\n        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'r':\n        {\n        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'R':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'S':\n        __get_second(__tm->tm_sec, __b, __e, __err, __ct);\n        break;\n    case 'T':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'w':\n        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'x':\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    case 'X':\n        {\n        const string_type& __fm = this->__X();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'y':\n        __get_year(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case 'Y':\n        __get_year4(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case '%':\n        __get_percent(__b, __e, __err, __ct);\n        break;\n    default:\n        __err |= ios_base::failbit;\n    }\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_get\n{\nprotected:\n    locale_t __loc_;\n\n    __time_get(const char* __nm);\n    __time_get(const string& __nm);\n    ~__time_get();\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS __time_get_storage\n    : public __time_get\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    string_type __weeks_[14];\n    string_type __months_[24];\n    string_type __am_pm_[2];\n    string_type __c_;\n    string_type __r_;\n    string_type __x_;\n    string_type __X_;\n\n    explicit __time_get_storage(const char* __nm);\n    explicit __time_get_storage(const string& __nm);\n\n    _LIBCPP_INLINE_VISIBILITY ~__time_get_storage() {}\n\n    time_base::dateorder __do_date_order() const;\n\nprivate:\n    void init(const ctype<_CharT>&);\n    string_type __analyze(char __fmt, const ctype<_CharT>&);\n};\n\n#define _LIBCPP_TIME_GET_STORAGE_EXPLICIT_INSTANTIATION(_CharT) \\\ntemplate <> _LIBCPP_FUNC_VIS time_base::dateorder __time_get_storage<_CharT>::__do_date_order() const; \\\ntemplate <> _LIBCPP_FUNC_VIS __time_get_storage<_CharT>::__time_get_storage(const char*); \\\ntemplate <> _LIBCPP_FUNC_VIS __time_get_storage<_CharT>::__time_get_storage(const string&); \\\ntemplate <> _LIBCPP_FUNC_VIS void __time_get_storage<_CharT>::init(const ctype<_CharT>&); \\\ntemplate <> _LIBCPP_FUNC_VIS __time_get_storage<_CharT>::string_type __time_get_storage<_CharT>::__analyze(char, const ctype<_CharT>&); \\\nextern template _LIBCPP_FUNC_VIS time_base::dateorder __time_get_storage<_CharT>::__do_date_order() const; \\\nextern template _LIBCPP_FUNC_VIS __time_get_storage<_CharT>::__time_get_storage(const char*); \\\nextern template _LIBCPP_FUNC_VIS __time_get_storage<_CharT>::__time_get_storage(const string&); \\\nextern template _LIBCPP_FUNC_VIS void __time_get_storage<_CharT>::init(const ctype<_CharT>&); \\\nextern template _LIBCPP_FUNC_VIS __time_get_storage<_CharT>::string_type __time_get_storage<_CharT>::__analyze(char, const ctype<_CharT>&); \\\n/**/\n\n_LIBCPP_TIME_GET_STORAGE_EXPLICIT_INSTANTIATION(char)\n_LIBCPP_TIME_GET_STORAGE_EXPLICIT_INSTANTIATION(wchar_t)\n#undef _LIBCPP_TIME_GET_STORAGE_EXPLICIT_INSTANTIATION\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_get_byname\n    : public time_get<_CharT, _InputIterator>,\n      private __time_get_storage<_CharT>\n{\npublic:\n    typedef time_base::dateorder    dateorder;\n    typedef _InputIterator          iter_type;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const char* __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const string& __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~time_get_byname() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    virtual dateorder do_date_order() const {return this->__do_date_order();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __weeks() const  {return this->__weeks_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __months() const {return this->__months_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __am_pm() const  {return this->__am_pm_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __c() const      {return this->__c_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __r() const      {return this->__r_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __x() const      {return this->__x_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __X() const      {return this->__X_;}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get_byname<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_put\n{\n    locale_t __loc_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY __time_put() : __loc_(_LIBCPP_GET_C_LOCALE) {}\n    __time_put(const char* __nm);\n    __time_put(const string& __nm);\n    ~__time_put();\n    void __do_put(char* __nb, char*& __ne, const tm* __tm,\n                  char __fmt, char __mod) const;\n    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,\n                  char __fmt, char __mod) const;\n};\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_put\n    : public locale::facet,\n      private __time_put\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,\n                  const char_type* __pb, const char_type* __pe) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const tm* __tm, char __fmt, char __mod = 0) const\n    {\n        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~time_put() {}\n    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,\n                             char __fmt, char __mod) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_put(const char* __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_put(const string& __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\ntime_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,\n                                       char_type __fl, const tm* __tm,\n                                       const char_type* __pb,\n                                       const char_type* __pe) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    for (; __pb != __pe; ++__pb)\n    {\n        if (__ct.narrow(*__pb, 0) == '%')\n        {\n            if (++__pb == __pe)\n            {\n                *__s++ = __pb[-1];\n                break;\n            }\n            char __mod = 0;\n            char __fmt = __ct.narrow(*__pb, 0);\n            if (__fmt == 'E' || __fmt == 'O')\n            {\n                if (++__pb == __pe)\n                {\n                    *__s++ = __pb[-2];\n                    *__s++ = __pb[-1];\n                    break;\n                }\n                __mod = __fmt;\n                __fmt = __ct.narrow(*__pb, 0);\n            }\n            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n        }\n        else\n            *__s++ = *__pb;\n    }\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,\n                                          char_type, const tm* __tm,\n                                          char __fmt, char __mod) const\n{\n    char_type __nar[100];\n    char_type* __nb = __nar;\n    char_type* __ne = __nb + 100;\n    __do_put(__nb, __ne, __tm, __fmt, __mod);\n    return _VSTD::copy(__nb, __ne, __s);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_put_byname\n    : public time_put<_CharT, _OutputIterator>\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_put_byname(const char* __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_put_byname(const string& __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~time_put_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put_byname<wchar_t>)\n\n// money_base\n\nclass _LIBCPP_TYPE_VIS money_base\n{\npublic:\n    enum part {none, space, symbol, sign, value};\n    struct pattern {char field[4];};\n\n    _LIBCPP_INLINE_VISIBILITY money_base() {}\n};\n\n// moneypunct\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TEMPLATE_VIS moneypunct\n    : public locale::facet,\n      public money_base\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit moneypunct(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY char_type   decimal_point() const {return do_decimal_point();}\n    _LIBCPP_INLINE_VISIBILITY char_type   thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_INLINE_VISIBILITY string      grouping()      const {return do_grouping();}\n    _LIBCPP_INLINE_VISIBILITY string_type curr_symbol()   const {return do_curr_symbol();}\n    _LIBCPP_INLINE_VISIBILITY string_type positive_sign() const {return do_positive_sign();}\n    _LIBCPP_INLINE_VISIBILITY string_type negative_sign() const {return do_negative_sign();}\n    _LIBCPP_INLINE_VISIBILITY int         frac_digits()   const {return do_frac_digits();}\n    _LIBCPP_INLINE_VISIBILITY pattern     pos_format()    const {return do_pos_format();}\n    _LIBCPP_INLINE_VISIBILITY pattern     neg_format()    const {return do_neg_format();}\n\n    static locale::id id;\n    static const bool intl = _International;\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~moneypunct() {}\n\n    virtual char_type   do_decimal_point() const {return numeric_limits<char_type>::max();}\n    virtual char_type   do_thousands_sep() const {return numeric_limits<char_type>::max();}\n    virtual string      do_grouping()      const {return string();}\n    virtual string_type do_curr_symbol()   const {return string_type();}\n    virtual string_type do_positive_sign() const {return string_type();}\n    virtual string_type do_negative_sign() const {return string_type(1, '-');}\n    virtual int         do_frac_digits()   const {return 0;}\n    virtual pattern     do_pos_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n    virtual pattern     do_neg_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n};\n\ntemplate <class _CharT, bool _International>\nlocale::id\nmoneypunct<_CharT, _International>::id;\n\ntemplate <class _CharT, bool _International>\nconst bool\nmoneypunct<_CharT, _International>::intl;\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<wchar_t, true>)\n\n// moneypunct_byname\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TEMPLATE_VIS moneypunct_byname\n    : public moneypunct<_CharT, _International>\n{\npublic:\n    typedef money_base::pattern  pattern;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~moneypunct_byname() {}\n\n    virtual char_type   do_decimal_point() const {return __decimal_point_;}\n    virtual char_type   do_thousands_sep() const {return __thousands_sep_;}\n    virtual string      do_grouping()      const {return __grouping_;}\n    virtual string_type do_curr_symbol()   const {return __curr_symbol_;}\n    virtual string_type do_positive_sign() const {return __positive_sign_;}\n    virtual string_type do_negative_sign() const {return __negative_sign_;}\n    virtual int         do_frac_digits()   const {return __frac_digits_;}\n    virtual pattern     do_pos_format()    const {return __pos_format_;}\n    virtual pattern     do_neg_format()    const {return __neg_format_;}\n\nprivate:\n    char_type   __decimal_point_;\n    char_type   __thousands_sep_;\n    string      __grouping_;\n    string_type __curr_symbol_;\n    string_type __positive_sign_;\n    string_type __negative_sign_;\n    int         __frac_digits_;\n    pattern     __pos_format_;\n    pattern     __neg_format_;\n\n    void init(const char*);\n};\n\ntemplate<> _LIBCPP_FUNC_VIS void moneypunct_byname<char, false>::init(const char*);\ntemplate<> _LIBCPP_FUNC_VIS void moneypunct_byname<char, true>::init(const char*);\ntemplate<> _LIBCPP_FUNC_VIS void moneypunct_byname<wchar_t, false>::init(const char*);\ntemplate<> _LIBCPP_FUNC_VIS void moneypunct_byname<wchar_t, true>::init(const char*);\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<wchar_t, true>)\n\n// money_get\n\ntemplate <class _CharT>\nclass __money_get\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY __money_get() {}\n\n    static void __gather_info(bool __intl, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __psn,\n                              string_type& __nsn, int& __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __psn,\n                                   string_type& __nsn, int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS money_get\n    : public locale::facet,\n      private __money_get<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit money_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, string_type& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~money_get() {}\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             long double& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             string_type& __v) const;\n\nprivate:\n    static bool __do_get(iter_type& __b, iter_type __e,\n                         bool __intl, const locale& __loc,\n                         ios_base::fmtflags __flags, ios_base::iostate& __err,\n                         bool& __neg, const ctype<char_type>& __ct,\n                         unique_ptr<char_type, void(*)(void*)>& __wb,\n                         char_type*& __wn, char_type* __we);\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nmoney_get<_CharT, _InputIterator>::id;\n\n_LIBCPP_FUNC_VIS void __do_nothing(void*);\n\ntemplate <class _Tp>\n_LIBCPP_HIDDEN\nvoid\n__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)\n{\n    bool __owns = __b.get_deleter() != __do_nothing;\n    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);\n    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?\n                       2 * __cur_cap : numeric_limits<size_t>::max();\n    if (__new_cap == 0)\n        __new_cap = sizeof(_Tp);\n    size_t __n_off = static_cast<size_t>(__n - __b.get());\n    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);\n    if (__t == 0)\n        __throw_bad_alloc();\n    if (__owns)\n        __b.release();\n    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);\n    __new_cap /= sizeof(_Tp);\n    __n = __b.get() + __n_off;\n    __e = __b.get() + __new_cap;\n}\n\n// true == success\ntemplate <class _CharT, class _InputIterator>\nbool\nmoney_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,\n                                            bool __intl, const locale& __loc,\n                                            ios_base::fmtflags __flags,\n                                            ios_base::iostate& __err,\n                                            bool& __neg,\n                                            const ctype<char_type>& __ct,\n                                            unique_ptr<char_type, void(*)(void*)>& __wb,\n                                            char_type*& __wn, char_type* __we)\n{\n    const unsigned __bz = 100;\n    unsigned __gbuf[__bz];\n    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);\n    unsigned* __gn = __gb.get();\n    unsigned* __ge = __gn + __bz;\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __psn;\n    string_type __nsn;\n    // Capture the spaces read into money_base::{space,none} so they\n    // can be compared to initial spaces in __sym.\n    string_type __spaces;\n    int __fd;\n    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,\n                                       __sym, __psn, __nsn, __fd);\n    const string_type* __trailing_sign = 0;\n    __wn = __wb.get();\n    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::space:\n            if (__p != 3)\n            {\n                if (__ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n                else\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            _LIBCPP_FALLTHROUGH();\n        case money_base::none:\n            if (__p != 3)\n            {\n                while (__b != __e && __ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n            }\n            break;\n        case money_base::sign:\n            if (__psn.size() + __nsn.size() > 0)\n            {\n                if (__psn.size() == 0 || __nsn.size() == 0)\n                {   // sign is optional\n                    if (__psn.size() > 0)\n                    {   // __nsn.size() == 0\n                        if (*__b == __psn[0])\n                        {\n                            ++__b;\n                            if (__psn.size() > 1)\n                                __trailing_sign = &__psn;\n                        }\n                        else\n                            __neg = true;\n                    }\n                    else if (*__b == __nsn[0])  // __nsn.size() > 0 &&  __psn.size() == 0\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                }\n                else  // sign is required\n                {\n                    if (*__b == __psn[0])\n                    {\n                        ++__b;\n                        if (__psn.size() > 1)\n                            __trailing_sign = &__psn;\n                    }\n                    else if (*__b == __nsn[0])\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                    else\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                }\n            }\n            break;\n        case money_base::symbol:\n            {\n            bool __more_needed = __trailing_sign ||\n                                 (__p < 2)       ||\n                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));\n            bool __sb = (__flags & ios_base::showbase) != 0;\n            if (__sb || __more_needed)\n            {\n                typename string_type::const_iterator __sym_space_end = __sym.begin();\n                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||\n                                __pat.field[__p - 1] == money_base::space)) {\n                    // Match spaces we've already read against spaces at\n                    // the beginning of __sym.\n                    while (__sym_space_end != __sym.end() &&\n                           __ct.is(ctype_base::space, *__sym_space_end))\n                        ++__sym_space_end;\n                    const size_t __num_spaces = __sym_space_end - __sym.begin();\n                    if (__num_spaces > __spaces.size() ||\n                        !equal(__spaces.end() - __num_spaces, __spaces.end(),\n                               __sym.begin())) {\n                        // No match. Put __sym_space_end back at the\n                        // beginning of __sym, which will prevent a\n                        // match in the next loop.\n                        __sym_space_end = __sym.begin();\n                    }\n                }\n                typename string_type::const_iterator __sym_curr_char = __sym_space_end;\n                while (__sym_curr_char != __sym.end() && __b != __e &&\n                       *__b == *__sym_curr_char) {\n                    ++__b;\n                    ++__sym_curr_char;\n                }\n                if (__sb && __sym_curr_char != __sym.end())\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            }\n            break;\n        case money_base::value:\n            {\n            unsigned __ng = 0;\n            for (; __b != __e; ++__b)\n            {\n                char_type __c = *__b;\n                if (__ct.is(ctype_base::digit, __c))\n                {\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = __c;\n                    ++__ng;\n                }\n                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)\n                {\n                    if (__gn == __ge)\n                        __double_or_nothing(__gb, __gn, __ge);\n                    *__gn++ = __ng;\n                    __ng = 0;\n                }\n                else\n                    break;\n            }\n            if (__gb.get() != __gn && __ng > 0)\n            {\n                if (__gn == __ge)\n                    __double_or_nothing(__gb, __gn, __ge);\n                *__gn++ = __ng;\n            }\n            if (__fd > 0)\n            {\n                if (__b == __e || *__b != __dp)\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n                for (++__b; __fd > 0; --__fd, ++__b)\n                {\n                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = *__b;\n                }\n            }\n            if (__wn == __wb.get())\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n            }\n            break;\n        }\n    }\n    if (__trailing_sign)\n    {\n        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)\n        {\n            if (__b == __e || *__b != (*__trailing_sign)[__i])\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n        }\n    }\n    if (__gb.get() != __gn)\n    {\n        ios_base::iostate __et = ios_base::goodbit;\n        __check_grouping(__grp, __gb.get(), __gn, __et);\n        if (__et)\n        {\n            __err |= ios_base::failbit;\n            return false;\n        }\n    }\n    return true;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          long double& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        const char __src[] = \"0123456789\";\n        char_type __atoms[sizeof(__src)-1];\n        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);\n        char __nbuf[__bz];\n        char* __nc = __nbuf;\n        unique_ptr<char, void(*)(void*)> __h(0, free);\n        if (__wn - __wb.get() > __bz-2)\n        {\n            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));\n            if (__h.get() == 0)\n                __throw_bad_alloc();\n            __nc = __h.get();\n        }\n        if (__neg)\n            *__nc++ = '-';\n        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)\n            *__nc = __src[find(__atoms, _VSTD::end(__atoms), *__w) - __atoms];\n        *__nc = char();\n        if (sscanf(__nbuf, \"%Lf\", &__v) != 1)\n            __throw_runtime_error(\"money_get error\");\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          string_type& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        __v.clear();\n        if (__neg)\n            __v.push_back(__ct.widen('-'));\n        char_type __z = __ct.widen('0');\n        char_type* __w;\n        for (__w = __wb.get(); __w < __wn-1; ++__w)\n            if (*__w != __z)\n                break;\n        __v.append(__w, __wn);\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_get<wchar_t>)\n\n// money_put\n\ntemplate <class _CharT>\nclass __money_put\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY __money_put() {}\n\n    static void __gather_info(bool __intl, bool __neg, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __sn,\n                              int& __fd);\n    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                         ios_base::fmtflags __flags,\n                         const char_type* __db, const char_type* __de,\n                         const ctype<char_type>& __ct, bool __neg,\n                         const money_base::pattern& __pat, char_type __dp,\n                         char_type __ts, const string& __grp,\n                         const string_type& __sym, const string_type& __sn,\n                         int __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __sn,\n                                   int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                              ios_base::fmtflags __flags,\n                              const char_type* __db, const char_type* __de,\n                              const ctype<char_type>& __ct, bool __neg,\n                              const money_base::pattern& __pat, char_type __dp,\n                              char_type __ts, const string& __grp,\n                              const string_type& __sym, const string_type& __sn,\n                              int __fd)\n{\n    __me = __mb;\n    for (unsigned __p = 0; __p < 4; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::none:\n            __mi = __me;\n            break;\n        case money_base::space:\n            __mi = __me;\n            *__me++ = __ct.widen(' ');\n            break;\n        case money_base::sign:\n            if (!__sn.empty())\n                *__me++ = __sn[0];\n            break;\n        case money_base::symbol:\n            if (!__sym.empty() && (__flags & ios_base::showbase))\n                __me = _VSTD::copy(__sym.begin(), __sym.end(), __me);\n            break;\n        case money_base::value:\n            {\n            // remember start of value so we can reverse it\n            char_type* __t = __me;\n            // find beginning of digits\n            if (__neg)\n                ++__db;\n            // find end of digits\n            const char_type* __d;\n            for (__d = __db; __d < __de; ++__d)\n                if (!__ct.is(ctype_base::digit, *__d))\n                    break;\n            // print fractional part\n            if (__fd > 0)\n            {\n                int __f;\n                for (__f = __fd; __d > __db && __f > 0; --__f)\n                    *__me++ = *--__d;\n                char_type __z = __f > 0 ? __ct.widen('0') : char_type();\n                for (; __f > 0; --__f)\n                    *__me++ = __z;\n                *__me++ = __dp;\n            }\n            // print units part\n            if (__d == __db)\n            {\n                *__me++ = __ct.widen('0');\n            }\n            else\n            {\n                unsigned __ng = 0;\n                unsigned __ig = 0;\n                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()\n                                              : static_cast<unsigned>(__grp[__ig]);\n                while (__d != __db)\n                {\n                    if (__ng == __gl)\n                    {\n                        *__me++ = __ts;\n                        __ng = 0;\n                        if (++__ig < __grp.size())\n                            __gl = __grp[__ig] == numeric_limits<char>::max() ?\n                                        numeric_limits<unsigned>::max() :\n                                        static_cast<unsigned>(__grp[__ig]);\n                    }\n                    *__me++ = *--__d;\n                    ++__ng;\n                }\n            }\n            // reverse it\n            reverse(__t, __me);\n            }\n            break;\n        }\n    }\n    // print rest of sign, if any\n    if (__sn.size() > 1)\n        __me = _VSTD::copy(__sn.begin()+1, __sn.end(), __me);\n    // set alignment\n    if ((__flags & ios_base::adjustfield) == ios_base::left)\n        __mi = __me;\n    else if ((__flags & ios_base::adjustfield) != ios_base::internal)\n        __mi = __mb;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS money_put\n    : public locale::facet,\n      private __money_put<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _OutputIterator         iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit money_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  long double __units) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __units);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  const string_type& __digits) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __digits);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~money_put() {}\n\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, long double __units) const;\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, const string_type& __digits) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nmoney_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           long double __units) const\n{\n    // convert to char\n    const size_t __bs = 100;\n    char __buf[__bs];\n    char* __bb = __buf;\n    char_type __digits[__bs];\n    char_type* __db = __digits;\n    size_t __n = static_cast<size_t>(snprintf(__bb, __bs, \"%.0Lf\", __units));\n    unique_ptr<char, void(*)(void*)> __hn(0, free);\n    unique_ptr<char_type, void(*)(void*)> __hd(0, free);\n    // secure memory for digit storage\n    if (__n > __bs-1)\n    {\n        __n = static_cast<size_t>(__libcpp_asprintf_l(&__bb, _LIBCPP_GET_C_LOCALE, \"%.0Lf\", __units));\n        if (__bb == 0)\n            __throw_bad_alloc();\n        __hn.reset(__bb);\n        __hd.reset((char_type*)malloc(__n * sizeof(char_type)));\n        if (__hd == nullptr)\n            __throw_bad_alloc();\n        __db = __hd.get();\n    }\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    __ct.widen(__bb, __bb + __n, __db);\n    bool __neg = __n > 0 && __bb[0] == '-';\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[__bs];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __hw(0, free);\n    size_t __exn = static_cast<int>(__n) > __fd ?\n                   (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() +\n                    __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > __bs)\n    {\n        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __hw.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __db, __db + __n, __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           const string_type& __digits) const\n{\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[100];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __h(0, free);\n    size_t __exn = static_cast<int>(__digits.size()) > __fd ?\n                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +\n                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > 100)\n    {\n        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __h.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __digits.data(), __digits.data() + __digits.size(), __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_put<wchar_t>)\n\n// messages\n\nclass _LIBCPP_TYPE_VIS messages_base\n{\npublic:\n    typedef ptrdiff_t catalog;\n\n    _LIBCPP_INLINE_VISIBILITY messages_base() {}\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS messages\n    : public locale::facet,\n      public messages_base\n{\npublic:\n    typedef _CharT               char_type;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit messages(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    catalog open(const basic_string<char>& __nm, const locale& __loc) const\n    {\n        return do_open(__nm, __loc);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    string_type get(catalog __c, int __set, int __msgid,\n                    const string_type& __dflt) const\n    {\n        return do_get(__c, __set, __msgid, __dflt);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void close(catalog __c) const\n    {\n        do_close(__c);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~messages() {}\n\n    virtual catalog do_open(const basic_string<char>&, const locale&) const;\n    virtual string_type do_get(catalog, int __set, int __msgid,\n                               const string_type& __dflt) const;\n    virtual void do_close(catalog) const;\n};\n\ntemplate <class _CharT>\nlocale::id\nmessages<_CharT>::id;\n\ntemplate <class _CharT>\ntypename messages<_CharT>::catalog\nmessages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const\n{\n#ifdef _LIBCPP_HAS_CATOPEN\n    catalog __cat = (catalog)catopen(__nm.c_str(), NL_CAT_LOCALE);\n    if (__cat != -1)\n        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));\n    return __cat;\n#else // !_LIBCPP_HAS_CATOPEN\n    _LIBCPP_UNUSED_VAR(__nm);\n    return -1;\n#endif // _LIBCPP_HAS_CATOPEN\n}\n\ntemplate <class _CharT>\ntypename messages<_CharT>::string_type\nmessages<_CharT>::do_get(catalog __c, int __set, int __msgid,\n                         const string_type& __dflt) const\n{\n#ifdef _LIBCPP_HAS_CATOPEN\n    string __ndflt;\n    __narrow_to_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__ndflt),\n                                                       __dflt.c_str(),\n                                                       __dflt.c_str() + __dflt.size());\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());\n    string_type __w;\n    __widen_from_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__w),\n                                                        __n, __n + strlen(__n));\n    return __w;\n#else // !_LIBCPP_HAS_CATOPEN\n    _LIBCPP_UNUSED_VAR(__c);\n    _LIBCPP_UNUSED_VAR(__set);\n    _LIBCPP_UNUSED_VAR(__msgid);\n    return __dflt;\n#endif // _LIBCPP_HAS_CATOPEN\n}\n\ntemplate <class _CharT>\nvoid\nmessages<_CharT>::do_close(catalog __c) const\n{\n#ifdef _LIBCPP_HAS_CATOPEN\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    catclose(__cat);\n#else // !_LIBCPP_HAS_CATOPEN\n    _LIBCPP_UNUSED_VAR(__c);\n#endif // _LIBCPP_HAS_CATOPEN\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages<wchar_t>)\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS messages_byname\n    : public messages<_CharT>\n{\npublic:\n    typedef messages_base::catalog catalog;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit messages_byname(const char*, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit messages_byname(const string&, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~messages_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages_byname<wchar_t>)\n\ntemplate<class _Codecvt, class _Elem = wchar_t,\n         class _Wide_alloc = allocator<_Elem>,\n         class _Byte_alloc = allocator<char> >\nclass _LIBCPP_TEMPLATE_VIS wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, _Byte_alloc>   byte_string;\n    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;\n    typedef typename _Codecvt::state_type                        state_type;\n    typedef typename wide_string::traits_type::int_type          int_type;\n\nprivate:\n    byte_string __byte_err_string_;\n    wide_string __wide_err_string_;\n    _Codecvt* __cvtptr_;\n    state_type __cvtstate_;\n    size_t __cvtcount_;\n\n    wstring_convert(const wstring_convert& __wc);\n    wstring_convert& operator=(const wstring_convert& __wc);\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(_Codecvt* __pcvt = new _Codecvt);\n    _LIBCPP_INLINE_VISIBILITY\n    wstring_convert(_Codecvt* __pcvt, state_type __state);\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(const byte_string& __byte_err,\n                    const wide_string& __wide_err = wide_string());\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    wstring_convert(wstring_convert&& __wc);\n#endif\n    ~wstring_convert();\n\n    _LIBCPP_INLINE_VISIBILITY\n    wide_string from_bytes(char __byte)\n        {return from_bytes(&__byte, &__byte+1);}\n    _LIBCPP_INLINE_VISIBILITY\n    wide_string from_bytes(const char* __ptr)\n        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}\n    _LIBCPP_INLINE_VISIBILITY\n    wide_string from_bytes(const byte_string& __str)\n        {return from_bytes(__str.data(), __str.data() + __str.size());}\n    wide_string from_bytes(const char* __first, const char* __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    byte_string to_bytes(_Elem __wchar)\n        {return to_bytes(&__wchar, &__wchar+1);}\n    _LIBCPP_INLINE_VISIBILITY\n    byte_string to_bytes(const _Elem* __wptr)\n        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}\n    _LIBCPP_INLINE_VISIBILITY\n    byte_string to_bytes(const wide_string& __wstr)\n        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}\n    byte_string to_bytes(const _Elem* __first, const _Elem* __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t converted() const _NOEXCEPT {return __cvtcount_;}\n    _LIBCPP_INLINE_VISIBILITY\n    state_type state() const {return __cvtstate_;}\n};\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt)\n        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt, state_type __state)\n        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)\n        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),\n          __cvtstate_(), __cvtcount_(0)\n{\n    __cvtptr_ = new _Codecvt;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(wstring_convert&& __wc)\n        : __byte_err_string_(_VSTD::move(__wc.__byte_err_string_)),\n          __wide_err_string_(_VSTD::move(__wc.__wide_err_string_)),\n          __cvtptr_(__wc.__cvtptr_),\n          __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtcount_)\n{\n    __wc.__cvtptr_ = nullptr;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()\n{\n    delete __cvtptr_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    from_bytes(const char* __frm, const char* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        wide_string __ws(2*(__frm_end - __frm), _Elem());\n        if (__frm != __frm_end)\n            __ws.resize(__ws.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            _Elem* __to = &__ws[0];\n            _Elem* __to_end = __to + __ws.size();\n            const char* __frm_nxt;\n            do\n            {\n                _Elem* __to_nxt;\n                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,\n                                          __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __ws.resize(__to - &__ws[0]);\n                    // This only gets executed if _Elem is char\n                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __ws.resize(__to_nxt - &__ws[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__ws[0];\n                    __ws.resize(2 * __s);\n                    __to = &__ws[0] + __s;\n                    __to_end = &__ws[0] + __ws.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n            return __ws;\n    }\n\n    if (__wide_err_string_.empty())\n        __throw_range_error(\"wstring_convert: from_bytes error\");\n\n    return __wide_err_string_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    to_bytes(const _Elem* __frm, const _Elem* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        byte_string __bs(2*(__frm_end - __frm), char());\n        if (__frm != __frm_end)\n            __bs.resize(__bs.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            char* __to = &__bs[0];\n            char* __to_end = __to + __bs.size();\n            const _Elem* __frm_nxt;\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,\n                                           __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    // This only gets executed if _Elem is char\n                    __bs.append((const char*)__frm, (const char*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __s);\n                    __to = &__bs[0] + __s;\n                    __to_end = &__bs[0] + __bs.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n        {\n            size_t __s = __bs.size();\n            __bs.resize(__bs.capacity());\n            char* __to = &__bs[0] + __s;\n            char* __to_end = __to + __bs.size();\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);\n                if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __sp = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __sp);\n                    __to = &__bs[0] + __sp;\n                    __to_end = &__bs[0] + __bs.size();\n                }\n            } while (__r == codecvt_base::partial);\n            if (__r == codecvt_base::ok)\n                return __bs;\n        }\n    }\n\n    if (__byte_err_string_.empty())\n        __throw_range_error(\"wstring_convert: to_bytes error\");\n\n    return __byte_err_string_;\n}\n\ntemplate <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >\nclass _LIBCPP_TEMPLATE_VIS wbuffer_convert\n    : public basic_streambuf<_Elem, _Tr>\n{\npublic:\n    // types:\n    typedef _Elem                          char_type;\n    typedef _Tr                            traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef typename _Codecvt::state_type  state_type;\n\nprivate:\n    char*       __extbuf_;\n    const char* __extbufnext_;\n    const char* __extbufend_;\n    char __extbuf_min_[8];\n    size_t __ebs_;\n    char_type* __intbuf_;\n    size_t __ibs_;\n    streambuf* __bufptr_;\n    _Codecvt* __cv_;\n    state_type __st_;\n    ios_base::openmode __cm_;\n    bool __owns_eb_;\n    bool __owns_ib_;\n    bool __always_noconv_;\n\n    wbuffer_convert(const wbuffer_convert&);\n    wbuffer_convert& operator=(const wbuffer_convert&);\npublic:\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wbuffer_convert(streambuf* __bytebuf = 0, \n            _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());\n    ~wbuffer_convert();\n\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf() const {return __bufptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf(streambuf* __bytebuf)\n    {\n        streambuf* __r = __bufptr_;\n        __bufptr_ = __bytebuf;\n        return __r;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    state_type state() const {return __st_;}\n\nprotected:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,\n                                                            streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual int sync();\n\nprivate:\n    bool __read_mode();\n    void __write_mode();\n    wbuffer_convert* __close();\n};\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::\n    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)\n    : __extbuf_(0),\n      __extbufnext_(0),\n      __extbufend_(0),\n      __ebs_(0),\n      __intbuf_(0),\n      __ibs_(0),\n      __bufptr_(__bytebuf),\n      __cv_(__pcvt),\n      __st_(__state),\n      __cm_(0),\n      __owns_eb_(false),\n      __owns_ib_(false),\n      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)\n{\n    setbuf(0, 4096);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()\n{\n    __close();\n    delete __cv_;\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    bool __initial = __read_mode();\n    char_type __1buf;\n    if (this->gptr() == 0)\n        this->setg(&__1buf, &__1buf+1, &__1buf+1);\n    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);\n    int_type __c = traits_type::eof();\n    if (this->gptr() == this->egptr())\n    {\n        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);\n            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);\n            if (__nmemb != 0)\n            {\n                this->setg(this->eback(),\n                           this->eback() + __unget_sz,\n                           this->eback() + __unget_sz + __nmemb);\n                __c = *this->gptr();\n            }\n        }\n        else\n        {\n             _LIBCPP_ASSERT(!(__extbufnext_ == NULL && (__extbufend_ != __extbufnext_)), \"underflow moving from NULL\" );\n             if (__extbufend_ != __extbufnext_)\n                memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);\n            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);\n            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);\n            streamsize __nmemb = _VSTD::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),\n                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));\n            codecvt_base::result __r;\n            // FIXME: Do we ever need to restore the state here?\n            //state_type __svs = __st_;\n            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);\n            if (__nr != 0)\n            {\n                __extbufend_ = __extbufnext_ + __nr;\n                char_type*  __inext;\n                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,\n                                       this->eback() + __unget_sz,\n                                       this->egptr(), __inext);\n                if (__r == codecvt_base::noconv)\n                {\n                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, \n                               (char_type*) const_cast<char *>(__extbufend_));\n                    __c = *this->gptr();\n                }\n                else if (__inext != this->eback() + __unget_sz)\n                {\n                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);\n                    __c = *this->gptr();\n                }\n            }\n        }\n    }\n    else\n        __c = *this->gptr();\n    if (this->eback() == &__1buf)\n        this->setg(0, 0, 0);\n    return __c;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)\n{\n    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->gbump(-1);\n            return traits_type::not_eof(__c);\n        }\n        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->gbump(-1);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    __write_mode();\n    char_type __1buf;\n    char_type* __pb_save = this->pbase();\n    char_type* __epb_save = this->epptr();\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        if (this->pptr() == 0)\n            this->setp(&__1buf, &__1buf+1);\n        *this->pptr() = traits_type::to_char_type(__c);\n        this->pbump(1);\n    }\n    if (this->pptr() != this->pbase())\n    {\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());\n            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                return traits_type::eof();\n        }\n        else\n        {\n            char* __extbe = __extbuf_;\n            codecvt_base::result __r;\n            do\n            {\n                const char_type* __e;\n                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,\n                                        __extbuf_, __extbuf_ + __ebs_, __extbe);\n                if (__e == this->pbase())\n                    return traits_type::eof();\n                if (__r == codecvt_base::noconv)\n                {\n                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                        return traits_type::eof();\n                }\n                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n                {\n                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                        return traits_type::eof();\n                    if (__r == codecvt_base::partial)\n                    {\n                        this->setp(const_cast<char_type *>(__e), this->pptr());\n                        this->__pbump(this->epptr() - this->pbase());\n                    }\n                }\n                else\n                    return traits_type::eof();\n            } while (__r == codecvt_base::partial);\n        }\n        this->setp(__pb_save, __epb_save);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbasic_streambuf<_Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)\n{\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n    __ebs_ = __n;\n    if (__ebs_ > sizeof(__extbuf_min_))\n    {\n        if (__always_noconv_ && __s)\n        {\n            __extbuf_ = (char*)__s;\n            __owns_eb_ = false;\n        }\n        else\n        {\n            __extbuf_ = new char[__ebs_];\n            __owns_eb_ = true;\n        }\n    }\n    else\n    {\n        __extbuf_ = __extbuf_min_;\n        __ebs_ = sizeof(__extbuf_min_);\n        __owns_eb_ = false;\n    }\n    if (!__always_noconv_)\n    {\n        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));\n        if (__s && __ibs_ >= sizeof(__extbuf_min_))\n        {\n            __intbuf_ = __s;\n            __owns_ib_ = false;\n        }\n        else\n        {\n            __intbuf_ = new char_type[__ibs_];\n            __owns_ib_ = true;\n        }\n    }\n    else\n    {\n        __ibs_ = 0;\n        __intbuf_ = 0;\n        __owns_ib_ = false;\n    }\n    return this;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,\n                                        ios_base::openmode __om)\n{\n    int __width = __cv_->encoding();\n    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())\n        return pos_type(off_type(-1));\n    // __width > 0 || __off == 0, now check __way\n    if (__way != ios_base::beg && __way != ios_base::cur && __way != ios_base::end)\n        return pos_type(off_type(-1));\n    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);\n    __r.state(__st_);\n    return __r;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)\n{\n    if (__cv_ == 0 || __bufptr_ == 0 || sync())\n        return pos_type(off_type(-1));\n    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))\n        return pos_type(off_type(-1));\n    return __sp;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nint\nwbuffer_convert<_Codecvt, _Elem, _Tr>::sync()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return 0;\n    if (__cm_ & ios_base::out)\n    {\n        if (this->pptr() != this->pbase())\n            if (overflow() == traits_type::eof())\n                return -1;\n        codecvt_base::result __r;\n        do\n        {\n            char* __extbe;\n            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);\n            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);\n            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                return -1;\n        } while (__r == codecvt_base::partial);\n        if (__r == codecvt_base::error)\n            return -1;\n        if (__bufptr_->pubsync())\n            return -1;\n    }\n    else if (__cm_ & ios_base::in)\n    {\n        off_type __c;\n        if (__always_noconv_)\n            __c = this->egptr() - this->gptr();\n        else\n        {\n            int __width = __cv_->encoding();\n            __c = __extbufend_ - __extbufnext_;\n            if (__width > 0)\n                __c += __width * (this->egptr() - this->gptr());\n            else\n            {\n                if (this->gptr() != this->egptr())\n                {\n                    reverse(this->gptr(), this->egptr());\n                    codecvt_base::result __r;\n                    const char_type* __e = this->gptr();\n                    char* __extbe;\n                    do\n                    {\n                        __r = __cv_->out(__st_, __e, this->egptr(), __e,\n                                         __extbuf_, __extbuf_ + __ebs_, __extbe);\n                        switch (__r)\n                        {\n                        case codecvt_base::noconv:\n                            __c += this->egptr() - this->gptr();\n                            break;\n                        case codecvt_base::ok:\n                        case codecvt_base::partial:\n                            __c += __extbe - __extbuf_;\n                            break;\n                        default:\n                            return -1;\n                        }\n                    } while (__r == codecvt_base::partial);\n                }\n            }\n        }\n        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))\n            return -1;\n        this->setg(0, 0, 0);\n        __cm_ = 0;\n    }\n    return 0;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbool\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()\n{\n    if (!(__cm_ & ios_base::in))\n    {\n        this->setp(0, 0);\n        if (__always_noconv_)\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + __ebs_,\n                       (char_type*)__extbuf_ + __ebs_);\n        else\n            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);\n        __cm_ = ios_base::in;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nvoid\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()\n{\n    if (!(__cm_ & ios_base::out))\n    {\n        this->setg(0, 0, 0);\n        if (__ebs_ > sizeof(__extbuf_min_))\n        {\n            if (__always_noconv_)\n                this->setp((char_type*)__extbuf_,\n                           (char_type*)__extbuf_ + (__ebs_ - 1));\n            else\n                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));\n        }\n        else\n            this->setp(0, 0);\n        __cm_ = ios_base::out;\n    }\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__close()\n{\n    wbuffer_convert* __rt = 0;\n    if (__cv_ != 0 && __bufptr_ != 0)\n    {\n        __rt = this;\n        if ((__cm_ & ios_base::out) && sync())\n            __rt = 0;\n    }\n    return __rt;\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_LOCALE\n","/**\n *  @note This file is part of Empirical, https://github.com/devosoft/Empirical\n *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md\n *  @date 2015-2017\n *\n *  @file color_map.hpp\n *  @brief Tools to dynamically build (and cache) color maps.\n */\n\n#ifndef EMP_WEB_COLOR_MAP_HPP_INCLUDE\n#define EMP_WEB_COLOR_MAP_HPP_INCLUDE\n\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <string>\n#include <tuple>\n\n#include \"../base/vector.hpp\"\n#include \"../tools/string_utils.hpp\"\n\nnamespace emp {\n\n  namespace {\n    using dHueMapKey = std::tuple<int, double, double, int, int>;\n    using dHueMap = std::map<dHueMapKey, emp::vector<std::string> >;\n\n    dHueMap hue_maps;\n  }\n\n  /// Generate a string to describe a JS color out of HSL values.\n  std::string ColorHSL(double h, double s, double l) {\n    emp_assert(h >= 0 && h <= 360, h);\n    emp_assert(s >= 0 && s <= 100, s);\n    emp_assert(l >= 0 && l <= 100, l);\n    std::stringstream ss;\n    ss << \"hsl(\" <<  h << ',' << s << \"%,\" <<  l << \"%)\";\n    return ss.str();\n  }\n\n  /// Generate a string to describe a JS color out of RGB values.\n  std::string ColorRGB(int r, int g, int b) {\n    emp_assert(r >= 0 && r <= 255);\n    emp_assert(g >= 0 && g <= 255);\n    emp_assert(b >= 0 && b <= 255);\n    std::stringstream ss;\n    ss << '#' << std::setw(2) << std::setfill('0') << std::hex << r\n       << std::setw(2) << std::setfill('0') << std::hex << g\n       << std::setw(2) << std::setfill('0') << std::hex << b;\n    return ss.str();\n  }\n\n  /// Generate a string to describe a JS color with an alpha channel.\n  std::string ColorRGB(int r, int g, int b, double a) {\n    emp_assert(r >= 0 && r <= 255);\n    emp_assert(g >= 0 && g <= 255);\n    emp_assert(b >= 0 && b <= 255);\n    emp_assert(a >= 0 && a <= 1.0);\n    std::stringstream ss;\n    ss << \"rgba(\" << r << ',' << g << ',' << b << ',' << a << ')';\n    return ss.str();\n  }\n\n  /// Generate a string to describe a JS color out of HSV values.\n  std::string ColorHSV(double h, double s, double v) {\n    // adapted from https://gist.github.com/kuathadianto/200148f53616cbd226d993b400214a7f\n\n    emp_assert( h >= 0.0 && h <= 360.0);\n    emp_assert( s >= 0.0 && s <= 1.0);\n    emp_assert( v >= 0.0 && v <= 1.0);\n\n    double c = s * v;\n    double x = c * (1 - std::abs(std::fmod(h / 60.0, 2) - 1));\n    double m = v - c;\n    double rs, gs, bs;\n\n    if(h >= 0 && h < 60) {\n      rs = c;\n      gs = x;\n      bs = 0;\n    } else if(h >= 60 && h < 120) {\n      rs = x;\n      gs = c;\n      bs = 0;\n    } else if(h >= 120 && h < 180) {\n      rs = 0;\n      gs = c;\n      bs = x;\n    } else if(h >= 180 && h < 240) {\n      rs = 0;\n      gs = x;\n      bs = c;\n    } else if(h >= 240 && h < 300) {\n      rs = x;\n      gs = 0;\n      bs = c;\n    } else {\n      rs = c;\n      gs = 0;\n      bs = x;\n    }\n\n    int r = (int) ((rs + m) * 255);\n    int g = (int) ((gs + m) * 255);\n    int b = (int) ((bs + m) * 255);\n\n    return ColorRGB(r, g, b);\n  }\n\n  /// Generate a vector of color strings with a specified range of hues, and fixed satuation and\n  /// luminosity,\n  const emp::vector<std::string> &\n  GetHueMap(size_t map_size, double min_h=0.0, double max_h=360.0, int s=100, int l=50) {\n    dHueMapKey map_key = std::make_tuple(map_size, min_h, max_h, s, l);\n\n    // Grab the current map out of the cache.\n    emp::vector<std::string> & cur_map = hue_maps[map_key];\n\n    // If we've already asked for an identical map before, skip map generation!\n    if (cur_map.size() != (std::size_t) map_size) {\n\n      // Otherwise generate this map...\n      cur_map.resize(map_size);\n      double step_size = (max_h - min_h) / (double) map_size;\n      for (size_t i = 0; i < map_size; ++i) {\n        double h = min_h + step_size * i;\n        cur_map[i] = ColorHSL(h, s, l);\n      }\n    }\n\n    return cur_map;\n  }\n\n  /// Generate a vector of color strings providing ranges of all of hue, satuation and luminosity.\n  emp::vector<std::string>\n  GetHSLMap(size_t map_size, double min_h=0.0, double max_h=360.0,\n            int min_s=100, int max_s=100,\n            int min_l=50, int max_l=50) {\n\n    // @CAO: Should cache maps!\n    emp::vector<std::string> cur_map(map_size);\n    double h_step = (max_h - min_h) / (double) map_size;\n    double s_step = (max_s - min_s) / (double) map_size;\n    double l_step = (max_l - min_l) / (double) map_size;\n    for (size_t i = 0; i < map_size; ++i) {\n      double h = min_h + h_step * i;\n      double s = min_s + s_step * i;\n      double l = min_l + l_step * i;\n      if (h > 360) h -= 360;\n      if (s > 100) s -= 100;\n      if (l > 100) l -= 100;\n      cur_map[i] = ColorHSL(h, s, l);\n    }\n\n    return cur_map;\n  }\n\n\n}\n\n\n#endif // #ifndef EMP_WEB_COLOR_MAP_HPP_INCLUDE\n"]}