#pragma once

#include <functional>
#include <map>
#include <iostream>
#include <string>
#include <algorithm>

#include "emp/bits/BitVector.hpp"
#include "emp/base/vector.hpp"
#include "emp/datastructs/vector_utils.hpp"
#include "emp/tools/string_utils.hpp"
#include "emp/functional/FunctionSet.hpp"

#include "chemical-ecology/CommunityStructure.hpp"
#include "chemical-ecology/RecordedCommunitySummarizer.hpp"

// TODO - clean things up with an interaction matrix class

namespace chemical_ecology {

// Forward declarations
struct RecordedCommunitySummary;
class RecordedCommunitySummarizer;

// TODO - make class, protect member variables?
struct RecordedCommunitySummary {
  emp::vector<double> counts;               // Species counts - this should uniquely identify this community (in the context of a RecordedCommunitySet)
  emp::vector<size_t> present_species_ids;  // List of species IDs present in this recorded community
  emp::BitVector present;                   // BitVector describing presence/absence of each species

  emp::BitVector present_with_other_subcommunity_members; // Species present with at least one other members of their subcommunity
  emp::BitVector present_with_interaction_path;   // Species present with at least one valid interaction path to another species present

  emp::vector<size_t> complete_subcommunities_present; // IDs of complete subcommunity structures present in this recorded community
                                                       //   IDs come from given CommunityStructure instance
  emp::vector<size_t> partial_subcommunities_present;  // IDs of partial subcommunity structures present in this recorded community
                                                       //   IDs come from given CommunityStructure instance
  emp::vector<double> proportion_subcommunity_present; // Proportion of each subcommunity structure present in recorded community

  bool operator<(const RecordedCommunitySummary& other) const {
    return counts < other.counts;
  }

  void Reset(size_t num_members=0) {
    (present.Resize(num_members)).Clear();
    (present_with_other_subcommunity_members.Resize(num_members)).Clear();
    (present_with_interaction_path.Resize(num_members)).Clear();
    present_species_ids.clear();
    counts.clear();
    counts.resize(num_members, 0);
    complete_subcommunities_present.clear();
    partial_subcommunities_present.clear();
    proportion_subcommunity_present.clear();
  }

  // Get number of distinct species present in this summarized community
  size_t GetNumSpeciesPresent() const { return present_species_ids.size(); }

  size_t GetPopulationSize() const {
    return emp::Sum(counts);
  }

  size_t GetNumCompleteSubCommunities() const {
    return complete_subcommunities_present.size();
  }

  // "Pretty" print the summary in a human-readable format
  void Print(std::ostream & os=std::cout, const std::string& prefix = "") const {
    os << prefix << "Community composition: ";
    emp::Print(counts, os);
    os << std::endl;
    os << prefix << "Present: " << present << std::endl;
    os << prefix << "Present (with at least one other member of subcommunity): " << present_with_other_subcommunity_members << std::endl;
    os << prefix << "Present (with at least one valid interaction path): " << present_with_interaction_path << std::endl;
    os << prefix << "Subcommunities present (\% of subcommunity): ";
    emp::Print(proportion_subcommunity_present, os);
    os << std::endl;
  }
};

// Generates instances of RecordedCommunitySummary from vectors of species counts
//  At the moment summarizer forces configuration on construction ==> this helps to
//  make sure that all summaries generated by a particular instance of a summarizer
//  were generated in the same way
class RecordedCommunitySummarizer {
public:
  using interaction_matrix_t = emp::vector<emp::vector<double>>;
  using is_present_fun_t = std::function<bool(double)>;
  using summary_update_fun_t = std::function<RecordedCommunitySummary(
    const RecordedCommunitySummarizer&,
    const RecordedCommunitySummary&
  )>;

protected:
  const CommunityStructure& community_structure;
  is_present_fun_t is_present_fun;
  emp::vector<summary_update_fun_t> summary_update_functions;

public:
  RecordedCommunitySummarizer(
    const CommunityStructure& structure,
    is_present_fun_t is_present,
    const emp::vector<summary_update_fun_t>& update_funs = {}
  ) :
    community_structure(structure),
    is_present_fun(is_present),
    summary_update_functions(update_funs)
  { }

  emp::vector<RecordedCommunitySummary> SummarizeAll(
    const emp::vector<emp::vector<double>>& cells,
    bool apply_update_functions=true
  ) const {
    emp::vector<RecordedCommunitySummary> summaries;
    for (size_t i = 0; i < cells.size(); ++i) {
      summaries.emplace_back(
        Summarize(
          cells[i],
          apply_update_functions
        )
      );
    }
    return summaries;
  }

  RecordedCommunitySummary Summarize(
    const emp::vector<double>& member_counts,
    bool apply_update_functions=true
  ) const {
    // Create a new community summary
    RecordedCommunitySummary summary;
    const size_t num_members = member_counts.size();
    summary.Reset(num_members);
    emp_assert(summary.counts.size() == member_counts.size());

    // Process counts
    for (size_t mem_i = 0; mem_i < num_members; ++mem_i) {
      summary.counts[mem_i] = member_counts[mem_i];
      // Fingerprint present/absence
      summary.present[mem_i] = is_present_fun(summary.counts[mem_i]);
      if (summary.present[mem_i]) {
        summary.present_species_ids.emplace_back(mem_i);
      }
    }

    // Identify members that are present with no other members of their subcommunity
    for (size_t mem_i : summary.present_species_ids) {
      emp_assert(summary.present[mem_i]);
      const size_t member_comm_id = community_structure.GetSubCommunityID(mem_i);
      const auto& subcommunity = community_structure.GetSubCommunityPresent(member_comm_id);
      emp_assert(subcommunity[mem_i]);
      // Does this member species have other species present that share a community?
      // I.e., are there more than one species of this subcommunity present?
      const size_t num_subcomm_present = (summary.present & subcommunity).CountOnes();
      summary.present_with_other_subcommunity_members[mem_i] = num_subcomm_present > 1;
    }

    // Idenfity members that are present but do not interact (directly or indirectly) with any other members of their subcommunity
    // NOTE: could probably speed this up a little by finding connected components on reduced interaction matrix that includes only present species
    for (size_t species_id : summary.present_species_ids) {
      emp_assert(summary.present[species_id]);
      const size_t community_id = community_structure.GetSubCommunityID(species_id);
      // We can limit our search to this species' subcommunity
      const auto& subcommunity = community_structure.GetSubCommunity(community_id);
      bool has_path = false;
      // // is there a path from species_id to each other present species, only going through other present species?
      for (size_t other_id : subcommunity) {
        // direct interactions only
        // has_path = PathExists(
        //   community_structure,
        //   species_id,
        //   other_id,
        //   summary.present
        // );

        // indirect + direct interactions
        has_path = community_structure.SpeciesInteractsWith(species_id, other_id);
        if (has_path) break;
      }
      summary.present_with_interaction_path[species_id] = has_path;
    }

    // Identify number of complete and partial subcommunities present
    summary.proportion_subcommunity_present.resize(community_structure.GetNumSubCommunities(), 0.0);
    // const size_t num_present = present_species_ids.size();
    const auto& subcomm_fingerprints = community_structure.GetFingerprints();
    for (size_t comm_id = 0; comm_id < community_structure.GetNumSubCommunities(); ++comm_id) {
      const auto& subcomm_fingerprint = subcomm_fingerprints[comm_id];
      const emp::BitVector result = summary.present & subcomm_fingerprint;
      const size_t shared_overlap = result.CountOnes();
      if (shared_overlap > 0) {
        summary.partial_subcommunities_present.emplace_back(comm_id);
      }
      // shared_overlap can't be larger than subcommunity size or number of present species
      emp_assert(shared_overlap <= community_structure.GetNumMembers(comm_id));
      emp_assert(shared_overlap <= summary.present_species_ids.size());
      if (shared_overlap == community_structure.GetNumMembers(comm_id)) {
        summary.complete_subcommunities_present.emplace_back(comm_id);
      }
      summary.proportion_subcommunity_present[comm_id] = (double)shared_overlap / (double)community_structure.GetNumMembers(comm_id);
    }

    // Apply any summary update functions in sequential order
    if (apply_update_functions) {
      for (size_t fun_i = 0; fun_i < summary_update_functions.size(); ++fun_i) {
        summary = summary_update_functions[fun_i](*this, summary);
      }
    }

    return summary;
  }
}; // End RecordedCommunitySummarizer definition

// Returns new summary with present-with-no-interactions species removed.
// RecordedCommunitySummary RemovePresentNoInteractions(
//   const RecordedCommunitySummarizer& summarizer,
//   const RecordedCommunitySummary& in_summary
// ) {
//   // Create new counts vector from given counts. Zero out all present no interaction species.
//   emp::vector<double> new_counts(in_summary.counts);
//   for (size_t species_i = 0; species_i < new_counts.size(); ++species_i) {
//     new_counts[species_i] = (in_summary.present_no_interactions[species_i]) ? 0 : new_counts[species_i];
//   }
//   return summarizer.Summarize(new_counts, false);
// }

RecordedCommunitySummary KeepPresentWithInteractionPath(
  const RecordedCommunitySummarizer& summarizer,
  const RecordedCommunitySummary& in_summary
) {
  // Create new counts vector from given counts. Zero out all present no interaction species.
  emp::vector<double> new_counts(in_summary.counts);
  for (size_t species_i = 0; species_i < new_counts.size(); ++species_i) {
    new_counts[species_i] = (in_summary.present_with_interaction_path[species_i]) ? new_counts[species_i] : 0;
  }
  return summarizer.Summarize(new_counts, false);
}

} // End chemical_ecology namespace